[
  {
    "_updatedAt": "2024-09-06T04:10:18Z",
    "gallery": [
      {
        "_key": "86b49d5673c1",
        "asset": {
          "_ref": "image-72f4ec559f0a3b5e125190b4ca03d640e9800582-594x348-png",
          "_type": "reference"
        },
        "_type": "image"
      },
      {
        "asset": {
          "_ref": "image-fcc95bcd4348691db1d59d8bd3dd99744528890a-588x458-png",
          "_type": "reference"
        },
        "_type": "image",
        "_key": "da21453da690"
      },
      {
        "_type": "image",
        "_key": "0e3f693d9095",
        "asset": {
          "_ref": "image-341eef3dcd35b5754088dca65b6348763d123aa3-554x856-png",
          "_type": "reference"
        }
      }
    ],
    "slug": {
      "current": "dio",
      "_type": "slug"
    },
    "likesCount": 7325,
    "_rev": "eaCZ7mIhmiYZX5KGqJmKYH",
    "description": "# Understanding the Dio Package in Flutter\n\n## What is Dio?\n\nDio is a powerful HTTP client for Dart and Flutter, designed to make networking in your applications easier and more efficient. It provides a simple and intuitive API for making HTTP requests, handling responses, and managing various aspects of network communication.\n\n## Key Features of Dio\n\n1. **Interceptors**: Dio allows you to intercept requests, responses, and errors before they are handled by `then` or `catchError`.\n\n2. **Global Configuration**: You can set up global configurations for all requests, such as headers, base URLs, and timeouts.\n\n3. **Form Data**: Easily handle form submissions, including file uploads.\n\n4. **Request Cancellation**: Cancel requests on demand, which is particularly useful for improving app performance.\n\n5. **Download/Upload Progress**: Track the progress of file downloads and uploads.\n\n6. **HTTP/2 Support**: Benefit from the improved performance of HTTP/2 protocol.\n\n7. **Cookie Management**: Automatic handling of cookies for your requests.\n\n## Why Use Dio?\n\nDio stands out from other HTTP clients due to its rich feature set and ease of use. It's particularly well-suited for complex networking tasks in Flutter applications, offering more control and flexibility compared to the built-in `http` package.\n\nWhether you're building a simple app that needs to fetch data from an API, or a complex application with intricate networking requirements, Dio provides the tools you need to handle your HTTP communication effectively.\n\nIn the following sections, we'll dive deeper into how to use Dio in your Flutter projects, exploring its features through practical examples and tutorials.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:dio/dio.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Dio Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: DioDemo(),\n    );\n  }\n}\n\nclass DioDemo extends StatefulWidget {\n  @override\n  _DioDemoState createState() => _DioDemoState();\n}\n\nclass _DioDemoState extends State<DioDemo> {\n  final Dio dio = Dio();\n  String result = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize Dio with base options\n    dio.options.baseUrl = 'https://jsonplaceholder.typicode.com';\n    dio.options.connectTimeout = Duration(seconds: 5);\n    dio.options.receiveTimeout = Duration(seconds: 3);\n\n    // Step 2: Add an interceptor for logging\n    dio.interceptors.add(LogInterceptor(responseBody: true));\n  }\n\n  // Step 3: Perform a GET request\n  Future<void> getRequest() async {\n    try {\n      final response = await dio.get('/posts/1');\n      setState(() {\n        result = 'GET Response: ${response.data}';\n      });\n    } catch (e) {\n      setState(() {\n        result = 'GET Error: $e';\n      });\n    }\n  }\n\n  // Step 4: Perform a POST request\n  Future<void> postRequest() async {\n    try {\n      final response = await dio.post(\n        '/posts',\n        data: {'title': 'foo', 'body': 'bar', 'userId': 1},\n      );\n      setState(() {\n        result = 'POST Response: ${response.data}';\n      });\n    } catch (e) {\n      setState(() {\n        result = 'POST Error: $e';\n      });\n    }\n  }\n\n  // Step 5: Download a file\n  Future<void> downloadFile() async {\n    try {\n      final response = await dio.download(\n        'https://example.com/file.pdf',\n        '/path/to/download/file.pdf',\n        onReceiveProgress: (received, total) {\n          if (total != -1) {\n            print((received / total * 100).toStringAsFixed(0) + \"%\");\n          }\n        },\n      );\n      setState(() {\n        result = 'Download complete: ${response.statusCode}';\n      });\n    } catch (e) {\n      setState(() {\n        result = 'Download Error: $e';\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Dio Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: getRequest,\n              child: Text('GET Request'),\n            ),\n            ElevatedButton(\n              onPressed: postRequest,\n              child: Text('POST Request'),\n            ),\n            ElevatedButton(\n              onPressed: downloadFile,\n              child: Text('Download File'),\n            ),\n            SizedBox(height: 20),\n            Text(result),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes Dio with base options and an interceptor.\n// 2. The UI presents three buttons for different Dio operations.\n// 3. When a button is pressed, it triggers the corresponding function:\n//    - getRequest(): Performs a GET request to fetch a post.\n//    - postRequest(): Performs a POST request to create a new post.\n//    - downloadFile(): Initiates a file download with progress tracking.\n// 4. The result of each operation is displayed on the screen.\n// 5. The LogInterceptor logs all requests and responses for debugging purposes.\n\n// Note: Replace 'https://example.com/file.pdf' with a real file URL and\n// '/path/to/download/file.pdf' with a valid path on the device for the download function to work correctly.\n```",
    "tags": [
      "dio",
      "http",
      "network",
      "interceptor",
      "middleware",
      "api",
      "rest",
      "client",
      "request"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-1ef4d4fb245bed3648df2d0bf1b1a92ed294a031-642x840-png",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:15:28Z",
    "name": "dio",
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "A powerful HTTP networking package,\nsupports Interceptors,\nAborting and canceling a request,\nCustom adapters, Transformers, etc.",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "7pjbp8va"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "olgyyx3w"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPapH2",
        "_type": "reference",
        "_key": "gq4hbue7"
      }
    ],
    "_id": "Rx1Nho763d29lawKra1Jgx",
    "author": "flutter.cn",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfBli",
        "_type": "reference",
        "_key": "xao992la"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-08-12T18:30:00.000Z",
    "tutorial": "# Dio Package Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the Dio package in your Flutter application. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nTo get started with Dio, you need to add it to your project's `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  dio: ^5.0.0  # Use the latest version\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nHere's a simple example of how to use Dio to make a GET request:\n\n```dart\nimport 'package:dio/dio.dart';\n\nvoid main() async {\n  final dio = Dio();\n  try {\n    final response = await dio.get('https://api.example.com/data');\n    print(response.data);\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n## Step 3: POST Request\n\nMaking a POST request is just as simple:\n\n```dart\nvoid postData() async {\n  final dio = Dio();\n  try {\n    final response = await dio.post(\n      'https://api.example.com/post',\n      data: {'name': 'John Doe', 'age': 30},\n    );\n    print(response.data);\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n## Step 4: Using Interceptors\n\nInterceptors are powerful tools for globally handling requests and responses:\n\n```dart\ndio.interceptors.add(InterceptorsWrapper(\n  onRequest: (options, handler) {\n    // Add custom headers\n    options.headers['Authorization'] = 'Bearer your_token_here';\n    return handler.next(options);\n  },\n  onResponse: (response, handler) {\n    // Process the response\n    print('Response received: ${response.data}');\n    return handler.next(response);\n  },\n  onError: (DioError e, handler) {\n    // Handle errors\n    print('Error occurred: ${e.message}');\n    return handler.next(e);\n  },\n));\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you might need to add internet permission to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### iOS\n\nFor iOS, if you're making requests to non-HTTPS URLs, you need to configure App Transport Security settings in your `Info.plist`:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\nBy following these steps, you'll have a solid foundation for using Dio in your Flutter projects across different platforms.",
    "tutorialIncluded": true,
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1LSx",
        "_type": "reference",
        "_key": "dq06wd6i"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPapH2",
        "_type": "reference",
        "_key": "k3bzxh1n"
      }
    ]
  },
  {
    "pubPoint": 160,
    "author": "bloclibrary.dev",
    "likesCount": 7042,
    "tutorial": "# Flutter Bloc Package: Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the `flutter_bloc` package in a Flutter application. We'll create a simple counter app to demonstrate the basic concepts.\n\n## Step 1: Setup\n\nFirst, add the required dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_bloc: ^8.1.3\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Create the Bloc\n\nCreate a new file `counter_bloc.dart` in the `lib` folder:\n\n```dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\n// Events\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n\n// Bloc\nclass CounterBloc extends Bloc<CounterEvent, int> {\n  CounterBloc() : super(0) {\n    on<IncrementEvent>((event, emit) => emit(state + 1));\n    on<DecrementEvent>((event, emit) => emit(state - 1));\n  }\n}\n```\n\n## Step 3: Implement the UI\n\nUpdate your `main.dart` file:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'counter_bloc.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Bloc Counter')),\n      body: Center(\n        child: BlocBuilder<CounterBloc, int>(\n          builder: (context, count) {\n            return Text('Count: $count', style: TextStyle(fontSize: 24));\n          },\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        children: [\n          FloatingActionButton(\n            child: Icon(Icons.add),\n            onPressed: () => context.read<CounterBloc>().add(IncrementEvent()),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            child: Icon(Icons.remove),\n            onPressed: () => context.read<CounterBloc>().add(DecrementEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, ensure that your `android/app/build.gradle` file has the minimum SDK version set:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### iOS\n\nFor iOS, update your `ios/Runner/Info.plist` file to include any necessary permissions:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n### Web\n\nFor web support, no additional configuration is needed. However, ensure that you have enabled web support in your Flutter project:\n\n```\nflutter config --enable-web\n```\n\n## Running the App\n\nTo run the app on different platforms:\n\n- Android: `flutter run -d android`\n- iOS: `flutter run -d ios`\n- Web: `flutter run -d chrome`\n\nThis tutorial provides a basic implementation of the `flutter_bloc` package. In the next section, we'll explore a more complex example that demonstrates additional features of the package.",
    "_updatedAt": "2024-09-06T04:10:19Z",
    "shortDescription": "Flutter Widgets that make it easy to implement the BLoC (Business Logic Component) design pattern. Built to be used with the bloc state management package.",
    "tags": [
      "bloc",
      "state-management",
      "reactive",
      "architecture",
      "pattern"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-0a7902ac26c0808193433dadf8e82ad5b6843ab5-546x650-webp",
        "_type": "reference"
      }
    },
    "lastUpdate": "2024-06-10T18:30:00.000Z",
    "name": "flutter_bloc",
    "_id": "Rx1Nho763d29lawKra1Jyh",
    "gallery": [
      {
        "_type": "image",
        "_key": "275bcd074fe7",
        "asset": {
          "_ref": "image-21c36acbbc44522c06f98445dfffb8e2390b6151-588x1114-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "930dec33c437",
        "asset": {
          "_ref": "image-92f4363b21c2feb782dd27f9e513d6bb92fc152e-572x568-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "799e42917cb7",
        "asset": {
          "_type": "reference",
          "_ref": "image-1f37a7ee0967d81009eceaa1959930b91e77611a-586x566-png"
        }
      }
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmKep",
    "description": "# Flutter Bloc Package: State Management Made Easy\n\n## Introduction\n\nThe `flutter_bloc` package is a powerful state management solution for Flutter applications. It implements the Business Logic Component (BLoC) pattern, which separates the presentation layer from the business logic. This separation makes your code more organized, testable, and maintainable.\n\n## Key Concepts\n\n1. **Bloc**: The central class that manages the state and business logic of a feature or component.\n2. **Event**: An input to the Bloc, typically triggered by user interactions or external data changes.\n3. **State**: The output of the Bloc, representing the current status of the application or a specific feature.\n4. **Stream**: A continuous flow of data used to emit states from the Bloc to the UI.\n\n## Advantages of flutter_bloc\n\n- **Separation of Concerns**: Keeps business logic separate from the UI, improving code organization.\n- **Testability**: Makes it easier to write unit tests for your business logic.\n- **Reusability**: Blocs can be reused across different parts of your application or even different projects.\n- **Performance**: Efficient updates to the UI by only rebuilding the necessary widgets.\n- **Developer Tools**: Comes with powerful dev tools for debugging and visualizing state changes.\n\n## When to Use flutter_bloc\n\nThe `flutter_bloc` package is particularly useful for:\n\n- Large-scale applications with complex state management needs\n- Apps that require real-time updates and reactive programming\n- Projects where testability and maintainability are crucial\n- Applications with multiple developers working on different features\n\nIn the following sections, we'll dive deeper into how to implement `flutter_bloc` in your Flutter projects and explore its features through a practical example.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\n// Step 1: Define Events\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\nclass ResetEvent extends CounterEvent {}\n\n// Step 2: Define States\nclass CounterState {\n  final int count;\n  final bool isEven;\n\n  CounterState(this.count) : isEven = count % 2 == 0;\n}\n\n// Step 3: Create Bloc\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterState(0)) {\n    on<IncrementEvent>((event, emit) => emit(CounterState(state.count + 1)));\n    on<DecrementEvent>((event, emit) => emit(CounterState(state.count - 1)));\n    on<ResetEvent>((event, emit) => emit(CounterState(0)));\n  }\n}\n\n// Step 4: Create Main App Widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Bloc Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: CounterPage(),\n      ),\n    );\n  }\n}\n\n// Step 5: Create Counter Page\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Bloc Counter')),\n      body: Center(\n        child: BlocBuilder<CounterBloc, CounterState>(\n          builder: (context, state) {\n            return Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text(\n                  'Count: ${state.count}',\n                  style: TextStyle(fontSize: 24),\n                ),\n                Text(\n                  'Is Even: ${state.isEven}',\n                  style: TextStyle(fontSize: 18),\n                ),\n              ],\n            );\n          },\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        children: [\n          FloatingActionButton(\n            child: Icon(Icons.add),\n            onPressed: () => context.read<CounterBloc>().add(IncrementEvent()),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            child: Icon(Icons.remove),\n            onPressed: () => context.read<CounterBloc>().add(DecrementEvent()),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            child: Icon(Icons.refresh),\n            onPressed: () => context.read<CounterBloc>().add(ResetEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 6: Run the App\nvoid main() => runApp(RealFlutter());\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and provides the CounterBloc to its child widgets.\n// 3. CounterPage is the main screen, which uses BlocBuilder to listen to state changes.\n// 4. User interactions (tapping buttons) trigger events (Increment, Decrement, Reset).\n// 5. These events are handled by the CounterBloc, which updates the state accordingly.\n// 6. The UI automatically rebuilds when the state changes, displaying the new count and even/odd status.\n\n// Key Features Demonstrated:\n// - Event handling with different event types\n// - Complex state management (count and isEven property)\n// - BlocProvider for dependency injection\n// - BlocBuilder for reactive UI updates\n// - Separation of business logic (in CounterBloc) from UI (in CounterPage)\n```",
    "tutorialIncluded": true,
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Ca4b",
        "_type": "reference",
        "_key": "gm2y9x87"
      },
      {
        "_key": "4irbj9fk",
        "_ref": "Rx1Nho763d29lawKra1kah",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG5F",
        "_type": "reference",
        "_key": "3j5rbgdd"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "6nm8y8t2"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CdzJ",
        "_type": "reference",
        "_key": "72au60df"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1swl",
        "_type": "reference",
        "_key": "qbejks3o"
      }
    ],
    "_createdAt": "2024-08-28T22:15:31Z",
    "slug": {
      "current": "flutter_bloc",
      "_type": "slug"
    }
  },
  {
    "_id": "Rx1Nho763d29lawKra1K9L",
    "author": "baseflow.com",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:geolocator/geolocator.dart';\nimport 'dart:async';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Geolocator Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: GeolocatorDemo(),\n    );\n  }\n}\n\nclass GeolocatorDemo extends StatefulWidget {\n  @override\n  _GeolocatorDemoState createState() => _GeolocatorDemoState();\n}\n\nclass _GeolocatorDemoState extends State<GeolocatorDemo> {\n  // Step 1: Initialize variables\n  String _locationMessage = \"\";\n  late StreamSubscription<Position> _positionStreamSubscription;\n  bool _isListening = false;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Check and request permissions when the widget initializes\n    _checkPermission();\n  }\n\n  // Step 3: Check and request location permissions\n  Future<void> _checkPermission() async {\n    bool serviceEnabled;\n    LocationPermission permission;\n\n    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n    if (!serviceEnabled) {\n      setState(() => _locationMessage = 'Location services are disabled.');\n      return;\n    }\n\n    permission = await Geolocator.checkPermission();\n    if (permission == LocationPermission.denied) {\n      permission = await Geolocator.requestPermission();\n      if (permission == LocationPermission.denied) {\n        setState(() => _locationMessage = 'Location permissions are denied');\n        return;\n      }\n    }\n    \n    if (permission == LocationPermission.deniedForever) {\n      setState(() => _locationMessage = 'Location permissions are permanently denied');\n      return;\n    }\n\n    // Permissions are granted, we can now use location features\n    _getCurrentLocation();\n  }\n\n  // Step 4: Get current location\n  void _getCurrentLocation() async {\n    try {\n      Position position = await Geolocator.getCurrentPosition(\n        desiredAccuracy: LocationAccuracy.high\n      );\n      setState(() {\n        _locationMessage = 'Latitude: ${position.latitude}, Longitude: ${position.longitude}';\n      });\n    } catch (e) {\n      setState(() => _locationMessage = 'Error: ${e.toString()}');\n    }\n  }\n\n  // Step 5: Toggle location stream\n  void _toggleListening() {\n    if (_isListening) {\n      _positionStreamSubscription.cancel();\n      setState(() => _isListening = false);\n    } else {\n      _positionStreamSubscription = Geolocator.getPositionStream(\n        locationSettings: LocationSettings(\n          accuracy: LocationAccuracy.high,\n          distanceFilter: 10,\n        )\n      ).listen((Position position) {\n        setState(() {\n          _locationMessage = 'Latitude: ${position.latitude}, Longitude: ${position.longitude}';\n        });\n      });\n      setState(() => _isListening = true);\n    }\n  }\n\n  // Step 6: Calculate distance between two points\n  void _calculateDistance() {\n    const startLatitude = 52.2165157;\n    const startLongitude = 6.9437819;\n    const endLatitude = 52.3546274;\n    const endLongitude = 4.8285838;\n\n    double distanceInMeters = Geolocator.distanceBetween(\n      startLatitude, startLongitude, endLatitude, endLongitude\n    );\n\n    setState(() {\n      _locationMessage = 'Distance: ${distanceInMeters.toStringAsFixed(2)} meters';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Geolocator Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(_locationMessage),\n            ElevatedButton(\n              child: Text('Get Current Location'),\n              onPressed: _getCurrentLocation,\n            ),\n            ElevatedButton(\n              child: Text(_isListening ? 'Stop Listening' : 'Start Listening'),\n              onPressed: _toggleListening,\n            ),\n            ElevatedButton(\n              child: Text('Calculate Distance'),\n              onPressed: _calculateDistance,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    if (_isListening) {\n      _positionStreamSubscription.cancel();\n    }\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the GeolocatorDemo widget.\n// 2. In initState, _checkPermission is called to verify and request location permissions.\n// 3. If permissions are granted, _getCurrentLocation is called to get the initial location.\n// 4. The user can interact with three buttons:\n//    - \"Get Current Location\": Updates the location once.\n//    - \"Start/Stop Listening\": Toggles continuous location updates.\n//    - \"Calculate Distance\": Demonstrates distance calculation between two fixed points.\n// 5. The app updates the UI with location information or distance calculations based on user interactions.\n// 6. When the widget is disposed, any active location stream is cancelled to prevent memory leaks.\n```",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 5405,
    "lastUpdate": "2024-08-05T18:30:00.000Z",
    "name": "geolocator",
    "shortDescription": "Geolocation plugin for Flutter. This plugin provides a cross-platform (iOS, Android) API for generic location (GPS etc.) functions.",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVGj",
        "_type": "reference",
        "_key": "4ez9xhvl"
      },
      {
        "_type": "reference",
        "_key": "x27lcih0",
        "_ref": "Rx1Nho763d29lawKra1a3n"
      }
    ],
    "_createdAt": "2024-08-28T22:15:33Z",
    "tutorial": "# Geolocator Package Tutorial\n\n## Setup\n\nBefore we start using the Geolocator package, we need to set up permissions for both Android and iOS platforms.\n\n### Android Setup\n\n1. Open the `android/app/src/main/AndroidManifest.xml` file.\n2. Add the following permissions inside the `<manifest>` tag:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\n### iOS Setup\n\n1. Open the `ios/Runner/Info.plist` file.\n2. Add the following keys:\n\n```xml\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>This app needs access to location when open.</string>\n<key>NSLocationAlwaysUsageDescription</key>\n<string>This app needs access to location when in the background.</string>\n```\n\n## Basic Usage\n\n### 1. Checking Location Services\n\nBefore requesting location, it's good practice to check if location services are enabled:\n\n```dart\nbool serviceEnabled = await Geolocator.isLocationServiceEnabled();\nif (!serviceEnabled) {\n  // Location services are not enabled, handle accordingly\n  return;\n}\n```\n\n### 2. Requesting Permissions\n\nNext, request location permissions:\n\n```dart\nLocationPermission permission = await Geolocator.checkPermission();\nif (permission == LocationPermission.denied) {\n  permission = await Geolocator.requestPermission();\n  if (permission == LocationPermission.denied) {\n    // Permissions are denied, handle accordingly\n    return;\n  }\n}\n\nif (permission == LocationPermission.deniedForever) {\n  // Permissions are denied forever, handle accordingly\n  return;\n}\n```\n\n### 3. Getting Current Position\n\nTo get the current position:\n\n```dart\nPosition position = await Geolocator.getCurrentPosition(\n  desiredAccuracy: LocationAccuracy.high\n);\nprint(position.latitude);\nprint(position.longitude);\n```\n\n### 4. Listening to Location Updates\n\nTo receive location updates:\n\n```dart\nStreamSubscription<Position> positionStream = Geolocator.getPositionStream(\n  locationSettings: LocationSettings(\n    accuracy: LocationAccuracy.high,\n    distanceFilter: 10,\n  )\n).listen((Position position) {\n  print(position.latitude);\n  print(position.longitude);\n});\n```\n\n### 5. Calculating Distance\n\nTo calculate the distance between two coordinates:\n\n```dart\ndouble distanceInMeters = Geolocator.distanceBetween(\n  52.2165157, 6.9437819,\n  52.3546274, 4.8285838\n);\n```\n\nIn the next section, we'll see a complete example that demonstrates these features in a functional Flutter application.",
    "slug": {
      "_type": "slug",
      "current": "geolocator"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaNyS",
    "_type": "package",
    "description": "# Understanding the Geolocator Package in Flutter\n\n## Introduction\n\nThe Geolocator package is a powerful tool for Flutter developers who need to implement location-based features in their applications. It provides a straightforward way to access geolocation data across different platforms, including iOS and Android.\n\n## Key Features\n\n1. **Current Location**: Easily retrieve the device's current location.\n2. **Location Updates**: Get real-time updates of the device's location.\n3. **Distance Calculation**: Calculate the distance between two coordinates.\n4. **Geocoding**: Convert between addresses and coordinates.\n5. **Geofencing**: Set up virtual boundaries and get notified when the device enters or exits these areas.\n6. **Platform Adaptability**: Works seamlessly on both iOS and Android platforms.\n\n## Why Use Geolocator?\n\n- **Simplicity**: The package offers a simple API that abstracts away the complexities of working with native location services.\n- **Cross-Platform**: It provides a unified interface for both iOS and Android, reducing the need for platform-specific code.\n- **Performance**: Optimized for efficient battery usage and accurate location data.\n- **Customization**: Offers various settings to fine-tune location accuracy and update frequency.\n\n## Getting Started\n\nTo use the Geolocator package in your Flutter project, you need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  geolocator: ^10.0.0\n```\n\nAfter adding the dependency, run `flutter pub get` to install the package.\n\nIn the next sections, we'll dive into a detailed tutorial on how to use the Geolocator package and provide a comprehensive example demonstrating its features.",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWvh",
        "_type": "reference",
        "_key": "47giwp7t"
      }
    ],
    "tags": [
      "geolocation",
      "gps",
      "location",
      "maps",
      "positioning"
    ],
    "tutorialIncluded": true,
    "pubPoint": 160,
    "subCategories": [
      {
        "_type": "reference",
        "_key": "tcps7q0p",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGMd"
      }
    ],
    "_updatedAt": "2024-09-06T04:10:20Z"
  },
  {
    "tags": [
      "files",
      "path-provider",
      "paths",
      "storage",
      "directory"
    ],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfBX6",
        "_type": "reference",
        "_key": "hx16w0fv"
      }
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmKoe",
    "_type": "package",
    "description": "# Understanding the path_provider Package in Flutter\n\n## Introduction\n\nThe `path_provider` package is an essential tool for Flutter developers who need to work with file system paths across different platforms. It provides a simple and consistent way to access commonly used locations on the device's file system, such as the temporary directory, application documents directory, and external storage.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly on iOS, Android, macOS, Windows, and Linux.\n2. **Easy access to common directories**: Simplifies retrieval of paths for temporary, document, and external storage directories.\n3. **Asynchronous operations**: All methods return Futures, ensuring non-blocking file system operations.\n4. **Platform-specific paths**: Provides access to platform-specific directories when needed.\n\n## Why Use path_provider?\n\n- **Consistency**: Offers a unified API across different platforms, reducing platform-specific code.\n- **Best practices**: Automatically follows platform-specific best practices for file storage.\n- **Performance**: Efficient access to file system locations without manual path construction.\n- **Maintenance**: Regularly updated to ensure compatibility with the latest Flutter versions and platform changes.\n\nIn the next sections, we'll dive into a tutorial on how to use the `path_provider` package and explore a comprehensive example demonstrating its features.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "tutorial": "# Path Provider Package Tutorial\n\n## Step 1: Add Dependencies\n\nAdd the `path_provider` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  path_provider: ^2.0.15\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:path_provider/path_provider.dart';\n```\n\n## Step 3: Using path_provider Methods\n\nHere are some common methods you can use:\n\n### Get Temporary Directory\n\n```dart\nFuture<String> getTemporaryPath() async {\n  final directory = await getTemporaryDirectory();\n  return directory.path;\n}\n```\n\n### Get Application Documents Directory\n\n```dart\nFuture<String> getAppDocumentsPath() async {\n  final directory = await getApplicationDocumentsDirectory();\n  return directory.path;\n}\n```\n\n### Get External Storage Directory (Android only)\n\n```dart\nFuture<String?> getExternalStoragePath() async {\n  if (Platform.isAndroid) {\n    final directory = await getExternalStorageDirectory();\n    return directory?.path;\n  }\n  return null;\n}\n```\n\n## Platform-Specific Details\n\n### iOS\n- `getTemporaryDirectory()`: Returns the NSTemporaryDirectory\n- `getApplicationDocumentsDirectory()`: Returns the NSDocumentDirectory\n- External storage is not applicable\n\n### Android\n- `getTemporaryDirectory()`: Returns the getCacheDir\n- `getApplicationDocumentsDirectory()`: Returns the AppData directory\n- `getExternalStorageDirectory()`: Returns the external storage directory\n\n### macOS\n- `getTemporaryDirectory()`: Returns the NSTemporaryDirectory\n- `getApplicationDocumentsDirectory()`: Returns the NSDocumentDirectory\n- External storage is not applicable\n\n### Windows\n- `getTemporaryDirectory()`: Returns the result of GetTempPath\n- `getApplicationDocumentsDirectory()`: Returns the roaming AppData directory\n- External storage is not applicable\n\n### Linux\n- `getTemporaryDirectory()`: Returns the value of TMPDIR environment variable or '/tmp'\n- `getApplicationDocumentsDirectory()`: Returns the XDG_DATA_HOME directory\n- External storage is not applicable\n\nRemember to handle platform-specific cases in your code, especially when dealing with external storage on Android.",
    "pubPoint": 160,
    "likesCount": 4892,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-7af85583f31fa50fee4207a7b9e8f6c5ad9ae596-700x1184-png",
        "_type": "reference"
      }
    },
    "name": "path_provider",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:21Z",
    "author": "flutter.dev",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1LIJ",
        "_type": "reference",
        "_key": "14cmklfb"
      }
    ],
    "example": "```\n// This example requires\nimport 'package:flutter/material.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Path Provider Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const PathProviderDemo(),\n    );\n  }\n}\n\nclass PathProviderDemo extends StatefulWidget {\n  const PathProviderDemo({Key? key}) : super(key: key);\n\n  @override\n  _PathProviderDemoState createState() => _PathProviderDemoState();\n}\n\nclass _PathProviderDemoState extends State<PathProviderDemo> {\n  String _tempPath = '';\n  String _appDocPath = '';\n  String _externalPath = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _loadPaths();\n  }\n\n  // Step 1: Load all paths when the widget initializes\n  Future<void> _loadPaths() async {\n    final tempDir = await getTemporaryDirectory();\n    final appDocDir = await getApplicationDocumentsDirectory();\n    \n    String? externalDir;\n    if (Platform.isAndroid) {\n      externalDir = (await getExternalStorageDirectory())?.path;\n    }\n\n    setState(() {\n      _tempPath = tempDir.path;\n      _appDocPath = appDocDir.path;\n      _externalPath = externalDir ?? 'Not available';\n    });\n  }\n\n  // Step 2: Create a file in the temporary directory\n  Future<void> _createTempFile() async {\n    final file = File('${_tempPath}/temp_file.txt');\n    await file.writeAsString('This is a temporary file');\n    _showSnackBar('Temporary file created');\n  }\n\n  // Step 3: Create a file in the app documents directory\n  Future<void> _createAppDocFile() async {\n    final file = File('${_appDocPath}/app_doc_file.txt');\n    await file.writeAsString('This is a file in the app documents directory');\n    _showSnackBar('App documents file created');\n  }\n\n  // Step 4: Create a file in the external storage (Android only)\n  Future<void> _createExternalFile() async {\n    if (Platform.isAndroid && _externalPath != 'Not available') {\n      final file = File('${_externalPath}/external_file.txt');\n      await file.writeAsString('This is a file in external storage');\n      _showSnackBar('External storage file created');\n    } else {\n      _showSnackBar('External storage not available');\n    }\n  }\n\n  void _showSnackBar(String message) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text(message)),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Path Provider Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Temporary Directory: $_tempPath'),\n            Text('App Documents Directory: $_appDocPath'),\n            Text('External Storage Directory: $_externalPath'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _createTempFile,\n              child: const Text('Create Temp File'),\n            ),\n            ElevatedButton(\n              onPressed: _createAppDocFile,\n              child: const Text('Create App Doc File'),\n            ),\n            ElevatedButton(\n              onPressed: _createExternalFile,\n              child: const Text('Create External File'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. The PathProviderDemo widget is created as the home screen.\n// 3. In initState, _loadPaths() is called to retrieve all directory paths.\n// 4. The UI displays the paths and buttons to create files.\n// 5. When a button is pressed, the corresponding method is called:\n//    - _createTempFile() creates a file in the temporary directory\n//    - _createAppDocFile() creates a file in the app documents directory\n//    - _createExternalFile() creates a file in external storage (Android only)\n// 6. After each file creation, a snackbar is shown to confirm the action.\n// 7. The app handles platform differences, especially for external storage.\n\n// Note: This example demonstrates basic usage of path_provider.\n// In a real app, you'd want to add error handling and possibly\n// check if files already exist before creating them.\n```",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CX1D",
        "_type": "reference",
        "_key": "ntz5kzlq"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cew9",
        "_type": "reference",
        "_key": "o6zhjoe9"
      }
    ],
    "_createdAt": "2024-08-28T22:15:34Z",
    "lastUpdate": "2024-07-29T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1L7f",
    "gallery": [
      {
        "_type": "image",
        "_key": "f5270732b8cd",
        "asset": {
          "_ref": "image-0a43977f90c52d864f18818f4d9e91cd72fe2b3c-684x694-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "241fc9eeb4ae",
        "asset": {
          "_ref": "image-1ed6d92cb3fcfede1c264d942fd16c8e86d40651-686x752-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "6f234c15bbc4",
        "asset": {
          "_type": "reference",
          "_ref": "image-4781ca93f54533aa7e88f6e5dfd6b1f021d677ec-756x1160-png"
        }
      }
    ],
    "shortDescription": "Flutter plugin for getting commonly used locations on host platform file systems, such as the temp and app data directories.",
    "slug": {
      "current": "path_provider",
      "_type": "slug"
    }
  },
  {
    "description": "# File Picker Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `file_picker` package is a powerful and versatile tool for Flutter developers who need to implement file selection functionality in their applications. This package provides a simple and customizable way to access the device's file system, allowing users to pick single or multiple files, choose directories, and save files.\n\n### Key Features:\n\n1. **Cross-platform compatibility**: Works seamlessly on Android, iOS, Web, Windows, macOS, and Linux.\n2. **Single and multiple file selection**: Choose one or multiple files with ease.\n3. **Custom file types**: Filter files based on specific extensions or MIME types.\n4. **Directory picking**: Select entire directories for bulk file operations.\n5. **Save file functionality**: Implement a save file dialog for your app.\n6. **Customizable UI**: Ability to use custom file picker UI on supported platforms.\n\n### Why Use File Picker?\n\nThe `file_picker` package simplifies the process of integrating file selection capabilities into your Flutter app. Instead of dealing with platform-specific code and APIs, you can use a single, unified interface to handle file operations across all supported platforms.\n\nThis package is particularly useful for:\n- Document management apps\n- Media players\n- File upload functionalities\n- Backup and restore features\n- Any app that requires access to the device's file system\n\nIn the following sections, we'll dive deeper into how to implement and use the `file_picker` package in your Flutter projects.",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-766623bb8fd29920a4232ddf21535eb433f461b6-648x860-png",
        "_type": "reference"
      }
    },
    "_updatedAt": "2024-09-06T04:10:22Z",
    "author": "miguelruivo.com",
    "shortDescription": "A package that allows you to use a native file explorer to pick single or multiple absolute file paths, with extension filtering support.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 4274,
    "lastUpdate": "2024-08-15T18:30:00.000Z",
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `file_picker` package into your Flutter project and demonstrate its basic usage.\n\n### Step 1: Add the package to your pubspec.yaml\n\n```yaml\ndependencies:\n  file_picker: ^5.3.1\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:file_picker/file_picker.dart';\n```\n\n### Step 3: Basic usage\n\nHere's a simple example of how to use the `file_picker` package to select a single file:\n\n```dart\nFuture<void> pickFile() async {\n  FilePickerResult? result = await FilePicker.platform.pickFiles();\n\n  if (result != null) {\n    PlatformFile file = result.files.first;\n    print(file.name);\n    print(file.bytes);\n    print(file.size);\n    print(file.extension);\n    print(file.path);\n  } else {\n    // User canceled the picker\n  }\n}\n```\n\n### Platform-specific details\n\n#### Android\n\n1. Add the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n```\n\n2. For Android 13 and above, add these permissions:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" />\n<uses-permission android:name=\"android.permission.READ_MEDIA_VIDEO\" />\n<uses-permission android:name=\"android.permission.READ_MEDIA_AUDIO\" />\n```\n\n#### iOS\n\n1. Add the following keys to your `Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>We need access to photo library for file picking</string>\n<key>NSDocumentPickerUsageDescription</key>\n<string>We need access to documents for file picking</string>\n```\n\n#### Web\n\nNo additional configuration is required for web platforms.\n\n#### Desktop (Windows, macOS, Linux)\n\nNo additional configuration is required for desktop platforms.\n\n### Advanced Usage\n\n1. **Picking multiple files**:\n\n```dart\nFilePickerResult? result = await FilePicker.platform.pickFiles(allowMultiple: true);\n\nif (result != null) {\n  List<File> files = result.paths.map((path) => File(path!)).toList();\n  // Use these files\n} else {\n  // User canceled the picker\n}\n```\n\n2. **Picking files with specific extensions**:\n\n```dart\nFilePickerResult? result = await FilePicker.platform.pickFiles(\n  type: FileType.custom,\n  allowedExtensions: ['jpg', 'pdf', 'doc'],\n);\n```\n\n3. **Picking a directory**:\n\n```dart\nString? selectedDirectory = await FilePicker.platform.getDirectoryPath();\n\nif (selectedDirectory != null) {\n  print(selectedDirectory);\n} else {\n  // User canceled the picker\n}\n```\n\nBy following this tutorial and exploring the various options provided by the `file_picker` package, you can easily implement robust file picking functionality in your Flutter applications across multiple platforms.",
    "gallery": [
      {
        "_type": "image",
        "_key": "109c28921e3f",
        "asset": {
          "_ref": "image-1948bdc626b81f8bd73e97c649ef87e09bb23668-434x486-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "5c7df6bc119d",
        "asset": {
          "_ref": "image-588d406418bf9254ccfb79b51ad69ffd11bc3d33-414x398-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "7e9a878eba7e",
        "asset": {
          "_type": "reference",
          "_ref": "image-5d6226210738519a14178dff86ab1b0aeab030eb-652x780-png"
        }
      },
      {
        "_type": "image",
        "_key": "81b9915646fa",
        "asset": {
          "_ref": "image-4aeefb49731a87fb39c35ee1f3e622347b73217a-630x474-png",
          "_type": "reference"
        }
      }
    ],
    "slug": {
      "current": "file_picker",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmKvC",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWg3",
        "_type": "reference",
        "_key": "q8rtfb6a"
      }
    ],
    "tags": [
      "file",
      "picker",
      "selection",
      "document",
      "chooser"
    ],
    "_createdAt": "2024-08-28T22:15:35Z",
    "name": "file_picker",
    "_id": "Rx1Nho763d29lawKra1LIJ",
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [
      {
        "_key": "37tbaydq",
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:file_picker/file_picker.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'File Picker Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const FilePickerDemo(),\n    );\n  }\n}\n\nclass FilePickerDemo extends StatefulWidget {\n  const FilePickerDemo({Key? key}) : super(key: key);\n\n  @override\n  _FilePickerDemoState createState() => _FilePickerDemoState();\n}\n\nclass _FilePickerDemoState extends State<FilePickerDemo> {\n  String? _fileName;\n  List<PlatformFile>? _paths;\n  String? _directoryPath;\n  String? _extension;\n  bool _multiPick = false;\n  FileType _pickingType = FileType.any;\n\n  // Step 1: Initialize the state\n  @override\n  void initState() {\n    super.initState();\n    _fileName = '';\n    _paths = null;\n    _directoryPath = null;\n    _extension = '';\n  }\n\n  // Step 2: Function to open file picker\n  void _openFileExplorer() async {\n    try {\n      _directoryPath = null;\n      _paths = (await FilePicker.platform.pickFiles(\n        type: _pickingType,\n        allowMultiple: _multiPick,\n        allowedExtensions: (_extension?.isNotEmpty ?? false)\n            ? _extension?.replaceAll(' ', '').split(',')\n            : null,\n      ))\n          ?.files;\n    } catch (e) {\n      print(\"Unsupported operation\" + e.toString());\n    }\n\n    // Step 3: Update the UI\n    if (!mounted) return;\n    setState(() {\n      _fileName = _paths != null ? _paths!.map((e) => e.name).toString() : '...';\n    });\n  }\n\n  // Step 4: Function to clear selected files\n  void _clearCachedFiles() {\n    FilePicker.platform.clearTemporaryFiles().then((result) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(\n          content: Text((result != null && result)\n              ? 'Temporary files removed with success.'\n              : 'Failed to clean temporary files'),\n        ),\n      );\n    });\n  }\n\n  // Step 5: Function to select directory\n  void _selectFolder() async {\n    _directoryPath = await FilePicker.platform.getDirectoryPath();\n    setState(() {\n      _directoryPath = _directoryPath;\n    });\n  }\n\n  // Step 6: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('File Picker Example'),\n      ),\n      body: Center(\n        child: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              ElevatedButton(\n                onPressed: _openFileExplorer,\n                child: const Text(\"Open File Explorer\"),\n              ),\n              const SizedBox(height: 10),\n              ElevatedButton(\n                onPressed: _selectFolder,\n                child: const Text(\"Pick Folder\"),\n              ),\n              const SizedBox(height: 10),\n              ElevatedButton(\n                onPressed: _clearCachedFiles,\n                child: const Text(\"Clear Temporary Files\"),\n              ),\n              const SizedBox(height: 20),\n              Text(\n                'File Name: $_fileName',\n                style: const TextStyle(fontSize: 16),\n              ),\n              if (_directoryPath != null)\n                Text(\n                  'Directory Path: $_directoryPath',\n                  style: const TextStyle(fontSize: 16),\n                ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with three buttons and text areas for file name and directory path.\n// 2. When \"Open File Explorer\" is pressed, it calls _openFileExplorer() which uses FilePicker to allow the user to select file(s).\n// 3. After file selection, the UI updates to display the name(s) of the selected file(s).\n// 4. The \"Pick Folder\" button calls _selectFolder() to allow the user to select a directory. The selected path is then displayed.\n// 5. \"Clear Temporary Files\" button calls _clearCachedFiles() to remove any temporary files created by FilePicker.\n// 6. The app continuously listens for user interactions and updates the UI accordingly.\n\n// Note: This example demonstrates basic file picking, folder selection, and clearing cached files.\n// You can extend this further by implementing file type filtering, custom UI, and handling the picked files for your specific use case.\n```",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "eydtd96y",
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ffX",
        "_type": "reference",
        "_key": "i0rfykgs"
      }
    ],
    "tutorialIncluded": true
  },
  {
    "tags": [
      "http",
      "network",
      "protocols",
      "api",
      "client",
      "request"
    ],
    "packageImage": null,
    "subCategories": [
      {
        "_key": "zubr5280",
        "_ref": "t8DYBEKn49O4mjbyRAfBli",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:15:37Z",
    "_id": "Rx1Nho763d29lawKra1LSx",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaO3F",
    "_type": "package",
    "shortDescription": "A composable, multi-platform, Future-based API for HTTP requests.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "i7sn2uuz"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 7738,
    "lastUpdate": "2024-07-15T18:30:00.000Z",
    "name": "http",
    "pubPoint": 160,
    "author": "dart.dev",
    "description": "# HTTP Package in Flutter: Making Network Requests a Breeze\n\n## Introduction\n\nIn the world of mobile app development, communication with web services is a fundamental requirement. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful and easy-to-use package for handling HTTP requests: the `http` package.\n\n## What is the HTTP Package?\n\nThe `http` package is a composable, Future-based library for making HTTP requests. It provides a straightforward way to fetch data from the internet and send data to a server. Whether you're working with RESTful APIs, downloading files, or submitting forms, the `http` package has got you covered.\n\n## Key Features\n\n1. **Simplified API**: The package offers a clean and intuitive API for making HTTP requests.\n2. **Future-based**: All operations return Futures, allowing for easy asynchronous programming.\n3. **Support for all HTTP methods**: GET, POST, PUT, DELETE, and more are supported out of the box.\n4. **Header manipulation**: Easily add custom headers to your requests.\n5. **Request and response streaming**: Efficient handling of large data transfers.\n6. **Multipart requests**: Useful for file uploads and complex form submissions.\n7. **Cookie management**: Automatic handling of cookies for stateful connections.\n\n## Why Use the HTTP Package?\n\nWhile Flutter provides the `dart:io` library for making HTTP requests, the `http` package offers several advantages:\n\n- **Simplicity**: The API is more straightforward and easier to use.\n- **Cross-platform compatibility**: Works seamlessly on both mobile and web platforms.\n- **Built-in error handling**: Provides clear error messages and exceptions.\n- **Community support**: Being a widely used package, it has excellent documentation and community resources.\n\nIn the following sections, we'll dive deeper into how to use the `http` package in your Flutter applications, demonstrating its capabilities with practical examples.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'HTTP Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String _responseText = 'No data';\n  bool _isLoading = false;\n\n  // Step 1: Define the base URL for our API\n  final String baseUrl = 'https://jsonplaceholder.typicode.com';\n\n  // Step 2: Create a method to fetch data (GET request)\n  Future<void> _fetchData() async {\n    setState(() => _isLoading = true);\n    try {\n      final response = await http.get(Uri.parse('$baseUrl/posts/1'));\n      if (response.statusCode == 200) {\n        setState(() {\n          _responseText = json.decode(response.body)['title'];\n        });\n      } else {\n        throw Exception('Failed to load data');\n      }\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  // Step 3: Create a method to send data (POST request)\n  Future<void> _sendData() async {\n    setState(() => _isLoading = true);\n    try {\n      final response = await http.post(\n        Uri.parse('$baseUrl/posts'),\n        headers: {'Content-Type': 'application/json; charset=UTF-8'},\n        body: json.encode({'title': 'foo', 'body': 'bar', 'userId': 1}),\n      );\n      if (response.statusCode == 201) {\n        setState(() {\n          _responseText = 'Post created with ID: ${json.decode(response.body)['id']}';\n        });\n      } else {\n        throw Exception('Failed to create post');\n      }\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  // Step 4: Create a method to update data (PUT request)\n  Future<void> _updateData() async {\n    setState(() => _isLoading = true);\n    try {\n      final response = await http.put(\n        Uri.parse('$baseUrl/posts/1'),\n        headers: {'Content-Type': 'application/json; charset=UTF-8'},\n        body: json.encode({'id': 1, 'title': 'Updated Title', 'body': 'Updated body', 'userId': 1}),\n      );\n      if (response.statusCode == 200) {\n        setState(() {\n          _responseText = 'Post updated: ${json.decode(response.body)['title']}';\n        });\n      } else {\n        throw Exception('Failed to update post');\n      }\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  // Step 5: Create a method to delete data (DELETE request)\n  Future<void> _deleteData() async {\n    setState(() => _isLoading = true);\n    try {\n      final response = await http.delete(Uri.parse('$baseUrl/posts/1'));\n      if (response.statusCode == 200) {\n        setState(() {\n          _responseText = 'Post deleted successfully';\n        });\n      } else {\n        throw Exception('Failed to delete post');\n      }\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('HTTP Package Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            if (_isLoading)\n              CircularProgressIndicator()\n            else\n              Text(_responseText, style: TextStyle(fontSize: 18)),\n            SizedBox(height: 20),\n            ElevatedButton(onPressed: _fetchData, child: Text('GET')),\n            ElevatedButton(onPressed: _sendData, child: Text('POST')),\n            ElevatedButton(onPressed: _updateData, child: Text('PUT')),\n            ElevatedButton(onPressed: _deleteData, child: Text('DELETE')),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons (GET, POST, PUT, DELETE) and a text area.\n// 2. When a user presses a button, the corresponding HTTP request is made:\n//    - GET: Fetches a post from the API and displays its title.\n//    - POST: Creates a new post and displays its ID.\n//    - PUT: Updates an existing post and displays the updated title.\n//    - DELETE: Deletes a post and displays a success message.\n// 3. During the request, a loading indicator is shown.\n// 4. After the request completes, the response or error message is displayed in the text area.\n// 5. The app uses error handling to catch and display any errors that occur during the requests.\n// 6. This example demonstrates how to use the http package to perform all major HTTP operations\n//    (GET, POST, PUT, DELETE) in a Flutter application.\n```",
    "tutorial": "# HTTP Package in Flutter: A Comprehensive Tutorial\n\n## Getting Started\n\nTo begin using the `http` package in your Flutter project, you need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  http: ^0.13.5\n```\n\nAfter adding the dependency, run `flutter pub get` to fetch the package.\n\n## Making a GET Request\n\nLet's start with a simple GET request to fetch data from an API:\n\n```dart\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nclass RealFlutter {\n  Future<Map<String, dynamic>> fetchData() async {\n    final response = await http.get(Uri.parse('https://api.example.com/data'));\n    \n    if (response.statusCode == 200) {\n      return json.decode(response.body);\n    } else {\n      throw Exception('Failed to load data');\n    }\n  }\n}\n```\n\n## Making a POST Request\n\nNow, let's look at how to make a POST request to send data to a server:\n\n```dart\nclass RealFlutter {\n  Future<http.Response> createPost(String title, String body) async {\n    return await http.post(\n      Uri.parse('https://api.example.com/posts'),\n      headers: <String, String>{\n        'Content-Type': 'application/json; charset=UTF-8',\n      },\n      body: jsonEncode(<String, String>{\n        'title': title,\n        'body': body,\n      }),\n    );\n  }\n}\n```\n\n## Handling Headers\n\nYou can easily add custom headers to your requests:\n\n```dart\nclass RealFlutter {\n  Future<http.Response> fetchWithAuth() async {\n    return await http.get(\n      Uri.parse('https://api.example.com/protected'),\n      headers: {\n        'Authorization': 'Bearer your_token_here',\n      },\n    );\n  }\n}\n```\n\n## Error Handling\n\nIt's crucial to handle errors gracefully:\n\n```dart\nclass RealFlutter {\n  Future<void> fetchDataWithErrorHandling() async {\n    try {\n      final response = await http.get(Uri.parse('https://api.example.com/data'));\n      if (response.statusCode == 200) {\n        // Handle successful response\n      } else {\n        throw Exception('Failed to load data: ${response.statusCode}');\n      }\n    } catch (e) {\n      print('Error occurred: $e');\n      // Handle error (e.g., show error message to user)\n    }\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you need to add internet permission to your `AndroidManifest.xml` file:\n\n```xml\n<manifest xmlns:android=\"...\">\n <uses-permission android:name=\"android.permission.INTERNET\" />\n <application ...\n```\n\n### iOS\n\nFor iOS, you don't need to add any special permissions for basic HTTP requests. However, if you're making requests to non-HTTPS URLs, you need to configure App Transport Security settings in your `Info.plist`:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\nNote: It's recommended to use HTTPS whenever possible for security reasons.\n\nBy following these guidelines and examples, you'll be well on your way to effectively using the `http` package in your Flutter applications across different platforms.",
    "slug": {
      "current": "http",
      "_type": "slug"
    },
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "lsyphyid"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPapH2",
        "_type": "reference",
        "_key": "dunk065f"
      }
    ],
    "_updatedAt": "2024-09-06T04:10:23Z"
  },
  {
    "author": "flutter.dev",
    "likesCount": 4017,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-bf90b8dfb5f8ff7a9f38aa8fe5797b251bf7cc84-548x1034-png",
        "_type": "reference"
      }
    },
    "name": "webview_flutter",
    "_updatedAt": "2024-09-06T04:10:24Z",
    "slug": {
      "current": "webview_flutter",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'WebView Flutter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: WebViewDemo(),\n    );\n  }\n}\n\nclass WebViewDemo extends StatefulWidget {\n  @override\n  _WebViewDemoState createState() => _WebViewDemoState();\n}\n\nclass _WebViewDemoState extends State<WebViewDemo> {\n  late WebViewController _controller;\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize the WebViewController\n    _controller = WebViewController()\n      ..setJavaScriptMode(JavaScriptMode.unrestricted)\n      ..setBackgroundColor(const Color(0x00000000))\n      ..setNavigationDelegate(\n        NavigationDelegate(\n          onPageStarted: (String url) {\n            setState(() {\n              _isLoading = true;\n            });\n          },\n          onPageFinished: (String url) {\n            setState(() {\n              _isLoading = false;\n            });\n          },\n          onNavigationRequest: (NavigationRequest request) {\n            if (request.url.startsWith('https://www.youtube.com/')) {\n              return NavigationDecision.prevent;\n            }\n            return NavigationDecision.navigate;\n          },\n        ),\n      )\n      ..loadRequest(Uri.parse('https://flutter.dev'));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 2: Build the UI\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('WebView Flutter Demo'),\n        // Step 3: Add navigation controls\n        actions: <Widget>[\n          IconButton(\n            icon: Icon(Icons.arrow_back),\n            onPressed: () async {\n              if (await _controller.canGoBack()) {\n                await _controller.goBack();\n              }\n            },\n          ),\n          IconButton(\n            icon: Icon(Icons.arrow_forward),\n            onPressed: () async {\n              if (await _controller.canGoForward()) {\n                await _controller.goForward();\n              }\n            },\n          ),\n          IconButton(\n            icon: Icon(Icons.refresh),\n            onPressed: () {\n              _controller.reload();\n            },\n          ),\n        ],\n      ),\n      // Step 4: Create the WebView\n      body: Stack(\n        children: [\n          WebViewWidget(controller: _controller),\n          if (_isLoading)\n            Center(\n              child: CircularProgressIndicator(),\n            ),\n        ],\n      ),\n      // Step 5: Add a floating action button for JavaScript execution\n      floatingActionButton: FloatingActionButton(\n        child: Icon(Icons.color_lens),\n        onPressed: () {\n          // Step 6: Execute JavaScript\n          _controller.runJavaScript(\n            'document.body.style.backgroundColor = \"#\" + Math.floor(Math.random()*16777215).toString(16);'\n          );\n        },\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the WebViewController with custom settings.\n// 2. The WebView loads the Flutter website (https://flutter.dev).\n// 3. While the page is loading, a loading indicator is displayed.\n// 4. Once the page is loaded, the loading indicator disappears.\n// 5. Users can navigate back and forward using the app bar buttons.\n// 6. The refresh button in the app bar reloads the current page.\n// 7. The floating action button executes JavaScript to change the background color randomly.\n// 8. Navigation to YouTube is prevented as an example of custom navigation handling.\n\n// This example demonstrates:\n// - WebView initialization and configuration\n// - Page loading and progress indication\n// - Navigation controls (back, forward, refresh)\n// - JavaScript execution\n// - Custom navigation handling\n```",
    "tags": [
      "html",
      "webview",
      "webview-flutter",
      "browser",
      "web"
    ],
    "_id": "Rx1Nho763d29lawKra1VCB",
    "_createdAt": "2024-08-28T22:15:50Z",
    "tutorial": "# WebView Flutter Package: Tutorial\n\nThis tutorial will guide you through setting up and using the `webview_flutter` package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  webview_flutter: ^4.0.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:webview_flutter/webview_flutter.dart';\n```\n\n## Step 3: Platform-Specific Setup\n\n### Android\n\nFor Android, you need to update your `minSdkVersion`. Open `android/app/build.gradle` and set:\n\n```gradle\ndefaultConfig {\n    minSdkVersion 19\n}\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n## Step 4: Create a WebView Widget\n\nHere's a basic example of how to create a WebView:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('WebView Example')),\n      body: WebView(\n        initialUrl: 'https://flutter.dev',\n        javascriptMode: JavascriptMode.unrestricted,\n      ),\n    );\n  }\n}\n```\n\n## Step 5: Customize WebView Behavior\n\nYou can customize the WebView behavior using various properties:\n\n```dart\nWebView(\n  initialUrl: 'https://flutter.dev',\n  javascriptMode: JavascriptMode.unrestricted,\n  onPageStarted: (String url) {\n    print('Page started loading: $url');\n  },\n  onPageFinished: (String url) {\n    print('Page finished loading: $url');\n  },\n  gestureNavigationEnabled: true,\n)\n```\n\n## Step 6: JavaScript Execution\n\nTo execute JavaScript in the WebView:\n\n```dart\nfinal controller = WebViewController()\n  ..loadRequest(Uri.parse('https://example.com'))\n  ..runJavaScript('document.body.style.backgroundColor = \"red\";');\n```\n\n## Step 7: Navigation Controls\n\nImplement navigation controls using the WebViewController:\n\n```dart\nElevatedButton(\n  child: Text('Go Back'),\n  onPressed: () async {\n    if (await controller.canGoBack()) {\n      await controller.goBack();\n    }\n  },\n)\n```\n\nBy following these steps, you'll have a basic implementation of WebView in your Flutter app. In the next section, we'll look at a more comprehensive example that demonstrates various features of the `webview_flutter` package.",
    "gallery": [
      {
        "_type": "image",
        "_key": "3e8a0f7a2244",
        "asset": {
          "_ref": "image-df4f5adadb3044521b5dedb922e1755ca54d0316-548x558-png",
          "_type": "reference"
        }
      }
    ],
    "_rev": "AE3hjGWNkNE6aGQMMbaO9d",
    "shortDescription": "A Flutter plugin that provides a WebView widget backed by the system webview.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1fNn",
        "_type": "reference",
        "_key": "p2ik3ab8"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGfb",
        "_type": "reference",
        "_key": "tjzddcqg"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ju7",
        "_type": "reference",
        "_key": "2t80t0sp"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPbBNs",
        "_type": "reference",
        "_key": "gp8k7qax"
      }
    ],
    "description": "# WebView Flutter Package: An In-Depth Look\n\nThe `webview_flutter` package is a powerful tool for Flutter developers who want to integrate web content seamlessly into their mobile applications. This package provides a WebView widget that allows you to display and interact with web pages directly within your Flutter app.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Supports both Android and iOS platforms.\n2. **JavaScript Execution**: Allows running JavaScript code in the WebView.\n3. **Navigation Controls**: Provides methods for navigating web pages (back, forward, reload).\n4. **Cookie Management**: Offers built-in cookie handling capabilities.\n5. **Custom User Agent**: Allows setting a custom user agent string.\n6. **File Upload**: Supports file upload from the device.\n7. **Geolocation**: Enables accessing the device's location (with proper permissions).\n8. **Local Storage**: Provides access to the WebView's local storage.\n\n## When to Use WebView Flutter\n\n- Displaying web content within your app without redirecting to an external browser.\n- Creating hybrid apps that combine native Flutter UI with web-based features.\n- Implementing in-app browsers for viewing external content.\n- Utilizing web-based authentication flows within your app.\n\nIn the following sections, we'll dive deeper into how to implement and utilize the `webview_flutter` package in your Flutter projects.",
    "platforms": [
      "android",
      "ios",
      "macos"
    ],
    "lastUpdate": "2024-08-20T18:30:00.000Z",
    "tutorialIncluded": true
  },
  {
    "shortDescription": "Render After Effects animations natively on Flutter. This package is a pure Dart implementation of a Lottie player.",
    "_createdAt": "2024-08-28T22:15:52Z",
    "tutorial": "# Lottie in Flutter: Tutorial\n\nThis tutorial will guide you through the process of implementing Lottie animations in your Flutter application. We'll cover basic usage, customization, and platform-specific considerations.\n\n## Basic Usage\n\n1. Add the Lottie dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  lottie: ^2.3.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the Lottie package in your Dart file:\n\n```dart\nimport 'package:lottie/lottie.dart';\n```\n\n4. Use the `Lottie` widget to display an animation:\n\n```dart\nLottie.asset('assets/animation.json')\n```\n\n## Loading Animations\n\nLottie supports loading animations from various sources:\n\n- **Assets**: `Lottie.asset('assets/animation.json')`\n- **Network**: `Lottie.network('https://example.com/animation.json')`\n- **File**: `Lottie.file(File('path/to/animation.json'))`\n\n## Customization\n\n### Controlling Animation\n\nYou can control the animation using an `AnimationController`:\n\n```dart\nclass _MyHomePageState extends State<MyHomePage> with TickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Lottie.asset(\n      'assets/animation.json',\n      controller: _controller,\n      onLoaded: (composition) {\n        _controller\n          ..duration = composition.duration\n          ..forward();\n      },\n    );\n  }\n}\n```\n\n### Modifying Colors\n\nYou can change the colors of your Lottie animation at runtime:\n\n```dart\nValueNotifier<Color> _colorNotifier = ValueNotifier<Color>(Colors.blue);\n\nLottie.asset(\n  'assets/animation.json',\n  delegates: LottieDelegates(\n    values: [\n      ValueDelegate.color(\n        ['**', 'Group 1', '**'],\n        value: _colorNotifier,\n      ),\n    ],\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure that your `minSdkVersion` is set to 16 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### iOS\n\nFor iOS, no additional configuration is required. Lottie works out of the box with Flutter's iOS support.\n\n### Web\n\nFor web support, make sure to include the Lottie JavaScript library in your `web/index.html` file:\n\n```html\n<head>\n  <!-- Other head elements -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.7.14/lottie.min.js\"></script>\n</head>\n```\n\nBy following these steps and considerations, you can effectively implement Lottie animations in your Flutter application across different platforms.",
    "author": "xaha.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaOCp",
    "description": "# Lottie in Flutter: Bringing Animations to Life\n\n## Introduction\n\nLottie is a powerful library that allows developers to easily add high-quality animations to their Flutter applications. Originally developed by Airbnb, Lottie has become a go-to solution for implementing complex animations without the need for manual coding or extensive animation knowledge.\n\n## What is Lottie?\n\nLottie is an open-source animation file format that enables designers to ship animations as easily as shipping static assets. These animations are exported as JSON files and can be rendered natively with Lottie on iOS, Android, and web platforms.\n\n## Why Use Lottie in Flutter?\n\n1. **Easy Integration**: Lottie animations can be easily integrated into Flutter projects with minimal code.\n2. **Performance**: Lottie animations are typically small in file size and render efficiently, ensuring smooth performance.\n3. **Cross-platform Compatibility**: Lottie works seamlessly across iOS, Android, and web platforms.\n4. **Designer-Developer Collaboration**: Designers can create complex animations using tools like Adobe After Effects, which developers can then easily implement using Lottie.\n5. **Customization**: Lottie allows runtime manipulation of animations, including color changes, speed adjustments, and more.\n\n## Getting Started\n\nTo use Lottie in your Flutter project, you'll need to add the `lottie` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  lottie: ^2.3.0  # Use the latest version\n```\n\nAfter adding the dependency, you can start using Lottie animations in your Flutter application. In the following sections, we'll dive deeper into how to implement and customize Lottie animations in your Flutter projects.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "wqy9f75s"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference",
        "_key": "1u6u8e7l"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:lottie/lottie.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Lottie Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const LottieDemoHome(),\n    );\n  }\n}\n\nclass LottieDemoHome extends StatefulWidget {\n  const LottieDemoHome({Key? key}) : super(key: key);\n\n  @override\n  _LottieDemoHomeState createState() => _LottieDemoHomeState();\n}\n\nclass _LottieDemoHomeState extends State<LottieDemoHome> with TickerProviderStateMixin {\n  // Step 1: Declare variables\n  late AnimationController _controller;\n  late AnimationController _repeatController;\n  bool _isPlaying = false;\n  ValueNotifier<Color> _colorNotifier = ValueNotifier<Color>(Colors.blue);\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Initialize controllers\n    _controller = AnimationController(vsync: this);\n    _repeatController = AnimationController(vsync: this, duration: const Duration(seconds: 2));\n    _repeatController.repeat();\n  }\n\n  @override\n  void dispose() {\n    // Step 7: Dispose controllers\n    _controller.dispose();\n    _repeatController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Lottie Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Column(\n          children: [\n            // Step 3: Basic Lottie animation\n            Lottie.asset(\n              'assets/animation1.json',\n              width: 200,\n              height: 200,\n              fit: BoxFit.cover,\n            ),\n            \n            // Step 4: Controlled Lottie animation\n            Lottie.asset(\n              'assets/animation2.json',\n              controller: _controller,\n              width: 200,\n              height: 200,\n              onLoaded: (composition) {\n                _controller.duration = composition.duration;\n              },\n            ),\n            \n            // Play/Pause button for controlled animation\n            ElevatedButton(\n              onPressed: () {\n                setState(() {\n                  if (_isPlaying) {\n                    _controller.stop();\n                  } else {\n                    _controller.reset();\n                    _controller.forward();\n                  }\n                  _isPlaying = !_isPlaying;\n                });\n              },\n              child: Text(_isPlaying ? 'Pause' : 'Play'),\n            ),\n            \n            // Step 5: Repeating Lottie animation\n            Lottie.asset(\n              'assets/animation3.json',\n              controller: _repeatController,\n              width: 200,\n              height: 200,\n            ),\n            \n            // Step 6: Color-changing Lottie animation\n            Lottie.asset(\n              'assets/animation4.json',\n              width: 200,\n              height: 200,\n              delegates: LottieDelegates(\n                values: [\n                  ValueDelegate.color(\n                    ['**', 'Group 1', '**'],\n                    value: _colorNotifier,\n                  ),\n                ],\n              ),\n            ),\n            \n            // Color change button\n            ElevatedButton(\n              onPressed: () {\n                _colorNotifier.value = Colors.primaries[\n                  (Colors.primaries.indexOf(_colorNotifier.value) + 1) % Colors.primaries.length\n                ];\n              },\n              child: const Text('Change Color'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. LottieDemoHome is created as the home screen.\n// 3. In the initState method, two AnimationControllers are initialized:\n//    - _controller for the manually controlled animation\n//    - _repeatController for the continuously repeating animation\n// 4. The build method creates a Scaffold with multiple Lottie animations:\n//    a. A basic animation loaded from assets\n//    b. A controlled animation with play/pause functionality\n//    c. A repeating animation that loops continuously\n//    d. A color-changing animation with a button to cycle through colors\n// 5. User interactions:\n//    - Tapping the Play/Pause button toggles the controlled animation\n//    - Tapping the Change Color button cycles through different colors for the last animation\n// 6. When navigating away from the screen or closing the app, the dispose method is called,\n//    ensuring that the AnimationControllers are properly disposed of to prevent memory leaks.\n```",
    "packageImage": null,
    "_type": "package",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "w2s1tz8c",
        "_ref": "4gmBGwifQuSypgRenUbVWC"
      }
    ],
    "likesCount": 3878,
    "name": "lottie",
    "tutorialIncluded": true,
    "slug": {
      "current": "lottie",
      "_type": "slug"
    },
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "tags": [
      "animation",
      "lottie",
      "vector",
      "graphics",
      "ui"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "pxbb3vav"
      },
      {
        "_key": "3d5nacou",
        "_ref": "uQRNMiDfrp20RZ8Id8CaUL",
        "_type": "reference"
      }
    ],
    "lastUpdate": "2024-05-16T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1VMp",
    "_updatedAt": "2024-09-06T04:10:26Z"
  },
  {
    "tutorial": "# Get_it Package Tutorial\n\n## Setting Up\n\nTo get started with `get_it`, you need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  get_it: ^7.2.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Basic Usage\n\n1. Create a global instance of `GetIt`:\n\n```dart\nimport 'package:get_it/get_it.dart';\n\nfinal getIt = GetIt.instance;\n```\n\n2. Register your dependencies:\n\n```dart\nvoid setupLocator() {\n  getIt.registerSingleton<ApiService>(ApiService());\n  getIt.registerFactory<UserRepository>(() => UserRepository());\n}\n```\n\n3. Use your registered dependencies:\n\n```dart\nfinal apiService = getIt<ApiService>();\nfinal userRepository = getIt<UserRepository>();\n```\n\n## Advanced Features\n\n### Asynchronous Registration\n\nFor services that require asynchronous initialization:\n\n```dart\nFuture<void> setupLocator() async {\n  getIt.registerSingletonAsync<DatabaseService>(() async {\n    final service = DatabaseService();\n    await service.init();\n    return service;\n  });\n}\n```\n\n### Lazy Singletons\n\nRegister a singleton that's only created when first accessed:\n\n```dart\ngetIt.registerLazySingleton<CacheManager>(() => CacheManager());\n```\n\n### Factory Functions\n\nRegister a factory function to create new instances each time:\n\n```dart\ngetIt.registerFactory<DataModel>(() => DataModel());\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nWhen using `get_it` in Android, ensure that you initialize your locator before running your app:\n\n```dart\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  setupLocator();\n  runApp(RealFlutter());\n}\n```\n\n### iOS\n\nFor iOS, you might want to consider initializing platform-specific services:\n\n```dart\nif (Platform.isIOS) {\n  getIt.registerSingleton<IosSpecificService>(IosSpecificService());\n}\n```\n\n### Web\n\nWhen targeting web platforms, be mindful of asynchronous initializations:\n\n```dart\nFuture<void> setupLocator() async {\n  getIt.registerSingletonAsync<WebStorageService>(() async {\n    final service = WebStorageService();\n    await service.init();\n    return service;\n  });\n  await getIt.allReady();\n}\n```\n\n## Best Practices\n\n1. Initialize your locator as early as possible, preferably before `runApp()`.\n2. Use meaningful names for your registered dependencies to avoid conflicts.\n3. Consider using interfaces for your services to make them easier to mock in tests.\n4. Don't overuse `get_it`. For local state or dependencies, consider passing them down the widget tree.\n\nBy following this tutorial, you'll be well on your way to effectively using `get_it` in your Flutter projects across different platforms.",
    "example": "import 'package:flutter/material.dart';\nimport 'package:get_it/get_it.dart';\n\n// Step 1: Create a global GetIt instance\nfinal getIt = GetIt.instance;\n\n// Step 2: Define our services and models\nclass ApiService {\n  Future<String> fetchData() async {\n    // Simulate API call\n    await Future.delayed(Duration(seconds: 1));\n    return \"Data from API\";\n  }\n}\n\nclass DatabaseService {\n  Future<void> init() async {\n    // Simulate database initialization\n    await Future.delayed(Duration(seconds: 1));\n    print(\"Database initialized\");\n  }\n\n  String getData() {\n    return \"Data from Database\";\n  }\n}\n\nclass UserModel {\n  final String name;\n  UserModel(this.name);\n}\n\n// Step 3: Set up our dependency injection\nFuture<void> setupLocator() async {\n  // Register a singleton\n  getIt.registerSingleton<ApiService>(ApiService());\n\n  // Register a lazy singleton\n  getIt.registerLazySingleton<UserModel>(() => UserModel(\"John Doe\"));\n\n  // Register an asynchronous singleton\n  getIt.registerSingletonAsync<DatabaseService>(() async {\n    final service = DatabaseService();\n    await service.init();\n    return service;\n  });\n\n  // Register a factory\n  getIt.registerFactory<DateTime>(() => DateTime.now());\n\n  // Wait for all async singletons to be ready\n  await getIt.allReady();\n}\n\n// Step 4: Create our main app widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: HomeScreen(),\n    );\n  }\n}\n\n// Step 5: Create a screen to demonstrate get_it usage\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('get_it Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              child: Text('Fetch API Data'),\n              onPressed: () async {\n                final apiService = getIt<ApiService>();\n                final data = await apiService.fetchData();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text(data)),\n                );\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Get Database Data'),\n              onPressed: () {\n                final dbService = getIt<DatabaseService>();\n                final data = dbService.getData();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text(data)),\n                );\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Get User Name'),\n              onPressed: () {\n                final user = getIt<UserModel>();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text(user.name)),\n                );\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Get Current Time'),\n              onPressed: () {\n                final now = getIt<DateTime>();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text(now.toString())),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 6: Set up the main function\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await setupLocator();\n  runApp(RealFlutter());\n}\n\n// Application Flow Explanation:\n// 1. The app starts in the main() function.\n// 2. We ensure Flutter bindings are initialized.\n// 3. We call setupLocator() to register all our dependencies with get_it.\n// 4. We wait for all async singletons to be ready before running the app.\n// 5. The app runs, starting with the RealFlutter widget.\n// 6. The HomeScreen is displayed, showing buttons for different get_it operations.\n// 7. When a button is pressed, we retrieve the corresponding service or model from get_it.\n// 8. We use the retrieved object to perform an action and display the result.\n// 9. This demonstrates how get_it allows easy access to dependencies from anywhere in the app.",
    "tags": [
      "dependency-injection",
      "service-locator",
      "inversion-of-control"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "9le5lg97"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "6h4ze4pp"
      }
    ],
    "packageImage": null,
    "author": "fluttercommunity.dev",
    "description": "# Understanding the get_it Package in Flutter\n\n## Introduction\n\nIn the world of Flutter development, state management and dependency injection are crucial aspects of building robust and maintainable applications. The `get_it` package is a powerful tool that simplifies these processes, offering a lightweight and easy-to-use service locator for Dart and Flutter projects.\n\n## What is get_it?\n\n`get_it` is a simple service locator for Dart and Flutter projects with a straightforward API. It allows you to register objects and access them from anywhere in your app, making it an excellent choice for dependency injection and state management.\n\n## Key Features\n\n1. **Simplicity**: `get_it` provides a simple and intuitive API, making it easy to learn and implement.\n2. **Flexibility**: It supports various registration types, including singletons, factories, and asynchronous initializations.\n3. **Performance**: `get_it` is designed to be fast and efficient, with minimal impact on your app's performance.\n4. **Testability**: The package makes it easy to replace dependencies in your tests, improving the overall testability of your code.\n5. **No Code Generation**: Unlike some other dependency injection solutions, `get_it` doesn't require code generation, reducing build times and complexity.\n\n## When to Use get_it\n\n`get_it` is particularly useful in the following scenarios:\n\n- When you need to access services or models from different parts of your app without passing them through constructors.\n- For managing global state in a clean and organized manner.\n- When you want to implement dependency injection without the complexity of more heavyweight solutions.\n- In projects where you need to easily swap implementations for testing or different environments.\n\nIn the next sections, we'll dive deeper into how to use `get_it` in your Flutter projects, providing a tutorial and a comprehensive example to demonstrate its capabilities.",
    "likesCount": 4117,
    "_createdAt": "2024-08-28T22:15:53Z",
    "_id": "Rx1Nho763d29lawKra1VXT",
    "_updatedAt": "2024-09-06T04:10:27Z",
    "slug": {
      "current": "get_it",
      "_type": "slug"
    },
    "_type": "package",
    "shortDescription": "Simple direct Service Locator that allows to decouple the interface from a concrete implementation and  to access the concrete implementation from everywhere in your App\"",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPanCW",
        "_type": "reference",
        "_key": "e0hfz8ka"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-04-14T18:30:00.000Z",
    "name": "get_it",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaOG1",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGCM",
        "_type": "reference",
        "_key": "fhyvse8s"
      }
    ]
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaOJD",
    "shortDescription": "A Dart package that helps to implement value based equality without needing to explicitly override == and hashCode.",
    "packageImage": null,
    "name": "equatable",
    "_createdAt": "2024-08-28T22:16:01Z",
    "_id": "Rx1Nho763d29lawKra1Vsl",
    "tutorial": "# Equatable Package Tutorial\n\n## Getting Started\n\nTo start using the Equatable package in your Flutter project, follow these steps:\n\n1. Add the dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  equatable: ^2.0.5\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:equatable/equatable.dart';\n```\n\n## Basic Usage\n\nLet's create a simple `Person` class using Equatable:\n\n```dart\nimport 'package:equatable/equatable.dart';\n\nclass Person extends Equatable {\n  final String name;\n  final int age;\n\n  const Person(this.name, this.age);\n\n  @override\n  List<Object> get props => [name, age];\n}\n```\n\nIn this example, `Person` extends `Equatable` and overrides the `props` getter to return a list of properties that should be used for equality comparisons.\n\n## Advanced Usage\n\n### Ignoring Properties\n\nIf you want to ignore certain properties in equality comparisons, you can exclude them from the `props` list:\n\n```dart\nclass User extends Equatable {\n  final String id;\n  final String name;\n  final String? lastLoginTime;\n\n  const User(this.id, this.name, this.lastLoginTime);\n\n  @override\n  List<Object?> get props => [id, name]; // Excluding lastLoginTime\n}\n```\n\n### Using with Flutter Widgets\n\nEquatable works seamlessly with Flutter widgets. Here's an example using a custom `StatelessWidget`:\n\n```dart\nclass CustomButton extends Equatable {\n  final String label;\n  final VoidCallback onPressed;\n\n  const CustomButton({required this.label, required this.onPressed});\n\n  @override\n  List<Object> get props => [label]; // Excluding onPressed function\n\n  @override\n  bool? get stringify => true; // For better toString() output\n}\n```\n\n### Platform-Specific Considerations\n\n#### iOS\nWhen using Equatable in iOS, ensure that you're using Swift 5.0 or later, as it provides better support for value types and equality comparisons.\n\n#### Android\nFor Android, Equatable works out of the box without any special considerations. However, be mindful of performance when dealing with large lists or complex objects.\n\n#### Web\nWhen targeting web platforms, be aware that JavaScript's equality comparisons might behave differently. Equatable helps maintain consistency across platforms, but always test thoroughly on web targets.\n\nIn the next section, we'll look at a complete example demonstrating various features of the Equatable package.",
    "author": "fluttercommunity.dev",
    "description": "# Understanding the Equatable Package in Flutter\n\n## Introduction\n\nIn the world of Flutter development, comparing objects can sometimes be a tricky task. This is where the `equatable` package comes to the rescue. The `equatable` package is a Dart library that helps in implementing equality without needing to explicitly override `==` and `hashCode`.\n\n## What is Equatable?\n\nEquatable is a Dart package that allows value-based equality comparisons in Dart and Flutter. It simplifies the process of implementing equality in your custom classes by automatically generating the `==` operator and `hashCode` methods based on the properties you define.\n\n## Why Use Equatable?\n\n1. **Simplicity**: Equatable reduces boilerplate code by automatically generating equality methods.\n2. **Consistency**: It ensures that equality comparisons are consistent across your entire application.\n3. **Performance**: Equatable can improve performance in certain scenarios, especially when using collections.\n\n## Key Features\n\n- Automatic generation of `==` and `hashCode` methods\n- Support for `const` constructors\n- Easy integration with existing Flutter classes\n- Compatible with most Dart and Flutter versions\n\nIn the next section, we'll dive into a tutorial on how to use the Equatable package in your Flutter projects.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:equatable/equatable.dart';\n\n// Step 1: Define our main application class\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Equatable Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const HomePage(),\n    );\n  }\n}\n\n// Step 2: Define a Person class using Equatable\nclass Person extends Equatable {\n  final String name;\n  final int age;\n\n  const Person(this.name, this.age);\n\n  @override\n  List<Object> get props => [name, age];\n\n  // Enable stringify for better toString method\n  @override\n  bool get stringify => true;\n}\n\n// Step 3: Define a ComplexPerson class with nested Equatable objects\nclass ComplexPerson extends Equatable {\n  final String id;\n  final Person details;\n  final List<String> hobbies;\n\n  const ComplexPerson(this.id, this.details, this.hobbies);\n\n  @override\n  List<Object> get props => [id, details, hobbies];\n\n  @override\n  bool get stringify => true;\n}\n\n// Step 4: Create the HomePage widget\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  late Person person1;\n  late Person person2;\n  late ComplexPerson complexPerson1;\n  late ComplexPerson complexPerson2;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 5: Initialize our test objects\n    person1 = const Person('Alice', 30);\n    person2 = const Person('Alice', 30);\n    complexPerson1 = ComplexPerson('1', person1, ['reading', 'coding']);\n    complexPerson2 = ComplexPerson('1', person2, ['reading', 'coding']);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Equatable Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 6: Display equality comparisons\n            Text('person1 == person2: ${person1 == person2}'),\n            const SizedBox(height: 10),\n            Text('complexPerson1 == complexPerson2: ${complexPerson1 == complexPerson2}'),\n            const SizedBox(height: 20),\n            // Step 7: Display string representations\n            Text('person1: $person1'),\n            const SizedBox(height: 10),\n            Text('complexPerson1: $complexPerson1'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 8: Run the application\nvoid main() {\n  runApp(const RealFlutter());\n}\n\n// Application Flow:\n// 1. The application starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. We define two Equatable classes: Person and ComplexPerson.\n// 3. The HomePage is created as a StatefulWidget.\n// 4. In initState, we create instances of Person and ComplexPerson.\n// 5. The build method creates a UI that displays:\n//    - The result of equality comparisons between the created objects.\n//    - The string representations of the objects (using stringify).\n// 6. The equality comparisons demonstrate how Equatable allows for value-based equality.\n// 7. The string representations show how Equatable improves object debugging.\n\n// Key Points:\n// - Equatable simplifies equality comparisons without manual overrides.\n// - It works with nested objects (as seen in ComplexPerson).\n// - The stringify feature provides better toString output for debugging.\n// - Equatable maintains consistency across different object instances with the same values.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "equality",
      "comparison",
      "value-equality"
    ],
    "slug": {
      "_type": "slug",
      "current": "equatable"
    },
    "pubPoint": 160,
    "_type": "package",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "2yrpzf6c"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaZr",
        "_type": "reference",
        "_key": "3p2juduw"
      }
    ],
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:28Z",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CbCT",
        "_type": "reference",
        "_key": "nnrtm1rt"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGCM",
        "_type": "reference",
        "_key": "6z6irsvz"
      }
    ],
    "likesCount": 3111,
    "lastUpdate": "2022-08-18T18:30:00.000Z"
  },
  {
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through how to use the `package_info_plus` package in your Flutter application. We'll cover basic usage and platform-specific details.\n\n### Basic Usage\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:package_info_plus/package_info_plus.dart';\n```\n\n2. To get the package information, use the `PackageInfo.fromPlatform()` method:\n\n```dart\nPackageInfo packageInfo = await PackageInfo.fromPlatform();\n\nString appName = packageInfo.appName;\nString packageName = packageInfo.packageName;\nString version = packageInfo.version;\nString buildNumber = packageInfo.buildNumber;\n```\n\n### Platform-Specific Details\n\n#### Android\n\n- `appName`: The app name in `AndroidManifest.xml`\n- `packageName`: The package name in the manifest\n- `version`: The `versionName` in the manifest\n- `buildNumber`: The `versionCode` in the manifest\n\n#### iOS\n\n- `appName`: The `CFBundleDisplayName` or `CFBundleName` in Info.plist\n- `packageName`: The bundle identifier in Info.plist\n- `version`: The `CFBundleShortVersionString` in Info.plist\n- `buildNumber`: The `CFBundleVersion` in Info.plist\n\n#### Web\n\n- `appName`: The `<title>` tag in the HTML file\n- `packageName`: Empty string\n- `version`: Empty string\n- `buildNumber`: Empty string\n\n#### macOS\n\n- Similar to iOS, using the macOS app's Info.plist file\n\n#### Windows\n\n- `appName`: The executable filename without the .exe extension\n- `packageName`: The executable filename without the .exe extension\n- `version`: The product version of the executable\n- `buildNumber`: The file version of the executable\n\n#### Linux\n\n- `appName`: The executable filename\n- `packageName`: The executable filename\n- `version`: Empty string\n- `buildNumber`: Empty string\n\n### Error Handling\n\nWhen using `PackageInfo.fromPlatform()`, it's good practice to handle potential errors:\n\n```dart\ntry {\n  PackageInfo packageInfo = await PackageInfo.fromPlatform();\n  // Use packageInfo\n} catch (e) {\n  print('Failed to get package info: $e');\n}\n```\n\nIn the next section, we'll look at a complete example that demonstrates all the features of the `package_info_plus` package.",
    "_type": "package",
    "shortDescription": "Flutter plugin for querying information about the application package, such as CFBundleVersion on iOS or versionCode on Android.",
    "likesCount": 2261,
    "_createdAt": "2024-08-28T22:16:02Z",
    "_id": "Rx1Nho763d29lawKra1WL9",
    "_updatedAt": "2024-09-06T04:10:28Z",
    "slug": {
      "current": "package_info_plus",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmL51",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8ChUH",
        "_type": "reference",
        "_key": "e3l18fbn"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGUX",
        "_type": "reference",
        "_key": "cuxl33h0"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:package_info_plus/package_info_plus.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Package Info Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const PackageInfoScreen(),\n    );\n  }\n}\n\nclass PackageInfoScreen extends StatefulWidget {\n  const PackageInfoScreen({Key? key}) : super(key: key);\n\n  @override\n  _PackageInfoScreenState createState() => _PackageInfoScreenState();\n}\n\nclass _PackageInfoScreenState extends State<PackageInfoScreen> {\n  PackageInfo _packageInfo = PackageInfo(\n    appName: 'Unknown',\n    packageName: 'Unknown',\n    version: 'Unknown',\n    buildNumber: 'Unknown',\n    buildSignature: 'Unknown',\n    installerStore: 'Unknown',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    _initPackageInfo();\n  }\n\n  // Step 1: Initialize package info\n  Future<void> _initPackageInfo() async {\n    try {\n      final info = await PackageInfo.fromPlatform();\n      setState(() {\n        _packageInfo = info;\n      });\n    } catch (e) {\n      print('Error getting package info: $e');\n    }\n  }\n\n  // Step 2: Create a widget to display package info\n  Widget _infoTile(String title, String subtitle) {\n    return ListTile(\n      title: Text(title),\n      subtitle: Text(subtitle.isEmpty ? 'Not available' : subtitle),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Build the UI\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Package Info Plus Demo'),\n      ),\n      body: ListView(\n        children: [\n          _infoTile('App name', _packageInfo.appName),\n          _infoTile('Package name', _packageInfo.packageName),\n          _infoTile('Version', _packageInfo.version),\n          _infoTile('Build number', _packageInfo.buildNumber),\n          _infoTile('Build signature', _packageInfo.buildSignature),\n          _infoTile('Installer store', _packageInfo.installerStore ?? 'Not available'),\n          // Step 4: Add a button to refresh package info\n          ElevatedButton(\n            onPressed: () {\n              setState(() {\n                _initPackageInfo();\n              });\n            },\n            child: const Text('Refresh Package Info'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application flow:\n// 1. The app starts and runs the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and sets PackageInfoScreen as the home screen.\n// 3. PackageInfoScreen is created, and its state is initialized.\n// 4. In the initState method, _initPackageInfo() is called to fetch the package information.\n// 5. _initPackageInfo() uses PackageInfo.fromPlatform() to get the package details.\n// 6. Once the information is retrieved, setState() is called to update the UI.\n// 7. The build method creates a ListView with ListTiles for each piece of package information.\n// 8. A \"Refresh Package Info\" button is added at the bottom, which calls _initPackageInfo() again when pressed.\n// 9. If there's an error fetching the package info, it's caught and printed to the console.\n\n// This example demonstrates:\n// - How to retrieve package information using package_info_plus\n// - How to display the information in a user-friendly format\n// - Error handling for package info retrieval\n// - How to manually refresh the package information\n// - Cross-platform compatibility (the same code works on all supported platforms)\n```",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "description": "# Package Info Plus: A Comprehensive Guide\n\n## 1. Description\n\n`package_info_plus` is a Flutter plugin that provides an easy way to query information about the application package. This plugin is particularly useful for developers who need to access details about their app's package across different platforms, including iOS, Android, Web, Windows, and more.\n\n### Key Features:\n\n1. **Cross-platform compatibility**: Works on iOS, Android, Web, macOS, Windows, and Linux.\n2. **Easy to use**: Simple API for querying package information.\n3. **Comprehensive data**: Provides access to app name, package name, version, build number, and more.\n4. **Null safety**: Fully supports Dart's null safety feature.\n\n### Why use package_info_plus?\n\n- **Version checking**: Implement version checks for updates or compatibility.\n- **Analytics**: Send app version information with crash reports or analytics data.\n- **Customization**: Display app version in the UI or about page.\n- **Debugging**: Easily access build information during development.\n\n### Installation\n\nTo use `package_info_plus` in your Flutter project, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  package_info_plus: ^4.0.0\n```\n\nThen, run `flutter pub get` to install the package.\n\nIn the next section, we'll dive into a tutorial on how to use `package_info_plus` in your Flutter applications, including platform-specific details.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "package_info_plus",
    "author": "fluttercommunity.dev",
    "tags": [
      "information",
      "identifier",
      "utils",
      "app-info",
      "version"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1hNz",
        "_type": "reference",
        "_key": "42lnkisj"
      },
      {
        "_key": "4249nv35",
        "_ref": "V06bsD4sX3T8NTHrBPafbI",
        "_type": "reference"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-08-08T18:30:00.000Z"
  },
  {
    "shortDescription": "Highly customizable, feature-packed calendar widget for Flutter.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "calendar",
      "date",
      "widget",
      "ui",
      "events"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:16:10Z",
    "lastUpdate": "2024-06-08T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1XCN",
    "_type": "package",
    "_updatedAt": "2024-09-06T04:10:30Z",
    "slug": {
      "current": "table_calendar",
      "_type": "slug"
    },
    "tutorialIncluded": true,
    "description": "# Table Calendar Package for Flutter: A Comprehensive Overview\n\nThe `table_calendar` package is a highly customizable calendar widget for Flutter applications. It provides a flexible and feature-rich solution for integrating calendars into your Flutter projects. This package is particularly useful for developers who need to display events, manage appointments, or simply offer a visually appealing calendar interface in their apps.\n\n## Key Features:\n\n1. **Customizable UI**: The package offers extensive customization options, allowing developers to tailor the calendar's appearance to match their app's design language.\n\n2. **Multiple Calendar Formats**: Supports various calendar formats including month, 2-week, and week views.\n\n3. **Event Management**: Easily add and display events on specific dates.\n\n4. **Gesture Handling**: Includes built-in gesture recognition for intuitive user interactions like swiping between months.\n\n5. **Localization**: Supports multiple languages and custom symbols for weekdays and months.\n\n6. **Dynamic Calendar Builders**: Allows for custom building of day cells, markers, and more.\n\n7. **Holiday Management**: Capability to highlight holidays or special days.\n\n8. **Range Selection**: Supports selecting a range of dates, useful for booking applications.\n\n## Why Choose table_calendar?\n\nThe `table_calendar` package stands out due to its balance of simplicity and power. It's easy to implement basic functionality quickly, while also offering depth for more complex use cases. Whether you're building a simple scheduling app or a complex event management system, `table_calendar` provides the tools you need to create a polished, user-friendly calendar interface.\n\nIn the following sections, we'll dive deeper into how to implement and customize this powerful package in your Flutter applications.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPb42i",
        "_type": "reference",
        "_key": "z3aqzsua"
      }
    ],
    "author": "",
    "_rev": "ezMiwuUkJkbYMWycA6RVbg",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:table_calendar/table_calendar.dart';\nimport 'package:intl/intl.dart';\n\n// Step 1: Define an Event class\nclass Event {\n  final String title;\n  final String description;\n  final DateTime date;\n\n  Event(this.title, this.description, this.date);\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 2: Initialize variables\n  CalendarFormat _calendarFormat = CalendarFormat.month;\n  DateTime _focusedDay = DateTime.now();\n  DateTime? _selectedDay;\n  Map<DateTime, List<Event>> _events = {};\n\n  // Step 3: Create a method to generate sample events\n  void _generateSampleEvents() {\n    final now = DateTime.now();\n    _events = {\n      now: [Event('Today\\'s Event', 'This is happening today!', now)],\n      now.add(Duration(days: 1)): [\n        Event('Tomorrow\\'s Event', 'This is happening tomorrow!', now.add(Duration(days: 1)))\n      ],\n      now.add(Duration(days: 3)): [\n        Event('Future Event 1', 'This is happening in 3 days!', now.add(Duration(days: 3))),\n        Event('Future Event 2', 'This is also happening in 3 days!', now.add(Duration(days: 3)))\n      ],\n    };\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _generateSampleEvents();\n    _selectedDay = _focusedDay;\n  }\n\n  // Step 4: Create a method to get events for a given day\n  List<Event> _getEventsForDay(DateTime day) {\n    return _events[day] ?? [];\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter Calendar'),\n      ),\n      body: Column(\n        children: [\n          // Step 5: Implement TableCalendar widget\n          TableCalendar(\n            firstDay: DateTime.utc(2010, 10, 16),\n            lastDay: DateTime.utc(2030, 3, 14),\n            focusedDay: _focusedDay,\n            calendarFormat: _calendarFormat,\n            selectedDayPredicate: (day) => isSameDay(_selectedDay, day),\n            eventLoader: _getEventsForDay,\n            startingDayOfWeek: StartingDayOfWeek.monday,\n            calendarStyle: CalendarStyle(\n              outsideDaysVisible: false,\n              weekendTextStyle: TextStyle(color: Colors.red),\n              holidayTextStyle: TextStyle(color: Colors.blue[800]),\n            ),\n            onDaySelected: (selectedDay, focusedDay, _) {\n              if (!isSameDay(_selectedDay, selectedDay)) {\n                setState(() {\n                  _selectedDay = selectedDay;\n                  _focusedDay = focusedDay;\n                });\n              }\n            },\n            onFormatChanged: (format) {\n              if (_calendarFormat != format) {\n                setState(() {\n                  _calendarFormat = format;\n                });\n              }\n            },\n            onPageChanged: (focusedDay) {\n              _focusedDay = focusedDay;\n            },\n          ),\n          // Step 6: Display events for the selected day\n          Expanded(\n            child: ListView(\n              children: _getEventsForDay(_selectedDay!)\n                  .map((event) => ListTile(\n                        title: Text(event.title),\n                        subtitle: Text(event.description),\n                        trailing: Text(DateFormat('HH:mm').format(event.date)),\n                      ))\n                  .toList(),\n            ),\n          ),\n        ],\n      ),\n      // Step 7: Add a floating action button to add new events\n      floatingActionButton: FloatingActionButton(\n        child: Icon(Icons.add),\n        onPressed: () => _showAddEventDialog(),\n      ),\n    );\n  }\n\n  // Step 8: Implement a dialog to add new events\n  void _showAddEventDialog() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text('Add Event'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(\n              decoration: InputDecoration(labelText: 'Title'),\n              onChanged: (value) {},\n            ),\n            TextField(\n              decoration: InputDecoration(labelText: 'Description'),\n              onChanged: (value) {},\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            child: Text('Cancel'),\n            onPressed: () => Navigator.pop(context),\n          ),\n          ElevatedButton(\n            child: Text('Add'),\n            onPressed: () {\n              // Add event logic here\n              Navigator.pop(context);\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n/* \nApplication Flow:\n1. The application starts by initializing the calendar with the current date as the focused day.\n2. Sample events are generated and stored in the _events map.\n3. The TableCalendar widget is rendered, displaying the current month by default.\n4. Users can interact with the calendar by:\n   a. Selecting a date, which updates the _selectedDay and _focusedDay.\n   b. Changing the calendar format (month, 2-week, week) using the format button.\n   c. Navigating between months/weeks using swipe gestures or arrow buttons.\n5. Below the calendar, a list of events for the selected day is displayed.\n6. Users can add new events by tapping the floating action button, which opens a dialog.\n7. The application updates the UI whenever the state changes (e.g., selecting a new day, adding an event).\n\nThis example demonstrates the core features of the table_calendar package, including:\n- Basic calendar display and navigation\n- Event management and display\n- Calendar format switching\n- Custom styling of calendar elements\n- Integration with user interactions (selecting days, adding events)\n\nTo further enhance this application, consider adding persistence for events, \nmore advanced event management features, and additional customization options.\n*/\n```",
    "tutorial": "# Table Calendar Tutorial: Implementing and Customizing in Flutter\n\nThis tutorial will guide you through the process of implementing the `table_calendar` package in your Flutter application. We'll cover installation, basic setup, and some advanced customizations.\n\n## Step 1: Installation\n\nAdd the `table_calendar` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  table_calendar: ^3.0.9\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:table_calendar/table_calendar.dart';\n```\n\nCreate a basic calendar widget:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  CalendarFormat _calendarFormat = CalendarFormat.month;\n  DateTime _focusedDay = DateTime.now();\n  DateTime? _selectedDay;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Table Calendar Example'),\n      ),\n      body: TableCalendar(\n        firstDay: DateTime.utc(2010, 10, 16),\n        lastDay: DateTime.utc(2030, 3, 14),\n        focusedDay: _focusedDay,\n        calendarFormat: _calendarFormat,\n        selectedDayPredicate: (day) {\n          return isSameDay(_selectedDay, day);\n        },\n        onDaySelected: (selectedDay, focusedDay, _) {\n          setState(() {\n            _selectedDay = selectedDay;\n            _focusedDay = focusedDay;\n          });\n        },\n        onFormatChanged: (format) {\n          setState(() {\n            _calendarFormat = format;\n          });\n        },\n      ),\n    );\n  }\n}\n```\n\n## Step 3: Adding Events\n\nTo add events to your calendar:\n\n1. Create an event class:\n\n```dart\nclass Event {\n  final String title;\n  Event(this.title);\n}\n```\n\n2. Create a map to store events:\n\n```dart\nfinal Map<DateTime, List<Event>> _events = {};\n```\n\n3. Modify the `TableCalendar` widget to display events:\n\n```dart\nTableCalendar(\n  // ... other properties\n  eventLoader: (day) {\n    return _events[day] ?? [];\n  },\n)\n```\n\n## Step 4: Customizing Appearance\n\nCustomize the calendar's appearance using the `calendarStyle` and `headerStyle` properties:\n\n```dart\nTableCalendar(\n  // ... other properties\n  calendarStyle: CalendarStyle(\n    todayDecoration: BoxDecoration(\n      color: Colors.blue,\n      shape: BoxShape.circle,\n    ),\n    selectedDecoration: BoxDecoration(\n      color: Colors.deepOrange,\n      shape: BoxShape.circle,\n    ),\n  ),\n  headerStyle: HeaderStyle(\n    formatButtonTextStyle: TextStyle(color: Colors.white),\n    formatButtonDecoration: BoxDecoration(\n      color: Colors.deepOrange,\n      borderRadius: BorderRadius.circular(16.0),\n    ),\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, ensure you've set the minimum deployment target in your `Podfile`:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n### Android\nFor Android, update your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 17\n        targetSdkVersion 31\n    }\n}\n```\n\nBy following these steps, you'll have a fully functional and customizable calendar in your Flutter application using the `table_calendar` package.",
    "pubPoint": 160,
    "likesCount": 2886,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "fz61ge7f",
        "_ref": "uQRNMiDfrp20RZ8Id8CaDn"
      }
    ],
    "name": "table_calendar",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFuy",
        "_type": "reference",
        "_key": "reezsyk2"
      }
    ]
  },
  {
    "shortDescription": "Small, easy to use and extensible logger which prints beautiful logs.",
    "tags": [
      "cli",
      "logging",
      "debug",
      "console",
      "output"
    ],
    "likesCount": 3155,
    "_id": "Rx1Nho763d29lawKra1YHn",
    "pubPoint": 160,
    "author": "sourcehorizon.org",
    "_rev": "eaCZ7mIhmiYZX5KGqJmLBZ",
    "packageImage": null,
    "name": "logger",
    "_type": "package",
    "description": "# Logger Package for Flutter: Enhancing Your Debugging Experience\n\n## Introduction\n\nIn the world of Flutter development, efficient debugging is crucial for creating robust and error-free applications. The `logger` package is a powerful tool that simplifies the process of logging and debugging in Flutter projects. This blog post will explore the features and benefits of using the `logger` package in your Flutter applications.\n\n## What is the Logger Package?\n\nThe `logger` package is a versatile logging utility for Dart and Flutter that provides a simple yet powerful way to add logging capabilities to your applications. It offers a range of features that make debugging more efficient and informative.\n\n## Key Features\n\n1. **Customizable Output**: The package allows you to customize the log output format, including colors, emoji support, and stack trace information.\n\n2. **Log Levels**: It supports various log levels such as verbose, debug, info, warning, error, and wtf (what a terrible failure), enabling you to categorize your logs based on their severity.\n\n3. **Pretty Printing**: The package can automatically format and pretty-print complex objects, making it easier to read and understand the logged data.\n\n4. **Filtering**: You can easily filter logs based on log levels or custom criteria, helping you focus on the most relevant information during debugging.\n\n5. **Output Redirection**: Logs can be redirected to different outputs, such as the console, file, or even a custom output of your choice.\n\n6. **Performance**: The package is designed to be lightweight and have minimal impact on your application's performance.\n\n## Why Use the Logger Package?\n\n1. **Improved Debugging**: The detailed and well-formatted logs make it easier to identify and fix issues in your code.\n\n2. **Time-saving**: With features like pretty-printing and customizable outputs, you spend less time deciphering log messages and more time solving problems.\n\n3. **Flexibility**: The package's customization options allow you to tailor the logging experience to your specific needs and preferences.\n\n4. **Cross-platform Support**: It works seamlessly across different platforms, including iOS, Android, and web.\n\nIn the following sections, we'll dive deeper into how to use the `logger` package in your Flutter projects and explore its various features through practical examples.",
    "example": "import 'package:flutter/material.dart';\nimport 'package:logger/logger.dart';\n\n// Step 1: Create a custom logger class\nclass RealFlutterLogger {\n  // Step 2: Initialize the logger with custom options\n  final logger = Logger(\n    printer: PrettyPrinter(\n      methodCount: 2,\n      errorMethodCount: 8,\n      lineLength: 120,\n      colors: true,\n      printEmojis: true,\n      printTime: true,\n    ),\n    // Step 3: Set the log level (change this to control verbosity)\n    level: Level.verbose,\n  );\n\n  // Step 4: Create methods for different log levels\n  void logVerbose(String message) => logger.v(message);\n  void logDebug(String message) => logger.d(message);\n  void logInfo(String message) => logger.i(message);\n  void logWarning(String message) => logger.w(message);\n  void logError(String message, [dynamic error, StackTrace? stackTrace]) =>\n      logger.e(message, error, stackTrace);\n  void logWtf(String message, [dynamic error, StackTrace? stackTrace]) =>\n      logger.wtf(message, error, stackTrace);\n}\n\n// Step 5: Create the main application class\nclass RealFlutter extends StatelessWidget {\n  final RealFlutterLogger logger = RealFlutterLogger();\n\n  RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('RealFlutter Logger Demo'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              ElevatedButton(\n                onPressed: _demonstrateLogging,\n                child: const Text('Demonstrate Logging'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Step 6: Create a method to demonstrate various logging levels\n  void _demonstrateLogging() {\n    logger.logVerbose('This is a verbose log');\n    logger.logDebug('This is a debug log');\n    logger.logInfo('This is an info log');\n    logger.logWarning('This is a warning log');\n    logger.logError('This is an error log');\n    \n    try {\n      // Step 7: Simulate an error\n      throw Exception('This is a simulated error');\n    } catch (e, stackTrace) {\n      logger.logWtf('This is a wtf log', e, stackTrace);\n    }\n\n    // Step 8: Log a complex object\n    final complexObject = {\n      'user': {\n        'name': 'John Doe',\n        'age': 30,\n        'hobbies': ['reading', 'coding', 'gaming'],\n      },\n      'settings': {\n        'darkMode': true,\n        'notifications': {\n          'email': true,\n          'push': false,\n        },\n      },\n    };\n    logger.logDebug('Logging a complex object: $complexObject');\n  }\n}\n\n// Step 9: Run the application\nvoid main() {\n  runApp(RealFlutter());\n}\n\n// Application Flow:\n// 1. The application starts and creates an instance of RealFlutter.\n// 2. RealFlutter initializes a RealFlutterLogger instance with custom settings.\n// 3. The UI is built with a single button labeled \"Demonstrate Logging\".\n// 4. When the button is pressed, the _demonstrateLogging method is called.\n// 5. The method logs messages at different levels: verbose, debug, info, warning, error, and wtf.\n// 6. A simulated error is thrown and caught to demonstrate error logging with stack traces.\n// 7. A complex object is logged to show how the logger handles nested data structures.\n// 8. All log messages are formatted and output according to the logger's configuration.\n// 9. The user can observe the logged messages in the console or the designated output.\n\n// Note: To fully appreciate the logger's output, run this application in debug mode\n// and check the console output in your IDE or terminal.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:16:17Z",
    "slug": {
      "current": "logger",
      "_type": "slug"
    },
    "lastUpdate": "2024-07-14T18:30:00.000Z",
    "tutorial": "# Logger Package for Flutter: A Comprehensive Tutorial\n\n## Getting Started\n\nTo begin using the `logger` package in your Flutter project, follow these steps:\n\n1. Add the package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  logger: ^1.4.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:logger/logger.dart';\n```\n\n## Basic Usage\n\nHere's a simple example of how to create and use a Logger instance:\n\n```dart\nclass RealFlutter {\n  final logger = Logger();\n\n  void logExample() {\n    logger.d('This is a debug message');\n    logger.i('This is an info message');\n    logger.w('This is a warning message');\n    logger.e('This is an error message');\n  }\n}\n```\n\n## Customizing the Logger\n\nYou can customize the logger's behavior by providing options when creating the Logger instance:\n\n```dart\nfinal logger = Logger(\n  printer: PrettyPrinter(\n    methodCount: 2,\n    errorMethodCount: 8,\n    lineLength: 120,\n    colors: true,\n    printEmojis: true,\n    printTime: true,\n  ),\n);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you may want to use the `AndroidLogOutput` to integrate with the native Android logging system:\n\n```dart\nimport 'package:logger/logger.dart';\nimport 'package:logger/src/outputs/android_log_output.dart';\n\nfinal logger = Logger(\n  output: AndroidLogOutput(),\n);\n```\n\n### iOS\n\nFor iOS, you can use the default console output, which integrates well with Xcode's console:\n\n```dart\nfinal logger = Logger();\n```\n\n### Web\n\nFor web applications, you might want to consider using a custom output that integrates with the browser's console:\n\n```dart\nclass WebConsoleOutput extends LogOutput {\n  @override\n  void output(OutputEvent event) {\n    event.lines.forEach(print);\n  }\n}\n\nfinal logger = Logger(\n  output: WebConsoleOutput(),\n);\n```\n\n## Advanced Features\n\n### Custom Log Levels\n\nYou can create custom log levels by extending the `Level` class:\n\n```dart\nclass CustomLevel extends Level {\n  const CustomLevel('CUSTOM', 450);\n}\n\nfinal customLogger = Logger(\n  level: CustomLevel(),\n);\n```\n\n### Filtering Logs\n\nYou can filter logs based on their level or other criteria:\n\n```dart\nfinal logger = Logger(\n  filter: ProductionFilter(),\n);\n```\n\n### Log to File\n\nTo log to a file, you can use a custom `LogOutput`:\n\n```dart\nimport 'dart:io';\n\nclass FileOutput extends LogOutput {\n  final File file;\n  final bool overrideExisting;\n  final Encoding encoding;\n\n  FileOutput({\n    required this.file,\n    this.overrideExisting = false,\n    this.encoding = utf8,\n  });\n\n  @override\n  void output(OutputEvent event) {\n    final output = event.lines.join('\\n');\n    file.writeAsStringSync(\n      '$output\\n',\n      mode: overrideExisting ? FileMode.writeOnly : FileMode.append,\n      encoding: encoding,\n    );\n  }\n}\n\nfinal logger = Logger(\n  output: FileOutput(file: File('app.log')),\n);\n```\n\nBy following this tutorial, you should now have a good understanding of how to use and customize the `logger` package in your Flutter applications across different platforms.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:31Z",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPas2O",
        "_type": "reference",
        "_key": "jzcahih0"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "u03va7wh",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGWu"
      }
    ],
    "dependentPackages": [
      {
        "_key": "dzvfljbc",
        "_ref": "V06bsD4sX3T8NTHrBPapH2",
        "_type": "reference"
      },
      {
        "_key": "oxl4w1kw",
        "_ref": "Rx1Nho763d29lawKra1wGZ",
        "_type": "reference"
      }
    ]
  },
  {
    "_createdAt": "2024-08-28T22:16:22Z",
    "tutorial": "# Tutorial: Implementing Animations with flutter_animate\n\nIn this tutorial, we'll walk through the process of adding animations to your Flutter application using the flutter_animate package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the flutter_animate package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_animate: ^4.1.1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the flutter_animate package:\n\n```dart\nimport 'package:flutter_animate/flutter_animate.dart';\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use flutter_animate:\n\n```dart\nText('Hello, World!')\n  .animate()\n  .fadeIn(duration: 600.ms)\n  .scale()\n```\n\nThis will fade in the text and scale it up.\n\n## Step 4: Chaining Multiple Effects\n\nYou can chain multiple effects to create more complex animations:\n\n```dart\nContainer(\n  width: 200,\n  height: 200,\n  color: Colors.blue,\n)\n  .animate()\n  .fadeIn(duration: 500.ms)\n  .scale(delay: 300.ms)\n  .slide(duration: 600.ms)\n```\n\n## Step 5: Using Play Controls\n\nYou can control animations using play controls:\n\n```dart\nfinal control = AnimationController(vsync: this, duration: Duration(seconds: 1));\n\nElevatedButton(\n  child: Text('Animate'),\n  onPressed: () => control.forward(from: 0),\n)\n  .animate(controller: control)\n  .fadeIn()\n  .scale()\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- iOS users are accustomed to smooth, subtle animations. Keep your animations refined and not too flashy.\n- Consider using spring-based animations for a more iOS-native feel:\n\n```dart\nText('iOS-style Animation')\n  .animate()\n  .scale(\n    duration: 400.ms,\n    curve: Curves.easeOutBack,\n  )\n```\n\n### Android\n- Material Design encourages the use of motion to provide meaning and focus.\n- Use elevation animations to adhere to Material Design principles:\n\n```dart\nCard(\n  child: Text('Android-style Animation'),\n)\n  .animate()\n  .elevation(\n    begin: 0,\n    end: 8,\n    curve: Curves.easeInOut,\n    duration: 300.ms,\n  )\n```\n\n### Web\n- Be mindful of performance on web platforms, especially for complex animations.\n- Consider using simpler animations for better performance on lower-end devices:\n\n```dart\nText('Web-friendly Animation')\n  .animate()\n  .fadeIn(duration: 300.ms)\n  .moveX(\n    begin: -50,\n    duration: 400.ms,\n    curve: Curves.easeOutCubic,\n  )\n```\n\nBy following these guidelines, you can create animations that look great and perform well across all platforms while maintaining a consistent user experience.",
    "_updatedAt": "2024-09-06T04:10:32Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_animate/flutter_animate.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Animate Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: AnimateDemoPage(),\n    );\n  }\n}\n\nclass AnimateDemoPage extends StatefulWidget {\n  @override\n  _AnimateDemoPageState createState() => _AnimateDemoPageState();\n}\n\nclass _AnimateDemoPageState extends State<AnimateDemoPage> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  bool _isExpanded = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this, duration: 1.seconds);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter Animate Demo'),\n        // Step 1: Animate the app bar title\n        flexibleSpace: FlexibleSpaceBar(\n          title: Text('RealFlutter')\n            .animate()\n            .fadeIn(duration: 1.seconds)\n            .scale(delay: 300.ms),\n        ),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Basic fade and scale animation\n            Text('Welcome to Flutter Animate!')\n              .animate()\n              .fadeIn(duration: 600.ms)\n              .scale(),\n            SizedBox(height: 20),\n            \n            // Step 3: Chained animation with multiple effects\n            Container(\n              width: 200,\n              height: 50,\n              color: Colors.blue,\n              child: Center(child: Text('Multi-effect Animation', style: TextStyle(color: Colors.white))),\n            )\n              .animate()\n              .fadeIn(duration: 500.ms)\n              .slideY(begin: 1, end: 0, duration: 600.ms)\n              .then(delay: 200.ms)\n              .shimmer(duration: 1.seconds),\n            SizedBox(height: 20),\n            \n            // Step 4: Animation with custom play controls\n            ElevatedButton(\n              child: Text('Play Animation'),\n              onPressed: () => _controller.forward(from: 0),\n            )\n              .animate(controller: _controller)\n              .scaleXY(end: 1.2)\n              .then()\n              .scaleXY(end: 1/1.2),\n            SizedBox(height: 20),\n            \n            // Step 5: Conditional animation based on state\n            GestureDetector(\n              onTap: () => setState(() => _isExpanded = !_isExpanded),\n              child: Container(\n                width: 100,\n                height: 100,\n                color: Colors.green,\n                child: Center(child: Text('Tap me!', style: TextStyle(color: Colors.white))),\n              )\n                .animate(target: _isExpanded ? 1 : 0)\n                .scaleXY(end: 1.5)\n                .rotate(end: 0.5),\n            ),\n          ],\n        ),\n      ),\n      // Step 6: Animated Floating Action Button\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: Icon(Icons.add),\n      )\n        .animate()\n        .scale(duration: 300.ms)\n        .then()\n        .shake(hz: 4, curve: Curves.easeInOutCubic),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. AnimateDemoPage is set as the home page.\n// 3. In AnimateDemoPage, we demonstrate various uses of the flutter_animate package:\n//    - The app bar title animates with a fade-in and scale effect.\n//    - A welcome text fades in and scales up.\n//    - A container demonstrates chained animations with fade, slide, and shimmer effects.\n//    - A button shows how to use custom play controls for animations.\n//    - A tappable container demonstrates conditional animations based on state.\n//    - The Floating Action Button has a scale and shake animation.\n// 4. The _controller is used to manually control the button animation.\n// 5. The _isExpanded state variable is used to toggle the conditional animation.\n// 6. setState is called when the user taps the green container, triggering a rebuild\n//    and updating the animation state.\n\n// This example showcases the versatility of the flutter_animate package, demonstrating\n// various animation techniques including chained animations, custom controls, \n// conditional animations, and more. It provides a good starting point for developers \n// to understand how to implement complex animations with ease using flutter_animate.\n```",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaUL",
        "_type": "reference",
        "_key": "dmxl8dvd"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "yjo74zu3"
      }
    ],
    "likesCount": 3276,
    "lastUpdate": "2024-01-30T18:30:00.000Z",
    "shortDescription": "Add beautiful animated effects & builders in Flutter, via an easy, customizable, unified API.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "de6eiv3a"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1VMp",
        "_type": "reference",
        "_key": "j9q7dtc1"
      }
    ],
    "tags": [
      "animation",
      "ui",
      "effects",
      "widget",
      "transitions"
    ],
    "name": "flutter_animate",
    "_id": "Rx1Nho763d29lawKra1Yd5",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "flutter_animate"
    },
    "author": "gskinner.com",
    "description": "# Flutter Animate: Bringing Life to Your Flutter Apps\n\nIn the ever-evolving world of mobile app development, creating engaging and interactive user interfaces is paramount. The flutter_animate package offers Flutter developers a powerful toolset to easily add stunning animations to their applications, enhancing user experience and visual appeal.\n\n## What is flutter_animate?\n\nflutter_animate is a comprehensive animation library for Flutter that simplifies the process of adding complex animations to your app. It provides a declarative API that allows developers to chain multiple animation effects together, creating sophisticated animations with minimal code.\n\n## Key Features of flutter_animate\n\n1. **Chainable Effects**: Easily combine multiple animation effects in a single, readable chain.\n2. **Rich Library of Effects**: Includes a wide range of pre-built effects like fade, scale, slide, blur, and many more.\n3. **Custom Effects**: Allows creation of custom effects to suit specific needs.\n4. **Staggered Animations**: Effortlessly create sequences of animations with precise timing control.\n5. **Reactive Animations**: Animations can react to state changes, making them dynamic and interactive.\n6. **Performance Optimized**: Designed to be efficient, even with complex animation chains.\n7. **Cross-Platform Compatibility**: Works seamlessly across iOS, Android, and web platforms.\n\n## Why Use flutter_animate?\n\n- **Simplicity**: Dramatically reduces the complexity of creating animations in Flutter.\n- **Flexibility**: Offers fine-grained control over every aspect of your animations.\n- **Reusability**: Easily reuse animation sequences across your app.\n- **Time-Saving**: Implement complex animations in a fraction of the time it would take with traditional methods.\n- **Maintainability**: The declarative syntax makes animations easier to understand and maintain.\n\nIn the following sections, we'll dive into a hands-on tutorial and explore a comprehensive example showcasing the full potential of the flutter_animate package in Flutter.",
    "_type": "package",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "gzwmq7hl",
        "_ref": "4gmBGwifQuSypgRenUbVWC"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmLI7"
  },
  {
    "likesCount": 2821,
    "_id": "Rx1Nho763d29lawKra1Yup",
    "_updatedAt": "2024-09-06T04:10:33Z",
    "author": "flutter.dev",
    "_rev": "eaCZ7mIhmiYZX5KGqJmLRw",
    "shortDescription": "Flutter plugin for Android and iOS devices to allow local authentication via fingerprint, touch ID, face ID, passcode, pin, or pattern.",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CYnX",
        "_type": "reference",
        "_key": "01wu5peu"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPaLDY",
        "_type": "reference",
        "_key": "mikvl43o"
      }
    ],
    "packageImage": null,
    "pubPoint": 160,
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaMLA",
        "_type": "reference",
        "_key": "fxm1n69f"
      }
    ],
    "_createdAt": "2024-08-28T22:16:29Z",
    "tags": [
      "authentication",
      "biometrics",
      "local-auth",
      "fingerprint",
      "face-id"
    ],
    "lastUpdate": "2024-08-05T18:30:00.000Z",
    "name": "local_auth",
    "_type": "package",
    "description": "# Flutter Local Auth Package: Enhancing Security with Biometric Authentication\n\nIn the era of sensitive data and personal information on mobile devices, securing your application is paramount. The Flutter local_auth package offers a robust solution for implementing biometric authentication in your Flutter apps, providing an extra layer of security and a seamless user experience.\n\n## What is Local Auth?\n\nLocal Auth is a Flutter plugin that allows you to use native biometric authentication capabilities on iOS and Android devices. It enables your app to leverage fingerprint sensors, facial recognition (Face ID), and other biometric systems supported by the device.\n\n## Key Features of the Local Auth Package\n\n1. **Cross-Platform Compatibility**: Works on both iOS and Android platforms.\n2. **Multiple Authentication Methods**: Supports various biometric authentication methods including fingerprint, facial recognition, and iris scanning (where available).\n3. **Fallback Options**: Provides PIN, pattern, or password fallback when biometric authentication is unavailable or fails.\n4. **Customizable UI**: Allows customization of authentication dialogs to match your app's design.\n5. **Device Capability Check**: Enables checking if the device supports biometric authentication.\n6. **Secure Storage Integration**: Can be combined with secure storage solutions for enhanced security.\n\n## Why Use the Local Auth Package?\n\n- **Enhanced Security**: Adds an extra layer of protection for sensitive operations or data access.\n- **User Convenience**: Offers a quick and easy way for users to authenticate without typing passwords.\n- **Modern UX**: Aligns with current mobile app trends, meeting user expectations for secure, convenient access.\n- **Flexibility**: Adapts to various device capabilities and user preferences.\n- **Native Integration**: Utilizes platform-specific APIs for optimal performance and reliability.\n\nIn the following sections, we'll dive into a hands-on tutorial and explore a comprehensive example showcasing the full potential of the Local Auth package in Flutter.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGSA",
        "_type": "reference",
        "_key": "a0ur95sz"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:local_auth/local_auth.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Local Auth Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: LocalAuthDemoPage(),\n    );\n  }\n}\n\nclass LocalAuthDemoPage extends StatefulWidget {\n  @override\n  _LocalAuthDemoPageState createState() => _LocalAuthDemoPageState();\n}\n\nclass _LocalAuthDemoPageState extends State<LocalAuthDemoPage> {\n  // Step 1: Initialize LocalAuthentication\n  final LocalAuthentication auth = LocalAuthentication();\n  \n  // Step 2: Declare variables to store auth state and available biometrics\n  bool _canCheckBiometrics = false;\n  bool _isDeviceSupported = false;\n  List<BiometricType> _availableBiometrics = [];\n  String _authorized = 'Not Authorized';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Check device capabilities when the widget initializes\n    _checkBiometrics();\n    _getAvailableBiometrics();\n  }\n\n  // Step 4: Check if the device can use biometrics\n  Future<void> _checkBiometrics() async {\n    bool canCheckBiometrics;\n    try {\n      canCheckBiometrics = await auth.canCheckBiometrics;\n      _isDeviceSupported = await auth.isDeviceSupported();\n    } on PlatformException catch (e) {\n      canCheckBiometrics = false;\n      print(e);\n    }\n    if (!mounted) return;\n\n    setState(() {\n      _canCheckBiometrics = canCheckBiometrics;\n    });\n  }\n\n  // Step 5: Get the list of available biometrics\n  Future<void> _getAvailableBiometrics() async {\n    List<BiometricType> availableBiometrics;\n    try {\n      availableBiometrics = await auth.getAvailableBiometrics();\n    } on PlatformException catch (e) {\n      availableBiometrics = <BiometricType>[];\n      print(e);\n    }\n    if (!mounted) return;\n\n    setState(() {\n      _availableBiometrics = availableBiometrics;\n    });\n  }\n\n  // Step 6: Perform authentication\n  Future<void> _authenticate() async {\n    bool authenticated = false;\n    try {\n      authenticated = await auth.authenticate(\n        localizedReason: 'Authenticate to access the app',\n        options: const AuthenticationOptions(\n          stickyAuth: true,\n          biometricOnly: false,\n        ),\n      );\n    } on PlatformException catch (e) {\n      print(e);\n      return;\n    }\n    if (!mounted) return;\n\n    setState(() {\n      _authorized = authenticated ? 'Authorized' : 'Not Authorized';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter Local Auth Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 7: Display device capability information\n            Text('Can check biometrics: $_canCheckBiometrics\\n'),\n            Text('Device Supported: $_isDeviceSupported\\n'),\n            Text('Available biometrics: ${_availableBiometrics.join(\", \")}\\n'),\n            Text('Current State: $_authorized\\n'),\n            // Step 8: Add a button to trigger authentication\n            ElevatedButton(\n              child: Text('Authenticate'),\n              onPressed: _authenticate,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. LocalAuthDemoPage is set as the home page.\n// 3. In LocalAuthDemoPage's initState, we check the device's biometric capabilities\n//    and available biometric types.\n// 4. The UI displays the current state of biometric support and authentication.\n// 5. When the user presses the \"Authenticate\" button, the _authenticate method is called.\n// 6. The authenticate method uses the local_auth package to prompt the user for biometric authentication.\n// 7. Based on the authentication result, the UI updates to show whether the user is authorized or not.\n// 8. The app handles potential platform exceptions throughout the process.\n\n// This example demonstrates how to implement local authentication in a Flutter app,\n// including checking device capabilities, listing available biometric types, and\n// performing authentication. It provides a foundation that can be expanded to secure\n// specific parts of your app or gate access to sensitive features.\n```",
    "platforms": [
      "android",
      "ios",
      "macos",
      "windows"
    ],
    "tutorial": "# Tutorial: Implementing Local Auth in Your Flutter App\n\nIn this tutorial, we'll walk through the process of adding biometric authentication to your Flutter application using the local_auth package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the local_auth package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  local_auth: ^2.1.6  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the local_auth package:\n\n```dart\nimport 'package:local_auth/local_auth.dart';\n```\n\n## Step 3: Initialize LocalAuthentication\n\nCreate an instance of LocalAuthentication:\n\n```dart\nfinal LocalAuthentication auth = LocalAuthentication();\n```\n\n## Step 4: Check Device Capabilities\n\nBefore attempting authentication, check if the device supports biometric authentication:\n\n```dart\nbool canCheckBiometrics = await auth.canCheckBiometrics;\nbool isDeviceSupported = await auth.isDeviceSupported();\n```\n\n## Step 5: Get Available Biometrics\n\nList the available biometric authentication methods:\n\n```dart\nList<BiometricType> availableBiometrics = await auth.getAvailableBiometrics();\n```\n\n## Step 6: Authenticate\n\nImplement the authentication process:\n\n```dart\nbool authenticated = false;\ntry {\n  authenticated = await auth.authenticate(\n    localizedReason: 'Authenticate to access the app',\n    options: const AuthenticationOptions(\n      stickyAuth: true,\n      biometricOnly: false,\n    ),\n  );\n} catch (e) {\n  print(e);\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- In your `Info.plist` file, add:\n  ```xml\n  <key>NSFaceIDUsageDescription</key>\n  <string>Why you are using Face ID</string>\n  ```\n- Face ID is only available on iPhone X and later.\n- For iOS Simulator, you need to enable Face ID in Features > Face ID.\n\n```swift\n// In your AppDelegate.swift\nimport LocalAuthentication\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    if #available(iOS 9.0, *) {\n        window.layer.cornerRadius = 10\n        window.clipsToBounds = true\n    }\n    return true\n}\n```\n\n### Android\n- In your `android/app/build.gradle`, ensure:\n  ```gradle\n  android {\n    defaultConfig {\n      ...\n      minSdkVersion 21\n    }\n  }\n  ```\n- Add the following permissions to your `AndroidManifest.xml`:\n  ```xml\n  <uses-permission android:name=\"android.permission.USE_BIOMETRIC\"/>\n  ```\n- For fingerprint authentication on Android versions earlier than P, add:\n  ```xml\n  <uses-permission android:name=\"android.permission.USE_FINGERPRINT\"/>\n  ```\n\n```kotlin\n// In your MainActivity.kt\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterFragmentActivity() {\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n    }\n}\n```\n\nBy following these guidelines, you can implement secure biometric authentication in your Flutter app across both iOS and Android platforms.",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "local_auth"
    }
  },
  {
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-03546ca2675d4e11781f4d05a3eac3d375fb2ae4-1000x463-webp",
        "_type": "reference"
      }
    },
    "_updatedAt": "2024-09-06T04:10:34Z",
    "slug": {
      "current": "animations",
      "_type": "slug"
    },
    "author": "flutter.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaOPb",
    "shortDescription": "Fancy pre-built animations that can easily be integrated into any Flutter application.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVWC",
        "_type": "reference",
        "_key": "2unf2xkt"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaUL",
        "_type": "reference",
        "_key": "0ioi7vps"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "56m9n27i"
      }
    ],
    "_type": "package",
    "lastUpdate": "2024-01-03T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1ZND",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'dart:math' as math;\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Animations Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> with TickerProviderStateMixin {\n  // Step 1: Define animation controllers\n  late AnimationController _rotationController;\n  late AnimationController _bounceController;\n  late AnimationController _colorController;\n\n  // Step 2: Define animations\n  late Animation<double> _rotationAnimation;\n  late Animation<double> _bounceAnimation;\n  late Animation<Color?> _colorAnimation;\n\n  // Step 3: Define state variables\n  bool _expanded = false;\n  double _opacity = 1.0;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Step 4: Initialize animation controllers\n    _rotationController = AnimationController(\n      duration: const Duration(seconds: 5),\n      vsync: this,\n    )..repeat();\n\n    _bounceController = AnimationController(\n      duration: const Duration(milliseconds: 1500),\n      vsync: this,\n    )..repeat(reverse: true);\n\n    _colorController = AnimationController(\n      duration: const Duration(seconds: 3),\n      vsync: this,\n    )..repeat();\n\n    // Step 5: Create animations\n    _rotationAnimation = Tween<double>(begin: 0, end: 2 * math.pi).animate(_rotationController);\n    _bounceAnimation = Tween<double>(begin: 0, end: 50).animate(\n      CurvedAnimation(parent: _bounceController, curve: Curves.elasticInOut),\n    );\n    _colorAnimation = ColorTween(begin: Colors.blue, end: Colors.red).animate(_colorController);\n  }\n\n  @override\n  void dispose() {\n    // Step 6: Dispose animation controllers\n    _rotationController.dispose();\n    _bounceController.dispose();\n    _colorController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Animations Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 7: Implement rotating animation\n            AnimatedBuilder(\n              animation: _rotationAnimation,\n              builder: (context, child) {\n                return Transform.rotate(\n                  angle: _rotationAnimation.value,\n                  child: child,\n                );\n              },\n              child: FlutterLogo(size: 100),\n            ),\n            SizedBox(height: 50),\n\n            // Step 8: Implement bouncing animation\n            AnimatedBuilder(\n              animation: _bounceAnimation,\n              builder: (context, child) {\n                return Transform.translate(\n                  offset: Offset(0, -_bounceAnimation.value),\n                  child: child,\n                );\n              },\n              child: Text('Bouncing Text!', style: TextStyle(fontSize: 24)),\n            ),\n            SizedBox(height: 50),\n\n            // Step 9: Implement color changing animation\n            AnimatedBuilder(\n              animation: _colorAnimation,\n              builder: (context, child) {\n                return Container(\n                  width: 100,\n                  height: 100,\n                  color: _colorAnimation.value,\n                );\n              },\n            ),\n            SizedBox(height: 50),\n\n            // Step 10: Implement implicit animations\n            GestureDetector(\n              onTap: () {\n                setState(() {\n                  _expanded = !_expanded;\n                  _opacity = _opacity == 1.0 ? 0.5 : 1.0;\n                });\n              },\n              child: AnimatedContainer(\n                duration: Duration(milliseconds: 300),\n                width: _expanded ? 200.0 : 100.0,\n                height: _expanded ? 100.0 : 50.0,\n                color: _expanded ? Colors.green : Colors.yellow,\n                child: Center(\n                  child: AnimatedOpacity(\n                    opacity: _opacity,\n                    duration: Duration(milliseconds: 300),\n                    child: Text('Tap me!'),\n                  ),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes all animation controllers and animations in the initState method.\n// 2. The build method creates a scaffold with multiple animated widgets:\n//    a. A rotating Flutter logo using AnimatedBuilder and Transform.rotate\n//    b. A bouncing text using AnimatedBuilder and Transform.translate\n//    c. A color-changing container using AnimatedBuilder\n//    d. An expandable container with changing opacity using implicit animations (AnimatedContainer and AnimatedOpacity)\n// 3. The rotating animation continuously rotates the Flutter logo.\n// 4. The bouncing animation makes the text move up and down with an elastic effect.\n// 5. The color-changing animation smoothly transitions the container's color from blue to red.\n// 6. When the user taps the bottom container, it toggles between expanded and collapsed states, changing its size and color.\n// 7. Simultaneously, the text inside the container changes its opacity.\n// 8. All animations run independently and continuously, creating a dynamic and engaging user interface.\n// 9. When the widget is disposed, all animation controllers are properly disposed to prevent memory leaks.\n```",
    "tags": [
      "animation",
      "ui",
      "transitions",
      "effects"
    ],
    "_createdAt": "2024-08-28T22:16:34Z",
    "name": "animations",
    "tutorial": "# Flutter Animations Tutorial: Getting Started with RealFlutter\n\nIn this tutorial, we'll walk through the process of implementing various animations using the RealFlutter class. We'll cover both basic and advanced animation techniques, including platform-specific considerations.\n\n## Setting Up Your Project\n\n1. Create a new Flutter project:\n   ```\n   flutter create real_flutter_animations\n   cd real_flutter_animations\n   ```\n\n2. Open your `pubspec.yaml` file and add the following dependencies:\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     animations: ^2.0.3\n   ```\n\n3. Run `flutter pub get` to install the dependencies.\n\n## Implementing Basic Animations\n\nLet's start by creating a simple animation using the `AnimatedContainer` widget:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  bool _expanded = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        setState(() {\n          _expanded = !_expanded;\n        });\n      },\n      child: AnimatedContainer(\n        duration: Duration(milliseconds: 300),\n        width: _expanded ? 200.0 : 100.0,\n        height: _expanded ? 200.0 : 100.0,\n        color: _expanded ? Colors.blue : Colors.red,\n        child: Center(\n          child: Text(\n            _expanded ? 'Expanded!' : 'Tap me!',\n            style: TextStyle(color: Colors.white),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis example demonstrates a simple container that expands and changes color when tapped.\n\n## Advanced Animations\n\nNow, let's implement a more complex animation using `AnimationController` and `Tween`:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _animation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    )..repeat(reverse: true);\n    _animation = Tween<double>(begin: 0, end: 2 * 3.14159).animate(_controller);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) {\n        return Transform(\n          alignment: Alignment.center,\n          transform: Matrix4.identity()\n            ..rotateY(_animation.value)\n            ..translate(50 * _animation.value.cos()),\n          child: Container(\n            width: 100,\n            height: 100,\n            color: Colors.blue,\n            child: Center(\n              child: Text(\n                'Rotating!',\n                style: TextStyle(color: Colors.white),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}\n```\n\nThis example shows a rotating and translating container using custom animations.\n\n## Platform-Specific Considerations\n\nWhen implementing animations, it's important to consider platform-specific behaviors and optimizations:\n\n### iOS\n\n- Use `CupertinoPageTransition` for navigation animations to match iOS design guidelines.\n- Implement `UIViewControllerAnimatedTransitioning` for custom page transitions.\n\n### Android\n\n- Use `MaterialPageRoute` for navigation animations that follow Material Design principles.\n- Implement `PageRouteBuilder` for custom page transitions.\n\n### Web\n\n- Optimize animations for web performance by using CSS animations where possible.\n- Consider using the `flutter_web_plugins` package for web-specific optimizations.\n\nRemember to test your animations on various devices and platforms to ensure consistent performance and behavior across different environments.\n\nIn the next section, we'll explore a comprehensive example that demonstrates multiple animation techniques in a single Flutter application.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "description": "# Flutter Animations Package: Bringing Your App to Life\n\n## Introduction\n\nFlutter, Google's UI toolkit for building natively compiled applications, offers a powerful and flexible animations package that allows developers to create stunning, smooth, and interactive user interfaces. In this blog post, we'll explore the Flutter animations package, its key features, and how it can elevate your app's user experience.\n\n## Key Features of Flutter Animations\n\n1. **Implicit Animations**: Flutter provides a set of implicit animation widgets that automatically animate changes in their properties. These include `AnimatedOpacity`, `AnimatedContainer`, and `AnimatedPositioned`, among others.\n\n2. **Explicit Animations**: For more complex animations, Flutter offers explicit animation widgets like `AnimationController` and `Tween`, giving developers fine-grained control over the animation process.\n\n3. **Custom Animations**: Developers can create custom animations using the `CustomPainter` class, allowing for unique and tailored visual effects.\n\n4. **Physics-based Animations**: Flutter's physics library enables the creation of realistic, physics-based animations that mimic natural movements.\n\n5. **Hero Animations**: Seamlessly animate widgets across different screens using Hero animations, creating a smooth transition between routes.\n\n6. **Staggered Animations**: Coordinate multiple animations to create complex, staggered effects that enhance the overall user experience.\n\n## Benefits of Using Flutter Animations\n\n- **Performance**: Flutter's animations are optimized for performance, ensuring smooth 60fps animations even on lower-end devices.\n- **Consistency**: Animations look and behave the same across different platforms, maintaining a consistent user experience.\n- **Customization**: The flexibility of Flutter's animation system allows for highly customized and unique animations.\n- **Ease of Use**: With a wide range of pre-built animation widgets and clear documentation, implementing animations in Flutter is straightforward for developers of all skill levels.\n\nIn the following sections, we'll dive deeper into how to implement these animations in your Flutter projects, starting with a tutorial and then exploring a comprehensive example that showcases various animation techniques.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference",
        "_key": "prhgep3e"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1VMp",
        "_type": "reference",
        "_key": "u1tm0tia"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 6093
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:just_audio/just_audio.dart';\nimport 'package:rxdart/rxdart.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late AudioPlayer _audioPlayer;\n\n  // Step 1: Initialize the AudioPlayer\n  @override\n  void initState() {\n    super.initState();\n    _audioPlayer = AudioPlayer();\n    _init();\n  }\n\n  // Step 2: Set up the audio source and load metadata\n  Future<void> _init() async {\n    try {\n      await _audioPlayer.setAsset('assets/audio/sample.mp3');\n      // You can also use setUrl() for network audio or setFilePath() for local files\n    } catch (e) {\n      print(\"Error loading audio source: $e\");\n    }\n  }\n\n  // Step 3: Dispose of the AudioPlayer when no longer needed\n  @override\n  void dispose() {\n    _audioPlayer.dispose();\n    super.dispose();\n  }\n\n  // Step 4: Create a stream that combines playback state and position\n  Stream<PositionData> get _positionDataStream =>\n      Rx.combineLatest3<Duration, Duration, Duration?, PositionData>(\n        _audioPlayer.positionStream,\n        _audioPlayer.bufferedPositionStream,\n        _audioPlayer.durationStream,\n        (position, bufferedPosition, duration) =>\n            PositionData(position, bufferedPosition, duration ?? Duration.zero),\n      );\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Audio Player')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // Step 5: Display current playing status\n          StreamBuilder<PlayerState>(\n            stream: _audioPlayer.playerStateStream,\n            builder: (context, snapshot) {\n              final playerState = snapshot.data;\n              final processingState = playerState?.processingState;\n              final playing = playerState?.playing;\n              if (processingState == ProcessingState.loading ||\n                  processingState == ProcessingState.buffering) {\n                return Container(\n                  margin: EdgeInsets.all(8.0),\n                  width: 64.0,\n                  height: 64.0,\n                  child: CircularProgressIndicator(),\n                );\n              } else if (playing != true) {\n                return IconButton(\n                  icon: Icon(Icons.play_arrow),\n                  iconSize: 64.0,\n                  onPressed: _audioPlayer.play,\n                );\n              } else if (processingState != ProcessingState.completed) {\n                return IconButton(\n                  icon: Icon(Icons.pause),\n                  iconSize: 64.0,\n                  onPressed: _audioPlayer.pause,\n                );\n              } else {\n                return IconButton(\n                  icon: Icon(Icons.replay),\n                  iconSize: 64.0,\n                  onPressed: () => _audioPlayer.seek(Duration.zero),\n                );\n              }\n            },\n          ),\n          // Step 6: Display and control the seek bar\n          StreamBuilder<PositionData>(\n            stream: _positionDataStream,\n            builder: (context, snapshot) {\n              final positionData = snapshot.data;\n              return SeekBar(\n                duration: positionData?.duration ?? Duration.zero,\n                position: positionData?.position ?? Duration.zero,\n                bufferedPosition:\n                    positionData?.bufferedPosition ?? Duration.zero,\n                onChangeEnd: _audioPlayer.seek,\n              );\n            },\n          ),\n          // Step 7: Display and control the volume\n          Row(\n            children: [\n              Icon(Icons.volume_up),\n              Expanded(\n                child: StreamBuilder<double>(\n                  stream: _audioPlayer.volumeStream,\n                  builder: (context, snapshot) {\n                    return Slider(\n                      min: 0.0,\n                      max: 1.0,\n                      value: snapshot.data ?? 1.0,\n                      onChanged: (value) {\n                        _audioPlayer.setVolume(value);\n                      },\n                    );\n                  },\n                ),\n              ),\n            ],\n          ),\n          // Step 8: Display and control the playback speed\n          Row(\n            children: [\n              Text(\"Speed\"),\n              Expanded(\n                child: StreamBuilder<double>(\n                  stream: _audioPlayer.speedStream,\n                  builder: (context, snapshot) {\n                    return Slider(\n                      min: 0.5,\n                      max: 2.0,\n                      value: snapshot.data ?? 1.0,\n                      onChanged: (value) {\n                        _audioPlayer.setSpeed(value);\n                      },\n                    );\n                  },\n                ),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass PositionData {\n  final Duration position;\n  final Duration bufferedPosition;\n  final Duration duration;\n\n  PositionData(this.position, this.bufferedPosition, this.duration);\n}\n\nclass SeekBar extends StatefulWidget {\n  final Duration duration;\n  final Duration position;\n  final Duration bufferedPosition;\n  final ValueChanged<Duration>? onChanged;\n  final ValueChanged<Duration>? onChangeEnd;\n\n  SeekBar({\n    required this.duration,\n    required this.position,\n    required this.bufferedPosition,\n    this.onChanged,\n    this.onChangeEnd,\n  });\n\n  @override\n  _SeekBarState createState() => _SeekBarState();\n}\n\nclass _SeekBarState extends State<SeekBar> {\n  double? _dragValue;\n  late SliderThemeData _sliderThemeData;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n\n    _sliderThemeData = SliderTheme.of(context).copyWith(\n      trackHeight: 2.0,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        SliderTheme(\n          data: _sliderThemeData.copyWith(\n            thumbShape: HiddenThumbComponentShape(),\n            activeTrackColor: Colors.blue.shade100,\n            inactiveTrackColor: Colors.grey.shade300,\n          ),\n          child: ExcludeSemantics(\n            child: Slider(\n              min: 0.0,\n              max: widget.duration.inMilliseconds.toDouble(),\n              value: widget.bufferedPosition.inMilliseconds.toDouble(),\n              onChanged: (value) {},\n            ),\n          ),\n        ),\n        SliderTheme(\n          data: _sliderThemeData.copyWith(\n            inactiveTrackColor: Colors.transparent,\n          ),\n          child: Slider(\n            min: 0.0,\n            max: widget.duration.inMilliseconds.toDouble(),\n            value: min(_dragValue ?? widget.position.inMilliseconds.toDouble(),\n                widget.duration.inMilliseconds.toDouble()),\n            onChanged: (value) {\n              setState(() {\n                _dragValue = value;\n              });\n              if (widget.onChanged != null) {\n                widget.onChanged!(Duration(milliseconds: value.round()));\n              }\n            },\n            onChangeEnd: (value) {\n              if (widget.onChangeEnd != null) {\n                widget.onChangeEnd!(Duration(milliseconds: value.round()));\n              }\n              _dragValue = null;\n            },\n          ),\n        ),\n        Positioned(\n          right: 16.0,\n          bottom: 0.0,\n          child: Text(\n              RegExp(r'((^0*[1-9]\\d*:)?\\d{2}:\\d{2})\\.\\d+$')\n                      .firstMatch(\"$_remaining\")\n                      ?.group(1) ??\n                  '$_remaining',\n              style: Theme.of(context).textTheme.caption),\n        ),\n      ],\n    );\n  }\n\n  Duration get _remaining => widget.duration - widget.position;\n}\n\nclass HiddenThumbComponentShape extends SliderComponentShape {\n  @override\n  Size getPreferredSize(bool isEnabled, bool isDiscrete) => Size.zero;\n\n  @override\n  void paint(\n    PaintingContext context,\n    Offset center, {\n    required Animation<double> activationAnimation,\n    required Animation<double> enableAnimation,\n    required bool isDiscrete,\n    required TextPainter labelPainter,\n    required RenderBox parentBox,\n    required SliderThemeData sliderTheme,\n    required TextDirection textDirection,\n    required double value,\n    required double textScaleFactor,\n    required Size sizeWithOverflow,\n  }) {}\n}\n\n// Application Flow:\n// 1. The application starts and creates an instance of AudioPlayer in the initState method.\n// 2. The _init method is called to set up the audio source (in this case, an asset).\n// 3. The UI is built with controls for play/pause, seek, volume, and playback speed.\n// 4. The application uses streams to update the UI in real-time based on the audio player's state.\n// 5. When the user interacts with the controls:\n//    - Play/Pause: Toggles audio playback\n//    - Seek Bar: Allows the user to jump to different parts of the audio\n//    - Volume Slider: Adjusts the audio volume\n//    - Speed Slider: Changes the playback speed\n// 6. The application continues to update the UI based on the current state of the audio playback.\n// 7. When the widget is disposed, the AudioPlayer is also disposed to free up resources.\n\n// This example demonstrates key features of the just_audio package:\n// - Loading audio from an asset\n// - Basic playback controls (play, pause, seek)\n// - Displaying and controlling volume\n// - Adjusting playback speed\n// - Real-time updates of playback position and buffered position\n// - Handling different player states (loading, playing, paused, completed)\n\n// Note: For a complete application, you would need to add error handling,\n// support for playlists, and potentially background audio playback capabilities.\n```",
    "_id": "Rx1Nho763d29lawKra1ZXr",
    "tutorial": "# Just Audio Package for Flutter: A Comprehensive Guide\n\n## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using the `just_audio` package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the `just_audio` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  just_audio: ^0.9.34\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:just_audio/just_audio.dart';\n```\n\n### Step 3: Create an AudioPlayer Instance\n\nCreate an instance of `AudioPlayer` in your `RealFlutter` class:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late AudioPlayer _audioPlayer;\n\n  @override\n  void initState() {\n    super.initState();\n    _audioPlayer = AudioPlayer();\n  }\n\n  @override\n  void dispose() {\n    _audioPlayer.dispose();\n    super.dispose();\n  }\n\n  // ... rest of the class\n}\n```\n\n### Step 4: Load and Play Audio\n\nLoad an audio file and play it:\n\n```dart\nFuture<void> _loadAndPlay() async {\n  await _audioPlayer.setAsset('assets/audio/sample.mp3');\n  _audioPlayer.play();\n}\n```\n\n### Step 5: Control Playback\n\nImplement basic playback controls:\n\n```dart\nvoid _playPause() {\n  if (_audioPlayer.playing) {\n    _audioPlayer.pause();\n  } else {\n    _audioPlayer.play();\n  }\n}\n\nvoid _stop() {\n  _audioPlayer.stop();\n}\n\nvoid _seek(Duration position) {\n  _audioPlayer.seek(position);\n}\n```\n\n### Platform-Specific Considerations\n\n#### Android\n\nAdd the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n```\n\n#### iOS\n\nAdd the following to your `Info.plist` file for background audio support:\n\n```xml\n<key>UIBackgroundModes</key>\n<array>\n  <string>audio</string>\n</array>\n```\n\n#### Web\n\nNo additional configuration is required for web support.\n\n#### macOS\n\nAdd the following to your `DebugProfile.entitlements` and `Release.entitlements` files:\n\n```xml\n<key>com.apple.security.network.client</key>\n<true/>\n```\n\nBy following these steps and considering the platform-specific requirements, you'll have a basic setup for using the `just_audio` package in your Flutter application. In the next section, we'll explore a more comprehensive example that demonstrates additional features of the package.",
    "slug": {
      "current": "just_audio",
      "_type": "slug"
    },
    "author": "ryanheise.com",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWZd",
        "_type": "reference",
        "_key": "jrseryqc"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "dwsl2arg",
        "_ref": "4gmBGwifQuSypgRenUbW9O"
      }
    ],
    "description": "# Just Audio Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `just_audio` package is a feature-rich and powerful audio playback library for Flutter applications. It provides a simple yet flexible API for playing audio from various sources, including local files, assets, and network streams. This package is designed to work seamlessly across multiple platforms, including iOS, Android, web, and desktop.\n\n### Key Features:\n\n1. **Multiple Audio Sources**: Supports local files, assets, network streams, and custom sources.\n2. **Gapless Playback**: Seamlessly transition between audio tracks without interruptions.\n3. **Seeking and Buffering**: Precise control over playback position and efficient buffering.\n4. **Background Audio**: Continues playback when the app is in the background.\n5. **Audio Effects**: Apply various audio effects like speed and pitch control.\n6. **Playlists**: Easily manage and control playlists with shuffle and repeat modes.\n7. **Caching**: Efficient caching mechanisms for improved performance.\n8. **Metadata Handling**: Extract and display audio metadata.\n\n### Why Choose just_audio?\n\nThe `just_audio` package stands out for its simplicity, performance, and cross-platform compatibility. It leverages platform-specific audio engines to ensure optimal performance and low latency playback. Whether you're building a music player, podcast app, or any application requiring audio playback, `just_audio` provides the tools and flexibility needed to create a robust and feature-rich audio experience.\n\nIn the following sections, we'll dive into a tutorial on how to set up and use the `just_audio` package, followed by a comprehensive example demonstrating its key features.",
    "shortDescription": "A feature-rich audio player for Flutter. Loop, clip and concatenate any sound from any source (asset/file/URL/stream) in a variety of audio formats with gapless playback.",
    "_type": "package",
    "tags": [
      "audio",
      "sound",
      "player",
      "background",
      "music"
    ],
    "likesCount": 3562,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "3kgcrc14",
        "_ref": "Rx1Nho763d29lawKra1lZ1"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPbPCe",
        "_type": "reference",
        "_key": "feqtnwb6"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:16:42Z",
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaOSn",
    "_updatedAt": "2024-09-06T04:10:36Z",
    "name": "just_audio",
    "tutorialIncluded": true,
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "lastUpdate": "2024-08-26T18:30:00.000Z"
  },
  {
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "xxt9gnx6"
      }
    ],
    "example": "```\nimport 'dart:io';\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:flutter_image_compress/flutter_image_compress.dart';\nimport 'package:path_provider/path_provider.dart' as path_provider;\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  File? _image;\n  File? _compressedImage;\n  String _compressionStatus = '';\n\n  // Step 1: Initialize image picker\n  final picker = ImagePicker();\n\n  // Step 2: Method to pick image from gallery\n  Future getImage() async {\n    final pickedFile = await picker.pickImage(source: ImageSource.gallery);\n\n    setState(() {\n      if (pickedFile != null) {\n        _image = File(pickedFile.path);\n        _compressedImage = null;\n        _compressionStatus = '';\n      }\n    });\n  }\n\n  // Step 3: Method to compress image\n  Future<void> compressImage() async {\n    if (_image == null) return;\n\n    final dir = await path_provider.getTemporaryDirectory();\n    final targetPath = dir.absolute.path + \"/compressed.jpg\";\n\n    // Step 4: Compress and get file\n    final result = await FlutterImageCompress.compressAndGetFile(\n      _image!.absolute.path,\n      targetPath,\n      quality: 88,\n      minWidth: 1024,\n      minHeight: 1024,\n      rotate: 0,\n    );\n\n    if (result != null) {\n      setState(() {\n        _compressedImage = File(result.path);\n        _updateCompressionStatus();\n      });\n    }\n  }\n\n  // Step 5: Method to update compression status\n  void _updateCompressionStatus() {\n    final originalSize = _image!.lengthSync();\n    final compressedSize = _compressedImage!.lengthSync();\n    final compressionRatio = (1 - (compressedSize / originalSize)) * 100;\n\n    setState(() {\n      _compressionStatus = 'Original: ${_formatSize(originalSize)}\\n'\n          'Compressed: ${_formatSize(compressedSize)}\\n'\n          'Compression Ratio: ${compressionRatio.toStringAsFixed(2)}%';\n    });\n  }\n\n  // Helper method to format file size\n  String _formatSize(int bytes) {\n    if (bytes <= 0) return \"0 B\";\n    const suffixes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    var i = (log(bytes) / log(1024)).floor();\n    return '${(bytes / pow(1024, i)).toStringAsFixed(2)} ${suffixes[i]}';\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Image Compressor')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 6: Display original image\n            _image == null\n                ? Text('No image selected.')\n                : Image.file(_image!, height: 200),\n            SizedBox(height: 20),\n            // Step 7: Display compressed image\n            _compressedImage == null\n                ? Container()\n                : Image.file(_compressedImage!, height: 200),\n            SizedBox(height: 20),\n            Text(_compressionStatus),\n            SizedBox(height: 20),\n            // Step 8: Buttons for selecting and compressing image\n            ElevatedButton(\n              onPressed: getImage,\n              child: Text('Select Image'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _image == null ? null : compressImage,\n              child: Text('Compress Image'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with a blank screen and two buttons: \"Select Image\" and \"Compress Image\".\n// 2. When the user taps \"Select Image\", the getImage() method is called, opening the device's gallery.\n// 3. After selecting an image, it's displayed on the screen, and the \"Compress Image\" button becomes active.\n// 4. Tapping \"Compress Image\" calls compressImage(), which:\n//    a. Creates a temporary file path for the compressed image.\n//    b. Uses FlutterImageCompress to compress the selected image.\n//    c. Saves the compressed image to the temporary file.\n// 5. After compression, the app displays both the original and compressed images.\n// 6. The _updateCompressionStatus() method calculates and displays compression statistics.\n// 7. The user can repeat the process by selecting a new image or compressing the current image again.\n\n// Note: This example demonstrates basic usage of flutter_image_compress.\n// For production use, consider adding error handling and progress indicators.\n```",
    "tags": [
      "image",
      "compression",
      "optimization",
      "resize"
    ],
    "tutorial": "# Flutter Image Compress: Implementation Tutorial\n\nThis tutorial will guide you through the process of integrating and using the `flutter_image_compress` package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_image_compress: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_image_compress/flutter_image_compress.dart';\n```\n\n## Step 3: Platform-Specific Setup\n\n### Android Setup\n\nNo additional setup is required for Android.\n\n### iOS Setup\n\nFor iOS, you need to add the following keys to your `Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for image compression.</string>\n<key>NSCameraUsageDescription</key>\n<string>This app requires access to the camera for image compression.</string>\n```\n\n### Web Setup\n\nFor web support, add the following script to your `web/index.html` file:\n\n```html\n<script src=\"https://unpkg.com/pica/dist/pica.min.js\"></script>\n```\n\n## Step 4: Basic Usage\n\nHere's a simple example of how to use `flutter_image_compress`:\n\n```dart\nimport 'dart:io';\nimport 'package:flutter_image_compress/flutter_image_compress.dart';\n\nclass RealFlutter {\n  Future<File?> compressImage(File file) async {\n    final filePath = file.absolute.path;\n    final lastIndex = filePath.lastIndexOf(RegExp(r'.jp'));\n    final splitted = filePath.substring(0, lastIndex);\n    final outPath = \"${splitted}_out${filePath.substring(lastIndex)}\";\n    \n    var result = await FlutterImageCompress.compressAndGetFile(\n      file.absolute.path,\n      outPath,\n      quality: 88,\n    );\n    \n    return result;\n  }\n}\n```\n\nThis method compresses an image file and saves the result to a new file.\n\n## Step 5: Advanced Usage\n\n### Resize Image\n\nTo resize an image during compression:\n\n```dart\nvar result = await FlutterImageCompress.compressAndGetFile(\n  file.absolute.path,\n  outPath,\n  minWidth: 1024,\n  minHeight: 1024,\n  quality: 90,\n);\n```\n\n### Compress to Uint8List\n\nTo compress an image to a Uint8List:\n\n```dart\nUint8List? result = await FlutterImageCompress.compressWithFile(\n  file.absolute.path,\n  minWidth: 2300,\n  minHeight: 1500,\n  quality: 94,\n  rotate: 90,\n);\n```\n\n### Change Output Format\n\nTo change the output format:\n\n```dart\nvar result = await FlutterImageCompress.compressAndGetFile(\n  file.absolute.path,\n  outPath,\n  format: CompressFormat.webp,\n  quality: 90,\n);\n```\n\nBy following these steps, you can effectively integrate and use the `flutter_image_compress` package in your Flutter application. In the next section, we'll explore a comprehensive example that demonstrates various features of this package.",
    "_rev": "AE3hjGWNkNE6aGQMMbaOVz",
    "_type": "package",
    "shortDescription": "Compress Pictures. Can effectively reduce the size of the transmission.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGKG",
        "_type": "reference",
        "_key": "5yviynf9"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ffX",
        "_type": "reference",
        "_key": "e57ofw0f"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "j11zdn6k"
      }
    ],
    "_id": "Rx1Nho763d29lawKra1ZiV",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:37Z",
    "pubPoint": 160,
    "slug": {
      "current": "flutter_image_compress",
      "_type": "slug"
    },
    "likesCount": 1459,
    "_createdAt": "2024-08-28T22:16:44Z",
    "author": "fluttercandies.com",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "packageImage": null,
    "lastUpdate": "2024-05-14T18:30:00.000Z",
    "name": "flutter_image_compress",
    "description": "# Flutter Image Compress: Optimizing Images in Your Flutter App\n\n## Introduction\n\nIn the world of mobile app development, optimizing images is crucial for enhancing app performance and user experience. The `flutter_image_compress` package offers a powerful solution for Flutter developers to compress and resize images efficiently. This blog post will explore the features and usage of this essential package.\n\n## What is flutter_image_compress?\n\n`flutter_image_compress` is a Flutter plugin that provides image compression functionality. It supports compressing images to reduce file size while maintaining acceptable quality. The package offers various compression methods and options, making it versatile for different use cases.\n\n## Key Features\n\n1. **Multiple Compression Formats**: Supports JPEG, PNG, and WebP formats.\n2. **Quality Control**: Allows fine-tuning of compression quality.\n3. **Resize Capabilities**: Enables resizing images during compression.\n4. **Platform Support**: Works on Android, iOS, and web platforms.\n5. **Memory Efficiency**: Offers methods to compress images without loading them entirely into memory.\n\n## Why Use flutter_image_compress?\n\n- **Improved App Performance**: Smaller image sizes lead to faster loading times and reduced network usage.\n- **Storage Optimization**: Compressed images take up less space on the device.\n- **Flexible API**: The package provides both synchronous and asynchronous methods for compression.\n- **Customization**: Developers can adjust compression parameters to balance quality and file size.\n\nIn the following sections, we'll dive into a tutorial on how to implement `flutter_image_compress` in your Flutter project and explore a comprehensive example showcasing its features."
  },
  {
    "_rev": "eaCZ7mIhmiYZX5KGqJmLbl",
    "shortDescription": "Flutter Page Transition Package which is the transition second page",
    "packageImage": null,
    "lastUpdate": "2023-09-09T18:30:00.000Z",
    "tutorial": "# Page Transition Package Tutorial\n\nIn this tutorial, we'll walk through the process of implementing page transitions using the `page_transition` package in a Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nFirst, add the `page_transition` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  page_transition: ^2.0.9\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nTo use a page transition, you'll need to import the package and use the `PageTransition` widget in your navigation code.\n\n```dart\nimport 'package:page_transition/page_transition.dart';\n\n// In your navigation code\nNavigator.push(\n  context,\n  PageTransition(\n    type: PageTransitionType.fade,\n    child: SecondPage(),\n  ),\n);\n```\n\n## Step 3: Customizing Transitions\n\nThe `PageTransition` widget offers various customization options:\n\n```dart\nPageTransition(\n  type: PageTransitionType.rightToLeft,\n  child: SecondPage(),\n  duration: Duration(milliseconds: 300),\n  reverseDuration: Duration(milliseconds: 300),\n  isIos: true,\n  curve: Curves.easeInOut,\n);\n```\n\n## Step 4: Platform-Specific Considerations\n\n### iOS-specific Details\n\nFor iOS, you might want to use transitions that feel native to the platform:\n\n```dart\nPageTransition(\n  type: PageTransitionType.cupertino,\n  child: SecondPage(),\n);\n```\n\n### Android-specific Details\n\nFor Android, material design transitions are often preferred:\n\n```dart\nPageTransition(\n  type: PageTransitionType.rightToLeft,\n  child: SecondPage(),\n);\n```\n\n## Step 5: Advanced Usage\n\nYou can create custom transition types by extending the `PageTransitionsBuilder` class:\n\n```dart\nclass CustomTransitionBuilder extends PageTransitionsBuilder {\n  @override\n  Widget buildTransitions<T>(\n    PageRoute<T> route,\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    // Implement your custom transition here\n  }\n}\n```\n\nBy following these steps, you can easily implement and customize page transitions in your Flutter application using the `page_transition` package.",
    "_id": "Rx1Nho763d29lawKra1Zt9",
    "slug": {
      "current": "page_transition",
      "_type": "slug"
    },
    "author": "yasinilhan.com",
    "description": "# Page Transition Package in Flutter: Enhancing Your App's Navigation Experience\n\n## Introduction\n\nIn the world of mobile app development, smooth and visually appealing transitions between pages can significantly enhance the user experience. Flutter, being a versatile framework, offers various ways to implement page transitions. One particularly useful package for this purpose is the `page_transition` package.\n\n## What is the Page Transition Package?\n\nThe `page_transition` package is a Flutter library that provides a collection of ready-to-use page transition animations. These transitions can be easily integrated into your Flutter application to create engaging and professional-looking navigation effects.\n\n## Key Features\n\n1. **Variety of Animations**: The package offers a wide range of transition types, including fade, scale, rotate, size, and slide transitions.\n\n2. **Customizable**: Each transition type comes with customizable parameters, allowing developers to fine-tune the animation to their specific needs.\n\n3. **Easy Integration**: The package seamlessly integrates with Flutter's navigation system, making it straightforward to implement in both new and existing projects.\n\n4. **Performance**: Designed with performance in mind, these transitions are optimized to run smoothly on various devices.\n\n5. **Cross-Platform**: Works flawlessly on both iOS and Android platforms, ensuring a consistent experience across different devices.\n\n## Why Use Page Transition Package?\n\n1. **Enhanced User Experience**: Smooth transitions between pages can make your app feel more polished and professional.\n\n2. **Time-Saving**: Instead of coding complex animations from scratch, you can use pre-built transitions and customize them as needed.\n\n3. **Consistency**: Using a standard package helps maintain consistency in animations throughout your app.\n\n4. **Flexibility**: With multiple transition types available, you can choose the most appropriate animation for each navigation scenario in your app.\n\nIn the following sections, we'll dive deeper into how to implement these transitions in your Flutter application, providing both a tutorial and a comprehensive example.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "65ze8h7a"
      }
    ],
    "likesCount": 1361,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaUL",
        "_type": "reference",
        "_key": "fnxn2lfi"
      },
      {
        "_key": "0psn5o50",
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference"
      }
    ],
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:page_transition/page_transition.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Page Transition Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\n// Step 1: Create a HomePage widget\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Page Transition Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Add buttons for different transition types\n            ElevatedButton(\n              child: Text('Fade Transition'),\n              onPressed: () => _navigateToPage(context, PageTransitionType.fade),\n            ),\n            ElevatedButton(\n              child: Text('Right to Left Transition'),\n              onPressed: () => _navigateToPage(context, PageTransitionType.rightToLeft),\n            ),\n            ElevatedButton(\n              child: Text('Scale Transition'),\n              onPressed: () => _navigateToPage(context, PageTransitionType.scale),\n            ),\n            ElevatedButton(\n              child: Text('Rotate Transition'),\n              onPressed: () => _navigateToPage(context, PageTransitionType.rotate),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 3: Implement navigation function\n  void _navigateToPage(BuildContext context, PageTransitionType transitionType) {\n    Navigator.push(\n      context,\n      PageTransition(\n        type: transitionType,\n        child: SecondPage(transitionType: transitionType),\n        duration: Duration(milliseconds: 300),\n        reverseDuration: Duration(milliseconds: 300),\n        curve: Curves.easeInOut,\n      ),\n    );\n  }\n}\n\n// Step 4: Create a SecondPage widget\nclass SecondPage extends StatelessWidget {\n  final PageTransitionType transitionType;\n\n  SecondPage({required this.transitionType});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('This page was opened with:'),\n            Text(transitionType.toString(), style: TextStyle(fontWeight: FontWeight.bold)),\n            ElevatedButton(\n              child: Text('Go Back'),\n              onPressed: () => Navigator.pop(context),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the HomePage, displaying buttons for different transition types.\n// 2. When a button is pressed, the _navigateToPage function is called with the corresponding PageTransitionType.\n// 3. The Navigator.push method is used with a PageTransition widget to navigate to the SecondPage.\n// 4. The SecondPage displays the type of transition used to open it.\n// 5. The user can go back to the HomePage using the 'Go Back' button or the app bar's back button.\n// 6. When returning to the HomePage, the reverse animation of the selected transition is applied.\n\n// Note: This example demonstrates basic usage of the page_transition package.\n// For more advanced scenarios, consider using custom transitions or adjusting the transition parameters.\n```",
    "tags": [
      "animation",
      "transition",
      "navigation",
      "route"
    ],
    "_createdAt": "2024-08-28T22:16:48Z",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfB3s",
        "_type": "reference",
        "_key": "4c8w2364"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "page_transition",
    "_updatedAt": "2024-09-06T04:10:38Z"
  },
  {
    "packageImage": null,
    "_createdAt": "2024-08-28T22:16:50Z",
    "pubPoint": 160,
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVGj",
        "_type": "reference",
        "_key": "q4e5kc13"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1781,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "3g1jj7wc",
        "_ref": "Rx1Nho763d29lawKra1K9L"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWvh",
        "_type": "reference",
        "_key": "2mi4lyr1"
      }
    ],
    "author": "fleaflet.dev",
    "_type": "package",
    "shortDescription": "A versatile mapping package for Flutter, that's simple and easy to learn, yet completely customizable and configurable",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "flutter_map"
    },
    "_id": "Rx1Nho763d29lawKra1a3n",
    "_rev": "eaCZ7mIhmiYZX5KGqJmLiJ",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWSz",
        "_type": "reference",
        "_key": "7yph3j5n"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_map/flutter_map.dart';\nimport 'package:latlong2/latlong.dart';\n\nvoid main() => runApp(MaterialApp(home: RealFlutter()));\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize variables\n  final mapController = MapController();\n  var currentZoom = 9.2;\n  var currentCenter = LatLng(51.509364, -0.128928);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Map')),\n      body: Stack(\n        children: [\n          // Step 2: Create the FlutterMap widget\n          FlutterMap(\n            mapController: mapController,\n            options: MapOptions(\n              center: currentCenter,\n              zoom: currentZoom,\n              onPositionChanged: (position, hasGesture) {\n                // Step 3: Update current zoom and center when map moves\n                setState(() {\n                  currentZoom = position.zoom!;\n                  currentCenter = position.center!;\n                });\n              },\n            ),\n            children: [\n              // Step 4: Add TileLayer for map tiles\n              TileLayer(\n                urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',\n                userAgentPackageName: 'com.example.app',\n              ),\n              // Step 5: Add MarkerLayer for points of interest\n              MarkerLayer(\n                markers: [\n                  Marker(\n                    point: LatLng(51.509364, -0.128928),\n                    width: 80,\n                    height: 80,\n                    builder: (context) => Icon(Icons.location_on, color: Colors.red, size: 40),\n                  ),\n                  Marker(\n                    point: LatLng(51.519364, -0.118928),\n                    width: 80,\n                    height: 80,\n                    builder: (context) => Icon(Icons.star, color: Colors.blue, size: 40),\n                  ),\n                ],\n              ),\n              // Step 6: Add PolylineLayer for routes\n              PolylineLayer(\n                polylines: [\n                  Polyline(\n                    points: [\n                      LatLng(51.5, -0.09),\n                      LatLng(51.51, -0.1),\n                      LatLng(51.53, -0.11),\n                    ],\n                    strokeWidth: 4.0,\n                    color: Colors.purple,\n                  ),\n                ],\n              ),\n              // Step 7: Add PolygonLayer for areas\n              PolygonLayer(\n                polygons: [\n                  Polygon(\n                    points: [\n                      LatLng(51.51, -0.12),\n                      LatLng(51.52, -0.13),\n                      LatLng(51.53, -0.12),\n                      LatLng(51.52, -0.11),\n                    ],\n                    color: Colors.blue.withOpacity(0.3),\n                    borderColor: Colors.blue,\n                    borderStrokeWidth: 2,\n                  ),\n                ],\n              ),\n            ],\n          ),\n          // Step 8: Add custom controls\n          Positioned(\n            bottom: 16,\n            right: 16,\n            child: Column(\n              children: [\n                FloatingActionButton(\n                  child: Icon(Icons.add),\n                  onPressed: () {\n                    // Step 9: Implement zoom in functionality\n                    mapController.move(currentCenter, currentZoom + 1);\n                  },\n                ),\n                SizedBox(height: 8),\n                FloatingActionButton(\n                  child: Icon(Icons.remove),\n                  onPressed: () {\n                    // Step 10: Implement zoom out functionality\n                    mapController.move(currentCenter, currentZoom - 1);\n                  },\n                ),\n              ],\n            ),\n          ),\n          // Step 11: Add information overlay\n          Positioned(\n            top: 16,\n            left: 16,\n            child: Container(\n              padding: EdgeInsets.all(8),\n              color: Colors.white.withOpacity(0.8),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('Zoom: ${currentZoom.toStringAsFixed(2)}'),\n                  Text('Center: ${currentCenter.latitude.toStringAsFixed(4)}, ${currentCenter.longitude.toStringAsFixed(4)}'),\n                ],\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by creating a Scaffold with an AppBar and a Stack as the body.\n// 2. Inside the Stack, we have the FlutterMap widget as the base layer.\n// 3. The FlutterMap is configured with a MapController, initial center, and zoom level.\n// 4. We add various layers to the map:\n//    - TileLayer for the base map tiles\n//    - MarkerLayer for points of interest\n//    - PolylineLayer for drawing routes\n//    - PolygonLayer for highlighting areas\n// 5. Custom zoom controls are added as FloatingActionButtons.\n// 6. An information overlay displays the current zoom level and center coordinates.\n// 7. The onPositionChanged callback updates the state with new zoom and center values when the map moves.\n// 8. User interactions:\n//    - Tapping the zoom buttons adjusts the map's zoom level.\n//    - Panning the map updates the center coordinates.\n//    - Markers, polylines, and polygons provide visual information on the map.\n\n// This example demonstrates key features of the flutter_map package, including:\n// - Basic map setup\n// - Adding markers, polylines, and polygons\n// - Custom controls for zooming\n// - Displaying map information\n// - Handling user interactions and map movements\n\n// To extend this example, consider adding:\n// - Custom marker icons\n// - User location tracking\n// - Geocoding and search functionality\n// - Layer toggling\n// - Offline map support\n```",
    "tags": [
      "flutter-map",
      "map",
      "leaflet",
      "openstreetmap",
      "geolocation"
    ],
    "name": "flutter_map",
    "description": "# Flutter Map Package: A Comprehensive Guide\n\n## 1. Description\n\nThe `flutter_map` package is a powerful and flexible mapping solution for Flutter applications. It provides a widget-based approach to integrating interactive maps into your Flutter projects. Built on top of the `leaflet.js` library, `flutter_map` offers a wide range of features and customization options.\n\n### Key Features:\n\n1. **Tile Layers**: Support for various tile providers, including OpenStreetMap, MapBox, and custom tile servers.\n2. **Markers**: Add custom markers to your map with ease.\n3. **Polylines and Polygons**: Draw lines and shapes on your map.\n4. **Map Controls**: Zoom and rotation controls for user interaction.\n5. **Gesture Support**: Pan, zoom, and rotate the map using touch gestures.\n6. **Customization**: Extensive options for styling map elements.\n7. **Offline Maps**: Support for offline map rendering with cached tiles.\n\n### Why Choose flutter_map?\n\n- **Performance**: Optimized for smooth rendering and interaction.\n- **Flexibility**: Easy to integrate with other Flutter widgets and state management solutions.\n- **Community Support**: Active development and a growing ecosystem of plugins.\n- **Cross-platform**: Works seamlessly on iOS, Android, and web platforms.\n\nIn the following sections, we'll dive into a tutorial on how to set up and use `flutter_map`, followed by a comprehensive example showcasing its features.",
    "lastUpdate": "2024-07-01T18:30:00.000Z",
    "tutorial": "# Flutter Map Package: A Comprehensive Guide\n\n## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using the `flutter_map` package in your Flutter project.\n\n### Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_map: ^6.0.0\n  latlong2: ^0.9.0\n```\n\nRun `flutter pub get` to install the dependencies.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the necessary packages:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_map/flutter_map.dart';\nimport 'package:latlong2/latlong.dart';\n```\n\n### Step 3: Create a Basic Map\n\nHere's a simple example of how to create a basic map:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return FlutterMap(\n      options: MapOptions(\n        center: LatLng(51.509364, -0.128928),\n        zoom: 9.2,\n      ),\n      children: [\n        TileLayer(\n          urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',\n          userAgentPackageName: 'com.example.app',\n        ),\n      ],\n    );\n  }\n}\n```\n\n### Step 4: Add Markers\n\nTo add markers to your map:\n\n```dart\nMarkerLayer(\n  markers: [\n    Marker(\n      point: LatLng(51.509364, -0.128928),\n      width: 80,\n      height: 80,\n      builder: (context) => Icon(Icons.location_on, color: Colors.red),\n    ),\n  ],\n),\n```\n\n### Step 5: Draw Polylines\n\nTo draw a polyline on your map:\n\n```dart\nPolylineLayer(\n  polylines: [\n    Polyline(\n      points: [\n        LatLng(51.5, -0.09),\n        LatLng(51.51, -0.1),\n        LatLng(51.53, -0.11),\n      ],\n      strokeWidth: 4.0,\n      color: Colors.purple,\n    ),\n  ],\n),\n```\n\n### Platform-Specific Considerations\n\n#### Android\n\nFor Android, add the following permissions to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\n#### iOS\n\nFor iOS, add the following to your `Info.plist`:\n\n```xml\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>This app needs access to location when open.</string>\n<key>NSLocationAlwaysUsageDescription</key>\n<string>This app needs access to location when in the background.</string>\n```\n\n#### Web\n\nFor web support, no additional configuration is required. However, ensure that your web server allows CORS for tile requests.\n\nIn the next section, we'll create a more comprehensive example that demonstrates various features of the `flutter_map` package.",
    "_updatedAt": "2024-09-06T04:10:39Z"
  },
  {
    "author": "steenbakker.dev",
    "likesCount": 1688,
    "_createdAt": "2024-08-28T22:16:52Z",
    "slug": {
      "current": "mobile_scanner",
      "_type": "slug"
    },
    "pubPoint": 160,
    "tutorial": "# Mobile Scanner Tutorial\n\nThis tutorial will guide you through the process of integrating the `mobile_scanner` package into your Flutter application.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  mobile_scanner: ^3.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:mobile_scanner/mobile_scanner.dart';\n```\n\n## Step 3: Implement the Scanner\n\nCreate a `MobileScanner` widget in your build method:\n\n```dart\nMobileScanner(\n  onDetect: (capture) {\n    final List<Barcode> barcodes = capture.barcodes;\n    for (final barcode in barcodes) {\n      print('Barcode found! ${barcode.rawValue}');\n    }\n  },\n)\n```\n\n## Step 4: Handle Permissions\n\n### For Android:\n\nAdd the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.CAMERA\" />\n```\n\n### For iOS:\n\nAdd the following key to your `Info.plist` file:\n\n```xml\n<key>NSCameraUsageDescription</key>\n<string>This app needs camera access to scan QR codes</string>\n```\n\n## Step 5: Customize Scanner Behavior\n\nYou can customize various aspects of the scanner:\n\n```dart\nMobileScanner(\n  controller: MobileScannerController(\n    facing: CameraFacing.back,\n    torchEnabled: false,\n  ),\n  onDetect: (capture) {\n    // Handle detection\n  },\n)\n```\n\n## Step 6: Handle Scanner Results\n\nProcess the scanned results in the `onDetect` callback:\n\n```dart\nonDetect: (capture) {\n  final List<Barcode> barcodes = capture.barcodes;\n  for (final barcode in barcodes) {\n    switch (barcode.type) {\n      case BarcodeType.url:\n        // Handle URL\n        break;\n      case BarcodeType.text:\n        // Handle text\n        break;\n      // Handle other types...\n    }\n  }\n},\n```\n\nBy following these steps, you'll have a functional barcode scanner integrated into your Flutter application using the `mobile_scanner` package.",
    "description": "# Mobile Scanner Package for Flutter\n\n## Overview\n\nThe `mobile_scanner` package is a powerful and flexible solution for implementing barcode and QR code scanning functionality in Flutter applications. It provides a high-performance, cross-platform scanner that can be easily integrated into your projects.\n\n## Key Features\n\n1. **Multiple Format Support**: Scan various barcode formats including QR Code, EAN-13, Code 128, and more.\n2. **Real-time Scanning**: Continuous scanning for quick and efficient code detection.\n3. **Customizable UI**: Easily overlay your own UI elements on top of the scanner view.\n4. **Platform Flexibility**: Works on both Android and iOS platforms.\n5. **Performance Optimized**: Utilizes native APIs for optimal scanning performance.\n6. **Configurable Settings**: Adjust scan speed, resolution, and other parameters to suit your needs.\n\n## Why Choose Mobile Scanner?\n\nThe `mobile_scanner` package stands out for its ease of use and robust functionality. Whether you're building a simple QR code reader or a complex inventory management system, this package provides the tools you need to implement efficient and reliable scanning capabilities in your Flutter application.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaovc",
        "_type": "reference",
        "_key": "wykqmkur"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\n\nvoid main() => runApp(const RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Mobile Scanner Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const ScannerPage(),\n    );\n  }\n}\n\nclass ScannerPage extends StatefulWidget {\n  const ScannerPage({Key? key}) : super(key: key);\n\n  @override\n  _ScannerPageState createState() => _ScannerPageState();\n}\n\nclass _ScannerPageState extends State<ScannerPage> {\n  MobileScannerController cameraController = MobileScannerController();\n  bool _screenOpened = false;\n  String _lastScannedCode = '';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Mobile Scanner\")),\n      body: Column(\n        children: [\n          Expanded(\n            flex: 4,\n            child: MobileScanner(\n              controller: cameraController,\n              onDetect: _foundBarcode,\n            ),\n          ),\n          Expanded(\n            flex: 1,\n            child: Container(\n              alignment: Alignment.center,\n              child: Text(\n                'Last Scanned Code: $_lastScannedCode',\n                style: const TextStyle(fontSize: 18),\n              ),\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => cameraController.toggleTorch(),\n        child: ValueListenableBuilder(\n          valueListenable: cameraController.torchState,\n          builder: (context, state, child) {\n            switch (state) {\n              case TorchState.off:\n                return const Icon(Icons.flash_off);\n              case TorchState.on:\n                return const Icon(Icons.flash_on);\n            }\n          },\n        ),\n      ),\n    );\n  }\n\n  void _foundBarcode(BarcodeCapture capture) {\n    // Step 1: Check if a dialog is already open\n    if (!_screenOpened) {\n      // Step 2: Get the first barcode from the list\n      final List<Barcode> barcodes = capture.barcodes;\n      final Barcode barcode = barcodes.first;\n      \n      // Step 3: Update the last scanned code\n      setState(() {\n        _lastScannedCode = barcode.rawValue ?? 'Failed to scan';\n      });\n\n      // Step 4: Set the flag to true to prevent multiple dialogs\n      _screenOpened = true;\n      \n      // Step 5: Show a dialog with the barcode information\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: const Text('Scanned Code'),\n          content: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              Text('Type: ${barcode.type.name}'),\n              Text('Data: ${barcode.rawValue}'),\n            ],\n          ),\n          actions: [\n            TextButton(\n              onPressed: () {\n                // Step 6: Close the dialog and reset the flag\n                Navigator.pop(context);\n                _screenOpened = false;\n              },\n              child: const Text('Close'),\n            ),\n          ],\n        ),\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    // Step 7: Dispose of the camera controller when the widget is disposed\n    cameraController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp with the ScannerPage as the home widget.\n// 3. ScannerPage is created, which initializes the MobileScannerController.\n// 4. The build method of ScannerPage sets up the UI:\n//    - An AppBar with the title \"Mobile Scanner\"\n//    - A MobileScanner widget that uses the controller and sets up the onDetect callback\n//    - A container to display the last scanned code\n//    - A FloatingActionButton to toggle the torch/flash\n// 5. When a barcode is detected, the _foundBarcode method is called:\n//    - It checks if a dialog is already open to prevent multiple dialogs\n//    - Updates the _lastScannedCode state variable\n//    - Shows a dialog with the scanned barcode information\n// 6. The user can close the dialog, which resets the _screenOpened flag\n// 7. The torch can be toggled on/off using the FloatingActionButton\n// 8. When the widget is disposed, the cameraController is also disposed to free resources\n```",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "packageImage": {
      "asset": {
        "_ref": "image-90927aa79f72ddd27c1106f3d5738e8cb090494c-1080x1920-webp",
        "_type": "reference"
      },
      "_type": "image"
    },
    "name": "mobile_scanner",
    "_id": "Rx1Nho763d29lawKra1aLX",
    "_type": "package",
    "_updatedAt": "2024-09-06T04:10:40Z",
    "tutorialIncluded": true,
    "shortDescription": "A universal barcode and QR code scanner for Flutter based on MLKit. Uses CameraX on Android, AVFoundation on iOS and Apple Vision & AVFoundation on macOS.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGrS",
        "_type": "reference",
        "_key": "7vhnll71"
      }
    ],
    "tags": [
      "qr",
      "barcode",
      "scanner",
      "camera",
      "reader"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1s1z",
        "_type": "reference",
        "_key": "4f4jtits"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CfWv",
        "_type": "reference",
        "_key": "xmwrg0mk"
      }
    ],
    "lastUpdate": "2024-08-19T18:30:00.000Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmLs8"
  },
  {
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "ejjosch3"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVRl",
        "_type": "reference",
        "_key": "irw775ts"
      }
    ],
    "_createdAt": "2024-08-28T22:16:55Z",
    "_id": "Rx1Nho763d29lawKra1adH",
    "slug": {
      "current": "printing",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaOhA",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "haxgn7fo",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGp5"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "pdf",
      "printer",
      "print",
      "printing",
      "report",
      "document"
    ],
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:41Z",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:printing/printing.dart';\nimport 'package:pdf/pdf.dart';\nimport 'package:pdf/widgets.dart' as pw;\nimport 'dart:typed_data';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Printing Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: PrintingDemoScreen(),\n    );\n  }\n}\n\nclass PrintingDemoScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Printing Demo')),\n      body: Center(\n        child: ElevatedButton(\n          child: Text('Print Document'),\n          onPressed: () => RealFlutter().printDocument(context),\n        ),\n      ),\n    );\n  }\n}\n\nclass RealFlutter {\n  Future<void> printDocument(BuildContext context) async {\n    // Step 1: Create a PDF document\n    final pdf = await _createPdf();\n\n    // Step 2: Show print preview\n    await Printing.layoutPdf(\n      onLayout: (PdfPageFormat format) async => pdf.save(),\n      name: 'RealFlutter_document.pdf',\n      format: PdfPageFormat.a4,\n    );\n  }\n\n  Future<pw.Document> _createPdf() async {\n    // Step 3: Initialize the PDF document\n    final pdf = pw.Document();\n\n    // Step 4: Add a cover page\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Center(\n            child: pw.Text(\n              'RealFlutter Printing Demo',\n              style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),\n            ),\n          );\n        },\n      ),\n    );\n\n    // Step 5: Add a page with text and an image\n    final image = pw.MemoryImage(\n      (await _getImageData()),\n    );\n\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Column(\n            crossAxisAlignment: pw.CrossAxisAlignment.start,\n            children: [\n              pw.Text('Welcome to RealFlutter Printing!'),\n              pw.SizedBox(height: 20),\n              pw.Image(image, width: 200),\n              pw.SizedBox(height: 20),\n              pw.Text('This is a demo of various printing features.'),\n            ],\n          );\n        },\n      ),\n    );\n\n    // Step 6: Add a page with a table\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Table.fromTextArray(\n            context: context,\n            data: <List<String>>[\n              <String>['Header 1', 'Header 2', 'Header 3'],\n              <String>['Row 1', 'Data', 'Data'],\n              <String>['Row 2', 'Data', 'Data'],\n              <String>['Row 3', 'Data', 'Data'],\n            ],\n          );\n        },\n      ),\n    );\n\n    return pdf;\n  }\n\n  Future<Uint8List> _getImageData() async {\n    // In a real app, you'd load an actual image here.\n    // For this example, we'll create a simple colored square.\n    final recorder = PictureRecorder();\n    final canvas = Canvas(recorder);\n    final paint = Paint()..color = Colors.blue;\n    canvas.drawRect(Rect.fromLTWH(0, 0, 100, 100), paint);\n    final picture = recorder.endRecording();\n    final img = await picture.toImage(100, 100);\n    final pngBytes = await img.toByteData(format: ImageByteFormat.png);\n    return pngBytes!.buffer.asUint8List();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a button to print a document.\n// 2. When the button is pressed, RealFlutter().printDocument() is called.\n// 3. A PDF document is created with multiple pages demonstrating different features:\n//    - A cover page with centered text\n//    - A page with text and an image\n//    - A page with a table\n// 4. The print preview is shown, allowing the user to view and print the document.\n// \n// Key Features Demonstrated:\n// - Multi-page PDF generation\n// - Text formatting\n// - Image inclusion\n// - Table creation\n// - Print preview functionality\n//\n// Note: In a real-world scenario, you'd typically load actual images and data\n// from your app's assets or a network source. The _getImageData() method in this\n// example creates a simple colored square for demonstration purposes.\n```",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-c1d1c576a89b1ae298f1f7f8fd2234b1cc55a5b8-913x1788-webp",
        "_type": "reference"
      }
    },
    "name": "printing",
    "tutorial": "# Flutter Printing Package: Tutorial\n\n## Setting Up\n\n1. Add the printing package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  printing: ^5.9.3\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:printing/printing.dart';\n```\n\n## Basic Usage\n\nHere's a simple example of how to use the RealFlutter class to print a basic document:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:printing/printing.dart';\nimport 'package:pdf/pdf.dart';\nimport 'package:pdf/widgets.dart' as pw;\n\nclass RealFlutter {\n  Future<void> printDocument() async {\n    final pdf = pw.Document();\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Center(\n            child: pw.Text('Hello, RealFlutter Printing!'),\n          );\n        },\n      ),\n    );\n    \n    await Printing.layoutPdf(\n      onLayout: (PdfPageFormat format) async => pdf.save(),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have the correct permissions in your `Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for printing images.</string>\n```\n\n### Android\n- Add the following permissions to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n### macOS\n- Add the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`:\n\n```xml\n<key>com.apple.security.print</key>\n<true/>\n```\n\n### Windows & Linux\n- No additional configuration is required for these platforms.\n\n## Advanced Features\n\n### Custom Page Sizes\n```dart\nfinal pdf = pw.Document(\n  pageMode: PdfPageMode.outlines,\n  pageFormat: PdfPageFormat.a4,\n);\n```\n\n### Adding Images\n```dart\nfinal image = pw.MemoryImage(\n  (await rootBundle.load('assets/logo.png')).buffer.asUint8List(),\n);\npdf.addPage(\n  pw.Page(\n    build: (pw.Context context) {\n      return pw.Center(\n        child: pw.Image(image),\n      );\n    },\n  ),\n);\n```\n\n### Network Printing\n```dart\nawait Printing.directPrintPdf(\n  printer: Printer(url: 'http://192.168.1.100'),\n  onLayout: (_) => pdf.save(),\n);\n```\n\nBy following this tutorial and considering the platform-specific details, you'll be well on your way to implementing robust printing functionality in your Flutter application using the RealFlutter class.",
    "pubPoint": 160,
    "description": "# Flutter Printing Package: A Comprehensive Guide\n\n## Introduction\n\nThe printing package for Flutter is a powerful tool that enables developers to generate and print documents directly from their Flutter applications. This package supports various platforms, including iOS, Android, macOS, Windows, and Linux, making it a versatile solution for cross-platform printing needs.\n\n## Key Features\n\n1. **Multi-platform support**: Works on mobile, desktop, and web platforms.\n2. **PDF generation**: Create PDF documents programmatically.\n3. **Custom layouts**: Design complex document layouts using Flutter widgets.\n4. **Print preview**: Offer users a preview of the document before printing.\n5. **Network printing**: Print to network printers or share documents via other apps.\n6. **Image printing**: Easily incorporate images into your printable documents.\n\n## Use Cases\n\n- Generating and printing invoices or receipts in point-of-sale applications.\n- Creating and printing reports in business or analytics apps.\n- Producing and printing tickets or passes for events or transportation.\n- Printing custom documents in productivity or office suite applications.\n\nIn the following sections, we'll dive deeper into how to implement printing functionality in your Flutter app using the RealFlutter class, and explore platform-specific considerations to ensure a smooth printing experience across all supported devices.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "zlimfv98",
        "_ref": "V06bsD4sX3T8NTHrBPadBM"
      }
    ],
    "likesCount": 1552,
    "author": "nfet.net",
    "shortDescription": "Plugin that allows Flutter apps to generate and print documents to compatible printers on Android, iOS, macOS, Windows, and Linux, as well as web print.",
    "lastUpdate": "2024-08-07T18:30:00.000Z"
  },
  {
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWg3",
        "_type": "reference",
        "_key": "604q7dxl"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "cache",
      "cache-manager",
      "storage",
      "file",
      "network"
    ],
    "likesCount": 1624,
    "_createdAt": "2024-08-28T22:17:02Z",
    "tutorial": "# Flutter Cache Manager: Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `flutter_cache_manager` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nTo get started with `flutter_cache_manager`, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_cache_manager: ^3.3.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nHere's a simple example of how to use `flutter_cache_manager` to download and cache a file:\n\n```dart\nimport 'package:flutter_cache_manager/flutter_cache_manager.dart';\n\nclass RealFlutter {\n  Future<File> downloadAndCacheFile(String url) async {\n    return await DefaultCacheManager().getSingleFile(url);\n  }\n}\n```\n\nThis method will download the file if it's not in the cache, or return the cached file if it exists.\n\n## Step 3: Customizing Cache Settings\n\nYou can create a custom `CacheManager` with specific settings:\n\n```dart\nclass RealFlutter {\n  late CacheManager customCacheManager;\n\n  RealFlutter() {\n    customCacheManager = CacheManager(\n      Config(\n        'customCacheKey',\n        stalePeriod: const Duration(days: 7),\n        maxNrOfCacheObjects: 100,\n        repo: JsonCacheInfoRepository(databaseName: 'customCache'),\n        fileService: HttpFileService(),\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Retrieving Cached Files\n\nTo retrieve a cached file without downloading:\n\n```dart\nclass RealFlutter {\n  Future<File?> getCachedFile(String url) async {\n    final fileInfo = await DefaultCacheManager().getFileFromCache(url);\n    return fileInfo?.file;\n  }\n}\n```\n\n## Step 5: Clearing the Cache\n\nTo remove a specific file from the cache:\n\n```dart\nclass RealFlutter {\n  Future<void> removeFileFromCache(String url) async {\n    await DefaultCacheManager().removeFile(url);\n  }\n}\n```\n\nTo clear the entire cache:\n\n```dart\nclass RealFlutter {\n  Future<void> clearCache() async {\n    await DefaultCacheManager().emptyCache();\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you need to add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n### Web\n\nFor web applications, `flutter_cache_manager` uses the browser's built-in caching mechanism. No additional configuration is required.\n\nBy following these steps and considering platform-specific requirements, you can effectively integrate `flutter_cache_manager` into your Flutter project and leverage its powerful caching capabilities.",
    "_updatedAt": "2024-09-06T04:10:42Z",
    "description": "# Flutter Cache Manager: Efficient File Caching for Your Flutter Apps\n\n## Introduction\n\nIn the world of mobile app development, efficient data management is crucial for providing a smooth user experience. One of the key aspects of data management is caching, which helps reduce network usage and improves app performance. For Flutter developers, the `flutter_cache_manager` package offers a powerful solution to handle file caching with ease.\n\n## What is flutter_cache_manager?\n\n`flutter_cache_manager` is a Flutter package that provides a convenient way to download and cache files in your Flutter applications. It offers features such as:\n\n1. Downloading files from the internet\n2. Storing files in the cache\n3. Retrieving files from the cache\n4. Managing cache size and expiration\n\nThis package is particularly useful for applications that need to handle images, audio files, or any other type of downloadable content.\n\n## Key Features\n\n- **Efficient caching**: Automatically stores downloaded files in the device's cache.\n- **Customizable cache settings**: Configure cache size limits and file expiration times.\n- **Multiple file support**: Cache various file types, including images, audio, and more.\n- **Background download**: Download files in the background without blocking the main thread.\n- **File retrieval**: Easily retrieve cached files using unique keys.\n- **Cache cleanup**: Automatically remove expired or least recently used files to manage cache size.\n\n## Why Use flutter_cache_manager?\n\n1. **Improved performance**: By caching files locally, your app can reduce network requests and load content faster.\n2. **Offline support**: Cached files can be accessed even when the device is offline.\n3. **Reduced data usage**: Minimize data consumption by serving cached content when available.\n4. **Easy integration**: Simple API that integrates seamlessly with Flutter projects.\n5. **Customizable**: Adapt the caching behavior to suit your app's specific needs.\n\nIn the following sections, we'll explore how to implement `flutter_cache_manager` in your Flutter projects and demonstrate its features through practical examples.",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_cache_manager/flutter_cache_manager.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Cache Manager Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final String imageUrl = 'https://example.com/image.jpg';\n  File? _cachedFile;\n  String _statusMessage = '';\n\n  // Step 1: Initialize a custom CacheManager\n  late CacheManager customCacheManager;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Configure the custom CacheManager\n    customCacheManager = CacheManager(\n      Config(\n        'customCacheKey',\n        stalePeriod: const Duration(days: 7),\n        maxNrOfCacheObjects: 100,\n        repo: JsonCacheInfoRepository(databaseName: 'customCache'),\n        fileService: HttpFileService(),\n      ),\n    );\n  }\n\n  // Step 3: Download and cache a file\n  Future<void> downloadAndCacheFile() async {\n    setState(() => _statusMessage = 'Downloading...');\n    try {\n      final file = await customCacheManager.getSingleFile(imageUrl);\n      setState(() {\n        _cachedFile = file;\n        _statusMessage = 'File downloaded and cached successfully';\n      });\n    } catch (e) {\n      setState(() => _statusMessage = 'Error: ${e.toString()}');\n    }\n  }\n\n  // Step 4: Retrieve a cached file\n  Future<void> getCachedFile() async {\n    setState(() => _statusMessage = 'Retrieving from cache...');\n    final fileInfo = await customCacheManager.getFileFromCache(imageUrl);\n    if (fileInfo != null) {\n      setState(() {\n        _cachedFile = fileInfo.file;\n        _statusMessage = 'File retrieved from cache';\n      });\n    } else {\n      setState(() => _statusMessage = 'File not found in cache');\n    }\n  }\n\n  // Step 5: Remove a specific file from the cache\n  Future<void> removeFileFromCache() async {\n    setState(() => _statusMessage = 'Removing file from cache...');\n    await customCacheManager.removeFile(imageUrl);\n    setState(() {\n      _cachedFile = null;\n      _statusMessage = 'File removed from cache';\n    });\n  }\n\n  // Step 6: Clear the entire cache\n  Future<void> clearCache() async {\n    setState(() => _statusMessage = 'Clearing cache...');\n    await customCacheManager.emptyCache();\n    setState(() {\n      _cachedFile = null;\n      _statusMessage = 'Cache cleared';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Flutter Cache Manager Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            if (_cachedFile != null)\n              Image.file(_cachedFile!, width: 200, height: 200)\n            else\n              const Icon(Icons.image, size: 200),\n            const SizedBox(height: 20),\n            Text(_statusMessage),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: downloadAndCacheFile,\n              child: const Text('Download and Cache'),\n            ),\n            ElevatedButton(\n              onPressed: getCachedFile,\n              child: const Text('Get Cached File'),\n            ),\n            ElevatedButton(\n              onPressed: removeFileFromCache,\n              child: const Text('Remove File from Cache'),\n            ),\n            ElevatedButton(\n              onPressed: clearCache,\n              child: const Text('Clear Cache'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes with a custom CacheManager configured in the initState method.\n// 2. The UI displays buttons for different cache operations and an area to show the cached image.\n// 3. When \"Download and Cache\" is pressed, the app downloads the image and stores it in the cache.\n// 4. \"Get Cached File\" retrieves the image from the cache without downloading it again.\n// 5. \"Remove File from Cache\" deletes the specific image file from the cache.\n// 6. \"Clear Cache\" removes all files from the cache.\n// 7. The status message and image display are updated after each operation to reflect the current state.\n\n// This example demonstrates the core features of flutter_cache_manager:\n// - Customizing cache settings\n// - Downloading and caching files\n// - Retrieving cached files\n// - Removing specific files from the cache\n// - Clearing the entire cache\n// \n// The app provides a practical implementation that developers can use as a starting point\n// for integrating flutter_cache_manager into their own projects.\n```",
    "_id": "Rx1Nho763d29lawKra1bY3",
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaOlx",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "u05042vj",
        "_ref": "V06bsD4sX3T8NTHrBPa6y0"
      }
    ],
    "dependentPackages": [
      {
        "_key": "ry70i136",
        "_ref": "V06bsD4sX3T8NTHrBPbBNs",
        "_type": "reference"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "r42yj5oq"
      }
    ],
    "lastUpdate": "2024-08-12T18:30:00.000Z",
    "name": "flutter_cache_manager",
    "slug": {
      "current": "flutter_cache_manager",
      "_type": "slug"
    },
    "author": "baseflow.com",
    "packageImage": null,
    "tutorialIncluded": true,
    "shortDescription": "Generic cache manager for flutter. Saves web files on the storages of the device and saves the cache info using sqflite."
  },
  {
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXCi",
        "_type": "reference",
        "_key": "admfcr9x"
      }
    ],
    "packageImage": null,
    "name": "flutter_lints",
    "_id": "Rx1Nho763d29lawKra1ea7",
    "tutorial": "# Flutter Lints Package: Tutorial\n\nThis tutorial will guide you through the process of integrating the `flutter_lints` package into your Flutter project. We'll cover installation, configuration, and usage across different platforms.\n\n## Step 1: Add the package to your project\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndev_dependencies:\n  flutter_lints: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Create or update analysis_options.yaml\n\nCreate an `analysis_options.yaml` file in the root of your project if it doesn't exist. Add the following content:\n\n```yaml\ninclude: package:flutter_lints/flutter.yaml\n\nlinter:\n  rules:\n    # Add any additional rules or override existing ones here\n```\n\n## Step 3: Customize linter rules (optional)\n\nYou can enable or disable specific rules by modifying the `analysis_options.yaml` file. For example:\n\n```yaml\nlinter:\n  rules:\n    avoid_print: false  # Disable the avoid_print rule\n    prefer_const_constructors: true  # Enable prefer_const_constructors rule\n```\n\n## Step 4: Run the linter\n\nTo run the linter and see any violations, use the following command:\n\n```\nflutter analyze\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android-specific linting:\n\n1. Open `android/app/build.gradle`\n2. Add the following to enable additional Android linting:\n\n```gradle\nandroid {\n    // ...\n    lintOptions {\n        disable 'InvalidPackage'\n        checkReleaseBuilds false\n    }\n}\n```\n\n### iOS\n\nFor iOS-specific linting:\n\n1. Open `ios/Runner.xcodeproj/project.pbxproj`\n2. Locate the `PRODUCT_BUNDLE_IDENTIFIER` key\n3. Ensure it follows reverse-domain naming convention, e.g., `com.example.myapp`\n\n### Web\n\nFor web projects, ensure your `web/index.html` file has the correct meta tags and script inclusions. Here's an example:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta content=\"IE=Edge\" http-equiv=\"X-UA-Compatible\">\n  <meta name=\"description\" content=\"A Flutter project using flutter_lints.\">\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n  <meta name=\"apple-mobile-web-app-title\" content=\"flutter_lints_demo\">\n  <link rel=\"apple-touch-icon\" href=\"icons/Icon-192.png\">\n  <link rel=\"icon\" type=\"image/png\" href=\"favicon.png\"/>\n  <title>flutter_lints_demo</title>\n  <link rel=\"manifest\" href=\"manifest.json\">\n</head>\n<body>\n  <script src=\"main.dart.js\" type=\"application/javascript\"></script>\n</body>\n</html>\n```\n\nBy following these steps and considering platform-specific details, you'll have successfully integrated the `flutter_lints` package into your Flutter project across all supported platforms.",
    "_type": "package",
    "description": "# Flutter Lints Package: A Deep Dive\n\n## Introduction\n\nThe `flutter_lints` package is an essential tool for Flutter developers who want to maintain clean, efficient, and consistent code across their projects. This package provides a set of recommended linter rules that help catch potential errors, enforce best practices, and improve overall code quality.\n\n## What are Lints?\n\nLints are static analysis tools that examine your code without executing it. They flag potential issues, style violations, and areas for improvement. By using lints, you can:\n\n1. Identify bugs early in the development process\n2. Enforce consistent coding standards across your team\n3. Improve code readability and maintainability\n4. Optimize performance by following best practices\n\n## The `flutter_lints` Package\n\nThe `flutter_lints` package is maintained by the Flutter team and includes a curated set of linter rules specifically designed for Flutter projects. These rules are based on years of experience and best practices within the Flutter community.\n\n### Key Features\n\n- **Comprehensive Rule Set**: Covers a wide range of potential issues and style guidelines.\n- **Easy Integration**: Simple to add to your project and configure.\n- **Customizable**: Allows you to enable or disable specific rules based on your project's needs.\n- **Regular Updates**: Maintained alongside Flutter to ensure compatibility and relevance.\n\n## Benefits of Using `flutter_lints`\n\n1. **Consistency**: Ensures all team members follow the same coding standards.\n2. **Time-saving**: Catches common mistakes automatically, reducing code review time.\n3. **Learning Tool**: Helps developers learn Flutter best practices and improve their coding skills.\n4. **Performance**: Encourages patterns that lead to better app performance.\n\nIn the following sections, we'll explore how to integrate `flutter_lints` into your project and demonstrate its usage in a real-world example.",
    "similarPackages": [
      {
        "_key": "qozmgaen",
        "_ref": "uQRNMiDfrp20RZ8Id8Ce4p",
        "_type": "reference"
      }
    ],
    "pubPoint": 160,
    "shortDescription": "Recommended lints for Flutter apps, packages, and plugins to encourage good coding practices.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "lints",
      "static-analysis",
      "code-quality",
      "best-practices"
    ],
    "likesCount": 1145,
    "tutorialIncluded": true,
    "author": "flutter.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaOp9",
    "example": "```\nimport 'package:flutter/material.dart';\n\n// Step 1: Define the main class\nclass RealFlutter extends StatelessWidget {\n  // Step 2: Use const constructor for better performance\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Use const for widget instantiation where possible\n    return const MaterialApp(\n      home: HomePage(),\n    );\n  }\n}\n\n// Step 4: Create a separate widget for the home page\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  // Step 5: Declare variables with proper types\n  int _counter = 0;\n  final List<String> _items = ['Item 1', 'Item 2', 'Item 3'];\n\n  // Step 6: Use a private method for incrementing the counter\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 7: Use const for static widgets\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Lints Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 8: Use string interpolation for dynamic text\n            Text(\n              'You have pushed the button $_counter times:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            // Step 9: Use a ListView.builder for efficient list rendering\n            Expanded(\n              child: ListView.builder(\n                itemCount: _items.length,\n                itemBuilder: (context, index) {\n                  return ListTile(\n                    title: Text(_items[index]),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n      // Step 10: Use a named function for the onPressed callback\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Step 11: Use the main function to run the app\nvoid main() {\n  runApp(const RealFlutter());\n}\n\n// Application Flow:\n// 1. The main function is called, which runs the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and sets HomePage as the home widget.\n// 3. HomePage is a StatefulWidget that manages a counter and a list of items.\n// 4. The build method of _HomePageState creates the UI:\n//    - An AppBar with the title \"Flutter Lints Demo\"\n//    - A Column in the body containing:\n//      a. A Text widget showing the current counter value\n//      b. A ListView.builder displaying the _items list\n//    - A FloatingActionButton that increments the counter when pressed\n// 5. When the FloatingActionButton is pressed, _incrementCounter is called:\n//    - It uses setState to increment _counter and rebuild the widget\n// 6. The UI updates to reflect the new counter value\n\n// This example demonstrates several Flutter best practices and lint rules:\n// - Use of const constructors\n// - Proper variable declarations\n// - Efficient list rendering with ListView.builder\n// - Use of private methods\n// - String interpolation\n// - Named functions for callbacks\n// - Separation of concerns (HomePage as a separate widget)\n```",
    "dependentPackages": [
      {
        "_key": "usy5my62",
        "_ref": "uQRNMiDfrp20RZ8Id8CasF",
        "_type": "reference"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CgMP",
        "_type": "reference",
        "_key": "4r2xy42b"
      }
    ],
    "_createdAt": "2024-08-28T22:17:11Z",
    "lastUpdate": "2024-05-08T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:10:43Z",
    "slug": {
      "current": "flutter_lints",
      "_type": "slug"
    }
  },
  {
    "pubPoint": 160,
    "tags": [
      "notifications",
      "push-notifications",
      "local-notifications",
      "alerts"
    ],
    "_createdAt": "2024-08-28T22:17:17Z",
    "name": "awesome_notifications",
    "tutorial": "# Awesome Notifications Tutorial\n\nThis tutorial will guide you through the process of integrating the `awesome_notifications` package into your Flutter project. We'll cover installation, basic setup, and platform-specific configurations.\n\n## Step 1: Installation\n\nAdd the `awesome_notifications` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  awesome_notifications: ^0.7.4+1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Setup\n\nIn your `main.dart` file, import the package and initialize it:\n\n```dart\nimport 'package:awesome_notifications/awesome_notifications.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  await AwesomeNotifications().initialize(\n    null, // default icon for notifications\n    [\n      NotificationChannel(\n        channelKey: 'basic_channel',\n        channelName: 'Basic Notifications',\n        channelDescription: 'Channel for basic notifications',\n        defaultColor: Colors.teal,\n        ledColor: Colors.white,\n        importance: NotificationImportance.High\n      ),\n    ]\n  );\n  \n  runApp(RealFlutter());\n}\n```\n\n## Step 3: Request Permissions\n\nBefore showing notifications, you need to request permissions from the user:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    AwesomeNotifications().isNotificationAllowed().then((isAllowed) {\n      if (!isAllowed) {\n        AwesomeNotifications().requestPermissionToSendNotifications();\n      }\n    });\n\n    // Rest of your app code...\n  }\n}\n```\n\n## Step 4: Create a Simple Notification\n\nHere's how to create a basic notification:\n\n```dart\nAwesomeNotifications().createNotification(\n  content: NotificationContent(\n    id: 1,\n    channelKey: 'basic_channel',\n    title: 'Simple Notification',\n    body: 'This is a basic notification from Awesome Notifications!',\n  )\n);\n```\n\n## Platform-Specific Configuration\n\n### Android\n\n1. Update `android/app/src/main/AndroidManifest.xml`:\n\n```xml\n<manifest ...>\n    <application ...>\n        <!-- Add this meta-data tag -->\n        <meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_icon\"\n            android:resource=\"@mipmap/ic_launcher\" />\n    </application>\n</manifest>\n```\n\n2. Ensure your app's icon is in PNG format for proper display in notifications.\n\n### iOS\n\n1. Update `ios/Runner/AppDelegate.swift`:\n\n```swift\nimport UIKit\nimport Flutter\nimport awesome_notifications\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    SwiftAwesomeNotificationsPlugin.setPluginRegistrantCallback { registry in\n        SwiftAwesomeNotificationsPlugin.register(\n          with: registry.registrar(forPlugin: \"io.flutter.plugins.awesomenotifications.AwesomeNotificationsPlugin\")!)\n    }\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}\n```\n\n2. In Xcode, go to your target's Signing & Capabilities tab and add the \"Background Modes\" capability. Check \"Remote notifications\" to enable background notifications.\n\nWith these steps completed, you're ready to start using Awesome Notifications in your Flutter project!",
    "slug": {
      "current": "awesome_notifications",
      "_type": "slug"
    },
    "tutorialIncluded": true,
    "author": "carda.me",
    "_rev": "AE3hjGWNkNE6aGQMMbaOsL",
    "_type": "package",
    "shortDescription": "A complete solution to create Local and Push Notifications, customizing buttons, images, sounds, emoticons and applying many different layouts for Flutter apps.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-03-16T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:10:43Z",
    "packageImage": null,
    "description": "# Awesome Notifications: Elevate Your Flutter App's Notification Game\n\nIn the ever-evolving world of mobile app development, user engagement is paramount. One of the most effective ways to keep users connected with your app is through well-implemented notifications. Enter `awesome_notifications`, a powerful Flutter package that revolutionizes how developers handle local and push notifications in their applications.\n\n## What is Awesome Notifications?\n\nAwesome Notifications is a Flutter package that provides a comprehensive solution for creating and managing notifications in your Flutter applications. It offers support for both local and push notifications, with a wide range of customization options and features that go beyond the basic notification functionality.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Works seamlessly on iOS, Android, and Web platforms.\n2. **Rich Media Support**: Incorporate images, sounds, and even buttons in your notifications.\n3. **Scheduling**: Set up notifications to be delivered at specific times or intervals.\n4. **Action Buttons**: Add interactive buttons to your notifications for quick user actions.\n5. **Customization**: Tailor the appearance and behavior of notifications to match your app's style.\n6. **Notification Channels**: Organize notifications into categories for better user control (Android).\n7. **Background Execution**: Handle notifications even when your app is not in the foreground.\n8. **Localization**: Support for multiple languages in your notifications.\n\n## Why Choose Awesome Notifications?\n\nThe `awesome_notifications` package stands out due to its extensive feature set and ease of use. It abstracts away many of the platform-specific complexities, allowing developers to create rich, interactive notifications with minimal effort. Whether you're building a simple reminder app or a complex social media platform, Awesome Notifications provides the tools you need to keep your users engaged and informed.\n\nIn the following sections, we'll dive into a tutorial on how to implement Awesome Notifications in your Flutter project, followed by a comprehensive example showcasing its features.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbY2y",
        "_type": "reference",
        "_key": "ufnzigfe"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:awesome_notifications/awesome_notifications.dart';\n\nvoid main() async {\n  // Step 1: Initialize AwesomeNotifications\n  WidgetsFlutterBinding.ensureInitialized();\n  await AwesomeNotifications().initialize(\n    null,\n    [\n      NotificationChannel(\n        channelKey: 'basic_channel',\n        channelName: 'Basic Notifications',\n        channelDescription: 'Channel for basic notifications',\n        defaultColor: Colors.teal,\n        ledColor: Colors.white,\n        importance: NotificationImportance.High\n      ),\n      NotificationChannel(\n        channelKey: 'scheduled_channel',\n        channelName: 'Scheduled Notifications',\n        channelDescription: 'Channel for scheduled notifications',\n        defaultColor: Colors.blue,\n        ledColor: Colors.white,\n        importance: NotificationImportance.High\n      ),\n    ]\n  );\n  \n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 2: Request notification permissions\n    AwesomeNotifications().isNotificationAllowed().then((isAllowed) {\n      if (!isAllowed) {\n        AwesomeNotifications().requestPermissionToSendNotifications();\n      }\n    });\n\n    return MaterialApp(\n      title: 'Awesome Notifications Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: NotificationDemo(),\n    );\n  }\n}\n\nclass NotificationDemo extends StatefulWidget {\n  @override\n  _NotificationDemoState createState() => _NotificationDemoState();\n}\n\nclass _NotificationDemoState extends State<NotificationDemo> {\n  @override\n  void initState() {\n    super.initState();\n    \n    // Step 3: Set up notification listeners\n    AwesomeNotifications().actionStream.listen((ReceivedAction receivedAction) {\n      if (receivedAction.buttonKeyPressed == 'OPEN_SCREEN') {\n        Navigator.of(context).pushNamed('/secondScreen');\n      }\n    });\n  }\n\n  // Step 4: Create a basic notification\n  void createBasicNotification() async {\n    await AwesomeNotifications().createNotification(\n      content: NotificationContent(\n        id: 1,\n        channelKey: 'basic_channel',\n        title: 'Basic Notification',\n        body: 'This is a basic notification from Awesome Notifications!',\n      )\n    );\n  }\n\n  // Step 5: Create a notification with an image\n  void createNotificationWithImage() async {\n    await AwesomeNotifications().createNotification(\n      content: NotificationContent(\n        id: 2,\n        channelKey: 'basic_channel',\n        title: 'Notification with Image',\n        body: 'This notification includes an image!',\n        bigPicture: 'https://example.com/large-image.jpg',\n        notificationLayout: NotificationLayout.BigPicture,\n      )\n    );\n  }\n\n  // Step 6: Create a scheduled notification\n  void createScheduledNotification() async {\n    await AwesomeNotifications().createNotification(\n      content: NotificationContent(\n        id: 3,\n        channelKey: 'scheduled_channel',\n        title: 'Scheduled Notification',\n        body: 'This notification was scheduled to appear 5 seconds from now!',\n      ),\n      schedule: NotificationInterval(interval: 5)\n    );\n  }\n\n  // Step 7: Create a notification with action buttons\n  void createNotificationWithActions() async {\n    await AwesomeNotifications().createNotification(\n      content: NotificationContent(\n        id: 4,\n        channelKey: 'basic_channel',\n        title: 'Action Buttons',\n        body: 'This notification has action buttons!',\n      ),\n      actionButtons: [\n        NotificationActionButton(\n          key: 'OPEN_SCREEN',\n          label: 'Open Screen',\n        ),\n        NotificationActionButton(\n          key: 'DISMISS',\n          label: 'Dismiss',\n          buttonType: ActionButtonType.DisabledAction,\n        ),\n      ]\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Awesome Notifications Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Basic Notification'),\n              onPressed: createBasicNotification,\n            ),\n            ElevatedButton(\n              child: Text('Notification with Image'),\n              onPressed: createNotificationWithImage,\n            ),\n            ElevatedButton(\n              child: Text('Scheduled Notification'),\n              onPressed: createScheduledNotification,\n            ),\n            ElevatedButton(\n              child: Text('Notification with Actions'),\n              onPressed: createNotificationWithActions,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes AwesomeNotifications with two channels: basic and scheduled.\n// 2. It requests notification permissions from the user.\n// 3. The main screen (NotificationDemo) is displayed with four buttons.\n// 4. Each button triggers a different type of notification:\n//    - Basic: A simple text notification\n//    - With Image: A notification including a large image\n//    - Scheduled: A notification that appears after a 5-second delay\n//    - With Actions: A notification with interactive buttons\n// 5. When a notification with actions is tapped, it can trigger navigation to a new screen.\n// \n// This example demonstrates the versatility of the awesome_notifications package,\n// showcasing various types of notifications and interactions possible within a Flutter app.\n```",
    "likesCount": 3072,
    "dependentPackages": [],
    "_id": "Rx1Nho763d29lawKra1err"
  },
  {
    "description": "# Flutter Crypto Package: Securing Your Data with Ease\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, security is paramount. Flutter, Google's UI toolkit for building natively compiled applications, offers a robust crypto package that enables developers to implement various cryptographic operations seamlessly. This blog post will explore the Flutter crypto package, its features, and how to leverage it in your applications.\n\n## What is the Crypto Package?\n\nThe `crypto` package in Flutter provides a set of cryptographic functions that can be used to secure data within your application. It includes implementations of various hashing algorithms, message authentication codes (MACs), and utilities for working with cryptographic keys.\n\n## Key Features\n\n1. **Hashing**: Supports multiple hashing algorithms like SHA-1, SHA-256, and MD5.\n2. **Message Authentication**: Implements HMAC (Hash-based Message Authentication Code) for data integrity and authenticity.\n3. **Key Derivation**: Offers PBKDF2 (Password-Based Key Derivation Function 2) for secure key generation.\n4. **Cross-platform Compatibility**: Works seamlessly on both Android and iOS platforms.\n\n## Why Use the Crypto Package?\n\n- **Data Security**: Protect sensitive information from unauthorized access.\n- **Data Integrity**: Ensure that data hasn't been tampered with during transmission.\n- **Password Hashing**: Securely store user passwords using strong hashing algorithms.\n- **API Authentication**: Generate secure tokens for API requests.\n\nIn the following sections, we'll dive deeper into how to use the crypto package in your Flutter applications, providing a step-by-step tutorial and a comprehensive example to demonstrate its capabilities.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "lb2p9d6y",
        "_ref": "t8DYBEKn49O4mjbyRAfCdI"
      }
    ],
    "_createdAt": "2024-08-28T22:17:18Z",
    "name": "crypto",
    "pubPoint": 160,
    "tags": [
      "crypto",
      "cryptography",
      "encryption",
      "hashing",
      "security"
    ],
    "packageImage": null,
    "lastUpdate": "2024-08-14T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1f2V",
    "tutorial": "# Flutter Crypto Package Tutorial\n\nThis tutorial will guide you through setting up and using the crypto package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Add the Crypto Package to Your Project\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  crypto: ^3.0.3\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the crypto package:\n\n```dart\nimport 'package:crypto/crypto.dart';\n```\n\n## Step 3: Basic Usage\n\n### Hashing\n\nTo create a hash of a string:\n\n```dart\nimport 'dart:convert';\nimport 'package:crypto/crypto.dart';\n\nvoid main() {\n  var bytes = utf8.encode(\"Hello, World!\"); // Convert string to bytes\n  var digest = sha256.convert(bytes);       // Create SHA-256 hash\n  \n  print(\"SHA-256 Digest: $digest\");\n}\n```\n\n### HMAC\n\nTo create an HMAC:\n\n```dart\nimport 'dart:convert';\nimport 'package:crypto/crypto.dart';\n\nvoid main() {\n  var key = utf8.encode('my secret key');\n  var bytes = utf8.encode(\"Message to authenticate\");\n  \n  var hmacSha256 = Hmac(sha256, key);\n  var digest = hmacSha256.convert(bytes);\n  \n  print(\"HMAC: $digest\");\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, the crypto package uses the native Java security providers. No additional setup is required.\n\n### iOS\n\nFor iOS, the package uses the CommonCrypto library, which is part of the iOS SDK. No additional configuration is needed.\n\n### Web\n\nWhen targeting web platforms, the crypto package uses the Web Cryptography API. Ensure that your target browsers support this API.\n\n## Best Practices\n\n1. **Use Strong Algorithms**: Prefer SHA-256 or SHA-3 over MD5 or SHA-1 for hashing.\n2. **Secure Key Storage**: Store encryption keys securely using platform-specific secure storage solutions.\n3. **Salt Passwords**: When hashing passwords, always use a unique salt for each password.\n4. **Update Regularly**: Keep the crypto package updated to benefit from the latest security improvements.\n\nBy following these steps and best practices, you can effectively use the crypto package to enhance the security of your Flutter applications across different platforms.",
    "_updatedAt": "2024-09-06T04:10:45Z",
    "_rev": "ezMiwuUkJkbYMWycA6RW0r",
    "shortDescription": "Implementations of SHA, MD5, and HMAC cryptographic functions.",
    "similarPackages": [],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaMLA",
        "_type": "reference",
        "_key": "6susrh4j"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CYnX",
        "_type": "reference",
        "_key": "nyllr044"
      }
    ],
    "author": "dart.dev",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:crypto/crypto.dart';\nimport 'dart:convert';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Crypto Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const CryptoDemo(),\n    );\n  }\n}\n\nclass CryptoDemo extends StatefulWidget {\n  const CryptoDemo({Key? key}) : super(key: key);\n\n  @override\n  _CryptoDemoState createState() => _CryptoDemoState();\n}\n\nclass _CryptoDemoState extends State<CryptoDemo> {\n  final TextEditingController _inputController = TextEditingController();\n  String _hashResult = '';\n  String _hmacResult = '';\n\n  // Step 1: Perform SHA-256 hashing\n  void _performHashing() {\n    final input = _inputController.text;\n    final bytes = utf8.encode(input);\n    final digest = sha256.convert(bytes);\n    setState(() {\n      _hashResult = digest.toString();\n    });\n  }\n\n  // Step 2: Perform HMAC-SHA256\n  void _performHMAC() {\n    final input = _inputController.text;\n    final key = utf8.encode('my secret key');\n    final bytes = utf8.encode(input);\n    final hmacSha256 = Hmac(sha256, key);\n    final digest = hmacSha256.convert(bytes);\n    setState(() {\n      _hmacResult = digest.toString();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Crypto Demo'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 3: Create input field\n            TextField(\n              controller: _inputController,\n              decoration: const InputDecoration(\n                labelText: 'Enter text to hash/HMAC',\n              ),\n            ),\n            const SizedBox(height: 20),\n            // Step 4: Add buttons for hashing and HMAC\n            ElevatedButton(\n              onPressed: _performHashing,\n              child: const Text('Perform SHA-256 Hashing'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _performHMAC,\n              child: const Text('Perform HMAC-SHA256'),\n            ),\n            const SizedBox(height: 20),\n            // Step 5: Display results\n            Text('SHA-256 Hash: $_hashResult'),\n            const SizedBox(height: 10),\n            Text('HMAC-SHA256: $_hmacResult'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a text input field and two buttons.\n// 2. User enters text into the input field.\n// 3. When the user presses the \"Perform SHA-256 Hashing\" button:\n//    - The input text is converted to bytes.\n//    - SHA-256 hashing is performed on these bytes.\n//    - The resulting hash is displayed on the screen.\n// 4. When the user presses the \"Perform HMAC-SHA256\" button:\n//    - The input text is converted to bytes.\n//    - A secret key is defined (in this case, it's hardcoded for simplicity).\n//    - HMAC-SHA256 is performed using the input and the secret key.\n//    - The resulting HMAC is displayed on the screen.\n// 5. The results are updated in real-time as the user interacts with the app.\n\n// Note: In a real-world application, you would want to handle errors,\n// validate input, and potentially use more secure methods for key management.\n// This example is simplified for demonstration purposes.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1616,
    "tutorialIncluded": true,
    "slug": {
      "current": "crypto",
      "_type": "slug"
    },
    "_type": "package"
  },
  {
    "description": "# Email Validator Package for Flutter: Ensuring Valid Email Inputs\n\n## Introduction\n\nIn the world of mobile app development, validating user inputs is crucial for maintaining data integrity and providing a smooth user experience. When it comes to email addresses, proper validation becomes even more critical. This is where the `email_validator` package for Flutter comes into play.\n\n## What is email_validator?\n\nThe `email_validator` package is a powerful and efficient tool for validating email addresses in Flutter applications. It provides a simple yet robust way to check if an email address is properly formatted and potentially valid.\n\n## Key Features\n\n1. **String-based Validation**: The package offers a straightforward `validate()` function that takes a string input and returns a boolean value indicating whether the email is valid or not.\n\n2. **Detailed Error Messages**: For more comprehensive feedback, the package provides an `EmailValidator.validate()` method that returns detailed error messages when an email is invalid.\n\n3. **Customizable Options**: Developers can fine-tune the validation process by specifying options such as allowing IP-based domain parts or requiring a top-level domain.\n\n4. **Cross-platform Compatibility**: The package works seamlessly across all platforms supported by Flutter, including iOS, Android, web, and desktop.\n\n## Why Use email_validator?\n\n1. **Improved User Experience**: By validating email addresses in real-time, you can provide immediate feedback to users, reducing errors and frustration.\n\n2. **Data Integrity**: Ensure that your app only collects valid email addresses, maintaining the quality of your user database.\n\n3. **Reduced Server Load**: By performing client-side validation, you can reduce unnecessary server requests and improve overall app performance.\n\n4. **Easy Integration**: With its simple API, the email_validator package can be quickly integrated into any Flutter project, saving development time and effort.\n\nIn the following sections, we'll dive deeper into how to implement and use the email_validator package in your Flutter applications, complete with a step-by-step tutorial and a comprehensive example.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXRx",
        "_type": "reference",
        "_key": "mts7erct"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:email_validator/email_validator.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Email Validator Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: EmailValidatorDemo(),\n    );\n  }\n}\n\nclass EmailValidatorDemo extends StatefulWidget {\n  @override\n  _EmailValidatorDemoState createState() => _EmailValidatorDemoState();\n}\n\nclass _EmailValidatorDemoState extends State<EmailValidatorDemo> {\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  String _validationMessage = '';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Email Validator Demo'),\n      ),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Form(\n          key: _formKey,\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              // Step 1: Create a TextFormField for email input\n              TextFormField(\n                controller: _emailController,\n                decoration: InputDecoration(\n                  labelText: 'Email',\n                  hintText: 'Enter your email',\n                ),\n                validator: (value) {\n                  // Step 2: Use EmailValidator to validate the input\n                  if (value == null || value.isEmpty) {\n                    return 'Please enter an email address';\n                  }\n                  if (!EmailValidator.validate(value)) {\n                    return 'Please enter a valid email address';\n                  }\n                  return null;\n                },\n              ),\n              SizedBox(height: 20),\n              // Step 3: Create a button to trigger validation\n              ElevatedButton(\n                onPressed: _validateEmail,\n                child: Text('Validate Email'),\n              ),\n              SizedBox(height: 20),\n              // Step 4: Display validation message\n              Text(\n                _validationMessage,\n                style: TextStyle(\n                  color: _validationMessage.startsWith('Valid') ? Colors.green : Colors.red,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Step 5: Implement the validation logic\n  void _validateEmail() {\n    if (_formKey.currentState!.validate()) {\n      setState(() {\n        _validationMessage = 'Valid email: ${_emailController.text}';\n      });\n    } else {\n      setState(() {\n        _validationMessage = 'Invalid email. Please check your input.';\n      });\n    }\n\n    // Step 6: Demonstrate advanced usage with options and error handling\n    try {\n      bool isValid = EmailValidator.validate(\n        _emailController.text,\n        true, // Allow top level domains\n        true  // Allow IP domain\n      );\n      print('Advanced validation result: $isValid');\n    } on EmailValidationException catch (e) {\n      print('Advanced validation error: ${e.message}');\n    }\n  }\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a form with an email input field and a \"Validate Email\" button.\n// 2. User enters an email address in the input field.\n// 3. When the user taps the \"Validate Email\" button, the _validateEmail() method is called.\n// 4. The form's validate() method is triggered, which calls the validator function of the TextFormField.\n// 5. The validator uses EmailValidator.validate() to check if the email is valid.\n// 6. If the email is valid, a success message is displayed. Otherwise, an error message is shown.\n// 7. Additionally, an advanced validation is performed using EmailValidator with custom options.\n// 8. The results of both validations are displayed or logged for demonstration purposes.\n\n// This example demonstrates:\n// - Basic email validation using EmailValidator.validate()\n// - Form validation integration with Flutter's Form and TextFormField\n// - Displaying validation results to the user\n// - Advanced usage of EmailValidator with custom options and error handling\n```",
    "packageImage": null,
    "slug": {
      "current": "email_validator",
      "_type": "slug"
    },
    "pubPoint": 160,
    "similarPackages": [],
    "tags": [
      "validation",
      "email",
      "form",
      "input"
    ],
    "lastUpdate": "2024-06-20T18:30:00.000Z",
    "tutorial": "# Email Validator Package Tutorial\n\nThis tutorial will guide you through the process of integrating and using the email_validator package in your Flutter application.\n\n## Step 1: Add the package to your pubspec.yaml\n\nOpen your `pubspec.yaml` file and add the following dependency:\n\n```yaml\ndependencies:\n  email_validator: ^2.1.17\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:email_validator/email_validator.dart';\n```\n\n## Step 3: Basic Usage\n\nTo validate an email address, use the `EmailValidator.validate()` method:\n\n```dart\nString email = 'example@email.com';\nbool isValid = EmailValidator.validate(email);\n\nif (isValid) {\n  print('Valid email');\n} else {\n  print('Invalid email');\n}\n```\n\n## Step 4: Advanced Usage with Options\n\nYou can customize the validation process using options:\n\n```dart\nbool isValid = EmailValidator.validate(\n  'example@email.com',\n  true, // Allow top level domains\n  true  // Allow IP domain\n);\n```\n\n## Step 5: Getting Detailed Error Messages\n\nFor more detailed feedback, use the `EmailValidator.validate()` method with error handling:\n\n```dart\ntry {\n  bool isValid = EmailValidator.validate('example@email', true, true);\n  print('Email is valid');\n} on EmailValidationException catch (e) {\n  print('Email is invalid. Reason: ${e.message}');\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have the latest version of Xcode installed.\n- The package works out of the box with no additional configuration needed.\n\n### Android\n- No special configuration is required for Android.\n- Ensure your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher.\n\n### Web\n- The package is compatible with Flutter web applications.\n- No additional configuration is needed.\n\n### Desktop (Windows, macOS, Linux)\n- The package supports Flutter desktop applications.\n- Ensure you have the latest Flutter SDK that supports desktop development.\n\nBy following these steps, you can easily integrate and use the email_validator package in your Flutter application across all supported platforms.",
    "_updatedAt": "2024-09-06T04:10:46Z",
    "author": "",
    "_type": "package",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaDn",
        "_type": "reference",
        "_key": "y6cdx036"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPb2kO",
        "_type": "reference",
        "_key": "p6vxnkid"
      }
    ],
    "_rev": "ezMiwuUkJkbYMWycA6RW83",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1084,
    "_createdAt": "2024-08-28T22:17:20Z",
    "name": "email_validator",
    "_id": "Rx1Nho763d29lawKra1fD9",
    "tutorialIncluded": true,
    "shortDescription": "A simple (but correct) dart class for validating email addresses"
  },
  {
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfHVI",
        "_type": "reference",
        "_key": "kqakepoc"
      }
    ],
    "tags": [
      "widget",
      "html",
      "css",
      "fwfh",
      "rendering"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbBNs",
        "_type": "reference",
        "_key": "blw48m0d"
      }
    ],
    "tutorial": "# Tutorial: Implementing Flutter Widget from HTML\n\nIn this tutorial, we'll walk through the process of implementing the `flutter_widget_from_html` package in your Flutter project. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_widget_from_html: ^0.10.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:flutter_widget_from_html/flutter_widget_from_html.dart';\n```\n\nTo render HTML content, use the `HtmlWidget` class:\n\n```dart\nHtmlWidget(\n  '<p>Hello, <b>World!</b></p>',\n)\n```\n\n## Step 3: Customization\n\nYou can customize the rendering by passing various parameters to the `HtmlWidget`:\n\n```dart\nHtmlWidget(\n  htmlContent,\n  customStylesBuilder: (element) {\n    if (element.classes.contains('custom-class')) {\n      return {'color': 'red'};\n    }\n    return null;\n  },\n  onTapUrl: (url) async {\n    // Handle URL taps\n    return true;\n  },\n)\n```\n\n## Step 4: Handling Images\n\nThe package automatically handles images in HTML content. For more control:\n\n```dart\nHtmlWidget(\n  htmlContent,\n  customImageRenders: {\n    networkSourceMatcher(domains: ['example.com']): (context, attributes, element) {\n      return Image.network(attributes['src']!);\n    },\n  },\n)\n```\n\n## Step 5: Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure you have the following in your `Info.plist` file to allow loading of web content:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n### Android\n\nFor Android, add internet permission in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### Web\n\nFor web platform, no additional configuration is required.\n\n## Step 6: Advanced Features\n\n### Handling Tables\n\nThe package supports HTML tables out of the box:\n\n```dart\nHtmlWidget(\n  '<table><tr><td>Cell 1</td><td>Cell 2</td></tr></table>',\n)\n```\n\n### Custom Widget Factories\n\nYou can create custom widgets for specific HTML elements:\n\n```dart\nHtmlWidget(\n  htmlContent,\n  customWidgetBuilder: (element) {\n    if (element.localName == 'custom-tag') {\n      return Text('Custom Widget');\n    }\n    return null;\n  },\n)\n```\n\nBy following these steps, you'll be able to effectively implement and utilize the `flutter_widget_from_html` package in your Flutter projects.",
    "_type": "package",
    "_rev": "AE3hjGWNkNE6aGQMMbaOvX",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_widget_from_html/flutter_widget_from_html.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Widget from HTML Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Widget from HTML Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              // Step 1: Basic HTML Rendering\n              const Text('Basic HTML Rendering:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '<p>This is a <b>bold</b> text and <i>italic</i> text.</p>',\n              ),\n              const SizedBox(height: 20),\n\n              // Step 2: Rendering Images\n              const Text('Rendering Images:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '<img src=\"https://via.placeholder.com/150\" alt=\"Placeholder Image\">',\n              ),\n              const SizedBox(height: 20),\n\n              // Step 3: Handling Links\n              const Text('Handling Links:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '<a href=\"https://flutter.dev\">Visit Flutter Website</a>',\n                onTapUrl: (url) async {\n                  print('Tapped URL: $url');\n                  return true;\n                },\n              ),\n              const SizedBox(height: 20),\n\n              // Step 4: Customizing Styles\n              const Text('Customizing Styles:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '<p class=\"custom-class\">This text has custom styling.</p>',\n                customStylesBuilder: (element) {\n                  if (element.classes.contains('custom-class')) {\n                    return {'color': 'red', 'font-size': '18px'};\n                  }\n                  return null;\n                },\n              ),\n              const SizedBox(height: 20),\n\n              // Step 5: Rendering Tables\n              const Text('Rendering Tables:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '''\n                <table border=\"1\">\n                  <tr><th>Header 1</th><th>Header 2</th></tr>\n                  <tr><td>Row 1, Cell 1</td><td>Row 1, Cell 2</td></tr>\n                  <tr><td>Row 2, Cell 1</td><td>Row 2, Cell 2</td></tr>\n                </table>\n                ''',\n              ),\n              const SizedBox(height: 20),\n\n              // Step 6: Custom Widget Builder\n              const Text('Custom Widget Builder:', style: TextStyle(fontWeight: FontWeight.bold)),\n              HtmlWidget(\n                '<custom-tag>This is a custom tag</custom-tag>',\n                customWidgetBuilder: (element) {\n                  if (element.localName == 'custom-tag') {\n                    return Container(\n                      padding: const EdgeInsets.all(8.0),\n                      color: Colors.yellow,\n                      child: Text(element.text),\n                    );\n                  }\n                  return null;\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The HomePage is displayed as the home screen.\n// 3. In the HomePage, we demonstrate various features of the flutter_widget_from_html package:\n//    - Basic HTML rendering\n//    - Rendering images\n//    - Handling links with custom tap behavior\n//    - Customizing styles for specific HTML classes\n//    - Rendering HTML tables\n//    - Using a custom widget builder for custom HTML tags\n// 4. Each feature is separated by a title and some spacing for clarity.\n// 5. The SingleChildScrollView allows the user to scroll through all examples if they don't fit on one screen.\n// 6. This example showcases the versatility of the package in handling different HTML elements and customization options.\n```",
    "_id": "Rx1Nho763d29lawKra1fNn",
    "author": "daohoangson.com",
    "shortDescription": "Flutter package to render html as widgets that supports hyperlink, image, audio, video, iframe and many other tags.",
    "likesCount": 896,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-a42aacfdb8a3ea2dd0f59033bc4980def2f2dff8-524x1080-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:17:26Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:47Z",
    "slug": {
      "current": "flutter_widget_from_html",
      "_type": "slug"
    },
    "pubPoint": 160,
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "ajqohj9c",
        "_ref": "V06bsD4sX3T8NTHrBPb5QO"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1VCB",
        "_type": "reference",
        "_key": "voeltztg"
      }
    ],
    "platforms": [
      "web"
    ],
    "lastUpdate": "2024-08-21T18:30:00.000Z",
    "name": "flutter_widget_from_html",
    "description": "# Flutter Widget from HTML: Rendering HTML Content in Flutter\n\nFlutter Widget from HTML (`flutter_widget_from_html`) is a powerful package that allows Flutter developers to render HTML content within their applications. This package is particularly useful when you need to display rich text content, such as blog posts, articles, or any other HTML-formatted text in your Flutter app.\n\n## Key Features\n\n1. **HTML Rendering**: Converts HTML strings into Flutter widgets, maintaining the structure and styling of the original HTML.\n\n2. **Customization**: Offers various customization options to control the rendering process and appearance of the rendered content.\n\n3. **Media Support**: Handles images, videos, and other media elements within the HTML content.\n\n4. **Table Support**: Renders HTML tables with proper formatting and layout.\n\n5. **CSS Support**: Supports inline CSS styles and some external CSS properties.\n\n6. **Interactive Elements**: Handles interactive elements like links and buttons within the HTML content.\n\n7. **Platform Compatibility**: Works across multiple platforms, including iOS, Android, and web.\n\n## Why Use Flutter Widget from HTML?\n\n1. **Simplified Content Display**: Easily display complex HTML content without manually creating equivalent Flutter widgets.\n\n2. **Consistency**: Maintain consistency between web content and mobile app representation.\n\n3. **Time-saving**: Reduces development time for apps that need to display HTML content from various sources.\n\n4. **Flexibility**: Allows for dynamic content updates without changing the app's codebase.\n\nIn the following sections, we'll explore how to implement this package in your Flutter projects and showcase its various features through a comprehensive example."
  },
  {
    "tutorial": "# Image Gallery Saver Package for Flutter: A Comprehensive Guide\n\n## 2. Tutorial\n\nIn this section, we'll walk through the process of integrating and using the `image_gallery_saver` package in your Flutter project.\n\n### Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  image_gallery_saver: ^2.0.3\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:image_gallery_saver/image_gallery_saver.dart';\n```\n\n### Step 3: Request Permissions\n\nBefore using the package, ensure you have the necessary permissions.\n\n#### For Android:\n\nAdd the following permissions to your `android/app/src/main/AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n#### For iOS:\n\nAdd the following keys to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryAddUsageDescription</key>\n<string>This app requires access to the photo library to save images and videos.</string>\n```\n\n### Step 4: Implement Image Saving Functionality\n\nHere's a basic example of how to save an image from a URL:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:image_gallery_saver/image_gallery_saver.dart';\nimport 'package:dio/dio.dart';\n\nclass RealFlutter extends StatelessWidget {\n  Future<void> _saveNetworkImage() async {\n    String url = \"https://example.com/image.jpg\";\n    final response = await Dio().get(url, options: Options(responseType: ResponseType.bytes));\n    final result = await ImageGallerySaver.saveImage(\n        Uint8List.fromList(response.data),\n        quality: 60,\n        name: \"example_image\");\n    print(result);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: _saveNetworkImage,\n      child: Text('Save Image'),\n    );\n  }\n}\n```\n\n### Step 5: Handle the Result\n\nThe `saveImage` method returns a `Future<Map<String, dynamic>>`. The map contains information about the save operation, including whether it was successful and the file path.\n\n```dart\nif (result['isSuccess']) {\n  print('Image saved successfully');\n  print('File path: ${result['filePath']}');\n} else {\n  print('Failed to save image');\n}\n```\n\nThis tutorial covers the basics of using the `image_gallery_saver` package. In the next section, we'll provide a more comprehensive example demonstrating various features of the package.",
    "pubPoint": 160,
    "author": "",
    "description": "# Image Gallery Saver Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `image_gallery_saver` package is a powerful tool for Flutter developers who need to save images or videos to the device's gallery. This package provides a simple and efficient way to interact with the device's media storage, allowing you to save various types of media files with ease.\n\n### Key Features:\n\n1. **Image Saving**: Save images from different sources, including network URLs, local file paths, and byte data.\n2. **Video Saving**: Save video files to the gallery.\n3. **Quality Control**: Adjust the quality of saved images to balance between file size and image quality.\n4. **Custom Album**: Save media to a specific album in the gallery.\n5. **Cross-Platform Support**: Works on both Android and iOS platforms.\n\n### Why Use Image Gallery Saver?\n\n- **Simplicity**: The package offers a straightforward API, making it easy to integrate into your Flutter projects.\n- **Versatility**: It supports various image formats and sources, giving you flexibility in your app's functionality.\n- **Performance**: Designed to be efficient, ensuring smooth performance even when dealing with large files.\n- **Permission Handling**: The package helps manage necessary permissions for accessing the device's gallery.\n\nIn the following sections, we'll dive deeper into how to use the `image_gallery_saver` package in your Flutter applications, providing a step-by-step tutorial and a comprehensive example to showcase its features.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "j1f3ftel",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGKG"
      }
    ],
    "platforms": [
      "android",
      "ios"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "qnrqvk4a"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7E4",
        "_type": "reference",
        "_key": "7j6q1aiz"
      }
    ],
    "lastUpdate": "2023-07-02T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:48Z",
    "slug": {
      "_type": "slug",
      "current": "image_gallery_saver"
    },
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "akquxwpk"
      }
    ],
    "likesCount": 773,
    "_id": "Rx1Nho763d29lawKra1ffX",
    "_type": "package",
    "tags": [
      "image",
      "gallery",
      "save",
      "storage",
      "media"
    ],
    "packageImage": null,
    "_rev": "AE3hjGWNkNE6aGQMMbaOyj",
    "shortDescription": "A flutter plugin for save image to gallery, iOS need to add the following keys to your Info.plist file.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:image_gallery_saver/image_gallery_saver.dart';\nimport 'package:dio/dio.dart';\nimport 'dart:typed_data';\nimport 'package:permission_handler/permission_handler.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Image Gallery Saver Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize variables\n  final String imageUrl = \"https://picsum.photos/200/300\";\n  final String gifUrl = \"https://media.giphy.com/media/3o7527pa7qs9kCG78A/giphy.gif\";\n  final String videoUrl = \"https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4\";\n\n  // Step 2: Request permissions\n  Future<bool> _requestPermission(Permission permission) async {\n    if (await permission.isGranted) {\n      return true;\n    } else {\n      var result = await permission.request();\n      if (result == PermissionStatus.granted) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Step 3: Save image from URL\n  Future<void> _saveNetworkImage() async {\n    if (await _requestPermission(Permission.storage)) {\n      var response = await Dio().get(imageUrl, options: Options(responseType: ResponseType.bytes));\n      final result = await ImageGallerySaver.saveImage(\n        Uint8List.fromList(response.data),\n        quality: 60,\n        name: \"sample_image\",\n      );\n      _showResult(result);\n    }\n  }\n\n  // Step 4: Save GIF from URL\n  Future<void> _saveNetworkGif() async {\n    if (await _requestPermission(Permission.storage)) {\n      var response = await Dio().get(gifUrl, options: Options(responseType: ResponseType.bytes));\n      final result = await ImageGallerySaver.saveImage(\n        Uint8List.fromList(response.data),\n        quality: 60,\n        name: \"sample_gif\",\n        isReturnImagePathOfIOS: true,\n      );\n      _showResult(result);\n    }\n  }\n\n  // Step 5: Save video from URL\n  Future<void> _saveNetworkVideo() async {\n    if (await _requestPermission(Permission.storage)) {\n      var response = await Dio().get(videoUrl, options: Options(responseType: ResponseType.bytes));\n      final result = await ImageGallerySaver.saveFile(\n        Uint8List.fromList(response.data),\n        name: \"sample_video\",\n        isReturnPathOfIOS: true,\n      );\n      _showResult(result);\n    }\n  }\n\n  // Step 6: Show result in a snackbar\n  void _showResult(Map<String, dynamic> result) {\n    if (result['isSuccess']) {\n      ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n        content: Text(\"File saved successfully!\"),\n        backgroundColor: Colors.green,\n      ));\n    } else {\n      ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n        content: Text(\"Failed to save file.\"),\n        backgroundColor: Colors.red,\n      ));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Image Gallery Saver Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: _saveNetworkImage,\n              child: Text('Save Image from URL'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _saveNetworkGif,\n              child: Text('Save GIF from URL'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _saveNetworkVideo,\n              child: Text('Save Video from URL'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Flow of the application:\n// 1. The app starts and displays three buttons for saving different types of media.\n// 2. When a button is pressed, it triggers the corresponding save function.\n// 3. Each save function first requests storage permission.\n// 4. If permission is granted, it downloads the file using Dio.\n// 5. The downloaded file is then saved to the gallery using ImageGallerySaver.\n// 6. The result of the save operation is displayed to the user via a snackbar.\n\n// This example demonstrates:\n// - Saving images, GIFs, and videos from URLs\n// - Handling permissions\n// - Using Dio for network requests\n// - Displaying feedback to the user\n// - Basic error handling\n\n// Note: Make sure to add the necessary dependencies (image_gallery_saver, dio, permission_handler) to your pubspec.yaml file.\n```",
    "_createdAt": "2024-08-28T22:17:39Z",
    "name": "image_gallery_saver"
  },
  {
    "packageImage": null,
    "pubPoint": 160,
    "likesCount": 951,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "text",
      "widget",
      "ui",
      "expandable"
    ],
    "_id": "Rx1Nho763d29lawKra1g0p",
    "tutorial": "# Tutorial: Implementing ReadMore in Flutter\n\nThis tutorial will guide you through the process of implementing the ReadMore package in your Flutter application.\n\n## Step 1: Add the Package\n\nFirst, add the ReadMore package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  readmore: ^2.2.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:readmore/readmore.dart';\n```\n\n## Step 3: Basic Implementation\n\nHere's a basic implementation of the ReadMore widget:\n\n```dart\nReadMoreText(\n  'Your long text goes here...',\n  trimLines: 2,\n  colorClickableText: Colors.pink,\n  trimMode: TrimMode.Line,\n  trimCollapsedText: 'Show more',\n  trimExpandedText: 'Show less',\n  moreStyle: TextStyle(fontSize: 14, fontWeight: FontWeight.bold),\n)\n```\n\n## Step 4: Customization\n\nThe ReadMore widget offers various customization options:\n\n- `trimLines`: Set the number of lines to display before trimming.\n- `trimMode`: Choose between `TrimMode.Line` and `TrimMode.Length`.\n- `trimCollapsedText` and `trimExpandedText`: Customize the toggle text.\n- `moreStyle` and `lessStyle`: Style the \"more\" and \"less\" text differently.\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, you might want to adjust the font to match the system font:\n\n```dart\nReadMoreText(\n  'Your text...',\n  style: TextStyle(fontFamily: '.SF Pro Text'),\n  // other properties...\n)\n```\n\n### Android\nFor Android, consider using the Roboto font for consistency:\n\n```dart\nReadMoreText(\n  'Your text...',\n  style: TextStyle(fontFamily: 'Roboto'),\n  // other properties...\n)\n```\n\n### Web\nFor web applications, ensure that the ReadMore widget is wrapped in a container with a defined width to prevent layout issues:\n\n```dart\nContainer(\n  width: 300, // or any appropriate width\n  child: ReadMoreText(\n    'Your text...',\n    // other properties...\n  ),\n)\n```\n\nBy following these steps and considerations, you can effectively implement and customize the ReadMore widget in your Flutter application across different platforms.",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:readmore/readmore.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'ReadMore Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ReadMoreDemo(),\n    );\n  }\n}\n\nclass ReadMoreDemo extends StatelessWidget {\n  // Step 1: Define a long text to demonstrate the ReadMore widget\n  final String longText = 'This is a very long text that demonstrates the '\n      'functionality of the ReadMore package. It will be trimmed based on '\n      'the settings we provide. You can customize various aspects like '\n      'the number of lines to show, the \"read more\" text, and more. '\n      'This package is very useful for handling long content in a '\n      'user-friendly way.';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('ReadMore Demo')),\n      body: SingleChildScrollView(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 2: Basic ReadMore implementation\n            Text('Basic ReadMore:'),\n            ReadMoreText(\n              longText,\n              trimLines: 2,\n              colorClickableText: Colors.pink,\n              trimMode: TrimMode.Line,\n              trimCollapsedText: 'Show more',\n              trimExpandedText: 'Show less',\n              moreStyle: TextStyle(fontSize: 14, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 20),\n\n            // Step 3: ReadMore with custom styling\n            Text('Custom Styled ReadMore:'),\n            ReadMoreText(\n              longText,\n              trimLines: 3,\n              colorClickableText: Colors.blue,\n              trimMode: TrimMode.Line,\n              trimCollapsedText: '...Read more',\n              trimExpandedText: ' Less',\n              style: TextStyle(fontSize: 16, color: Colors.black87),\n              moreStyle: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.blue),\n              lessStyle: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.blue),\n            ),\n            SizedBox(height: 20),\n\n            // Step 4: ReadMore with character-based trimming\n            Text('Character-based Trimming:'),\n            ReadMoreText(\n              longText,\n              trimLength: 100,\n              colorClickableText: Colors.green,\n              trimMode: TrimMode.Length,\n              trimCollapsedText: '...Expand',\n              trimExpandedText: 'Collapse',\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and sets ReadMoreDemo as the home screen.\n// 3. In ReadMoreDemo, we create a Scaffold with an AppBar and a SingleChildScrollView body.\n// 4. Inside the body, we demonstrate three different implementations of ReadMoreText:\n//    a. A basic implementation with default settings.\n//    b. A custom-styled implementation with different colors and fonts.\n//    c. A character-based trimming implementation.\n// 5. Each ReadMoreText widget trims the longText based on its settings.\n// 6. Users can interact with each ReadMoreText widget independently to expand or collapse the text.\n\n// Note: This example showcases various features of the ReadMore package.\n// You can further customize these widgets based on your specific needs.\n```",
    "name": "readmore",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:49Z",
    "slug": {
      "current": "readmore",
      "_type": "slug"
    },
    "shortDescription": "A Flutter package that allows for dynamic expansion and collapse of text, as well as interactions with text patterns such as hashtags, URLs, and mentions.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP",
        "_type": "reference",
        "_key": "1mm5pd84"
      }
    ],
    "description": "# ReadMore Package in Flutter: Enhancing Text Display\n\nThe ReadMore package is a powerful tool for Flutter developers looking to improve the way they display text in their applications. This package is especially useful when dealing with long text content that needs to be condensed for better user experience.\n\n## Key Features\n\n1. **Customizable Toggle:** The package allows you to set custom \"Read more\" and \"Read less\" text.\n2. **Flexible Trimming:** You can specify the number of lines or characters to display before trimming.\n3. **Style Control:** Easily customize the style of both the trimmed and expanded text.\n4. **Animation:** Smooth animation when expanding or collapsing the text.\n\n## Why Use ReadMore?\n\nIn mobile app development, screen real estate is precious. The ReadMore package helps you manage long text content efficiently, allowing users to choose whether they want to view the full text or just a summary. This is particularly useful for:\n\n- Article previews\n- Product descriptions\n- User reviews\n- Social media posts\n\nBy implementing the ReadMore widget, you can create a cleaner, more user-friendly interface that doesn't overwhelm the user with excessive text.\n\nIn the following sections, we'll dive into how to implement this package in your Flutter projects and explore its various features through a comprehensive example.",
    "similarPackages": [],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "li0674ko",
        "_ref": "Rx1Nho763d29lawKra1fNn"
      }
    ],
    "_createdAt": "2024-08-28T22:17:42Z",
    "lastUpdate": "2024-03-26T18:30:00.000Z",
    "author": "getx.site",
    "_rev": "AE3hjGWNkNE6aGQMMbaP1v"
  },
  {
    "pubPoint": 160,
    "_type": "package",
    "tutorial": "# Window Manager Package Tutorial\n\nThis tutorial will guide you through the process of integrating and using the `window_manager` package in your Flutter desktop application.\n\n## Step 1: Setup\n\nFirst, ensure you have added the `window_manager` package to your `pubspec.yaml` file and run `flutter pub get`.\n\n## Step 2: Initialization\n\nIn your `main.dart` file, import the package and initialize it before running your app:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:window_manager/window_manager.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  // Must add this line.\n  await windowManager.ensureInitialized();\n\n  WindowOptions windowOptions = WindowOptions(\n    size: Size(800, 600),\n    center: true,\n    backgroundColor: Colors.transparent,\n    skipTaskbar: false,\n    titleBarStyle: TitleBarStyle.normal,\n  );\n  windowManager.waitUntilReadyToShow(windowOptions, () async {\n    await windowManager.show();\n    await windowManager.focus();\n  });\n\n  runApp(RealFlutter());\n}\n```\n\n## Step 3: Using Window Manager Features\n\nNow that we've initialized the window manager, let's explore some of its key features:\n\n### Resizing the Window\n\n```dart\nawait windowManager.setSize(Size(1024, 768));\n```\n\n### Moving the Window\n\n```dart\nawait windowManager.setPosition(Offset(100, 100));\n```\n\n### Toggling Full-Screen Mode\n\n```dart\nbool isFullScreen = await windowManager.isFullScreen();\nawait windowManager.setFullScreen(!isFullScreen);\n```\n\n### Minimizing and Maximizing\n\n```dart\nawait windowManager.minimize();\nawait windowManager.maximize();\n```\n\n### Customizing the Title Bar\n\n```dart\nawait windowManager.setTitle('My Awesome App');\nawait windowManager.setTitleBarStyle(TitleBarStyle.hidden);\n```\n\n## Platform-Specific Considerations\n\n### Windows\n\nOn Windows, you may need to add the following to your `windows/runner/main.cpp` file:\n\n```cpp\n#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n#include <bitsdojo_window_windows/bitsdojo_window_plugin.h>\nauto bdw = bitsdojo_window_configure(BDW_CUSTOM_FRAME | BDW_HIDE_ON_STARTUP);\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // ... (existing code)\n  \n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  // Add this line to handle the window's messages\n  ::MSG msg;\n  ::PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE);\n\n  RunLoop();\n\n  return EXIT_SUCCESS;\n}\n```\n\n### macOS\n\nFor macOS, modify your `macos/Runner/MainFlutterWindow.swift`:\n\n```swift\nimport Cocoa\nimport FlutterMacOS\n\nclass MainFlutterWindow: NSWindow {\n  override func awakeFromNib() {\n    let flutterViewController = FlutterViewController.init()\n    let windowFrame = self.frame\n    self.contentViewController = flutterViewController\n    self.setFrame(windowFrame, display: true)\n\n    RegisterGeneratedPlugins(registry: flutterViewController)\n\n    super.awakeFromNib()\n  }\n}\n```\n\n### Linux\n\nFor Linux, you might need to adjust your `my_application.cc` file in the `linux` folder:\n\n```cpp\n#include \"my_application.h\"\n\n#include <flutter_linux/flutter_linux.h>\n#ifdef GDK_WINDOWING_X11\n#include <gdk/gdkx.h>\n#endif\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nstruct _MyApplication {\n  GtkApplication parent_instance;\n  char** dart_entrypoint_arguments;\n};\n\nG_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)\n\n// ... (existing code)\n\nstatic void my_application_activate(GApplication* application) {\n  MyApplication* self = MY_APPLICATION(application);\n  GtkWindow* window =\n      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));\n\n  // Use a header bar when running in GNOME as this is the common style used\n  // by applications and is the setup most users will be using (e.g. Ubuntu\n  // desktop).\n  // If running on X and not using GNOME then just use a traditional title bar\n  // in case the window manager does more exotic layout, e.g. tiling.\n  // If running on Wayland assume the header bar will work (may need changing\n  // if future cases occur).\n  gboolean use_header_bar = TRUE;\n#ifdef GDK_WINDOWING_X11\n  GdkScreen* screen = gtk_window_get_screen(window);\n  if (GDK_IS_X11_SCREEN(screen)) {\n    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);\n    if (g_strcmp0(wm_name, \"GNOME Shell\") != 0) {\n      use_header_bar = FALSE;\n    }\n  }\n#endif\n  if (use_header_bar) {\n    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());\n    gtk_widget_show(GTK_WIDGET(header_bar));\n    gtk_header_bar_set_title(header_bar, \"example\");\n    gtk_header_bar_set_show_close_button(header_bar, TRUE);\n    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));\n  } else {\n    gtk_window_set_title(window, \"example\");\n  }\n\n  gtk_window_set_default_size(window, 1280, 720);\n  gtk_widget_show(GTK_WIDGET(window));\n\n  g_autoptr(FlDartProject) project = fl_dart_project_new();\n  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);\n\n  FlView* view = fl_view_new(project);\n  gtk_widget_show(GTK_WIDGET(view));\n  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));\n\n  fl_register_plugins(FL_PLUGIN_REGISTRY(view));\n\n  gtk_widget_grab_focus(GTK_WIDGET(view));\n}\n\n// ... (rest of the existing code)\n```\n\nBy following these platform-specific adjustments, you ensure that the `window_manager` package works seamlessly across different desktop environments.",
    "slug": {
      "current": "window_manager",
      "_type": "slug"
    },
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:window_manager/window_manager.dart';\n\nvoid main() async {\n  // Step 1: Initialize WidgetsFlutterBinding\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Step 2: Initialize WindowManager\n  await windowManager.ensureInitialized();\n\n  // Step 3: Set initial window options\n  WindowOptions windowOptions = WindowOptions(\n    size: Size(800, 600),\n    center: true,\n    backgroundColor: Colors.transparent,\n    skipTaskbar: false,\n    titleBarStyle: TitleBarStyle.normal,\n  );\n\n  // Step 4: Apply window options and show the window\n  windowManager.waitUntilReadyToShow(windowOptions, () async {\n    await windowManager.show();\n    await windowManager.focus();\n  });\n\n  // Step 5: Run the app\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Window Manager Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: WindowManagerDemo(),\n    );\n  }\n}\n\nclass WindowManagerDemo extends StatefulWidget {\n  @override\n  _WindowManagerDemoState createState() => _WindowManagerDemoState();\n}\n\nclass _WindowManagerDemoState extends State<WindowManagerDemo> with WindowListener {\n  bool _isFullScreen = false;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 6: Add window listener\n    windowManager.addListener(this);\n  }\n\n  @override\n  void dispose() {\n    // Step 7: Remove window listener\n    windowManager.removeListener(this);\n    super.dispose();\n  }\n\n  // Step 8: Implement window listener methods\n  @override\n  void onWindowEvent(String eventName) {\n    print('[WindowManager] onWindowEvent: $eventName');\n  }\n\n  @override\n  void onWindowClose() async {\n    bool _isPreventClose = await windowManager.isPreventClose();\n    if (_isPreventClose) {\n      showDialog(\n        context: context,\n        builder: (_) {\n          return AlertDialog(\n            title: Text('Are you sure you want to close this window?'),\n            actions: [\n              TextButton(\n                child: Text('No'),\n                onPressed: () {\n                  Navigator.of(context).pop();\n                },\n              ),\n              TextButton(\n                child: Text('Yes'),\n                onPressed: () async {\n                  Navigator.of(context).pop();\n                  await windowManager.destroy();\n                },\n              ),\n            ],\n          );\n        },\n      );\n    }\n  }\n\n  // Step 9: Implement window manipulation methods\n  void _toggleFullScreen() async {\n    await windowManager.setFullScreen(!_isFullScreen);\n    setState(() {\n      _isFullScreen = !_isFullScreen;\n    });\n  }\n\n  void _minimizeWindow() async {\n    await windowManager.minimize();\n  }\n\n  void _maximizeWindow() async {\n    await windowManager.maximize();\n  }\n\n  void _restoreWindow() async {\n    await windowManager.restore();\n  }\n\n  void _closeWindow() async {\n    await windowManager.close();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Window Manager Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: _toggleFullScreen,\n              child: Text(_isFullScreen ? 'Exit Full Screen' : 'Enter Full Screen'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _minimizeWindow,\n              child: Text('Minimize Window'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _maximizeWindow,\n              child: Text('Maximize Window'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _restoreWindow,\n              child: Text('Restore Window'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _closeWindow,\n              child: Text('Close Window'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The application starts by initializing the WidgetsFlutterBinding and WindowManager.\n// 2. Initial window options are set, including size, position, and appearance.\n// 3. The main RealFlutter widget is created, which sets up the MaterialApp and theme.\n// 4. The WindowManagerDemo widget is created as the home screen.\n// 5. In the WindowManagerDemo's state, we add a WindowListener to handle window events.\n// 6. The build method creates a UI with buttons to demonstrate various window management features.\n// 7. Each button triggers a specific window management action (e.g., fullscreen, minimize, maximize).\n// 8. The onWindowClose method demonstrates how to handle window closing events, including showing a confirmation dialog.\n// 9. When the user interacts with the buttons, the corresponding window management methods are called.\n// 10. The state is updated as necessary (e.g., tracking fullscreen mode) to reflect the current window state.\n\n// This example showcases the core functionality of the window_manager package,\n// allowing developers to create desktop applications with native-like window controls.\n```",
    "likesCount": 865,
    "packageImage": null,
    "name": "window_manager",
    "_updatedAt": "2024-09-06T04:10:50Z",
    "author": "leanflutter.dev",
    "similarPackages": [
      {
        "_key": "hltycxn7",
        "_ref": "Rx1Nho763d29lawKra1wbr",
        "_type": "reference"
      }
    ],
    "platforms": [
      "linux",
      "macos",
      "windows"
    ],
    "dependentPackages": [
      {
        "_key": "trbu184s",
        "_ref": "Rx1Nho763d29lawKra1mMh",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:18:10Z",
    "lastUpdate": "2024-08-17T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1hDL",
    "_rev": "ezMiwuUkJkbYMWycA6RWpD",
    "description": "# Flutter Window Manager Package: Enhancing Desktop App Experiences\n\n## Introduction\n\nThe `window_manager` package is a powerful tool for Flutter developers looking to create rich, customizable desktop applications. This package provides a set of APIs to control and manipulate window properties on desktop platforms, including Windows, macOS, and Linux.\n\n## Key Features\n\n1. **Window Manipulation**: Resize, move, and position windows programmatically.\n2. **Full-Screen Mode**: Toggle full-screen mode for immersive experiences.\n3. **Window States**: Manage minimize, maximize, and restore states.\n4. **Title Bar Customization**: Hide or show the title bar, and set custom titles.\n5. **Focus Control**: Programmatically focus or blur windows.\n6. **Multi-Window Support**: Create and manage multiple windows in your application.\n\n## Why Use Window Manager?\n\nFor developers transitioning from mobile to desktop app development with Flutter, the `window_manager` package offers essential tools to create native-feeling desktop experiences. It bridges the gap between Flutter's cross-platform capabilities and desktop-specific functionalities, allowing for more control over the application window's behavior and appearance.\n\n## Getting Started\n\nTo begin using the `window_manager` package in your Flutter project, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  window_manager: ^0.3.0\n```\n\nAfter adding the dependency, run `flutter pub get` to fetch the package.\n\nIn the next sections, we'll dive into a detailed tutorial on how to use the `window_manager` package and explore a comprehensive example showcasing its features.",
    "shortDescription": "This plugin allows Flutter desktop apps to resizing and repositioning the window.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGhy",
        "_type": "reference",
        "_key": "jxefn9o1"
      }
    ],
    "tags": [
      "window",
      "window-resize",
      "window-manager",
      "desktop",
      "desktop-window",
      "multi-platform"
    ],
    "tutorialIncluded": true
  },
  {
    "platforms": [
      "android"
    ],
    "_createdAt": "2024-08-28T22:18:16Z",
    "lastUpdate": "2024-06-01T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1hNz",
    "_updatedAt": "2024-09-06T04:10:51Z",
    "pubPoint": 160,
    "author": "jonasbark.de",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPafbI",
        "_type": "reference",
        "_key": "z17ztyz4"
      }
    ],
    "subCategories": [
      {
        "_key": "4mo1r4s6",
        "_ref": "t8DYBEKn49O4mjbyRAfEfw",
        "_type": "reference"
      }
    ],
    "likesCount": 1058,
    "slug": {
      "current": "in_app_update",
      "_type": "slug"
    },
    "description": "# In-App Update Package for Flutter: Keeping Your App Fresh\n\n## Introduction\n\nIn the ever-evolving world of mobile applications, keeping your app up-to-date is crucial for maintaining user satisfaction and ensuring the best performance. The `in_app_update` package for Flutter provides a seamless way to implement in-app updates for Android and iOS platforms. This powerful tool allows developers to prompt users to update their app without leaving the application, resulting in a smoother user experience and higher update adoption rates.\n\n## Key Features\n\n1. **Flexible Update Modes**: The package supports two update modes:\n   - Immediate updates: For critical updates that need to be installed right away.\n   - Flexible updates: For less urgent updates that can be downloaded in the background.\n\n2. **Platform-Specific Implementation**: Utilizes platform-specific APIs to ensure native behavior:\n   - Android: Implements Google Play Core Library for in-app updates.\n   - iOS: Uses App Store API to check for updates and redirect users to the App Store.\n\n3. **Update Checking**: Provides methods to check for available updates programmatically.\n\n4. **Update Status Tracking**: Allows developers to track the status of updates, including download progress and installation status.\n\n5. **Customizable UI**: While the package uses platform-specific UI for updates, it provides hooks for developers to implement custom UI elements if needed.\n\n6. **Error Handling**: Robust error handling mechanisms to manage various scenarios like network issues or insufficient storage.\n\n## Benefits\n\n- **Improved User Experience**: Users can update the app without leaving the application, reducing friction in the update process.\n- **Higher Update Adoption**: By making updates more accessible, you can ensure more users are running the latest version of your app.\n- **Better App Performance**: Keeping users on the latest version helps maintain optimal app performance and security.\n- **Reduced Support Issues**: Fewer users on older versions means fewer version-specific bugs and support requests.\n\nIn the following sections, we'll dive into a tutorial on how to implement the `in_app_update` package in your Flutter application and showcase a complete example demonstrating its features.",
    "shortDescription": "Enables In App Updates on Android using the official Android APIs.",
    "tags": [
      "update",
      "app-update",
      "version",
      "playstore"
    ],
    "packageImage": null,
    "tutorial": "# Tutorial: Implementing In-App Updates in Flutter\n\nThis tutorial will guide you through the process of implementing in-app updates in your Flutter application using the `in_app_update` package.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  in_app_update: ^4.2.2\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:in_app_update/in_app_update.dart';\n```\n\n## Step 3: Check for Updates\n\nTo check for available updates, use the `checkForUpdate` method:\n\n```dart\nAppUpdateInfo? _updateInfo;\n\nFuture<void> checkForUpdate() async {\n  try {\n    _updateInfo = await InAppUpdate.checkForUpdate();\n  } catch (e) {\n    print('Error checking for update: $e');\n  }\n}\n```\n\n## Step 4: Perform Immediate Update\n\nIf an immediate update is available and necessary, use the following code:\n\n```dart\nFuture<void> performImmediateUpdate() async {\n  if (_updateInfo?.updateAvailability == UpdateAvailability.updateAvailable) {\n    try {\n      await InAppUpdate.performImmediateUpdate();\n    } catch (e) {\n      print('Error performing immediate update: $e');\n    }\n  }\n}\n```\n\n## Step 5: Perform Flexible Update\n\nFor less urgent updates, you can use the flexible update option:\n\n```dart\nFuture<void> startFlexibleUpdate() async {\n  if (_updateInfo?.updateAvailability == UpdateAvailability.updateAvailable) {\n    try {\n      await InAppUpdate.startFlexibleUpdate();\n    } catch (e) {\n      print('Error starting flexible update: $e');\n    }\n  }\n}\n```\n\nAfter starting a flexible update, you need to complete it:\n\n```dart\nFuture<void> completeFlexibleUpdate() async {\n  try {\n    await InAppUpdate.completeFlexibleUpdate();\n  } catch (e) {\n    print('Error completing flexible update: $e');\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\n1. Ensure your app is published on the Google Play Store.\n2. The minimum Android version supported is Android 5.0 (API level 21).\n3. Update your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        ...\n        minSdkVersion 21\n        ...\n    }\n}\n\ndependencies {\n    implementation 'com.google.android.play:core:1.10.3'\n}\n```\n\n### iOS\n\n1. Ensure your app is published on the App Store.\n2. The package uses `UIApplication.openURL(_:)` to redirect users to the App Store.\n3. No additional configuration is needed for iOS.\n\nBy following these steps, you'll have successfully implemented in-app updates in your Flutter application. In the next section, we'll look at a complete example that demonstrates all the features of this package.",
    "tutorialIncluded": true,
    "_rev": "ezMiwuUkJkbYMWycA6RWwP",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:in_app_update/in_app_update.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'In-App Update Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const UpdateScreen(),\n    );\n  }\n}\n\nclass UpdateScreen extends StatefulWidget {\n  const UpdateScreen({Key? key}) : super(key: key);\n\n  @override\n  _UpdateScreenState createState() => _UpdateScreenState();\n}\n\nclass _UpdateScreenState extends State<UpdateScreen> {\n  AppUpdateInfo? _updateInfo;\n\n  // Step 1: Initialize the state\n  @override\n  void initState() {\n    super.initState();\n    checkForUpdate();\n  }\n\n  // Step 2: Check for available updates\n  Future<void> checkForUpdate() async {\n    try {\n      final updateInfo = await InAppUpdate.checkForUpdate();\n      setState(() {\n        _updateInfo = updateInfo;\n      });\n    } catch (e) {\n      print('Error checking for update: $e');\n    }\n  }\n\n  // Step 3: Perform an immediate update\n  Future<void> performImmediateUpdate() async {\n    if (_updateInfo?.updateAvailability == UpdateAvailability.updateAvailable) {\n      try {\n        await InAppUpdate.performImmediateUpdate();\n      } catch (e) {\n        print('Error performing immediate update: $e');\n      }\n    }\n  }\n\n  // Step 4: Start a flexible update\n  Future<void> startFlexibleUpdate() async {\n    if (_updateInfo?.updateAvailability == UpdateAvailability.updateAvailable) {\n      try {\n        await InAppUpdate.startFlexibleUpdate();\n      } catch (e) {\n        print('Error starting flexible update: $e');\n      }\n    }\n  }\n\n  // Step 5: Complete a flexible update\n  Future<void> completeFlexibleUpdate() async {\n    try {\n      await InAppUpdate.completeFlexibleUpdate();\n    } catch (e) {\n      print('Error completing flexible update: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('In-App Update Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Update Availability: ${_updateInfo?.updateAvailability ?? \"Unknown\"}'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: checkForUpdate,\n              child: const Text('Check for Update'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: performImmediateUpdate,\n              child: const Text('Perform Immediate Update'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: startFlexibleUpdate,\n              child: const Text('Start Flexible Update'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: completeFlexibleUpdate,\n              child: const Text('Complete Flexible Update'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the UpdateScreen is displayed.\n// 2. In initState(), checkForUpdate() is called to check for available updates.\n// 3. The UI displays the current update availability status.\n// 4. Users can manually check for updates by pressing the \"Check for Update\" button.\n// 5. If an update is available, users can choose to:\n//    a. Perform an immediate update, which will prompt them to update right away.\n//    b. Start a flexible update, which will download the update in the background.\n// 6. If a flexible update is started, users can complete it later by pressing the \"Complete Flexible Update\" button.\n// 7. The app handles errors and edge cases, such as when updates are not available or when there are network issues.\n\n// Note: This example demonstrates the basic functionality of the in_app_update package.\n// In a real-world application, you would want to add more error handling, user notifications,\n// and possibly implement a more sophisticated update strategy based on your app's needs.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1WL9",
        "_type": "reference",
        "_key": "lzpy0ufn"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1vZz",
        "_type": "reference",
        "_key": "rrhx4ari"
      }
    ],
    "name": "in_app_update"
  },
  {
    "packageImage": null,
    "_id": "Rx1Nho763d29lawKra1ju7",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:51Z",
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "url",
      "web",
      "routing",
      "navigation"
    ],
    "dependentPackages": [],
    "slug": {
      "current": "url_strategy",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmM8V",
    "shortDescription": "Flutter package that allows setting the web app URL strategy with a single line of code.",
    "likesCount": 542,
    "name": "url_strategy",
    "similarPackages": [],
    "subCategories": [
      {
        "_key": "b8kzkfkj",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGfb",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:url_strategy/url_strategy.dart';\n\n// Step 1: Entry point of the application\nvoid main() {\n  // Step 2: Set the URL strategy to remove '#' from URLs\n  setPathUrlStrategy();\n  \n  // Step 3: Run the app\n  runApp(RealFlutter());\n}\n\n// Step 4: Define the main app widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter URL Strategy Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      // Step 5: Set up the routes for navigation\n      initialRoute: '/',\n      routes: {\n        '/': (context) => HomePage(),\n        '/about': (context) => AboutPage(),\n        '/contact': (context) => ContactPage(),\n      },\n    );\n  }\n}\n\n// Step 6: Create the HomePage widget\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Welcome to RealFlutter!'),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Go to About'),\n              onPressed: () => Navigator.pushNamed(context, '/about'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              child: Text('Go to Contact'),\n              onPressed: () => Navigator.pushNamed(context, '/contact'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 7: Create the AboutPage widget\nclass AboutPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('About')),\n      body: Center(\n        child: Text('This is the About page. Notice the clean URL!'),\n      ),\n    );\n  }\n}\n\n// Step 8: Create the ContactPage widget\nclass ContactPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Contact')),\n      body: Center(\n        child: Text('This is the Contact page. The URL is hash-free!'),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The main() function sets the URL strategy and runs the app.\n// 2. RealFlutter widget sets up the MaterialApp with routes.\n// 3. The app starts with the HomePage.\n// 4. Users can navigate to About or Contact pages using buttons.\n// 5. Each page has a clean URL without '#' symbols.\n// 6. The back button in the app bar allows navigation back to previous pages.\n\n// Key Points:\n// - setPathUrlStrategy() removes '#' from URLs.\n// - Routes are defined in the MaterialApp for easy navigation.\n// - Each page is a separate widget for better organization.\n// - The URL changes cleanly as users navigate between pages.\n```",
    "lastUpdate": "2024-08-01T18:30:00.000Z",
    "author": "simpleclub.com",
    "description": "# Understanding the url_strategy Package in Flutter\n\nThe `url_strategy` package is a powerful tool for Flutter developers who want to enhance their web applications by removing the hash (#) from URLs. This package is particularly useful for creating cleaner, more SEO-friendly URLs in Flutter web apps.\n\n## What is url_strategy?\n\nThe `url_strategy` package allows you to modify the URL strategy of your Flutter web application. By default, Flutter web apps use a hash-based URL strategy, which includes a '#' in the URL. This package enables you to switch to a path-based URL strategy, resulting in cleaner URLs without the hash.\n\n## Key Features\n\n1. **Remove Hash**: Eliminates the '#' from your Flutter web app URLs.\n2. **SEO Friendly**: Improves search engine optimization by using cleaner URLs.\n3. **Easy Integration**: Simple to implement with just a few lines of code.\n4. **Cross-Platform Compatibility**: Works seamlessly across different web browsers and platforms.\n\n## Why Use url_strategy?\n\n1. **Improved User Experience**: Cleaner URLs are easier for users to read and remember.\n2. **Better SEO**: Search engines prefer URLs without hashes, potentially improving your app's search rankings.\n3. **Professional Look**: Gives your web app a more polished and professional appearance.\n\nIn the following sections, we'll dive into how to implement and use the `url_strategy` package in your Flutter web applications.",
    "_createdAt": "2024-08-28T22:18:28Z",
    "tutorial": "# Tutorial: Implementing url_strategy in Your Flutter Web App\n\nThis tutorial will guide you through the process of implementing the `url_strategy` package in your Flutter web application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Add the Package to Your Project\n\nFirst, add the `url_strategy` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  url_strategy: ^0.2.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Modify Your main.dart File\n\nIn your `main.dart` file, import the package and set the URL strategy:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:url_strategy/url_strategy.dart';\n\nvoid main() {\n  setPathUrlStrategy(); // This removes the '#' from your URLs\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Demo',\n      home: HomePage(),\n    );\n  }\n}\n```\n\n## Step 3: Configure Your Web Server\n\nFor the path URL strategy to work correctly, you need to configure your web server to handle Flutter's routing:\n\n### For Apache:\nCreate a `.htaccess` file in your web root directory with the following content:\n\n```apache\nRewriteEngine on\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule ^(.*)$ /index.html?path=$1 [NC,L,QSA]\n```\n\n### For Nginx:\nAdd the following to your server block:\n\n```nginx\nlocation / {\n    try_files $uri $uri/ /index.html;\n}\n```\n\n## Step 4: Test Your Application\n\nRun your Flutter web app and verify that the URLs no longer contain the '#' symbol.\n\n## Platform-Specific Considerations\n\n- **Web**: The `url_strategy` package primarily affects web applications. It has no effect on mobile or desktop apps.\n- **SEO**: While removing the hash improves SEO, remember to implement proper meta tags and follow other SEO best practices for optimal results.\n- **Browser Support**: Ensure your web app works correctly across different browsers after implementing the path URL strategy.\n\nBy following these steps, you've successfully implemented the `url_strategy` package in your Flutter web application, creating cleaner and more SEO-friendly URLs."
  },
  {
    "_type": "package",
    "_id": "Rx1Nho763d29lawKra1k4l",
    "_rev": "ezMiwuUkJkbYMWycA6RX3b",
    "shortDescription": "Flutter integration for MobX. It provides a set of Observer widgets that automatically rebuild when the tracked observables change.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_mobx/flutter_mobx.dart';\nimport 'package:mobx/mobx.dart';\n\n// Step 1: Create the store\npart 'main.g.dart';\n\nclass RealFlutterStore = _RealFlutterStore with _$RealFlutterStore;\n\nabstract class _RealFlutterStore with Store {\n  @observable\n  int counter = 0;\n\n  @observable\n  String name = '';\n\n  @observable\n  ObservableList<String> todos = ObservableList<String>();\n\n  @computed\n  int get todoCount => todos.length;\n\n  @action\n  void increment() {\n    counter++;\n  }\n\n  @action\n  void setName(String value) {\n    name = value;\n  }\n\n  @action\n  void addTodo(String todo) {\n    todos.add(todo);\n  }\n\n  @action\n  void removeTodo(String todo) {\n    todos.remove(todo);\n  }\n}\n\n// Step 2: Create the main widget\nclass RealFlutter extends StatelessWidget {\n  final store = RealFlutterStore();\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('RealFlutter MobX Demo')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // Step 3: Use Observer widget for reactive UI updates\n              Observer(\n                builder: (_) => Text(\n                  'Counter: ${store.counter}',\n                  style: TextStyle(fontSize: 24),\n                ),\n              ),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: store.increment,\n                child: Text('Increment'),\n              ),\n              SizedBox(height: 20),\n              // Step 4: Demonstrate computed values\n              Observer(\n                builder: (_) => Text(\n                  'Todo Count: ${store.todoCount}',\n                  style: TextStyle(fontSize: 18),\n                ),\n              ),\n              SizedBox(height: 20),\n              // Step 5: Demonstrate actions with user input\n              TextField(\n                onChanged: store.setName,\n                decoration: InputDecoration(labelText: 'Enter your name'),\n              ),\n              SizedBox(height: 10),\n              Observer(\n                builder: (_) => Text(\n                  'Hello, ${store.name}!',\n                  style: TextStyle(fontSize: 18),\n                ),\n              ),\n              SizedBox(height: 20),\n              // Step 6: Demonstrate ObservableList\n              Expanded(\n                child: Observer(\n                  builder: (_) => ListView.builder(\n                    itemCount: store.todos.length,\n                    itemBuilder: (context, index) {\n                      final todo = store.todos[index];\n                      return ListTile(\n                        title: Text(todo),\n                        trailing: IconButton(\n                          icon: Icon(Icons.delete),\n                          onPressed: () => store.removeTodo(todo),\n                        ),\n                      );\n                    },\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // Step 7: Add a new todo\n            showDialog(\n              context: context,\n              builder: (context) {\n                String newTodo = '';\n                return AlertDialog(\n                  title: Text('Add Todo'),\n                  content: TextField(\n                    onChanged: (value) => newTodo = value,\n                    decoration: InputDecoration(labelText: 'Todo'),\n                  ),\n                  actions: [\n                    TextButton(\n                      onPressed: () {\n                        if (newTodo.isNotEmpty) {\n                          store.addTodo(newTodo);\n                          Navigator.of(context).pop();\n                        }\n                      },\n                      child: Text('Add'),\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\n// Application Flow:\n// 1. The RealFlutterStore is created with observables (counter, name, todos) and actions (increment, setName, addTodo, removeTodo).\n// 2. The RealFlutter widget builds the UI using the store.\n// 3. Observer widgets are used to automatically update the UI when observables change.\n// 4. The counter can be incremented using the ElevatedButton, which calls the increment action.\n// 5. The name can be set using the TextField, which calls the setName action on each change.\n// 6. Todos can be added using the FloatingActionButton, which shows a dialog and calls the addTodo action.\n// 7. Todos can be removed by tapping the delete icon, which calls the removeTodo action.\n// 8. The todoCount computed value is automatically updated whenever the todos list changes.\n\n// This example demonstrates key MobX concepts:\n// - Observables: counter, name, todos\n// - Computed Values: todoCount\n// - Actions: increment, setName, addTodo, removeTodo\n// - Reactions: Observer widgets that rebuild when observables change\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "reactive-programming",
      "state-management",
      "ui",
      "mobx"
    ],
    "_createdAt": "2024-08-28T22:18:30Z",
    "pubPoint": 160,
    "author": "vyuh.tech",
    "slug": {
      "current": "flutter_mobx",
      "_type": "slug"
    },
    "lastUpdate": "2024-03-27T18:30:00.000Z",
    "tutorial": "# Flutter MobX Tutorial\n\nThis tutorial will guide you through setting up and using Flutter MobX in your project. We'll cover installation, basic concepts, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_mobx: ^2.0.6+5\n  mobx: ^2.1.3\n\ndev_dependencies:\n  build_runner: ^2.3.3\n  mobx_codegen: ^2.1.1\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Create a Store\n\nCreate a new file called `real_flutter_store.dart`:\n\n```dart\nimport 'package:mobx/mobx.dart';\n\npart 'real_flutter_store.g.dart';\n\nclass RealFlutterStore = _RealFlutterStore with _$RealFlutterStore;\n\nabstract class _RealFlutterStore with Store {\n  @observable\n  int counter = 0;\n\n  @action\n  void increment() {\n    counter++;\n  }\n}\n```\n\n## Step 3: Generate MobX Code\n\nRun the following command to generate the MobX code:\n\n```\nflutter pub run build_runner build\n```\n\nThis will create the `real_flutter_store.g.dart` file.\n\n## Step 4: Use the Store in Your Widget\n\nUpdate your main widget to use the RealFlutterStore:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_mobx/flutter_mobx.dart';\nimport 'real_flutter_store.dart';\n\nclass RealFlutter extends StatelessWidget {\n  final store = RealFlutterStore();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter MobX Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('You have pushed the button this many times:'),\n            Observer(\n              builder: (_) => Text(\n                '${store.counter}',\n                style: Theme.of(context).textTheme.headline4,\n              ),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: store.increment,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional setup is required. However, to optimize performance, consider using the `@computed` decorator for complex calculations based on observables.\n\n### iOS\n\nFor iOS, ensure that you have CocoaPods installed. Run `pod install` in the `ios` folder of your Flutter project to set up the necessary native dependencies.\n\n### Web\n\nWhen targeting web platforms, be aware that the initial page load might be slightly slower due to the additional JavaScript required for MobX. Consider using lazy loading techniques for larger applications.\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, Flutter MobX works out of the box. However, be mindful of memory usage, especially when dealing with large observable collections.\n\nBy following these steps and considerations, you'll have a solid foundation for using Flutter MobX in your cross-platform Flutter applications.",
    "name": "flutter_mobx",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:53Z",
    "likesCount": 670,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "cmqvny7c"
      },
      {
        "_key": "l4eshztm",
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "9leqxfum",
        "_ref": "EyMM3FfV3Ih5n1NWrhPG9z"
      }
    ],
    "packageImage": null,
    "description": "# Flutter MobX: Simplified State Management for Flutter Applications\n\n## Introduction\n\nFlutter MobX is a powerful state management solution that combines the simplicity of MobX with the reactive nature of Flutter. It provides a clean and efficient way to manage application state, making it easier to build complex, data-driven applications.\n\n## Key Features\n\n1. **Reactive Programming**: MobX uses observables, actions, and reactions to create a reactive programming model that automatically updates the UI when the underlying data changes.\n\n2. **Boilerplate Reduction**: With the help of code generation, Flutter MobX significantly reduces the amount of boilerplate code needed for state management.\n\n3. **Easy Integration**: Flutter MobX integrates seamlessly with existing Flutter projects, allowing developers to gradually adopt it in their applications.\n\n4. **Performance Optimization**: By leveraging fine-grained reactivity, Flutter MobX ensures that only the necessary parts of the UI are rebuilt when state changes occur.\n\n5. **Debugging Tools**: MobX provides excellent debugging tools that help developers understand how state changes propagate through the application.\n\n## When to Use Flutter MobX\n\nFlutter MobX is particularly useful in scenarios where:\n\n- Your application has complex state management requirements\n- You need to maintain a clear separation between business logic and UI\n- You want to minimize unnecessary UI rebuilds for better performance\n- You prefer a more object-oriented approach to state management\n\nIn the following sections, we'll dive deeper into how to use Flutter MobX in your projects and explore its features through a practical example.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1kFP",
        "_type": "reference",
        "_key": "4tknm3rp"
      }
    ]
  },
  {
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "kpb38j88"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "gcz6irvj"
      }
    ],
    "packageImage": null,
    "slug": {
      "current": "mobx",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaP9u",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:54Z",
    "_id": "Rx1Nho763d29lawKra1kFP",
    "tutorial": "# MobX in Flutter: A Practical Tutorial\n\nIn this tutorial, we'll create a simple counter application using MobX for state management. We'll cover the basics of setting up MobX in a Flutter project and demonstrate how to use observables, actions, and reactions.\n\n## Step 1: Project Setup\n\n1. Create a new Flutter project:\n   ```\n   flutter create mobx_counter\n   cd mobx_counter\n   ```\n\n2. Add the required dependencies to your `pubspec.yaml` file as mentioned in the previous section.\n\n3. Run `flutter pub get` to install the dependencies.\n\n## Step 2: Create the Store\n\n1. Create a new file `lib/counter_store.dart`:\n\n```dart\nimport 'package:mobx/mobx.dart';\n\npart 'counter_store.g.dart';\n\nclass CounterStore = _CounterStore with _$CounterStore;\n\nabstract class _CounterStore with Store {\n  @observable\n  int count = 0;\n\n  @action\n  void increment() {\n    count++;\n  }\n}\n```\n\n2. Run the code generator:\n   ```\n   flutter pub run build_runner build\n   ```\n\n## Step 3: Create the RealFlutter Widget\n\nCreate a new file `lib/real_flutter.dart`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_mobx/flutter_mobx.dart';\nimport 'counter_store.dart';\n\nclass RealFlutter extends StatelessWidget {\n  final CounterStore counterStore = CounterStore();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('MobX Counter Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('You have pushed the button this many times:'),\n            Observer(\n              builder: (_) => Text(\n                '${counterStore.count}',\n                style: Theme.of(context).textTheme.headline4,\n              ),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: counterStore.increment,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Update main.dart\n\nUpdate your `lib/main.dart` file to use the `RealFlutter` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'real_flutter.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter MobX Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, no additional setup is required. The MobX package works out of the box.\n\n### iOS\n\nFor iOS, ensure that you have CocoaPods installed. If not, install it using:\n\n```\nsudo gem install cocoapods\n```\n\nThen, navigate to the iOS folder and run:\n\n```\npod install\n```\n\n### Web\n\nFor web support, make sure you have enabled web support in your Flutter project:\n\n```\nflutter config --enable-web\n```\n\nMobX works seamlessly with Flutter web applications without any additional configuration.\n\nThis concludes the basic tutorial for implementing MobX in a Flutter application. In the next section, we'll look at a more comprehensive example showcasing various features of MobX.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1k4l",
        "_type": "reference",
        "_key": "3m33in81"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG9z",
        "_type": "reference",
        "_key": "jw45o6ax"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_mobx/flutter_mobx.dart';\nimport 'package:mobx/mobx.dart';\n\n// Step 1: Define the store\npart 'real_flutter.g.dart';\n\nclass RealFlutter = _RealFlutter with _$RealFlutter;\n\nabstract class _RealFlutter with Store {\n  // Step 2: Define observables\n  @observable\n  int counter = 0;\n\n  @observable\n  String name = '';\n\n  @observable\n  ObservableList<String> todos = ObservableList<String>();\n\n  // Step 3: Define computed values\n  @computed\n  String get welcomeMessage => 'Welcome, $name! You have $counter clicks.';\n\n  // Step 4: Define actions\n  @action\n  void incrementCounter() {\n    counter++;\n  }\n\n  @action\n  void setName(String newName) {\n    name = newName;\n  }\n\n  @action\n  void addTodo(String todo) {\n    todos.add(todo);\n  }\n\n  @action\n  void removeTodo(String todo) {\n    todos.remove(todo);\n  }\n}\n\n// Step 5: Create the main widget\nclass RealFlutterWidget extends StatefulWidget {\n  @override\n  _RealFlutterWidgetState createState() => _RealFlutterWidgetState();\n}\n\nclass _RealFlutterWidgetState extends State<RealFlutterWidget> {\n  final RealFlutter store = RealFlutter();\n  final TextEditingController _nameController = TextEditingController();\n  final TextEditingController _todoController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 6: Set up reactions\n    reaction((_) => store.counter, (int count) {\n      print('Counter changed to: $count');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter MobX Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 7: Use Observer widget for reactive UI updates\n            Observer(\n              builder: (_) => Text(\n                store.welcomeMessage,\n                style: TextTheme.headline6,\n              ),\n            ),\n            SizedBox(height: 20),\n            TextField(\n              controller: _nameController,\n              decoration: InputDecoration(labelText: 'Enter your name'),\n              onSubmitted: store.setName,\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: store.incrementCounter,\n              child: Text('Increment Counter'),\n            ),\n            SizedBox(height: 20),\n            TextField(\n              controller: _todoController,\n              decoration: InputDecoration(labelText: 'Add a todo'),\n              onSubmitted: (String todo) {\n                store.addTodo(todo);\n                _todoController.clear();\n              },\n            ),\n            SizedBox(height: 20),\n            Text('Todo List:', style: TextTheme.subtitle1),\n            // Step 8: Use Observer for list updates\n            Observer(\n              builder: (_) => ListView.builder(\n                shrinkWrap: true,\n                itemCount: store.todos.length,\n                itemBuilder: (context, index) {\n                  final todo = store.todos[index];\n                  return ListTile(\n                    title: Text(todo),\n                    trailing: IconButton(\n                      icon: Icon(Icons.delete),\n                      onPressed: () => store.removeTodo(todo),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 9: Main function\nvoid main() {\n  runApp(MaterialApp(home: RealFlutterWidget()));\n}\n\n// Step 10: Explanation of the application flow\n/*\nApplication Flow:\n1. The RealFlutter store is defined with observables (counter, name, todos),\n   computed values (welcomeMessage), and actions (incrementCounter, setName, addTodo, removeTodo).\n2. The RealFlutterWidget is created, which uses the RealFlutter store.\n3. In initState, a reaction is set up to log counter changes.\n4. The build method creates the UI, using Observer widgets to automatically\n   update when observables change.\n5. User interactions:\n   - Entering a name updates the 'name' observable via the setName action.\n   - Clicking the \"Increment Counter\" button calls the incrementCounter action.\n   - Adding a todo calls the addTodo action.\n   - Removing a todo calls the removeTodo action.\n6. Any changes to observables automatically trigger UI updates in the relevant\n   Observer widgets, ensuring the view stays in sync with the state.\n\nThis example demonstrates the core concepts of MobX:\n- Observables for tracking state\n- Actions for updating state\n- Computed values for derived state\n- Reactions for side effects\n- Observer widgets for reactive UI updates\n\nThe MobX architecture promotes a clear separation of concerns, making the code\nmore maintainable and easier to reason about as the application grows.\n*/\n```",
    "tags": [
      "reactive-programming",
      "state-management",
      "observable",
      "action"
    ],
    "_createdAt": "2024-08-28T22:18:33Z",
    "lastUpdate": "2024-04-02T18:30:00.000Z",
    "pubPoint": 160,
    "author": "vyuh.tech",
    "description": "# MobX in Flutter: Simplifying State Management\n\n## Introduction\n\nMobX is a powerful state management library that has gained popularity in the Flutter ecosystem. It provides a simple and scalable approach to managing application state, making it easier for developers to build reactive and maintainable applications.\n\n## What is MobX?\n\nMobX is based on the principles of reactive programming. It uses three main concepts:\n\n1. **Observables**: These are the state variables that you want to track.\n2. **Actions**: Functions that modify the observables.\n3. **Reactions**: Side effects that automatically run when observables change.\n\n## Why Use MobX in Flutter?\n\n1. **Simplicity**: MobX offers a straightforward way to manage state without complex boilerplate code.\n2. **Reactivity**: It automatically updates the UI when the state changes, reducing manual work.\n3. **Scalability**: MobX works well for both small and large applications.\n4. **Testability**: The clear separation of concerns makes it easier to write unit tests.\n\n## Getting Started\n\nTo use MobX in your Flutter project, you'll need to add the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_mobx: ^2.0.6+5\n  mobx: ^2.1.3\n\ndev_dependencies:\n  build_runner: ^2.3.3\n  mobx_codegen: ^2.1.1\n```\n\nIn the next section, we'll dive into a tutorial on how to implement MobX in a Flutter application.",
    "shortDescription": "MobX is a library for reactively managing the state of your applications. Use the power of observables, actions, and reactions to supercharge your Dart and Flutter apps.",
    "likesCount": 1238,
    "name": "mobx"
  },
  {
    "similarPackages": [],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "im00thnb",
        "_ref": "4gmBGwifQuSypgRenUbXYU"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:xml/xml.dart';\nimport 'package:xml/xpath.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'XML Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const XMLDemoPage(),\n    );\n  }\n}\n\nclass XMLDemoPage extends StatefulWidget {\n  const XMLDemoPage({Key? key}) : super(key: key);\n\n  @override\n  _XMLDemoPageState createState() => _XMLDemoPageState();\n}\n\nclass _XMLDemoPageState extends State<XMLDemoPage> {\n  String _parsedResult = '';\n  String _generatedXML = '';\n  String _xpathResult = '';\n\n  // Step 1: Define sample XML data\n  final String sampleXML = '''\n    <RealFlutter>\n      <users>\n        <user id=\"1\">\n          <name>John Doe</name>\n          <email>john@example.com</email>\n        </user>\n        <user id=\"2\">\n          <name>Jane Smith</name>\n          <email>jane@example.com</email>\n        </user>\n      </users>\n      <features>\n        <feature>XML Parsing</feature>\n        <feature>XML Generation</feature>\n        <feature>XPath Support</feature>\n      </features>\n    </RealFlutter>\n  ''';\n\n  // Step 2: Implement XML parsing\n  void parseXML() {\n    final document = XmlDocument.parse(sampleXML);\n    final features = document.findAllElements('feature');\n\n    setState(() {\n      _parsedResult = features.map((f) => f.text).join(', ');\n    });\n  }\n\n  // Step 3: Implement XML generation\n  void generateXML() {\n    final builder = XmlBuilder();\n    builder.processing('xml', 'version=\"1.0\"');\n    builder.element('RealFlutter', nest: () {\n      builder.element('app', nest: () {\n        builder.attribute('name', 'XML Demo');\n        builder.element('version', nest: '1.0');\n        builder.element('description', nest: 'A demo of XML package');\n      });\n    });\n\n    final document = builder.buildDocument();\n    setState(() {\n      _generatedXML = document.toXmlString(pretty: true);\n    });\n  }\n\n  // Step 4: Implement XPath querying\n  void useXPath() {\n    final document = XmlDocument.parse(sampleXML);\n    \n    // Find all user emails\n    final emails = document.xpath('//email/text()');\n    \n    setState(() {\n      _xpathResult = emails.join(', ');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('XML Demo')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            ElevatedButton(\n              onPressed: parseXML,\n              child: const Text('Parse XML'),\n            ),\n            const SizedBox(height: 10),\n            Text('Parsed Features: $_parsedResult'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: generateXML,\n              child: const Text('Generate XML'),\n            ),\n            const SizedBox(height: 10),\n            Text('Generated XML:\\n$_generatedXML'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: useXPath,\n              child: const Text('Use XPath'),\n            ),\n            const SizedBox(height: 10),\n            Text('XPath Result (Emails): $_xpathResult'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a page with three buttons: Parse XML, Generate XML, and Use XPath.\n// 2. When \"Parse XML\" is clicked, it parses the sample XML and displays the extracted features.\n// 3. When \"Generate XML\" is clicked, it creates a new XML document and displays it.\n// 4. When \"Use XPath\" is clicked, it uses XPath to find all email addresses in the sample XML.\n// 5. The results of each operation are displayed on the screen.\n\n// This example demonstrates:\n// - XML parsing: Converting XML string to Dart objects\n// - XML generation: Creating XML documents programmatically\n// - XPath usage: Querying XML documents efficiently\n// - Integration with Flutter UI: Displaying results and handling user interactions\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "parser",
      "sax",
      "xml",
      "xpath",
      "data-format"
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:55Z",
    "slug": {
      "current": "xml",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmMF3",
    "dependentPackages": [
      {
        "_key": "r92iwrsz",
        "_ref": "Rx1Nho763d29lawKra1fNn",
        "_type": "reference"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CeJX",
        "_type": "reference",
        "_key": "29bl9i4a"
      }
    ],
    "lastUpdate": "2023-12-01T18:30:00.000Z",
    "pubPoint": 160,
    "author": "lukas-renggli.ch",
    "_type": "package",
    "_createdAt": "2024-08-28T22:18:34Z",
    "name": "xml",
    "_id": "Rx1Nho763d29lawKra1kQ3",
    "tutorial": "# XML Package for Flutter: Tutorial\n\nIn this tutorial, we'll explore how to use the XML package in a Flutter application. We'll cover parsing XML, generating XML, and using XPath for querying XML documents.\n\n## Setup\n\nFirst, ensure you have the XML package added to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  xml: ^6.1.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Parsing XML\n\nTo parse XML, we'll use the `XmlDocument.parse()` method. Here's an example:\n\n```dart\nimport 'package:xml/xml.dart';\n\nvoid parseXML() {\n  final xmlString = '''\n    <RealFlutter>\n      <feature>XML Parsing</feature>\n      <feature>XML Generation</feature>\n      <feature>XPath Support</feature>\n    </RealFlutter>\n  ''';\n\n  final document = XmlDocument.parse(xmlString);\n  final features = document.findAllElements('feature');\n\n  for (var feature in features) {\n    print(feature.text);\n  }\n}\n```\n\nThis code parses a simple XML string and prints out all the features listed.\n\n## Generating XML\n\nTo generate XML, we can use the `XmlBuilder` class:\n\n```dart\nimport 'package:xml/xml.dart';\n\nString generateXML() {\n  final builder = XmlBuilder();\n  builder.processing('xml', 'version=\"1.0\"');\n  builder.element('RealFlutter', nest: () {\n    builder.element('app', nest: () {\n      builder.attribute('name', 'XML Demo');\n      builder.element('version', nest: '1.0');\n      builder.element('description', nest: 'A demo of XML package');\n    });\n  });\n\n  final document = builder.buildDocument();\n  return document.toXmlString(pretty: true);\n}\n```\n\nThis function generates an XML document with a root element `RealFlutter` containing app information.\n\n## Using XPath\n\nXPath is a powerful way to navigate XML documents. Here's how you can use it:\n\n```dart\nimport 'package:xml/xml.dart';\nimport 'package:xml/xpath.dart';\n\nvoid useXPath() {\n  final xmlString = '''\n    <RealFlutter>\n      <users>\n        <user id=\"1\">\n          <name>John Doe</name>\n          <email>john@example.com</email>\n        </user>\n        <user id=\"2\">\n          <name>Jane Smith</name>\n          <email>jane@example.com</email>\n        </user>\n      </users>\n    </RealFlutter>\n  ''';\n\n  final document = XmlDocument.parse(xmlString);\n  \n  // Find all user names\n  final names = document.xpath('//name/text()');\n  for (var name in names) {\n    print('Name: ${name}');\n  }\n\n  // Find user with id=\"2\"\n  final user2 = document.xpath('//user[@id=\"2\"]').first;\n  print('User 2 email: ${user2.findElements('email').first.text}');\n}\n```\n\nThis example demonstrates how to use XPath to find specific elements within an XML document.\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you don't need to do any additional setup to use the XML package. It works out of the box.\n\n### iOS\n\nSimilarly, iOS doesn't require any special configuration for the XML package.\n\n### Web\n\nWhen targeting web platforms, be aware that large XML processing might impact performance. Consider using web workers for heavy XML parsing or generation tasks.\n\n### Windows, macOS, and Linux\n\nFor desktop platforms, the XML package works without additional setup. However, when dealing with local XML files, make sure to handle file I/O operations appropriately for each platform.\n\nIn the next section, we'll look at a complete example that demonstrates all these features in action.",
    "description": "# XML Package for Flutter: Parsing and Generating XML with Ease\n\n## Introduction\n\nThe XML package for Flutter is a powerful tool that allows developers to parse and generate XML data within their Flutter applications. XML (eXtensible Markup Language) is a widely used format for storing and transporting structured data, making it essential for many applications that deal with data exchange or configuration.\n\n## Key Features\n\n1. **XML Parsing**: The package provides robust XML parsing capabilities, allowing you to convert XML strings into easily manipulable Dart objects.\n\n2. **XML Generation**: Create XML documents programmatically, making it simple to generate XML data for various purposes.\n\n3. **XPath Support**: Utilize XPath expressions to navigate and query XML documents efficiently.\n\n4. **Namespace Handling**: The package offers full support for XML namespaces, ensuring compatibility with complex XML structures.\n\n5. **Stream Processing**: Parse large XML documents using stream processing, which is memory-efficient and suitable for handling sizeable data.\n\n## Use Cases\n\n- **Data Exchange**: Implement XML-based APIs or work with third-party services that use XML for data transfer.\n- **Configuration Management**: Parse and modify XML configuration files within your Flutter application.\n- **Document Processing**: Handle XML-based document formats like DOCX, SVG, or RSS feeds.\n- **Web Scraping**: Extract data from XML-based web pages or feeds.\n\n## Getting Started\n\nTo start using the XML package in your Flutter project, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  xml: ^6.1.0\n```\n\nThen, run `flutter pub get` to fetch the package.\n\nIn the next sections, we'll dive into a tutorial on how to use the XML package and provide a comprehensive example demonstrating its features.",
    "shortDescription": "A lightweight library for parsing, traversing, querying, transforming and building XML documents.",
    "likesCount": 395
  },
  {
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "csra24kt"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "a4055mvo"
      }
    ],
    "_updatedAt": "2024-09-06T04:10:56Z",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "tx85zyzm"
      },
      {
        "_type": "reference",
        "_key": "zbygaei3",
        "_ref": "uQRNMiDfrp20RZ8Id8Ca4b"
      }
    ],
    "tags": [
      "bloc",
      "cache",
      "state-management",
      "persistence"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-8d19cc25c9977ca22c8ae7ea3e6e91fb4679614e-660x650-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:18:40Z",
    "tutorialIncluded": true,
    "author": "bloclibrary.dev",
    "_rev": "eaCZ7mIhmiYZX5KGqJmMLb",
    "description": "# Hydrated Bloc: Persisting State in Flutter\n\n## Introduction\n\nIn the world of Flutter development, managing and persisting state across app restarts can be a challenging task. Enter `hydrated_bloc`, an extension to the popular `bloc` state management library that simplifies the process of persisting and restoring state in Flutter applications.\n\n## What is Hydrated Bloc?\n\nHydrated Bloc is a powerful package that extends the functionality of the bloc library. It automatically persists and restores bloc states, eliminating the need for manual serialization and deserialization of your application's state.\n\n## Key Features\n\n1. **Automatic Persistence**: Hydrated Bloc automatically saves your bloc state to local storage whenever it changes.\n2. **Effortless Restoration**: When your app restarts, Hydrated Bloc seamlessly restores the previous state.\n3. **Custom Storage**: While it uses SharedPreferences by default, you can easily configure it to use your preferred storage solution.\n4. **Type Safety**: Hydrated Bloc maintains type safety throughout the persistence process.\n5. **Selective Persistence**: You have full control over which parts of your state are persisted.\n\n## Why Use Hydrated Bloc?\n\n- **Simplified State Management**: Reduce boilerplate code related to state persistence.\n- **Improved User Experience**: Maintain app state across restarts, providing a seamless experience for your users.\n- **Flexibility**: Easily integrate with existing bloc-based architectures.\n- **Performance**: Efficient serialization and deserialization of state objects.\n\nIn the following sections, we'll dive deeper into how to implement Hydrated Bloc in your Flutter projects and explore its features through practical examples.",
    "shortDescription": "An extension to the bloc state management library which automatically persists and restores bloc states.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:hydrated_bloc/hydrated_bloc.dart';\nimport 'package:path_provider/path_provider.dart';\n\n// Step 1: Main function\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Initialize HydratedBloc storage\n  HydratedBloc.storage = await HydratedStorage.build(\n    storageDirectory: await getTemporaryDirectory(),\n  );\n  \n  runApp(RealFlutter());\n}\n\n// Step 2: Create the main app widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Hydrated Bloc Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: BlocProvider(\n        create: (_) => SettingsCubit(),\n        child: HomePage(),\n      ),\n    );\n  }\n}\n\n// Step 3: Create a HydratedCubit for app settings\nclass SettingsCubit extends HydratedCubit<Map<String, dynamic>> {\n  SettingsCubit() : super({\n    'isDarkMode': false,\n    'fontSize': 16,\n  });\n\n  void toggleDarkMode() {\n    emit({...state, 'isDarkMode': !state['isDarkMode']});\n  }\n\n  void updateFontSize(double size) {\n    emit({...state, 'fontSize': size});\n  }\n\n  @override\n  Map<String, dynamic>? fromJson(Map<String, dynamic> json) => json;\n\n  @override\n  Map<String, dynamic>? toJson(Map<String, dynamic> state) => state;\n}\n\n// Step 4: Create the HomePage widget\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<SettingsCubit, Map<String, dynamic>>(\n      builder: (context, settings) {\n        return Scaffold(\n          appBar: AppBar(\n            title: Text('Hydrated Bloc Demo'),\n          ),\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                // Step 5: Display and toggle dark mode\n                Text(\n                  'Dark Mode: ${settings['isDarkMode'] ? 'On' : 'Off'}',\n                  style: TextStyle(fontSize: settings['fontSize'].toDouble()),\n                ),\n                ElevatedButton(\n                  onPressed: () => context.read<SettingsCubit>().toggleDarkMode(),\n                  child: Text('Toggle Dark Mode'),\n                ),\n                SizedBox(height: 20),\n                // Step 6: Display and adjust font size\n                Text(\n                  'Font Size: ${settings['fontSize']}',\n                  style: TextStyle(fontSize: settings['fontSize'].toDouble()),\n                ),\n                Slider(\n                  value: settings['fontSize'].toDouble(),\n                  min: 10,\n                  max: 30,\n                  divisions: 20,\n                  label: settings['fontSize'].toString(),\n                  onChanged: (double value) {\n                    context.read<SettingsCubit>().updateFontSize(value);\n                  },\n                ),\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by initializing HydratedBloc storage in the main function.\n// 2. RealFlutter widget is created as the root of the app, setting up the MaterialApp.\n// 3. A SettingsCubit is provided at the top level using BlocProvider.\n// 4. The HomePage is displayed, which uses BlocBuilder to listen to SettingsCubit state changes.\n// 5. The UI shows the current dark mode status and allows toggling it.\n// 6. The UI also displays the current font size and provides a slider to adjust it.\n// 7. When the user interacts with the UI (toggling dark mode or adjusting font size):\n//    a. The corresponding method in SettingsCubit is called.\n//    b. The cubit emits a new state with updated values.\n//    c. HydratedBloc automatically persists the new state.\n//    d. The UI rebuilds to reflect the changes.\n// 8. If the app is closed and reopened, HydratedBloc will restore the persisted state,\n//    ensuring that user settings are maintained across app restarts.\n\n// This example demonstrates key features of hydrated_bloc:\n// - Automatic state persistence and restoration\n// - Easy integration with existing Bloc pattern\n// - Handling multiple settings in a single cubit\n// - Reactive UI updates based on persisted state\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 795,
    "slug": {
      "current": "hydrated_bloc",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "name": "hydrated_bloc",
    "_id": "Rx1Nho763d29lawKra1kah",
    "tutorial": "# Hydrated Bloc Tutorial\n\nIn this tutorial, we'll walk through the process of implementing Hydrated Bloc in a Flutter application. We'll create a simple counter app that persists its state across app restarts.\n\n## Prerequisites\n\n- Flutter SDK installed\n- Basic knowledge of Flutter and the bloc pattern\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_bloc: ^8.1.3\n  hydrated_bloc: ^9.1.2\n  path_provider: ^2.1.1\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Initialize Hydrated Bloc\n\nIn your `main.dart` file, initialize Hydrated Bloc before running your app:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:hydrated_bloc/hydrated_bloc.dart';\nimport 'package:path_provider/path_provider.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  HydratedBloc.storage = await HydratedStorage.build(\n    storageDirectory: await getTemporaryDirectory(),\n  );\n  runApp(RealFlutter());\n}\n```\n\n## Step 3: Create a Hydrated Cubit\n\nLet's create a `CounterCubit` that extends `HydratedCubit`:\n\n```dart\nimport 'package:hydrated_bloc/hydrated_bloc.dart';\n\nclass CounterCubit extends HydratedCubit<int> {\n  CounterCubit() : super(0);\n\n  void increment() => emit(state + 1);\n  void decrement() => emit(state - 1);\n\n  @override\n  int? fromJson(Map<String, dynamic> json) => json['value'] as int;\n\n  @override\n  Map<String, dynamic>? toJson(int state) => {'value': state};\n}\n```\n\n## Step 4: Use the Hydrated Cubit in Your Widget\n\nNow, let's use our `CounterCubit` in a widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => CounterCubit(),\n      child: CounterView(),\n    );\n  }\n}\n\nclass CounterView extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Hydrated Counter')),\n      body: Center(\n        child: BlocBuilder<CounterCubit, int>(\n          builder: (context, count) {\n            return Text('$count', style: TextStyle(fontSize: 24));\n          },\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        children: [\n          FloatingActionButton(\n            child: Icon(Icons.add),\n            onPressed: () => context.read<CounterCubit>().increment(),\n          ),\n          SizedBox(height: 8),\n          FloatingActionButton(\n            child: Icon(Icons.remove),\n            onPressed: () => context.read<CounterCubit>().decrement(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional configuration is needed. The `path_provider` package will use the app's internal storage.\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file to allow local storage:\n\n```xml\n<key>NSDocumentsDirectory</key>\n<string>YES</string>\n```\n\n### Web\n\nFor web support, you'll need to use a different storage solution, as `SharedPreferences` is not available on web. Consider using `hydrated_bloc_web` package or implement a custom storage solution using `localStorage`.\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, the `path_provider` package will use appropriate locations for each OS. No additional configuration is required.\n\nBy following these steps, you've created a Flutter app that uses Hydrated Bloc to persist the counter state across app restarts. Experiment with closing and reopening the app to see the state persistence in action!",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG5F",
        "_type": "reference",
        "_key": "vkrrflg5"
      }
    ],
    "lastUpdate": "2024-03-23T18:30:00.000Z"
  },
  {
    "tags": [
      "tracking",
      "privacy",
      "ios",
      "permissions"
    ],
    "_createdAt": "2024-08-28T22:18:59Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:10:57Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaPEh",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:app_tracking_transparency/app_tracking_transparency.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'App Tracking Transparency Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String _authStatus = 'Unknown';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize by checking the tracking status\n    WidgetsBinding.instance.addPostFrameCallback((_) => initPlugin());\n  }\n\n  // Step 2: Function to initialize the plugin and check the initial status\n  Future<void> initPlugin() async {\n    final status = await AppTrackingTransparency.trackingAuthorizationStatus;\n    setState(() {\n      _authStatus = '$status';\n    });\n    // Step 3: If not determined, we'll need to request permission\n    if (status == TrackingStatus.notDetermined) {\n      await requestTrackingPermission();\n    }\n  }\n\n  // Step 4: Function to request tracking permission\n  Future<void> requestTrackingPermission() async {\n    final status = await AppTrackingTransparency.requestTrackingAuthorization();\n    setState(() {\n      _authStatus = '$status';\n    });\n  }\n\n  // Step 5: Function to check the current tracking status\n  Future<void> checkTrackingStatus() async {\n    final status = await AppTrackingTransparency.trackingAuthorizationStatus;\n    setState(() {\n      _authStatus = '$status';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('RealFlutter ATT Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Tracking Authorization Status: $_authStatus'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: requestTrackingPermission,\n              child: const Text('Request Tracking Permission'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: checkTrackingStatus,\n              child: const Text('Check Tracking Status'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the RealFlutter widget is created.\n// 2. In initState, we call initPlugin() after the first frame is rendered.\n// 3. initPlugin() checks the initial tracking status and updates the UI.\n// 4. If the status is notDetermined, it automatically requests permission.\n// 5. The user can manually request permission or check status using the buttons.\n// 6. Each action updates the _authStatus variable and refreshes the UI.\n\n// Note: On Android, the status will always be TrackingStatus.notDetermined\n// as Android doesn't have an equivalent to iOS's App Tracking Transparency.\n```",
    "platforms": [
      "ios"
    ],
    "likesCount": 383,
    "lastUpdate": "2024-07-30T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1klL",
    "shortDescription": "This Flutter plugin allows you to display ios tracking authorization dialogue and request permission to collect data.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7E4",
        "_type": "reference",
        "_key": "2c49d8t6"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "b7sj9oew"
      }
    ],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "17dg93qs",
        "_ref": "Rx1Nho763d29lawKra1x0h"
      }
    ],
    "tutorial": "## 2. Tutorial: Implementing App Tracking Transparency\n\nIn this section, we'll walk through the process of implementing the `app_tracking_transparency` package in your Flutter project.\n\n### Step 1: Add the package to your pubspec.yaml\n\n```yaml\ndependencies:\n  app_tracking_transparency: ^2.0.4\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:app_tracking_transparency/app_tracking_transparency.dart';\n```\n\n### Step 3: Configure your project\n\n#### iOS Configuration:\n\n1. Open your `ios/Runner/Info.plist` file.\n2. Add the following key-value pair:\n\n```xml\n<key>NSUserTrackingUsageDescription</key>\n<string>This identifier will be used to deliver personalized ads to you.</string>\n```\n\nReplace the string with your own description of why you're requesting tracking permission.\n\n#### Android Configuration:\n\nNo additional configuration is required for Android.\n\n### Step 4: Implement tracking transparency\n\nHere's a basic implementation of the tracking transparency request:\n\n```dart\nclass RealFlutter {\n  Future<void> requestTrackingPermission() async {\n    final status = await AppTrackingTransparency.trackingAuthorizationStatus;\n    if (status == TrackingStatus.notDetermined) {\n      await AppTrackingTransparency.requestTrackingAuthorization();\n    }\n  }\n}\n```\n\n### Step 5: Call the method\n\nCall the `requestTrackingPermission` method when your app starts, typically in the `initState` method of your main widget:\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) => requestTrackingPermission());\n}\n```\n\n### Step 6: Handle the authorization status\n\nYou can check the authorization status and act accordingly:\n\n```dart\nFuture<void> checkTrackingStatus() async {\n  final status = await AppTrackingTransparency.trackingAuthorizationStatus;\n  switch (status) {\n    case TrackingStatus.authorized:\n      print('Tracking authorized');\n      // Proceed with tracking\n      break;\n    case TrackingStatus.denied:\n      print('Tracking denied');\n      // Handle denied status\n      break;\n    case TrackingStatus.notDetermined:\n      print('Tracking not determined');\n      // Request permission\n      break;\n    case TrackingStatus.restricted:\n      print('Tracking restricted');\n      // Handle restricted status\n      break;\n  }\n}\n```\n\nIn the next section, we'll provide a complete example that demonstrates all the features of the `app_tracking_transparency` package.",
    "slug": {
      "current": "app_tracking_transparency",
      "_type": "slug"
    },
    "description": "# App Tracking Transparency in Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `app_tracking_transparency` package is a crucial tool for Flutter developers who want to comply with Apple's App Tracking Transparency (ATT) framework. This framework, introduced in iOS 14.5, requires apps to request user permission before tracking their data across apps or websites owned by other companies.\n\n### Key Features:\n\n1. **Request Tracking Authorization**: Prompt users with a system dialog to allow or disallow tracking.\n2. **Check Tracking Authorization Status**: Determine the current status of tracking authorization.\n3. **Get Tracking Authorization Status**: Retrieve the latest tracking authorization status.\n\n### Why Use App Tracking Transparency?\n\n1. **Compliance**: Ensures your app complies with Apple's privacy guidelines.\n2. **User Trust**: Demonstrates respect for user privacy, potentially increasing trust in your app.\n3. **Avoid Rejection**: Apps that don't implement ATT when required may be rejected from the App Store.\n\n### Compatibility:\n\n- iOS: 14.5 and above\n- macOS: 11.3 and above\n\nFor Android devices, the package provides a default implementation that always returns `AuthorizationStatus.notDetermined`.\n\nIn the next section, we'll dive into a tutorial on how to implement the `app_tracking_transparency` package in your Flutter project.",
    "author": "he2apps.com",
    "_type": "package",
    "packageImage": null,
    "name": "app_tracking_transparency",
    "pubPoint": 160
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:avatar_glow/avatar_glow.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Avatar Glow Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: AvatarGlowDemo(),\n    );\n  }\n}\n\nclass AvatarGlowDemo extends StatefulWidget {\n  @override\n  _AvatarGlowDemoState createState() => _AvatarGlowDemoState();\n}\n\nclass _AvatarGlowDemoState extends State<AvatarGlowDemo> {\n  // Step 1: Initialize variables for customization\n  bool _isGlowing = true;\n  Color _glowColor = Colors.blue;\n  double _endRadius = 90.0;\n  Duration _duration = Duration(milliseconds: 2000);\n  bool _repeat = true;\n  bool _showTwoGlows = true;\n  Curve _curve = Curves.fastOutSlowIn;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Avatar Glow Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Implement AvatarGlow widget\n            AvatarGlow(\n              glowColor: _glowColor,\n              endRadius: _endRadius,\n              duration: _duration,\n              repeat: _repeat,\n              showTwoGlows: _showTwoGlows,\n              repeatPauseDuration: Duration(milliseconds: 100),\n              curve: _curve,\n              child: Material(\n                elevation: 8.0,\n                shape: CircleBorder(),\n                child: CircleAvatar(\n                  backgroundColor: Colors.grey[100],\n                  radius: 40.0,\n                  child: Icon(\n                    Icons.flutter_dash,\n                    size: 40,\n                    color: Colors.blue,\n                  ),\n                ),\n              ),\n            ),\n            SizedBox(height: 20),\n            // Step 3: Add controls for customization\n            ElevatedButton(\n              onPressed: () {\n                setState(() {\n                  _isGlowing = !_isGlowing;\n                  _repeat = _isGlowing;\n                });\n              },\n              child: Text(_isGlowing ? 'Stop Glowing' : 'Start Glowing'),\n            ),\n            SizedBox(height: 10),\n            Slider(\n              value: _endRadius,\n              min: 50,\n              max: 200,\n              divisions: 15,\n              label: _endRadius.round().toString(),\n              onChanged: (double value) {\n                setState(() {\n                  _endRadius = value;\n                });\n              },\n            ),\n            Text('End Radius: ${_endRadius.round()}'),\n            SizedBox(height: 10),\n            DropdownButton<Color>(\n              value: _glowColor,\n              items: [\n                DropdownMenuItem(value: Colors.blue, child: Text('Blue')),\n                DropdownMenuItem(value: Colors.red, child: Text('Red')),\n                DropdownMenuItem(value: Colors.green, child: Text('Green')),\n              ],\n              onChanged: (Color? newValue) {\n                if (newValue != null) {\n                  setState(() {\n                    _glowColor = newValue;\n                  });\n                }\n              },\n            ),\n            SizedBox(height: 10),\n            Switch(\n              value: _showTwoGlows,\n              onChanged: (value) {\n                setState(() {\n                  _showTwoGlows = value;\n                });\n              },\n            ),\n            Text('Show Two Glows'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by displaying a glowing avatar in the center of the screen.\n// 2. Users can interact with various controls to customize the glow effect:\n//    - Toggle the glow on/off using the button.\n//    - Adjust the glow radius using the slider.\n//    - Change the glow color using the dropdown menu.\n//    - Toggle between showing one or two glows using the switch.\n// 3. The AvatarGlow widget updates in real-time as the user modifies these settings.\n// 4. The state of the app is managed within the _AvatarGlowDemoState class, \n//    which updates the UI whenever setState is called.\n// 5. This demo showcases the flexibility and customization options of the avatar_glow package,\n//    allowing developers to create dynamic and engaging UI elements easily.\n```",
    "tutorialIncluded": true,
    "_rev": "eaCZ7mIhmiYZX5KGqJmMS9",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "gllfw4a8",
        "_ref": "t8DYBEKn49O4mjbyRAfAQu"
      }
    ],
    "likesCount": 1108,
    "lastUpdate": "2023-12-11T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:10:58Z",
    "author": "ayushpgupta.com",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "description": "# Avatar Glow Package for Flutter: Adding Animated Glow Effects to Widgets\n\nThe `avatar_glow` package is a powerful and customizable Flutter library that allows developers to add eye-catching glow effects to various widgets in their applications. This package is particularly useful for creating attention-grabbing UI elements, such as profile pictures, action buttons, or any other widget that needs to stand out.\n\n## Key Features\n\n1. **Customizable Glow**: Adjust the color, size, and intensity of the glow effect to match your app's design.\n2. **Animation Control**: Fine-tune the animation duration and curve for smooth and appealing transitions.\n3. **Flexible Widget Support**: Apply the glow effect to any widget, not just avatars or circular shapes.\n4. **Performance Optimized**: Designed to work efficiently, even with multiple glowing elements on screen.\n\n## Use Cases\n\n- Highlighting active user profiles in a social media app\n- Creating pulsating action buttons for important actions\n- Emphasizing selected items in a list or grid view\n- Adding a magical or futuristic touch to game UI elements\n\nThe `avatar_glow` package simplifies the process of adding dynamic and engaging visual effects to your Flutter app, enhancing user experience and interface aesthetics with minimal effort.",
    "shortDescription": "A Flutter package providing a Avatar Glow Widget with cool background glowing animation",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "yn6yfzef"
      }
    ],
    "tags": [
      "glow-effect",
      "custom-widget",
      "ripple-effect",
      "sound-wave",
      "avatar",
      "animation"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference",
        "_key": "f0m9ybp8"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "aq91ra12"
      }
    ],
    "pubPoint": 160,
    "_type": "package",
    "name": "avatar_glow",
    "_id": "Rx1Nho763d29lawKra1l6d",
    "tutorial": "# Tutorial: Implementing Avatar Glow in Your Flutter App\n\nThis tutorial will guide you through the process of adding the `avatar_glow` package to your Flutter project and using it effectively.\n\n## Step 1: Add the package to your pubspec.yaml\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  avatar_glow: ^2.0.2  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:avatar_glow/avatar_glow.dart';\n```\n\n## Step 3: Use the AvatarGlow widget\n\nWrap your desired widget with the `AvatarGlow` widget:\n\n```dart\nAvatarGlow(\n  glowColor: Colors.blue,\n  endRadius: 90.0,\n  duration: Duration(milliseconds: 2000),\n  repeat: true,\n  showTwoGlows: true,\n  repeatPauseDuration: Duration(milliseconds: 100),\n  child: Material(\n    elevation: 8.0,\n    shape: CircleBorder(),\n    child: CircleAvatar(\n      backgroundColor: Colors.grey[100],\n      child: Image.asset(\n        'assets/flutter_logo.png',\n        height: 60,\n      ),\n      radius: 40.0,\n    ),\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nNo additional setup is required for Android.\n\n### iOS\n\nFor iOS, you need to update the `Info.plist` file to allow usage of the device's GPU for better performance. Add the following to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>CADisableMinimumFrameDurationOnPhone</key>\n<true/>\n```\n\n### Web\n\nThe `avatar_glow` package is compatible with Flutter web applications without any additional configuration.\n\n## Customization Options\n\n- `glowColor`: Set the color of the glow effect.\n- `endRadius`: Determine the maximum size of the glow.\n- `duration`: Control how long each glow animation cycle takes.\n- `repeat`: Choose whether the glow effect should repeat.\n- `showTwoGlows`: Enable or disable the second glow effect for added depth.\n- `curve`: Adjust the animation curve for custom easing effects.\n\nExperiment with these properties to achieve the desired visual effect for your app's UI.",
    "slug": {
      "current": "avatar_glow",
      "_type": "slug"
    },
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-988925d6387f670cf3b17925c5e5fb0979fd4a48-400x711-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:19:05Z"
  },
  {
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:event_bus/event_bus.dart';\n\n// Step 1: Define event classes\nclass UserLoggedInEvent {\n  final String username;\n  UserLoggedInEvent(this.username);\n}\n\nclass DataUpdatedEvent {\n  final Map<String, dynamic> newData;\n  DataUpdatedEvent(this.newData);\n}\n\n// Step 2: Create RealFlutter class with EventBus instance\nclass RealFlutter {\n  static final EventBus eventBus = EventBus();\n}\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Event Bus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  String _lastLoggedInUser = '';\n  Map<String, dynamic> _lastUpdatedData = {};\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Subscribe to events\n    RealFlutter.eventBus.on<UserLoggedInEvent>().listen((event) {\n      setState(() {\n        _lastLoggedInUser = event.username;\n      });\n    });\n\n    RealFlutter.eventBus.on<DataUpdatedEvent>().listen((event) {\n      setState(() {\n        _lastUpdatedData = event.newData;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Event Bus Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Last Logged In User: $_lastLoggedInUser'),\n            SizedBox(height: 20),\n            Text('Last Updated Data: $_lastUpdatedData'),\n            SizedBox(height: 40),\n            ElevatedButton(\n              child: Text('Simulate Login'),\n              onPressed: () {\n                // Step 4: Publish UserLoggedInEvent\n                RealFlutter.eventBus.fire(UserLoggedInEvent('JohnDoe'));\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Simulate Data Update'),\n              onPressed: () {\n                // Step 5: Publish DataUpdatedEvent\n                RealFlutter.eventBus.fire(DataUpdatedEvent({'key': 'value'}));\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 6: Clean up subscriptions (if necessary)\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the HomePage is created.\n// 2. In initState(), we subscribe to UserLoggedInEvent and DataUpdatedEvent.\n// 3. When the 'Simulate Login' button is pressed, it fires a UserLoggedInEvent.\n// 4. The subscription to UserLoggedInEvent updates the _lastLoggedInUser state.\n// 5. When the 'Simulate Data Update' button is pressed, it fires a DataUpdatedEvent.\n// 6. The subscription to DataUpdatedEvent updates the _lastUpdatedData state.\n// 7. Each state update triggers a rebuild of the widget, reflecting the new data.\n// 8. The dispose() method is called when the widget is removed from the tree.\n\n// Note: In a real-world scenario, you might want to cancel event subscriptions\n// in the dispose() method to prevent memory leaks, especially if you're\n// subscribing to events in widgets that are frequently created and destroyed.\n```",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "2ocnojhp"
      },
      {
        "_key": "0540jmpz",
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference"
      }
    ],
    "name": "event_bus",
    "slug": {
      "current": "event_bus",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmN5R",
    "description": "# Event Bus in Flutter: Simplifying Communication in Your App\n\n## Introduction\n\nThe `event_bus` package is a powerful tool for implementing the publish-subscribe pattern in Flutter applications. It provides a simple and efficient way to decouple different parts of your app, allowing them to communicate without direct dependencies.\n\n## What is Event Bus?\n\nEvent Bus is a communication pattern that allows different components in an application to communicate with each other without knowing about each other explicitly. It consists of three main components:\n\n1. **Events**: Custom objects that encapsulate data to be shared.\n2. **Publishers**: Components that create and post events to the bus.\n3. **Subscribers**: Components that listen for specific events on the bus.\n\n## Benefits of Using Event Bus\n\n- **Decoupling**: Reduces dependencies between components, making your code more modular and easier to maintain.\n- **Flexibility**: Allows for easy addition or removal of subscribers without affecting publishers.\n- **Scalability**: Simplifies communication in complex applications with many interconnected components.\n- **Testability**: Makes it easier to test individual components in isolation.\n\n## When to Use Event Bus\n\nEvent Bus is particularly useful in scenarios such as:\n\n- Communicating between widgets that are not directly related in the widget tree.\n- Updating multiple widgets when a global state changes.\n- Implementing features like real-time notifications or updates.\n\nIn the next sections, we'll dive into a tutorial on how to implement Event Bus in your Flutter application and explore a comprehensive example showcasing its features.",
    "subCategories": [
      {
        "_key": "2obbthv8",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference"
      }
    ],
    "lastUpdate": "2021-03-03T18:30:00.000Z",
    "tutorial": "# Event Bus in Flutter: A Comprehensive Tutorial\n\nIn this tutorial, we'll walk through the process of implementing Event Bus in a Flutter application using the `event_bus` package. We'll cover setup, basic usage, and platform-specific considerations.\n\n## Step 1: Add Dependencies\n\nFirst, add the `event_bus` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  event_bus: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Create Event Classes\n\nDefine custom classes for your events. These classes will encapsulate the data you want to transmit:\n\n```dart\nclass UserLoggedInEvent {\n  final String username;\n  UserLoggedInEvent(this.username);\n}\n\nclass DataUpdatedEvent {\n  final Map<String, dynamic> newData;\n  DataUpdatedEvent(this.newData);\n}\n```\n\n## Step 3: Create an Event Bus Instance\n\nCreate a singleton instance of EventBus that can be accessed throughout your app:\n\n```dart\nimport 'package:event_bus/event_bus.dart';\n\nclass RealFlutter {\n  static final EventBus eventBus = EventBus();\n}\n```\n\n## Step 4: Publish Events\n\nTo publish an event, use the `fire` method of the EventBus instance:\n\n```dart\nRealFlutter.eventBus.fire(UserLoggedInEvent('JohnDoe'));\n```\n\n## Step 5: Subscribe to Events\n\nTo listen for events, use the `on` method of the EventBus instance:\n\n```dart\nvar subscription = RealFlutter.eventBus.on<UserLoggedInEvent>().listen((event) {\n  print('User ${event.username} has logged in!');\n});\n```\n\nRemember to cancel the subscription when it's no longer needed:\n\n```dart\nsubscription.cancel();\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might need to handle events in background modes. Ensure you've configured your app's capabilities in Xcode and use `FlutterEngineGroup` for efficient background execution.\n\n### Android\n\nOn Android, consider using a `Service` for long-running background tasks that might publish events. Ensure you've set up the necessary permissions in your `AndroidManifest.xml`.\n\n### Web\n\nWhen using Event Bus in a web application, be mindful of memory management. Cancel subscriptions when components are disposed to prevent memory leaks.\n\nIn the next section, we'll explore a comprehensive example that demonstrates these concepts in action.",
    "author": "jakobservices.ch",
    "shortDescription": "A simple Event Bus using Dart Streams for decoupling applications",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:19:09Z",
    "_updatedAt": "2024-09-06T04:10:59Z",
    "similarPackages": [],
    "tags": [
      "events",
      "pub-sub",
      "communication",
      "messaging"
    ],
    "likesCount": 634,
    "packageImage": null,
    "_id": "Rx1Nho763d29lawKra1lON",
    "tutorialIncluded": true
  },
  {
    "lastUpdate": "2024-07-16T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1lZ1",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "pxppki9b"
      }
    ],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbW9O",
        "_type": "reference",
        "_key": "z7k15bjf"
      }
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:00Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:audio_service/audio_service.dart';\nimport 'package:just_audio/just_audio.dart';\n\n// Step 1: Define the main entry point of the application\nvoid main() async {\n  // Initialize the audio service before running the app\n  await AudioService.init(\n    builder: () => RealFlutterAudioHandler(),\n    config: const AudioServiceConfig(\n      androidNotificationChannelId: 'com.realflutter.channel.audio',\n      androidNotificationChannelName: 'Audio playback',\n      androidNotificationOngoing: true,\n    ),\n  );\n  runApp(const MyApp());\n}\n\n// Step 2: Define the main app widget\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Audio Player',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const AudioPlayerScreen(),\n    );\n  }\n}\n\n// Step 3: Create the main audio player screen\nclass AudioPlayerScreen extends StatelessWidget {\n  const AudioPlayerScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('RealFlutter Audio Player')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 4: Display current track information\n            StreamBuilder<MediaItem?>(\n              stream: AudioService.currentMediaItemStream,\n              builder: (context, snapshot) {\n                final mediaItem = snapshot.data;\n                return Column(\n                  children: [\n                    Text(mediaItem?.title ?? 'No track selected',\n                        style: Theme.of(context).textTheme.headline6),\n                    Text(mediaItem?.artist ?? '',\n                        style: Theme.of(context).textTheme.subtitle1),\n                  ],\n                );\n              },\n            ),\n            const SizedBox(height: 20),\n            // Step 5: Add playback controls\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                IconButton(\n                  icon: const Icon(Icons.skip_previous),\n                  onPressed: AudioService.skipToPrevious,\n                ),\n                StreamBuilder<PlaybackState>(\n                  stream: AudioService.playbackStateStream,\n                  builder: (context, snapshot) {\n                    final playing = snapshot.data?.playing ?? false;\n                    return IconButton(\n                      icon: Icon(playing ? Icons.pause : Icons.play_arrow),\n                      onPressed: playing ? AudioService.pause : AudioService.play,\n                    );\n                  },\n                ),\n                IconButton(\n                  icon: const Icon(Icons.skip_next),\n                  onPressed: AudioService.skipToNext,\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 6: Implement the RealFlutterAudioHandler\nclass RealFlutterAudioHandler extends BaseAudioHandler with QueueHandler, SeekHandler {\n  final _player = AudioPlayer();\n  final _playlist = ConcatenatingAudioSource(children: []);\n\n  RealFlutterAudioHandler() {\n    _loadPlaylist();\n    _notifyAudioHandlerAboutPlaybackEvents();\n    _listenForDurationChanges();\n    _listenForCurrentSongIndexChanges();\n    _listenForSequenceStateChanges();\n  }\n\n  // Step 7: Load playlist\n  Future<void> _loadPlaylist() async {\n    try {\n      await _player.setAudioSource(_playlist);\n    } catch (e) {\n      print(\"Error: $e\");\n    }\n  }\n\n  // Step 8: Playback control methods\n  @override\n  Future<void> play() => _player.play();\n\n  @override\n  Future<void> pause() => _player.pause();\n\n  @override\n  Future<void> seek(Duration position) => _player.seek(position);\n\n  @override\n  Future<void> skipToQueueItem(int index) => _player.seek(Duration.zero, index: index);\n\n  // Step 9: Playlist management methods\n  Future<void> addQueueItem(MediaItem mediaItem) async {\n    final audioSource = AudioSource.uri(Uri.parse(mediaItem.id));\n    _playlist.add(audioSource);\n\n    final newQueue = queue.value..add(mediaItem);\n    queue.add(newQueue);\n  }\n\n  @override\n  Future<void> removeQueueItem(MediaItem mediaItem) async {\n    final index = queue.value.indexOf(mediaItem);\n    if (index != -1) {\n      _playlist.removeAt(index);\n\n      final newQueue = queue.value..removeAt(index);\n      queue.add(newQueue);\n    }\n  }\n\n  // Step 10: Listeners for player events\n  void _notifyAudioHandlerAboutPlaybackEvents() {\n    _player.playbackEventStream.listen((PlaybackEvent event) {\n      final playing = _player.playing;\n      playbackState.add(playbackState.value.copyWith(\n        controls: [\n          MediaControl.skipToPrevious,\n          if (playing) MediaControl.pause else MediaControl.play,\n          MediaControl.stop,\n          MediaControl.skipToNext,\n        ],\n        systemActions: const {\n          MediaAction.seek,\n          MediaAction.seekForward,\n          MediaAction.seekBackward,\n        },\n        androidCompactActionIndices: const [0, 1, 3],\n        processingState: const {\n          ProcessingState.idle: AudioProcessingState.idle,\n          ProcessingState.loading: AudioProcessingState.loading,\n          ProcessingState.buffering: AudioProcessingState.buffering,\n          ProcessingState.ready: AudioProcessingState.ready,\n          ProcessingState.completed: AudioProcessingState.completed,\n        }[_player.processingState]!,\n        playing: playing,\n        updatePosition: _player.position,\n        bufferedPosition: _player.bufferedPosition,\n        speed: _player.speed,\n        queueIndex: event.currentIndex,\n      ));\n    });\n  }\n\n  void _listenForDurationChanges() {\n    _player.durationStream.listen((duration) {\n      var index = _player.currentIndex;\n      final newQueue = queue.value;\n      if (index == null || newQueue.isEmpty) return;\n      if (_player.shuffleModeEnabled) {\n        index = _player.shuffleIndices!.indexOf(index);\n      }\n      final oldMediaItem = newQueue[index];\n      final newMediaItem = oldMediaItem.copyWith(duration: duration);\n      newQueue[index] = newMediaItem;\n      queue.add(newQueue);\n      mediaItem.add(newMediaItem);\n    });\n  }\n\n  void _listenForCurrentSongIndexChanges() {\n    _player.currentIndexStream.listen((index) {\n      final playlist = queue.value;\n      if (index == null || playlist.isEmpty) return;\n      if (_player.shuffleModeEnabled) {\n        index = _player.shuffleIndices!.indexOf(index);\n      }\n      mediaItem.add(playlist[index]);\n    });\n  }\n\n  void _listenForSequenceStateChanges() {\n    _player.sequenceStateStream.listen((SequenceState? sequenceState) {\n      final sequence = sequenceState?.effectiveSequence;\n      if (sequence == null || sequence.isEmpty) return;\n      final items = sequence.map((source) => source.tag as MediaItem);\n      queue.add(items.toList());\n    });\n  }\n}\n\n// Application Flow:\n// 1. The app starts by initializing the AudioService with our custom RealFlutterAudioHandler.\n// 2. The main screen (AudioPlayerScreen) is displayed, showing the current track info and playback controls.\n// 3. RealFlutterAudioHandler sets up the audio player, loads the playlist, and configures various listeners.\n// 4. User interactions (play, pause, skip) are handled by calling the corresponding AudioService methods.\n// 5. The RealFlutterAudioHandler processes these commands and controls the underlying AudioPlayer.\n// 6. Changes in playback state, current track, or playlist are reflected in the UI through StreamBuilder widgets.\n// 7. The audio continues to play in the background when the app is minimized or the screen is locked.\n\n// This example demonstrates key features of the audio_service package:\n// - Background playback\n// - Media controls (play, pause, skip)\n// - Playlist management\n// - Real-time UI updates based on playback state\n// - Handling of audio events and state changes\n\n// To extend this example, consider adding:\n// - A full playlist view\n// - More advanced playback options (shuffle, repeat)\n// - Audio effects or equalizer controls\n// - Persistent storage for playlists\n// - Integration with online music services\n```",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbPCe",
        "_type": "reference",
        "_key": "acais0sd"
      }
    ],
    "name": "audio_service",
    "tutorial": "# Audio Service Package Tutorial\n\nThis tutorial will guide you through setting up and using the `audio_service` package in your Flutter application. We'll cover installation, configuration, and basic usage across different platforms.\n\n## Step 1: Installation\n\nAdd the `audio_service` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  audio_service: ^0.18.9\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Android Configuration\n\n1. Open `android/app/src/main/AndroidManifest.xml` and add the following permissions:\n\n```xml\n<manifest ...>\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n    <application ...>\n        ...\n        <service android:name=\"com.ryanheise.audioservice.AudioService\"\n            android:foregroundServiceType=\"mediaPlayback\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.media.browse.MediaBrowserService\" />\n            </intent-filter>\n        </service>\n        <receiver android:name=\"com.ryanheise.audioservice.MediaButtonReceiver\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MEDIA_BUTTON\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n```\n\n2. In `android/app/build.gradle`, set the minimum SDK version to 21:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n    }\n}\n```\n\n## Step 3: iOS Configuration\n\n1. Open `ios/Runner/Info.plist` and add the following:\n\n```xml\n<key>UIBackgroundModes</key>\n<array>\n    <string>audio</string>\n</array>\n```\n\n2. In `ios/Podfile`, set the minimum deployment target to 11.0:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n## Step 4: Basic Implementation\n\n1. Create an `AudioHandler` class:\n\n```dart\nimport 'package:audio_service/audio_service.dart';\n\nclass RealFlutterAudioHandler extends BaseAudioHandler {\n  // Implement methods for playback control, queue management, etc.\n  @override\n  Future<void> play() async {\n    // Start playback logic\n    playbackState.add(playbackState.value.copyWith(playing: true));\n  }\n\n  @override\n  Future<void> pause() async {\n    // Pause playback logic\n    playbackState.add(playbackState.value.copyWith(playing: false));\n  }\n\n  // Implement other methods as needed\n}\n```\n\n2. Initialize the audio service in your `main.dart`:\n\n```dart\nvoid main() async {\n  await AudioService.init(\n    builder: () => RealFlutterAudioHandler(),\n    config: const AudioServiceConfig(\n      androidNotificationChannelId: 'com.mycompany.myapp.channel.audio',\n      androidNotificationChannelName: 'Audio playback',\n    ),\n  );\n  runApp(MyApp());\n}\n```\n\n3. Use the `AudioService` in your app:\n\n```dart\nElevatedButton(\n  onPressed: () => AudioService.play(),\n  child: Text('Play'),\n),\nElevatedButton(\n  onPressed: () => AudioService.pause(),\n  child: Text('Pause'),\n),\n```\n\nThis basic setup provides a foundation for using the `audio_service` package. In the next section, we'll see a more comprehensive example demonstrating additional features and best practices.",
    "pubPoint": 160,
    "author": "ryanheise.com",
    "tags": [
      "audio",
      "background",
      "music",
      "player",
      "service"
    ],
    "_createdAt": "2024-08-28T22:19:12Z",
    "slug": {
      "current": "audio_service",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaPHt",
    "description": "# Audio Service Package for Flutter: Background Audio Playback Made Easy\n\n## Introduction\n\nThe `audio_service` package is a powerful tool for Flutter developers looking to implement background audio functionality in their applications. It provides a robust framework for managing audio playback, handling media controls, and updating metadata, all while running in the background.\n\n## Key Features\n\n1. **Background Playback**: Continue playing audio even when the app is in the background or the device is locked.\n\n2. **Media Controls**: Handle media controls from various sources, including the notification area, lock screen, headset buttons, and smart watches.\n\n3. **Metadata Updates**: Keep track of and update the currently playing audio's metadata, such as title, artist, and album art.\n\n4. **Queue Management**: Manage a queue of audio tracks, allowing for seamless playback of multiple items.\n\n5. **Custom Actions**: Define and handle custom actions specific to your app's needs.\n\n6. **Multiple Platforms**: Works across Android, iOS, and web platforms, with a consistent API.\n\n## Why Use Audio Service?\n\nImplementing background audio playback can be challenging due to platform-specific requirements and limitations. The `audio_service` package abstracts away much of this complexity, providing a unified API that works across platforms. This allows developers to focus on creating great user experiences rather than dealing with low-level system interactions.\n\nWhether you're building a music player, a podcast app, or any application that requires background audio capabilities, the `audio_service` package offers a solid foundation to build upon.\n\nIn the following sections, we'll dive into a tutorial on how to set up and use the `audio_service` package, followed by a comprehensive example demonstrating its features.",
    "shortDescription": "Flutter plugin to play audio in the background while the screen is off.",
    "likesCount": 1173
  },
  {
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CasF",
        "_type": "reference",
        "_key": "z69zyohe"
      },
      {
        "_type": "reference",
        "_key": "cjkhus2r",
        "_ref": "Rx1Nho763d29lawKra1ea7"
      }
    ],
    "lastUpdate": "2024-08-27T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1ljf",
    "_type": "package",
    "description": "# FlutterGen: Streamlining Asset Management in Flutter\n\nFlutter is a powerful framework for building cross-platform applications, but managing assets can become cumbersome as your project grows. This is where FlutterGen comes to the rescue. FlutterGen is a code generator for your assets, fonts, colors, and more, making it easier to use resources in your Flutter projects.\n\n## What is FlutterGen?\n\nFlutterGen is a Dart package that generates code for your Flutter project's assets, fonts, and colors. It creates strongly-typed references to your resources, eliminating the need for error-prone string-based asset paths and allowing you to leverage your IDE's autocomplete features.\n\n## Key Features\n\n1. **Asset Generation**: Automatically generates classes for accessing your images, fonts, and other assets.\n2. **Color Generation**: Creates color constants from your color definitions in pubspec.yaml.\n3. **Font Generation**: Generates font family constants for easy use in your TextStyle definitions.\n4. **Platform-Specific Assets**: Supports generation of platform-specific asset references.\n5. **Integration with build_runner**: Seamlessly integrates with Flutter's build system.\n\n## Benefits of Using FlutterGen\n\n- **Type Safety**: Reduces runtime errors by providing compile-time checks for asset references.\n- **Improved Developer Experience**: Offers autocomplete suggestions for assets, enhancing productivity.\n- **Easy Refactoring**: Centralized asset management makes it easier to rename or move assets without breaking your code.\n- **Optimized Asset Usage**: Helps prevent unused asset imports, potentially reducing app size.\n\nIn the following sections, we'll dive into how to set up and use FlutterGen in your Flutter projects, along with a practical example demonstrating its features.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_svg/flutter_svg.dart';\n// Step 1: Import generated files\nimport 'gen/assets.gen.dart';\nimport 'gen/colors.gen.dart';\nimport 'gen/fonts.gen.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'FlutterGen Demo',\n      theme: ThemeData(\n        // Step 2: Use generated color\n        primarySwatch: ColorName.primaryColor,\n        // Step 3: Use generated font\n        fontFamily: FontFamily.roboto,\n      ),\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('FlutterGen Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 4: Use generated image asset\n            Assets.images.logo.image(\n              width: 200,\n              height: 200,\n            ),\n            SizedBox(height: 20),\n            // Step 5: Use platform-specific asset\n            Assets.images.platformLogo.image(\n              platform: TargetPlatform.android,\n              width: 100,\n              height: 100,\n            ),\n            SizedBox(height: 20),\n            // Step 6: Use SVG asset\n            SvgPicture.asset(\n              Assets.icons.settings,\n              width: 50,\n              height: 50,\n            ),\n            SizedBox(height: 20),\n            // Step 7: Use generated color\n            Container(\n              width: 100,\n              height: 100,\n              color: ColorName.accentColor,\n              child: Center(\n                child: Text(\n                  'Colored Box',\n                  style: TextStyle(color: Colors.white),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp with a theme using generated colors and fonts.\n// 3. The home page (MyHomePage) is displayed, showcasing various features of FlutterGen:\n//    - It displays a logo using a generated image asset.\n//    - It shows a platform-specific logo (for Android in this case).\n//    - It renders an SVG icon using a generated asset path.\n//    - It creates a colored box using a generated color constant.\n// 4. All assets and colors are accessed using strongly-typed references,\n//    providing compile-time safety and auto-completion in the IDE.\n\n// Note: Make sure to run 'flutter pub run build_runner build' whenever you add new assets\n// or make changes to your asset structure to regenerate the necessary files.\n```",
    "tags": [
      "code-generation",
      "assets",
      "resources",
      "localization"
    ],
    "tutorial": "# FlutterGen Tutorial\n\nThis tutorial will guide you through setting up and using FlutterGen in your Flutter project. We'll cover installation, configuration, and basic usage.\n\n## Step 1: Installation\n\nAdd FlutterGen to your `pubspec.yaml` file:\n\n```yaml\ndev_dependencies:\n  flutter_gen_runner: ^5.4.0\n  build_runner: ^2.4.8\n```\n\nRun the following command to install the dependencies:\n\n```bash\nflutter pub get\n```\n\n## Step 2: Configuration\n\nCreate a `build.yaml` file in the root of your project with the following content:\n\n```yaml\ntargets:\n  $default:\n    builders:\n      flutter_gen_runner:\n        options:\n          output: lib/gen/\n          line_length: 80\n\nflutter_gen:\n  output: lib/gen/\n  line_length: 80\n\n  integrations:\n    flutter_svg: true\n    flare_flutter: true\n    rive: true\n\n  colors:\n    inputs:\n      - assets/color/colors.xml\n\n  assets:\n    enabled: true\n    package_parameter_enabled: true\n    style: snake-case\n```\n\n## Step 3: Organize Your Assets\n\nEnsure your assets are properly organized in your project. For example:\n\n```\nassets/\n images/\n    logo.png\n    background.jpg\n fonts/\n    custom_font.ttf\n color/\n     colors.xml\n```\n\nUpdate your `pubspec.yaml` to include these assets:\n\n```yaml\nflutter:\n  assets:\n    - assets/images/\n  fonts:\n    - family: CustomFont\n      fonts:\n        - asset: assets/fonts/custom_font.ttf\n```\n\n## Step 4: Generate Code\n\nRun the following command to generate the FlutterGen code:\n\n```bash\nflutter pub run build_runner build\n```\n\nThis will create the necessary files in the `lib/gen/` directory.\n\n## Step 5: Using Generated Code\n\nNow you can use the generated code in your Flutter application. Here's a simple example:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:your_project/gen/assets.gen.dart';\nimport 'package:your_project/gen/colors.gen.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('FlutterGen Example'),\n        backgroundColor: ColorName.primaryColor,\n      ),\n      body: Center(\n        child: Assets.images.logo.image(),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Assets\n\nFlutterGen supports platform-specific assets. To use them, organize your assets like this:\n\n```\nassets/\n images/\n    logo.png\n    logo_android.png\n    logo_ios.png\n    logo_web.png\n```\n\nFlutterGen will generate platform-specific getters for these assets, which you can use like this:\n\n```dart\nAssets.images.logo.image(\n  platform: TargetPlatform.android,\n)\n```\n\nThis will automatically use the Android-specific logo on Android devices, falling back to the default `logo.png` on other platforms.\n\nBy following these steps, you'll have FlutterGen set up and ready to use in your Flutter project, making asset management more efficient and type-safe.",
    "_updatedAt": "2024-09-06T04:11:01Z",
    "slug": {
      "current": "flutter_gen",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaPMg",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbX6B",
        "_type": "reference",
        "_key": "vlhi3q7g"
      }
    ],
    "name": "flutter_gen",
    "pubPoint": 160,
    "shortDescription": "The Flutter code generator for your assets, fonts, colors,   Get rid of all String-based APIs.",
    "likesCount": 1409,
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:19Z",
    "tutorialIncluded": true,
    "author": "wasabeef.jp",
    "platforms": [
      "linux",
      "macos",
      "windows"
    ]
  },
  {
    "tutorial": "# Toastification Tutorial: Implementation Guide\n\nIn this tutorial, we'll walk through the process of implementing the Toastification package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nTo get started with Toastification, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  toastification: ^0.0.3\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nTo use Toastification in your Flutter app, follow these steps:\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:toastification/toastification.dart';\n```\n\n2. Create a `BuildContext` variable to reference your current context:\n\n```dart\nBuildContext context = /* Your current build context */;\n```\n\n3. Use the `showToast` method to display a toast:\n\n```dart\ntoastification.showToast(\n  context: context,\n  title: Text('Hello, Toastification!'),\n  description: Text('This is a basic toast notification.'),\n);\n```\n\n## Step 3: Customization\n\nToastification offers various customization options. Here's an example of a more customized toast:\n\n```dart\ntoastification.showToast(\n  context: context,\n  type: ToastificationType.success,\n  style: ToastificationStyle.fillColored,\n  title: Text('Success!'),\n  description: Text('Your action was completed successfully.'),\n  alignment: Alignment.topRight,\n  autoCloseDuration: const Duration(seconds: 5),\n  animationDuration: const Duration(milliseconds: 300),\n  animationBuilder: (context, animation, alignment, child) {\n    return SlideTransition(\n      position: Tween<Offset>(\n        begin: const Offset(0.0, -1.0),\n        end: Offset.zero,\n      ).animate(animation),\n      child: child,\n    );\n  },\n);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, ensure that you have the latest version of the Android Gradle plugin in your `android/build.gradle` file:\n\n```gradle\nbuildscript {\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.1.2'\n    }\n}\n```\n\n### iOS\n\nFor iOS, no additional configuration is required. However, ensure that your `Info.plist` file has the necessary permissions if you're planning to use features like vibration or sound with your toasts.\n\n### Web\n\nToastification works out of the box for web applications. However, be mindful of browser compatibility when using advanced CSS features for styling your toasts.\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize Toastification in your Flutter projects across different platforms.",
    "_rev": "eaCZ7mIhmiYZX5KGqJmNFG",
    "shortDescription": "Toastification is a Flutter package that allows you to easily show toast and notification messages in your application.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr",
        "_type": "reference",
        "_key": "wl78p6h5"
      }
    ],
    "tags": [
      "toast",
      "notification",
      "message",
      "toastification",
      "alert"
    ],
    "likesCount": 652,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CblP",
        "_type": "reference",
        "_key": "7x79wgzt"
      },
      {
        "_key": "ftxen844",
        "_ref": "uQRNMiDfrp20RZ8Id8CgZH",
        "_type": "reference"
      }
    ],
    "_id": "Rx1Nho763d29lawKra1luJ",
    "tutorialIncluded": true,
    "description": "# Toastification: Elevate Your Flutter Notifications\n\nIn the world of mobile app development, user feedback is crucial. One of the most common ways to provide instant feedback is through toast notifications. Flutter, being a versatile framework, offers various packages for this purpose. Today, we're diving deep into the `toastification` package, a powerful tool for creating customizable and animated toast notifications in your Flutter applications.\n\n## What is Toastification?\n\nToastification is a Flutter package that allows developers to create beautiful, customizable, and animated toast notifications. It provides a simple and intuitive API to display informative messages, warnings, or errors to users in a non-intrusive manner.\n\n## Key Features\n\n1. **Customizable Appearance**: Toastification offers extensive customization options, allowing you to tailor the look and feel of your notifications to match your app's design.\n\n2. **Multiple Positions**: You can display toasts at various positions on the screen, such as top, bottom, or center.\n\n3. **Animation Support**: The package includes smooth entrance and exit animations, enhancing the user experience.\n\n4. **Duration Control**: Set custom durations for how long the toast should be displayed.\n\n5. **Action Buttons**: Add interactive buttons to your toasts, enabling users to take immediate action.\n\n6. **Styling Options**: Customize colors, icons, fonts, and more to create visually appealing notifications.\n\n7. **Queuing System**: Manage multiple toasts efficiently with an built-in queuing system.\n\n8. **Dismissible Toasts**: Users can dismiss toasts manually if desired.\n\nIn the following sections, we'll explore how to implement Toastification in your Flutter projects and showcase its various features through practical examples.",
    "_updatedAt": "2024-09-06T04:11:03Z",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:20Z",
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:toastification/toastification.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Toastification Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const ToastificationDemo(),\n    );\n  }\n}\n\nclass ToastificationDemo extends StatelessWidget {\n  const ToastificationDemo({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Toastification Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: () => _showBasicToast(context),\n              child: const Text('Show Basic Toast'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _showCustomToast(context),\n              child: const Text('Show Custom Toast'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _showActionToast(context),\n              child: const Text('Show Action Toast'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Basic Toast\n  void _showBasicToast(BuildContext context) {\n    toastification.showToast(\n      context: context,\n      title: Text('Hello, Toastification!'),\n      description: Text('This is a basic toast notification.'),\n    );\n  }\n\n  // Step 2: Custom Toast\n  void _showCustomToast(BuildContext context) {\n    toastification.showToast(\n      context: context,\n      type: ToastificationType.success,\n      style: ToastificationStyle.fillColored,\n      title: Text('Success!'),\n      description: Text('Your action was completed successfully.'),\n      alignment: Alignment.topRight,\n      autoCloseDuration: const Duration(seconds: 5),\n      animationDuration: const Duration(milliseconds: 300),\n      animationBuilder: (context, animation, alignment, child) {\n        return SlideTransition(\n          position: Tween<Offset>(\n            begin: const Offset(0.0, -1.0),\n            end: Offset.zero,\n          ).animate(animation),\n          child: child,\n        );\n      },\n    );\n  }\n\n  // Step 3: Action Toast\n  void _showActionToast(BuildContext context) {\n    toastification.showToast(\n      context: context,\n      type: ToastificationType.warning,\n      style: ToastificationStyle.flat,\n      title: Text('Warning!'),\n      description: Text('Are you sure you want to proceed?'),\n      primaryButtonText: Text('Yes'),\n      primaryButtonOnTap: () {\n        print('User confirmed the action');\n        toastification.dismissAll(context);\n      },\n      closeButtonText: Text('No'),\n      closeOnButtonTap: true,\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with three buttons.\n// 2. When the user taps \"Show Basic Toast\":\n//    - A simple toast appears with a title and description.\n// 3. When the user taps \"Show Custom Toast\":\n//    - A more elaborate toast slides in from the top-right corner.\n//    - It has a success icon, custom styling, and animation.\n// 4. When the user taps \"Show Action Toast\":\n//    - A warning toast appears with two action buttons.\n//    - If the user taps \"Yes\", it prints a message to the console and dismisses the toast.\n//    - If the user taps \"No\", the toast is simply dismissed.\n// 5. Each toast demonstrates different features of the Toastification package,\n//    showcasing its flexibility and customization options.\n```",
    "lastUpdate": "2024-08-25T18:30:00.000Z",
    "name": "toastification",
    "slug": {
      "current": "toastification",
      "_type": "slug"
    },
    "author": "payamzahedi.com"
  },
  {
    "description": "# Wakelock Plus: Keep Your Flutter App Awake\n\n## Introduction\n\nIn the world of mobile app development, managing device sleep behavior is crucial for certain types of applications. Enter `wakelock_plus`, a powerful Flutter package that allows developers to keep the device screen on and prevent it from going to sleep. This functionality is particularly useful for apps that require continuous user interaction or display important information for extended periods.\n\n## What is Wakelock Plus?\n\n`wakelock_plus` is a Flutter plugin that provides a simple and efficient way to control the device's wakelock. A wakelock is a mechanism that keeps the device's screen and CPU active, preventing the system from entering a low-power state or sleep mode.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly on Android, iOS, macOS, Windows, and web platforms.\n2. **Simple API**: Offers straightforward methods to enable and disable the wakelock.\n3. **Customizable**: Allows developers to toggle the wakelock state based on specific app requirements.\n4. **Battery-aware**: Provides options to automatically disable the wakelock when the device is low on battery.\n5. **State management**: Includes methods to check the current wakelock state.\n\n## When to Use Wakelock Plus\n\nConsider using `wakelock_plus` in scenarios such as:\n\n- Video playback applications\n- Reading apps with long-form content\n- Navigation or map-based apps\n- Games that require constant screen interaction\n- Presentation or slideshow apps\n\nBy integrating `wakelock_plus` into your Flutter project, you can ensure that your app remains active and visible when needed, enhancing the user experience and functionality of your application.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:wakelock_plus/wakelock_plus.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Wakelock Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const WakelockDemo(),\n    );\n  }\n}\n\nclass WakelockDemo extends StatefulWidget {\n  const WakelockDemo({Key? key}) : super(key: key);\n\n  @override\n  _WakelockDemoState createState() => _WakelockDemoState();\n}\n\nclass _WakelockDemoState extends State<WakelockDemo> {\n  bool _isWakelockEnabled = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkWakelockStatus();\n  }\n\n  // Step 1: Check initial wakelock status\n  Future<void> _checkWakelockStatus() async {\n    bool isEnabled = await WakelockPlus.enabled;\n    setState(() {\n      _isWakelockEnabled = isEnabled;\n    });\n  }\n\n  // Step 2: Toggle wakelock\n  Future<void> _toggleWakelock() async {\n    try {\n      await WakelockPlus.toggle(enable: !_isWakelockEnabled);\n      await _checkWakelockStatus();\n    } catch (e) {\n      print('Failed to toggle wakelock: $e');\n    }\n  }\n\n  // Step 3: Enable wakelock\n  Future<void> _enableWakelock() async {\n    try {\n      await WakelockPlus.enable();\n      await _checkWakelockStatus();\n    } catch (e) {\n      print('Failed to enable wakelock: $e');\n    }\n  }\n\n  // Step 4: Disable wakelock\n  Future<void> _disableWakelock() async {\n    try {\n      await WakelockPlus.disable();\n      await _checkWakelockStatus();\n    } catch (e) {\n      print('Failed to disable wakelock: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Wakelock Plus Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 5: Display current wakelock status\n            Text(\n              'Wakelock is ${_isWakelockEnabled ? 'enabled' : 'disabled'}',\n              style: TextStyle(fontSize: 18),\n            ),\n            SizedBox(height: 20),\n            // Step 6: Button to toggle wakelock\n            ElevatedButton(\n              onPressed: _toggleWakelock,\n              child: Text('Toggle Wakelock'),\n            ),\n            SizedBox(height: 10),\n            // Step 7: Button to enable wakelock\n            ElevatedButton(\n              onPressed: _enableWakelock,\n              child: Text('Enable Wakelock'),\n            ),\n            SizedBox(height: 10),\n            // Step 8: Button to disable wakelock\n            ElevatedButton(\n              onPressed: _disableWakelock,\n              child: Text('Disable Wakelock'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. The WakelockDemo widget is created as the home screen.\n// 3. In the initState method, the app checks the initial wakelock status.\n// 4. The UI displays the current wakelock status and provides three buttons:\n//    - Toggle Wakelock: Switches between enabled and disabled states.\n//    - Enable Wakelock: Explicitly enables the wakelock.\n//    - Disable Wakelock: Explicitly disables the wakelock.\n// 5. When a button is pressed, the corresponding function is called:\n//    - _toggleWakelock(): Toggles the wakelock state.\n//    - _enableWakelock(): Enables the wakelock.\n//    - _disableWakelock(): Disables the wakelock.\n// 6. After each action, the app updates the UI to reflect the new wakelock status.\n// 7. Error handling is implemented to catch and log any issues that may occur\n//    during wakelock operations.\n\n// This example demonstrates the core functionality of the wakelock_plus package,\n// allowing users to control the device's screen behavior directly from the app interface.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1hDL",
        "_type": "reference",
        "_key": "bhchf51f"
      }
    ],
    "_createdAt": "2024-08-28T22:19:25Z",
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1mMh",
    "pubPoint": 160,
    "shortDescription": "Plugin that allows you to keep the device screen awake, i.e. prevent the screen from sleeping on Android, iOS, macOS, Windows, Linux, and web.",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfECi",
        "_type": "reference",
        "_key": "yxf8lzqx"
      }
    ],
    "tags": [
      "wakelock",
      "screen",
      "power-management",
      "display"
    ],
    "likesCount": 307,
    "name": "wakelock_plus",
    "tutorial": "# Wakelock Plus Tutorial\n\nThis tutorial will guide you through the process of integrating and using the `wakelock_plus` package in your Flutter application.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  wakelock_plus: ^1.1.3\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:wakelock_plus/wakelock_plus.dart';\n```\n\n## Step 3: Basic Usage\n\n### Enabling Wakelock\n\nTo keep the screen on, use the `enable` method:\n\n```dart\nawait WakelockPlus.enable();\n```\n\n### Disabling Wakelock\n\nTo allow the screen to turn off, use the `disable` method:\n\n```dart\nawait WakelockPlus.disable();\n```\n\n### Checking Wakelock State\n\nTo check if the wakelock is currently enabled:\n\n```dart\nbool isEnabled = await WakelockPlus.enabled;\nprint('Wakelock is enabled: $isEnabled');\n```\n\n## Step 4: Platform-Specific Details\n\n### Android\n\nNo additional setup is required for Android.\n\n### iOS\n\nAdd the following to your `Info.plist` file:\n\n```xml\n<key>UIBackgroundModes</key>\n<array>\n    <string>audio</string>\n</array>\n```\n\n### macOS\n\nAdd the following to your `Info.plist` file:\n\n```xml\n<key>NSSystemExtensionUsageDescription</key>\n<string>This app requires system extension to function properly.</string>\n```\n\n### Web\n\nFor web support, add the following script tag to your `index.html` file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/wakelock-plus@1.1.3/dist/wakelock-plus.js\"></script>\n```\n\n### Windows\n\nNo additional setup is required for Windows.\n\n## Step 5: Advanced Usage\n\n### Toggle Wakelock\n\nTo toggle the wakelock state:\n\n```dart\nawait WakelockPlus.toggle(enable: true); // Enable wakelock\nawait WakelockPlus.toggle(enable: false); // Disable wakelock\n```\n\n### Error Handling\n\nAlways use try-catch blocks to handle potential errors:\n\n```dart\ntry {\n  await WakelockPlus.enable();\n} catch (e) {\n  print('Failed to enable wakelock: $e');\n}\n```\n\nBy following this tutorial, you'll be able to effectively implement and control the wakelock functionality in your Flutter application across multiple platforms.",
    "_type": "package",
    "_rev": "eaCZ7mIhmiYZX5KGqJmNLo",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:04Z",
    "slug": {
      "current": "wakelock_plus",
      "_type": "slug"
    },
    "author": "fluttercommunity.dev"
  },
  {
    "packageImage": null,
    "name": "mocktail",
    "tutorial": "# Mocktail Tutorial: Getting Started with Mocking in Flutter\n\n## Setup\n\nTo get started with Mocktail in your Flutter project, follow these steps:\n\n1. Add Mocktail to your `pubspec.yaml` file:\n\n```yaml\ndev_dependencies:\n  mocktail: ^0.3.0\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import Mocktail in your test file:\n\n```dart\nimport 'package:mocktail/mocktail.dart';\n```\n\n## Creating a Mock\n\nLet's create a simple mock for a `UserRepository` class:\n\n```dart\nclass MockUserRepository extends Mock implements UserRepository {}\n```\n\n## Stubbing Methods\n\nTo stub a method, use the `when` function:\n\n```dart\nfinal mockRepository = MockUserRepository();\nwhen(() => mockRepository.getUser(any())).thenReturn(User('John Doe'));\n```\n\n## Verifying Calls\n\nYou can verify that a method was called using the `verify` function:\n\n```dart\nverify(() => mockRepository.getUser(any())).called(1);\n```\n\n## Using Argument Matchers\n\nMocktail provides various argument matchers:\n\n```dart\nwhen(() => mockRepository.getUser(argThat(startsWith('user')))).thenReturn(User('John Doe'));\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nWhen testing Android-specific code:\n\n1. Use `MethodChannel` mocks for platform channels.\n2. Mock `PlatformDispatcher` for UI-related tests.\n\nExample:\n\n```dart\nclass MockMethodChannel extends Mock implements MethodChannel {}\n\nfinal mockChannel = MockMethodChannel();\nwhen(() => mockChannel.invokeMethod<String>('getAndroidVersion'))\n    .thenAnswer((_) async => 'Android 12');\n```\n\n### iOS\n\nFor iOS-specific testing:\n\n1. Use `MethodChannel` mocks similarly to Android.\n2. Mock `UIKit` related classes when necessary.\n\nExample:\n\n```dart\nclass MockUIDeviceClass extends Mock implements UIDeviceClass {}\n\nfinal mockUIDevice = MockUIDeviceClass();\nwhen(() => mockUIDevice.systemVersion).thenReturn('15.0');\n```\n\n## Best Practices\n\n1. Keep your mocks in a separate file for better organization.\n2. Use meaningful names for your mock classes.\n3. Avoid over-mocking; mock only what's necessary for the test.\n4. Reset mocks between tests to ensure clean state.\n\nBy following this tutorial, you'll be well on your way to effectively using Mocktail in your Flutter projects across different platforms.",
    "subCategories": [
      {
        "_key": "b4qv8u8b",
        "_ref": "4gmBGwifQuSypgRenUbXCi",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1swl",
        "_type": "reference",
        "_key": "d0hynre2"
      }
    ],
    "similarPackages": [],
    "lastUpdate": "2024-06-11T18:30:00.000Z",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "author": "felangel.dev",
    "shortDescription": "A Dart mock library which simplifies mocking with null safety support and no manual mocks or code generation.",
    "slug": {
      "current": "mocktail",
      "_type": "slug"
    },
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\n\n// Step 1: Define the classes we'll be working with\nclass User {\n  final String name;\n  final int age;\n\n  User(this.name, this.age);\n}\n\nclass UserRepository {\n  Future<User> getUser(String id) async {\n    // Simulating API call\n    await Future.delayed(Duration(seconds: 1));\n    return User('John Doe', 30);\n  }\n\n  Future<List<User>> getAllUsers() async {\n    // Simulating API call\n    await Future.delayed(Duration(seconds: 1));\n    return [\n      User('John Doe', 30),\n      User('Jane Smith', 25),\n    ];\n  }\n}\n\nclass UserService {\n  final UserRepository repository;\n\n  UserService(this.repository);\n\n  Future<String> getUserName(String id) async {\n    final user = await repository.getUser(id);\n    return user.name;\n  }\n\n  Future<double> getAverageAge() async {\n    final users = await repository.getAllUsers();\n    final totalAge = users.fold(0, (sum, user) => sum + user.age);\n    return totalAge / users.length;\n  }\n}\n\n// Step 2: Create a mock for UserRepository\nclass MockUserRepository extends Mock implements UserRepository {}\n\n// Step 3: Define our main widget\nclass RealFlutter extends StatefulWidget {\n  final UserService userService;\n\n  RealFlutter({Key? key, required this.userService}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String userName = '';\n  double averageAge = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadData();\n  }\n\n  Future<void> _loadData() async {\n    final name = await widget.userService.getUserName('user1');\n    final age = await widget.userService.getAverageAge();\n    setState(() {\n      userName = name;\n      averageAge = age;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('User Name: $userName'),\n            Text('Average Age: ${averageAge.toStringAsFixed(1)}'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 4: Write tests using Mocktail\nvoid main() {\n  late MockUserRepository mockRepository;\n  late UserService userService;\n\n  setUp(() {\n    // Step 5: Initialize the mock before each test\n    mockRepository = MockUserRepository();\n    userService = UserService(mockRepository);\n  });\n\n  testWidgets('RealFlutter displays user data correctly', (WidgetTester tester) async {\n    // Step 6: Stub the repository methods\n    when(() => mockRepository.getUser(any())).thenAnswer((_) async => User('Test User', 25));\n    when(() => mockRepository.getAllUsers()).thenAnswer((_) async => [\n          User('Test User 1', 20),\n          User('Test User 2', 30),\n        ]);\n\n    // Step 7: Build our widget and trigger a frame\n    await tester.pumpWidget(MaterialApp(home: RealFlutter(userService: userService)));\n\n    // Step 8: Wait for the async operations to complete\n    await tester.pumpAndSettle();\n\n    // Step 9: Verify that the widget displays the correct data\n    expect(find.text('User Name: Test User'), findsOneWidget);\n    expect(find.text('Average Age: 25.0'), findsOneWidget);\n\n    // Step 10: Verify that the repository methods were called\n    verify(() => mockRepository.getUser(any())).called(1);\n    verify(() => mockRepository.getAllUsers()).called(1);\n  });\n}\n\n// Flow of the application:\n// 1. The RealFlutter widget is created with a UserService.\n// 2. In initState, _loadData() is called, which triggers two async operations:\n//    - getUserName(): Fetches a user's name from the repository.\n//    - getAverageAge(): Fetches all users and calculates their average age.\n// 3. The widget's state is updated with the fetched data.\n// 4. The build method renders the user name and average age.\n\n// In the test:\n// 1. We create a mock UserRepository and inject it into a UserService.\n// 2. We stub the getUser and getAllUsers methods to return predefined data.\n// 3. We build the RealFlutter widget with our mocked UserService.\n// 4. We wait for all async operations to complete.\n// 5. We verify that the widget displays the correct data.\n// 6. Finally, we verify that the repository methods were called as expected.\n\n// This example demonstrates how Mocktail can be used to:\n// - Create mocks of complex classes (UserRepository)\n// - Stub method calls to return specific data\n// - Verify that methods are called with the correct arguments\n// - Test asynchronous operations in widgets\n// By using Mocktail, we can thoroughly test our widget's behavior without relying on actual API calls or database operations.\n```",
    "_createdAt": "2024-08-28T22:19:29Z",
    "likesCount": 1038,
    "_id": "Rx1Nho763d29lawKra1mhz",
    "_updatedAt": "2024-09-06T04:11:05Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaPWG",
    "description": "# Mocktail: A Powerful Mocking Framework for Flutter\n\n## Introduction\n\nMocktail is a feature-rich mocking library for Dart and Flutter that simplifies the process of creating mock objects for unit testing. It provides an intuitive API for creating and verifying mocks, making it easier to write robust and maintainable tests for your Flutter applications.\n\n## Key Features\n\n1. **Simple API**: Mocktail offers a straightforward and easy-to-use API that allows developers to create mocks with minimal boilerplate code.\n\n2. **Flexible Mocking**: It supports mocking of classes, abstract classes, and even mixins, giving you the flexibility to mock various components of your application.\n\n3. **Verification**: Mocktail provides powerful verification capabilities, allowing you to ensure that specific methods are called with the expected arguments.\n\n4. **Stubbing**: You can easily stub method calls to return specific values or throw exceptions, enabling you to test different scenarios.\n\n5. **Argument Matchers**: Mocktail includes a wide range of argument matchers, making it easy to verify method calls with complex arguments.\n\n6. **No Code Generation**: Unlike some other mocking libraries, Mocktail doesn't require code generation, which simplifies the development process and reduces build times.\n\n## Why Choose Mocktail?\n\nMocktail stands out from other mocking libraries due to its simplicity and power. It allows developers to write cleaner, more readable test code while providing all the functionality needed for comprehensive unit testing. Whether you're working on a small Flutter project or a large-scale application, Mocktail can help you improve your testing process and ensure the reliability of your code.\n\nIn the following sections, we'll dive deeper into how to use Mocktail in your Flutter projects, providing a tutorial and a comprehensive example to demonstrate its capabilities.",
    "tags": [
      "mock",
      "testing",
      "unit-test",
      "test-double"
    ]
  },
  {
    "packageImage": null,
    "lastUpdate": "2023-06-24T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1msd",
    "_updatedAt": "2024-09-06T04:11:06Z",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "tm6kfzbv"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFqE",
        "_type": "reference",
        "_key": "s1m82nuj"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:loading_indicator/loading_indicator.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Loading Indicator Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const LoadingIndicatorDemo(),\n    );\n  }\n}\n\nclass LoadingIndicatorDemo extends StatefulWidget {\n  const LoadingIndicatorDemo({Key? key}) : super(key: key);\n\n  @override\n  _LoadingIndicatorDemoState createState() => _LoadingIndicatorDemoState();\n}\n\nclass _LoadingIndicatorDemoState extends State<LoadingIndicatorDemo> {\n  // Step 1: Initialize variables\n  Indicator _currentIndicator = Indicator.ballPulse;\n  bool _isLoading = false;\n\n  // Step 2: Create a list of all available indicators\n  final List<Indicator> _indicators = Indicator.values;\n\n  // Step 3: Create a method to toggle loading state\n  void _toggleLoading() {\n    setState(() {\n      _isLoading = !_isLoading;\n    });\n  }\n\n  // Step 4: Create a method to change the current indicator\n  void _changeIndicator() {\n    setState(() {\n      int nextIndex = (_indicators.indexOf(_currentIndicator) + 1) % _indicators.length;\n      _currentIndicator = _indicators[nextIndex];\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Loading Indicator Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 5: Display the current indicator name\n            Text(\n              'Current Indicator: ${_currentIndicator.toString().split('.').last}',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedBox(height: 20),\n            // Step 6: Display the loading indicator when _isLoading is true\n            if (_isLoading)\n              SizedBox(\n                width: 100,\n                height: 100,\n                child: LoadingIndicator(\n                  indicatorType: _currentIndicator,\n                  colors: const [Colors.blue, Colors.red, Colors.green, Colors.yellow],\n                  strokeWidth: 2,\n                  backgroundColor: Colors.transparent,\n                  pathBackgroundColor: Colors.black,\n                ),\n              ),\n            const SizedBox(height: 20),\n            // Step 7: Add buttons to control the demo\n            ElevatedButton(\n              onPressed: _toggleLoading,\n              child: Text(_isLoading ? 'Hide Indicator' : 'Show Indicator'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _changeIndicator,\n              child: const Text('Change Indicator'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp and theme.\n// 2. The LoadingIndicatorDemo widget is created as the home screen.\n// 3. In the LoadingIndicatorDemo, we initialize the state with a default indicator and loading state.\n// 4. The build method creates the UI, which includes:\n//    - An AppBar with the title\n//    - A Column in the body containing:\n//      a. Text showing the current indicator name\n//      b. A LoadingIndicator widget (only shown when _isLoading is true)\n//      c. Two buttons to toggle the loading state and change the indicator\n// 5. When the user taps \"Show Indicator\", _toggleLoading is called, setting _isLoading to true and showing the indicator.\n// 6. When the user taps \"Change Indicator\", _changeIndicator is called, cycling through the list of available indicators.\n// 7. The UI updates reactively based on the state changes, providing an interactive demo of the loading_indicator package.\n\n// This example demonstrates:\n// - How to import and use the loading_indicator package\n// - How to customize the indicator (colors, size, type)\n// - How to create an interactive demo to showcase different indicators\n// - Proper state management in a Flutter application\n```",
    "likesCount": 559,
    "slug": {
      "_type": "slug",
      "current": "loading_indicator"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaPb3",
    "author": "tinocheng.app",
    "_type": "package",
    "description": "# Loading Indicator Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nThe `loading_indicator` package is a powerful and flexible solution for adding visually appealing loading animations to your Flutter applications. This package offers a wide range of customizable loading indicators, allowing developers to enhance the user experience during data fetching, processing, or any other time-consuming operations.\n\n## Key Features\n\n1. **Diverse Indicator Types**: The package includes over 20 different loading indicator styles, from simple spinners to complex animations.\n\n2. **High Customizability**: Developers can easily adjust colors, sizes, and animation speeds to match their app's design language.\n\n3. **Performance Optimized**: Built with efficiency in mind, ensuring smooth animations even on lower-end devices.\n\n4. **Cross-Platform Compatibility**: Works seamlessly on both iOS and Android platforms.\n\n5. **Easy Integration**: Simple to add to any Flutter project with minimal setup required.\n\n## Why Choose Loading Indicator Package?\n\nIn modern app development, providing visual feedback during loading states is crucial for maintaining user engagement. The `loading_indicator` package stands out by offering:\n\n- A wide variety of visually appealing animations\n- Flexibility in customization to match any app theme\n- Lightweight implementation for minimal impact on app performance\n- Regular updates and community support\n\nWhether you're building a simple mobile app or a complex cross-platform application, the `loading_indicator` package provides the tools you need to create a polished and professional user experience.\n\nIn the following sections, we'll dive deeper into how to implement and customize these loading indicators in your Flutter projects.",
    "tags": [
      "loading",
      "progress",
      "indicator",
      "ui",
      "widget"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cakt",
        "_type": "reference",
        "_key": "iip5ccd1"
      }
    ],
    "_createdAt": "2024-08-28T22:19:31Z",
    "name": "loading_indicator",
    "pubPoint": 160,
    "tutorialIncluded": true,
    "tutorial": "# Tutorial: Implementing Loading Indicators in Flutter\n\nThis tutorial will guide you through the process of integrating the `loading_indicator` package into your Flutter application, including platform-specific considerations.\n\n## Step 1: Add the Package to Your Project\n\nAdd the following line to your `pubspec.yaml` file under the `dependencies` section:\n\n```yaml\ndependencies:\n  loading_indicator: ^3.1.0\n```\n\nThen run:\n\n```\nflutter pub get\n```\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:loading_indicator/loading_indicator.dart';\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use a loading indicator:\n\n```dart\nLoadingIndicator(\n    indicatorType: Indicator.ballPulse,\n    colors: const [Colors.white],\n    strokeWidth: 2,\n    backgroundColor: Colors.black,\n    pathBackgroundColor: Colors.black\n)\n```\n\n## Step 4: Customization\n\nYou can customize various aspects of the loading indicator:\n\n```dart\nLoadingIndicator(\n    indicatorType: Indicator.ballRotateChase,\n    colors: const [Colors.red, Colors.green, Colors.blue],\n    strokeWidth: 4.0,\n    backgroundColor: Colors.yellow,\n    pathBackgroundColor: Colors.black\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to use indicators that match the native look and feel:\n\n```dart\nLoadingIndicator(\n    indicatorType: Indicator.lineSpinFadeLoader,\n    colors: const [Colors.blue],\n    strokeWidth: 1,\n    backgroundColor: Colors.transparent,\n)\n```\n\n### Android\n\nFor Android, consider using Material Design inspired indicators:\n\n```dart\nLoadingIndicator(\n    indicatorType: Indicator.ballTrianglePath,\n    colors: const [Colors.deepPurple],\n    strokeWidth: 2,\n    backgroundColor: Colors.transparent,\n)\n```\n\n## Advanced Usage: Responsive Design\n\nTo make your loading indicator responsive, you can use `LayoutBuilder`:\n\n```dart\nLayoutBuilder(\n  builder: (BuildContext context, BoxConstraints constraints) {\n    double size = constraints.maxWidth < 200 ? constraints.maxWidth : 200;\n    return SizedBox(\n      width: size,\n      height: size,\n      child: LoadingIndicator(\n        indicatorType: Indicator.orbit,\n        colors: [Theme.of(context).primaryColor],\n        strokeWidth: 2,\n        backgroundColor: Colors.transparent,\n      ),\n    );\n  },\n)\n```\n\nThis approach ensures that your loading indicator looks great on various screen sizes and orientations.\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize loading indicators in your Flutter application across different platforms.",
    "shortDescription": "A collection loading animations written in pure dart. Out of the box, no extra dependency."
  },
  {
    "tutorialIncluded": true,
    "slug": {
      "current": "loader_overlay",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:loader_overlay/loader_overlay.dart';\nimport 'dart:async';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Wrap the entire app with LoaderOverlay\n    return LoaderOverlay(\n      useDefaultLoading: false,\n      overlayColor: Colors.black.withOpacity(0.7),\n      overlayWidget: Center(\n        child: CircularProgressIndicator(\n          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),\n        ),\n      ),\n      child: MaterialApp(\n        title: 'Loader Overlay Demo',\n        theme: ThemeData(\n          primarySwatch: Colors.blue,\n        ),\n        home: HomePage(),\n      ),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Loader Overlay Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Button to show global overlay\n            ElevatedButton(\n              child: Text('Show Global Overlay'),\n              onPressed: () => _showGlobalOverlay(context),\n            ),\n            SizedBox(height: 20),\n            // Step 3: Local overlay example\n            LoaderOverlay(\n              child: ElevatedButton(\n                child: Text('Show Local Overlay'),\n                onPressed: () => _showLocalOverlay(context),\n              ),\n            ),\n            SizedBox(height: 20),\n            // Step 4: Custom overlay example\n            ElevatedButton(\n              child: Text('Show Custom Overlay'),\n              onPressed: () => _showCustomOverlay(context),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 5: Function to show global overlay\n  void _showGlobalOverlay(BuildContext context) async {\n    context.loaderOverlay.show();\n    // Simulating a task\n    await Future.delayed(Duration(seconds: 3));\n    context.loaderOverlay.hide();\n  }\n\n  // Step 6: Function to show local overlay\n  void _showLocalOverlay(BuildContext context) async {\n    context.loaderOverlay.show();\n    // Simulating a task\n    await Future.delayed(Duration(seconds: 2));\n    context.loaderOverlay.hide();\n  }\n\n  // Step 7: Function to show custom overlay\n  void _showCustomOverlay(BuildContext context) async {\n    context.loaderOverlay.show(widget: _CustomOverlay());\n    // Simulating a task\n    await Future.delayed(Duration(seconds: 4));\n    context.loaderOverlay.hide();\n  }\n}\n\n// Step 8: Custom overlay widget\nclass _CustomOverlay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(16),\n      color: Colors.blue.withOpacity(0.8),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          CircularProgressIndicator(\n            valueColor: AlwaysStoppedAnimation<Color>(Colors.white),\n          ),\n          SizedBox(height: 20),\n          Text(\n            'Loading...',\n            style: TextStyle(color: Colors.white, fontSize: 18),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Flow of the application:\n// 1. The app starts with RealFlutter widget, which wraps the entire app with LoaderOverlay.\n// 2. The HomePage is displayed with three buttons.\n// 3. When \"Show Global Overlay\" is pressed, it shows the default overlay for 3 seconds.\n// 4. When \"Show Local Overlay\" is pressed, it shows a local overlay only for that button for 2 seconds.\n// 5. When \"Show Custom Overlay\" is pressed, it displays a custom overlay with a loading message for 4 seconds.\n// 6. Each overlay is shown using context.loaderOverlay.show() and hidden using context.loaderOverlay.hide().\n// 7. The custom overlay demonstrates how to create and use a completely custom loading widget.\n\n// This example showcases the flexibility of the loader_overlay package,\n// allowing for global, local, and custom overlays with ease.\n```",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "u9lwdwag"
      }
    ],
    "tags": [
      "loading",
      "overlay",
      "progress",
      "ui",
      "widget"
    ],
    "likesCount": 447,
    "dependentPackages": [],
    "author": "rodrigobastos.dev",
    "_rev": "ezMiwuUkJkbYMWycA6RXvY",
    "shortDescription": "A simple package to simplify screen management. When loading any async task, this package prevent the user from interacting with the screen until the async task finishes.",
    "packageImage": null,
    "lastUpdate": "2024-07-21T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:11:07Z",
    "name": "loader_overlay",
    "_id": "Rx1Nho763d29lawKra1n3H",
    "tutorial": "# Tutorial: Implementing Loader Overlay in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the Loader Overlay package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `loader_overlay` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  loader_overlay: ^2.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:loader_overlay/loader_overlay.dart';\n```\n\n2. Wrap your `MaterialApp` or the widget you want to overlay with `LoaderOverlay`:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return LoaderOverlay(\n      child: MaterialApp(\n        home: HomePage(),\n      ),\n    );\n  }\n}\n```\n\n3. Show the overlay when needed:\n\n```dart\ncontext.loaderOverlay.show();\n```\n\n4. Hide the overlay when the operation is complete:\n\n```dart\ncontext.loaderOverlay.hide();\n```\n\n## Step 3: Customization\n\nYou can customize the overlay's appearance:\n\n```dart\nLoaderOverlay(\n  useDefaultLoading: false,\n  overlayColor: Colors.black.withOpacity(0.8),\n  overlayWidget: Center(\n    child: SpinKitCubeGrid(\n      color: Colors.white,\n      size: 50.0,\n    ),\n  ),\n  child: MaterialApp(\n    home: HomePage(),\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to use the native-looking `CupertinoActivityIndicator`:\n\n```dart\noverlayWidget: Center(\n  child: CupertinoActivityIndicator(\n    radius: 20,\n  ),\n),\n```\n\n### Android\n\nFor Android, consider using Material Design's `CircularProgressIndicator`:\n\n```dart\noverlayWidget: Center(\n  child: CircularProgressIndicator(),\n),\n```\n\n### Web\n\nFor web applications, you might want to use a more lightweight loader:\n\n```dart\noverlayWidget: Center(\n  child: Container(\n    width: 50,\n    height: 50,\n    child: CircularProgressIndicator(\n      strokeWidth: 2,\n    ),\n  ),\n),\n```\n\n## Advanced Usage\n\n1. **Local Overlays**: You can create local overlays for specific widgets:\n\n```dart\nLoaderOverlay(\n  child: YourWidget(),\n)\n```\n\n2. **Custom Overlay Widgets**: Use any widget as an overlay:\n\n```dart\ncontext.loaderOverlay.show(widget: YourCustomWidget());\n```\n\n3. **Overlay Opacity**: Adjust the overlay's opacity:\n\n```dart\nLoaderOverlay(\n  overlayOpacity: 0.5,\n  child: YourWidget(),\n)\n```\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize the Loader Overlay package in your Flutter application across different platforms.",
    "description": "# Loader Overlay Package for Flutter: Simplifying Loading States\n\n## Introduction\n\nIn the world of mobile app development, providing a smooth user experience during data loading or processing is crucial. The `loader_overlay` package for Flutter offers an elegant solution to this common challenge. This powerful tool allows developers to easily add a customizable loading overlay to their Flutter applications, enhancing user interaction and feedback.\n\n## What is Loader Overlay?\n\nLoader Overlay is a Flutter package that provides a simple and flexible way to display a loading indicator over your app's content. It's designed to be easily integrated into any Flutter project, offering a range of customization options to match your app's design language.\n\n## Key Features\n\n1. **Easy Integration**: With just a few lines of code, you can wrap your entire app or specific widgets with a loading overlay.\n\n2. **Customizable Appearance**: The package allows you to customize the overlay's color, opacity, and loading indicator.\n\n3. **Flexible Usage**: You can show or hide the overlay programmatically from anywhere in your app.\n\n4. **Built-in Animations**: Smooth fade-in and fade-out animations are included for a polished look.\n\n5. **Overlay Widgets**: Besides the default loading indicator, you can use any custom widget as an overlay.\n\n6. **Global and Local Overlays**: You can have a global overlay for your entire app or local overlays for specific sections.\n\n## Why Use Loader Overlay?\n\n- **Improved User Experience**: By providing visual feedback during loading states, you keep users informed and engaged.\n- **Code Reusability**: Implement a consistent loading UI across your entire app with minimal code duplication.\n- **Time-Saving**: The package handles the complexities of overlay management, allowing you to focus on core app functionality.\n\nIn the following sections, we'll dive into a tutorial on how to implement the Loader Overlay package in your Flutter project, followed by a comprehensive example showcasing its features.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:19:32Z"
  },
  {
    "similarPackages": [],
    "tags": [
      "credit-card",
      "payment",
      "ui",
      "widget",
      "form"
    ],
    "lastUpdate": "2023-10-08T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1nDv",
    "_updatedAt": "2024-09-06T04:11:08Z",
    "pubPoint": 160,
    "author": "simform.com",
    "description": "# Flutter Credit Card Package: An In-Depth Look\n\n## Introduction\n\nIn the world of mobile app development, handling payment information securely and efficiently is crucial. The `flutter_credit_card` package offers Flutter developers a powerful tool to integrate credit card input and display functionality into their applications. This blog post will explore the features, usage, and implementation of this package in detail.\n\n## What is flutter_credit_card?\n\n`flutter_credit_card` is a Flutter package that provides a customizable credit card widget. It allows developers to easily add credit card input forms and display credit card information in their Flutter applications. The package supports various credit card types and offers both form input and display functionalities.\n\n## Key Features\n\n1. **Credit Card Widget**: A customizable widget to display credit card information.\n2. **Credit Card Form**: An easy-to-use form for inputting credit card details.\n3. **Validation**: Built-in validation for credit card numbers, expiry dates, and CVV.\n4. **Customization**: Extensive options to customize the appearance of the credit card widget.\n5. **Animation**: Smooth flip animation between front and back of the card.\n6. **Multi-language Support**: Ability to change the language of the form labels.\n\n## Why Use flutter_credit_card?\n\n- **Ease of Implementation**: Quickly add professional-looking credit card functionality to your app.\n- **Customization**: Tailor the look and feel to match your app's design.\n- **Security**: Helps in implementing secure credit card input without storing sensitive data.\n- **User Experience**: Provides a visually appealing and interactive way for users to input card details.\n\nIn the next sections, we'll dive into a tutorial on how to implement this package in your Flutter project and explore a comprehensive example showcasing all its features.",
    "likesCount": 920,
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:33Z",
    "dependentPackages": [],
    "name": "flutter_credit_card",
    "slug": {
      "current": "flutter_credit_card",
      "_type": "slug"
    },
    "_type": "package",
    "shortDescription": "A Credit Card widget package with support of entering card details, and animations like card flip and float.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_credit_card/flutter_credit_card.dart';\n\nvoid main() => runApp(const RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Credit Card Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const CreditCardDemo(),\n    );\n  }\n}\n\nclass CreditCardDemo extends StatefulWidget {\n  const CreditCardDemo({Key? key}) : super(key: key);\n\n  @override\n  _CreditCardDemoState createState() => _CreditCardDemoState();\n}\n\nclass _CreditCardDemoState extends State<CreditCardDemo> {\n  String cardNumber = '';\n  String expiryDate = '';\n  String cardHolderName = '';\n  String cvvCode = '';\n  bool isCvvFocused = false;\n  bool useGlassMorphism = false;\n  bool useBackgroundImage = false;\n  OutlineInputBorder? border;\n  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n\n  @override\n  void initState() {\n    border = OutlineInputBorder(\n      borderSide: BorderSide(\n        color: Colors.grey.withOpacity(0.7),\n        width: 2.0,\n      ),\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      resizeToAvoidBottomInset: false,\n      body: SafeArea(\n        child: Column(\n          children: <Widget>[\n            const SizedBox(height: 30),\n            // Step 1: CreditCardWidget to display the card\n            CreditCardWidget(\n              cardNumber: cardNumber,\n              expiryDate: expiryDate,\n              cardHolderName: cardHolderName,\n              cvvCode: cvvCode,\n              bankName: 'Real Flutter Bank',\n              showBackView: isCvvFocused,\n              obscureCardNumber: true,\n              obscureCardCvv: true,\n              isHolderNameVisible: true,\n              cardBgColor: Colors.red,\n              backgroundImage:\n                  useBackgroundImage ? 'assets/card_bg.png' : null,\n              isSwipeGestureEnabled: true,\n              onCreditCardWidgetChange: (CreditCardBrand brand) {},\n              customCardTypeIcons: <CustomCardTypeIcon>[\n                CustomCardTypeIcon(\n                  cardType: CardType.mastercard,\n                  cardImage: Image.asset(\n                    'assets/mastercard.png',\n                    height: 48,\n                    width: 48,\n                  ),\n                ),\n              ],\n            ),\n            Expanded(\n              child: SingleChildScrollView(\n                child: Column(\n                  children: <Widget>[\n                    // Step 2: CreditCardForm for input\n                    CreditCardForm(\n                      formKey: formKey,\n                      obscureCvv: true,\n                      obscureNumber: true,\n                      cardNumber: cardNumber,\n                      cvvCode: cvvCode,\n                      isHolderNameVisible: true,\n                      isCardNumberVisible: true,\n                      isExpiryDateVisible: true,\n                      cardHolderName: cardHolderName,\n                      expiryDate: expiryDate,\n                      themeColor: Colors.blue,\n                      textColor: Colors.black,\n                      cardNumberDecoration: InputDecoration(\n                        labelText: 'Number',\n                        hintText: 'XXXX XXXX XXXX XXXX',\n                        focusedBorder: border,\n                        enabledBorder: border,\n                      ),\n                      expiryDateDecoration: InputDecoration(\n                        focusedBorder: border,\n                        enabledBorder: border,\n                        labelText: 'Expired Date',\n                        hintText: 'XX/XX',\n                      ),\n                      cvvCodeDecoration: InputDecoration(\n                        focusedBorder: border,\n                        enabledBorder: border,\n                        labelText: 'CVV',\n                        hintText: 'XXX',\n                      ),\n                      cardHolderDecoration: InputDecoration(\n                        focusedBorder: border,\n                        enabledBorder: border,\n                        labelText: 'Card Holder',\n                      ),\n                      onCreditCardModelChange: onCreditCardModelChange,\n                    ),\n                    const SizedBox(height: 20),\n                    // Step 3: Additional customization options\n                    Row(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: <Widget>[\n                        const Text('Glassmorphism'),\n                        Switch(\n                          value: useGlassMorphism,\n                          onChanged: (bool value) => setState(() {\n                            useGlassMorphism = value;\n                          }),\n                        ),\n                        const Text('Card Background'),\n                        Switch(\n                          value: useBackgroundImage,\n                          onChanged: (bool value) => setState(() {\n                            useBackgroundImage = value;\n                          }),\n                        ),\n                      ],\n                    ),\n                    const SizedBox(height: 20),\n                    ElevatedButton(\n                      style: ElevatedButton.styleFrom(\n                        shape: RoundedRectangleBorder(\n                          borderRadius: BorderRadius.circular(8.0),\n                        ),\n                        primary: const Color(0xff1b447b),\n                      ),\n                      child: Container(\n                        margin: const EdgeInsets.all(12),\n                        child: const Text(\n                          'Validate',\n                          style: TextStyle(\n                            color: Colors.white,\n                            fontFamily: 'halter',\n                            fontSize: 14,\n                            package: 'flutter_credit_card',\n                          ),\n                        ),\n                      ),\n                      onPressed: () {\n                        if (formKey.currentState!.validate()) {\n                          print('valid!');\n                        } else {\n                          print('invalid!');\n                        }\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  void onCreditCardModelChange(CreditCardModel? creditCardModel) {\n    setState(() {\n      cardNumber = creditCardModel!.cardNumber;\n      expiryDate = creditCardModel.expiryDate;\n      cardHolderName = creditCardModel.cardHolderName;\n      cvvCode = creditCardModel.cvvCode;\n      isCvvFocused = creditCardModel.isCvvFocused;\n    });\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter class, which sets up the MaterialApp and theme.\n// 2. The CreditCardDemo widget is the main screen, containing the credit card display and input form.\n// 3. In the build method:\n//    a. CreditCardWidget displays the current card information.\n//    b. CreditCardForm allows users to input card details.\n//    c. Switches allow toggling of glassmorphism effect and background image.\n//    d. A validate button checks if the form input is valid.\n// 4. The onCreditCardModelChange method updates the state when the user inputs data in the form.\n// 5. The app reactively updates the card display as the user types in the form.\n// 6. Validation occurs when the user presses the Validate button, checking if all inputs are correct.\n\n// This example demonstrates all major features of the flutter_credit_card package:\n// - Card display with customizable appearance\n// - Input form with validation\n// - Real-time updates of the card display\n// - Toggle for glassmorphism effect and background image\n// - Custom styling of input decorations\n// - Form validation on button press\n```",
    "tutorial": "# Flutter Credit Card Package: Tutorial\n\nThis tutorial will guide you through the process of integrating the `flutter_credit_card` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `flutter_credit_card` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_credit_card: ^3.0.6\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_credit_card/flutter_credit_card.dart';\n```\n\n## Step 3: Basic Usage\n\n### Displaying a Credit Card\n\nTo display a credit card, use the `CreditCardWidget`:\n\n```dart\nCreditCardWidget(\n  cardNumber: '4111 1111 1111 1111',\n  expiryDate: '12/25',\n  cardHolderName: 'John Doe',\n  cvvCode: '123',\n  showBackView: false,\n  onCreditCardWidgetChange: (CreditCardBrand) {}, // Optional\n)\n```\n\n### Creating a Credit Card Form\n\nTo create an input form for credit card details, use the `CreditCardForm`:\n\n```dart\nCreditCardForm(\n  formKey: formKey, // Required\n  onCreditCardModelChange: (CreditCardModel data) {}, // Required\n  themeColor: Colors.red,\n  obscureCvv: true,\n  obscureNumber: true,\n  isHolderNameVisible: true,\n  isCardNumberVisible: true,\n  isExpiryDateVisible: true,\n  cardNumberDecoration: const InputDecoration(\n    labelText: 'Number',\n    hintText: 'XXXX XXXX XXXX XXXX',\n  ),\n  expiryDateDecoration: const InputDecoration(\n    labelText: 'Expired Date',\n    hintText: 'XX/XX',\n  ),\n  cvvCodeDecoration: const InputDecoration(\n    labelText: 'CVV',\n    hintText: 'XXX',\n  ),\n  cardHolderDecoration: const InputDecoration(\n    labelText: 'Card Holder',\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, no additional configuration is required. The package works out of the box.\n\n### Android\n\nFor Android, you need to ensure that your app's `minSdkVersion` is at least 21. Update your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n        // other configurations...\n    }\n}\n```\n\n### Web\n\nFor web support, add the following script tag to your `web/index.html` file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/creditcardvalidator-js@1.0.1/dist/creditcard.min.js\"></script>\n```\n\n## Customization Tips\n\n1. **Card Background**: Customize the card background using the `cardBgColor` parameter in `CreditCardWidget`.\n2. **Text Colors**: Adjust text colors using parameters like `textColor` and `cursorColor`.\n3. **Animations**: Control animations with the `animate` and `animationDuration` parameters.\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize the `flutter_credit_card` package in your Flutter application.",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaPeF",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "7okwil0y"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "web"
    ]
  },
  {
    "slug": {
      "current": "envied",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaPhR",
    "similarPackages": [],
    "subCategories": [
      {
        "_key": "flvj0sa7",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:envied/envied.dart';\n\n// Step 1: Import the generated env.dart file\nimport 'env/env.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Envied Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const MyHomePage(title: 'Envied Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  // Step 2: Use the environment variables from RealFlutter class\n  final String apiKey = RealFlutter.apiKey;\n  final String apiUrl = RealFlutter.apiUrl;\n  final bool debugMode = RealFlutter.debugMode;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 3: Display the environment variables\n            Text('API Key: $apiKey'),\n            Text('API URL: $apiUrl'),\n            Text('Debug Mode: $debugMode'),\n            // Step 4: Demonstrate conditional rendering based on debug mode\n            if (debugMode)\n              const Text(\n                'Debug mode is enabled',\n                style: TextStyle(color: Colors.red),\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 5: Application flow explanation\n/*\nApplication Flow:\n1. The application starts by running the MyApp widget.\n2. MyApp sets up the MaterialApp with a theme and the MyHomePage as the home widget.\n3. In MyHomePage, we access the environment variables using the RealFlutter class.\n4. The build method of _MyHomePageState creates a Scaffold with an AppBar and a Center widget.\n5. Inside the Center widget, we display the values of our environment variables.\n6. We demonstrate conditional rendering by showing a debug message only if debugMode is true.\n\nSecurity Considerations:\n- The actual values of the environment variables are not hardcoded in this file.\n- The RealFlutter class, generated by Envied, provides type-safe access to the environment variables.\n- If obfuscation is enabled in the Envied configuration, the values will be further protected from reverse engineering.\n\nBest Practices:\n- Always use the RealFlutter class to access environment variables instead of hardcoding them.\n- Keep the .env file out of version control to protect sensitive information.\n- Use different .env files for different environments (development, staging, production).\n*/\n```",
    "_createdAt": "2024-08-28T22:19:35Z",
    "lastUpdate": "2024-04-02T18:30:00.000Z",
    "tutorialIncluded": true,
    "tags": [
      "environment-variables",
      "dotenv",
      "config",
      "secrets"
    ],
    "likesCount": 655,
    "dependentPackages": [],
    "pubPoint": 160,
    "name": "envied",
    "_updatedAt": "2024-09-06T04:11:09Z",
    "tutorial": "# Envied Tutorial: Implementing Secure Environment Variables in Flutter\n\nThis tutorial will guide you through the process of setting up and using the Envied package in your Flutter project. We'll cover installation, configuration, and usage across different platforms.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  envied: ^0.3.0+3\n\ndev_dependencies:\n  envied_generator: ^0.3.0+3\n  build_runner: ^2.3.3\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Create a .env File\n\nIn your project root, create a `.env` file with your environment variables:\n\n```\nAPI_KEY=your_api_key_here\nAPI_URL=https://api.example.com\nDEBUG_MODE=true\n```\n\n## Step 3: Create an Env Class\n\nCreate a new file `lib/env/env.dart`:\n\n```dart\nimport 'package:envied/envied.dart';\n\npart 'env.g.dart';\n\n@Envied(path: '.env')\nabstract class RealFlutter {\n  @EnviedField(varName: 'API_KEY')\n  static const String apiKey = _RealFlutter.apiKey;\n\n  @EnviedField(varName: 'API_URL')\n  static const String apiUrl = _RealFlutter.apiUrl;\n\n  @EnviedField(varName: 'DEBUG_MODE', defaultValue: 'false')\n  static const bool debugMode = _RealFlutter.debugMode;\n}\n```\n\n## Step 4: Generate the Env Class\n\nRun the following command to generate the Envied class:\n\n```\nflutter pub run build_runner build\n```\n\nThis will create the `env.g.dart` file with the generated code.\n\n## Step 5: Using Environment Variables\n\nNow you can use your environment variables in your Flutter app:\n\n```dart\nimport 'package:your_app/env/env.dart';\n\nvoid main() {\n  print(RealFlutter.apiKey);\n  print(RealFlutter.apiUrl);\n  print(RealFlutter.debugMode);\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nNo additional setup is required for Android.\n\n### iOS\n\nFor iOS, you need to add your `.env` file to the Xcode project:\n\n1. Open your iOS project in Xcode.\n2. Right-click on your project in the Project Navigator.\n3. Select \"Add Files to [Your Project Name]\".\n4. Choose your `.env` file and ensure \"Copy items if needed\" is checked.\n5. Add the `.env` file to your `.gitignore` to prevent it from being committed.\n\n### Web\n\nFor web projects, ensure that your `.env` file is not accessible publicly. You may need to configure your web server to block access to the `.env` file.\n\n### Desktop (Windows, macOS, Linux)\n\nNo additional setup is required for desktop platforms.\n\nBy following these steps, you'll have successfully implemented secure environment variable management in your Flutter project using the Envied package.",
    "author": "cinibulk.dev",
    "_type": "package",
    "description": "# Envied: Secure Environment Variable Management for Flutter\n\n## Introduction\n\nIn the world of Flutter development, managing environment variables securely is crucial for protecting sensitive information such as API keys, database credentials, and other configuration details. The `envied` package offers a robust solution to this challenge, providing a type-safe and compile-time constant approach to handling environment variables in Flutter applications.\n\n## Key Features\n\n1. **Type Safety**: Envied generates Dart classes with strong typing, reducing runtime errors related to environment variables.\n2. **Compile-Time Constants**: Variables are generated as compile-time constants, optimizing performance.\n3. **Obfuscation**: Offers optional obfuscation to add an extra layer of security to your sensitive data.\n4. **Multi-Environment Support**: Easily manage different sets of environment variables for various deployment scenarios.\n5. **Code Generation**: Automates the process of creating Dart classes from your `.env` files.\n\n## Why Use Envied?\n\nTraditional methods of handling environment variables in Flutter, such as reading from `.env` files at runtime, can pose security risks and impact performance. Envied addresses these concerns by:\n\n- Eliminating the need to ship `.env` files with your app\n- Reducing the risk of accidentally exposing sensitive data in your codebase\n- Improving app startup time by using compile-time constants\n- Providing a clean, type-safe API for accessing environment variables\n\nIn the following sections, we'll dive into how to set up and use Envied in your Flutter projects, demonstrating its power and flexibility in managing environment variables securely and efficiently.",
    "shortDescription": "Explicitly reads environment variables into a dart file from a .env file for more security and faster start up times.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_id": "Rx1Nho763d29lawKra1nOZ"
  },
  {
    "description": "# Maps Launcher Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `maps_launcher` package is a powerful tool for Flutter developers who want to integrate map functionality into their applications. This package provides a simple and efficient way to launch maps applications on both Android and iOS devices, allowing users to view locations, get directions, and more.\n\n### Key Features:\n\n1. **Cross-Platform Compatibility**: Works seamlessly on both Android and iOS.\n2. **Multiple Map Apps**: Supports various map applications, including Google Maps, Apple Maps, and others.\n3. **Flexible Usage**: Can launch maps with coordinates, addresses, or place names.\n4. **Easy Integration**: Simple to implement with just a few lines of code.\n5. **Customizable**: Allows for customization of map views and markers.\n\n### Why Use Maps Launcher?\n\n- **User Experience**: Provides a native map experience to users.\n- **Efficiency**: Saves development time by utilizing existing map applications.\n- **Reliability**: Leverages well-established mapping services for accurate data.\n\nIn the following sections, we'll dive into a tutorial on how to implement this package and explore a comprehensive example showcasing its features.",
    "_createdAt": "2024-08-28T22:19:36Z",
    "author": "byte-sapling.io",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaqDw",
        "_type": "reference",
        "_key": "z3en37m3"
      }
    ],
    "likesCount": 438,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1K9L",
        "_type": "reference",
        "_key": "m1vpo9pu"
      },
      {
        "_key": "a812ecwo",
        "_ref": "uQRNMiDfrp20RZ8Id8CVGj",
        "_type": "reference"
      }
    ],
    "tutorial": "## 2. Tutorial\n\n### Step 1: Add Dependencies\n\nFirst, add the `maps_launcher` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  maps_launcher: ^2.0.1\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:maps_launcher/maps_launcher.dart';\n```\n\n### Step 3: Implement Map Launching\n\nYou can launch maps using various methods:\n\n#### Launch with Coordinates:\n\n```dart\nMapsLauncher.launchCoordinates(37.4220041, -122.0862462);\n```\n\n#### Launch with Address:\n\n```dart\nMapsLauncher.launchQuery('1600 Amphitheatre Parkway, Mountain View, CA');\n```\n\n### Platform-Specific Considerations\n\n#### Android\n\nFor Android, no additional setup is required. The package will use the default map application on the device.\n\n#### iOS\n\nFor iOS, you need to add the following to your `Info.plist` file:\n\n```xml\n<key>LSApplicationQueriesSchemes</key>\n<array>\n    <string>comgooglemaps</string>\n    <string>maps</string>\n</array>\n```\n\nThis allows your app to query and open Google Maps or Apple Maps.\n\n### Best Practices\n\n1. **Error Handling**: Always wrap map launching calls in a try-catch block to handle potential errors gracefully.\n2. **User Preferences**: Consider allowing users to choose their preferred map application if multiple options are available.\n3. **Fallback Mechanism**: Implement a fallback option, such as opening a web-based map, in case the device doesn't have a compatible maps application.\n\nIn the next section, we'll look at a complete example that demonstrates these concepts in action.",
    "packageImage": null,
    "lastUpdate": "2024-03-02T18:30:00.000Z",
    "name": "maps_launcher",
    "pubPoint": 160,
    "_type": "package",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWSz",
        "_type": "reference",
        "_key": "ktnjy7x2"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "maps",
      "navigation",
      "launcher",
      "geolocation"
    ],
    "_updatedAt": "2024-09-06T04:11:10Z",
    "slug": {
      "current": "maps_launcher",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaPkd",
    "shortDescription": "Simple Flutter plugin to open the maps application (or browser) on all platforms.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:maps_launcher/maps_launcher.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Maps Launcher Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: MapLauncherDemo(),\n    );\n  }\n}\n\nclass MapLauncherDemo extends StatefulWidget {\n  @override\n  _MapLauncherDemoState createState() => _MapLauncherDemoState();\n}\n\nclass _MapLauncherDemoState extends State<MapLauncherDemo> {\n  // Step 1: Define variables for input fields\n  final TextEditingController _latController = TextEditingController();\n  final TextEditingController _lngController = TextEditingController();\n  final TextEditingController _addressController = TextEditingController();\n\n  // Step 2: Create methods to launch maps\n  void _launchCoordinates() {\n    // Step 2.1: Parse input and launch map with coordinates\n    try {\n      double lat = double.parse(_latController.text);\n      double lng = double.parse(_lngController.text);\n      MapsLauncher.launchCoordinates(lat, lng);\n    } catch (e) {\n      _showErrorDialog('Invalid coordinates. Please enter valid numbers.');\n    }\n  }\n\n  void _launchAddress() {\n    // Step 2.2: Launch map with address query\n    if (_addressController.text.isNotEmpty) {\n      MapsLauncher.launchQuery(_addressController.text);\n    } else {\n      _showErrorDialog('Please enter an address.');\n    }\n  }\n\n  // Step 3: Create a method to show error dialogs\n  void _showErrorDialog(String message) {\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: Text('Error'),\n        content: Text(message),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.of(ctx).pop(),\n            child: Text('OK'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 4: Build the UI\n    return Scaffold(\n      appBar: AppBar(title: Text('Maps Launcher Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 4.1: Coordinate input fields\n            TextField(\n              controller: _latController,\n              decoration: InputDecoration(labelText: 'Latitude'),\n              keyboardType: TextInputType.number,\n            ),\n            TextField(\n              controller: _lngController,\n              decoration: InputDecoration(labelText: 'Longitude'),\n              keyboardType: TextInputType.number,\n            ),\n            ElevatedButton(\n              onPressed: _launchCoordinates,\n              child: Text('Launch with Coordinates'),\n            ),\n            SizedBox(height: 20),\n            // Step 4.2: Address input field\n            TextField(\n              controller: _addressController,\n              decoration: InputDecoration(labelText: 'Address'),\n            ),\n            ElevatedButton(\n              onPressed: _launchAddress,\n              child: Text('Launch with Address'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 5: Dispose of controllers\n    _latController.dispose();\n    _lngController.dispose();\n    _addressController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays two sections: one for coordinates and one for addresses.\n// 2. User can enter latitude and longitude in the first section, or an address in the second section.\n// 3. When the user presses \"Launch with Coordinates\":\n//    - The app attempts to parse the input as doubles.\n//    - If successful, it calls MapsLauncher.launchCoordinates() with the parsed values.\n//    - If parsing fails, it shows an error dialog.\n// 4. When the user presses \"Launch with Address\":\n//    - If the address field is not empty, the app calls MapsLauncher.launchQuery() with the entered address.\n//    - If the address field is empty, it shows an error dialog.\n// 5. The maps_launcher package then handles opening the appropriate maps application on the device.\n// 6. Error handling is implemented to provide feedback if inputs are invalid or if map launching fails.\n// 7. The app uses TextEditingControllers for input management, which are properly disposed of when the widget is destroyed.\n\n// Note: This example demonstrates basic usage. In a production app, you might want to add more robust error checking,\n// input validation, and possibly a way to handle cases where no maps application is available on the device.\n```",
    "_id": "Rx1Nho763d29lawKra1nZD",
    "tutorialIncluded": true
  },
  {
    "author": "",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CZDH",
        "_type": "reference",
        "_key": "dwwjj0ih"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:numberpicker/numberpicker.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'NumberPicker Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: NumberPickerDemo(),\n    );\n  }\n}\n\nclass NumberPickerDemo extends StatefulWidget {\n  @override\n  _NumberPickerDemoState createState() => _NumberPickerDemoState();\n}\n\nclass _NumberPickerDemoState extends State<NumberPickerDemo> {\n  // Step 1: Initialize variables for different picker types\n  int _currentIntValue = 10;\n  double _currentDoubleValue = 3.0;\n  int _currentHorizontalIntValue = 10;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('NumberPicker Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Column(\n          children: <Widget>[\n            // Step 2: Implement Integer NumberPicker\n            SizedBox(height: 16),\n            Text('Integer NumberPicker'),\n            NumberPicker(\n              value: _currentIntValue,\n              minValue: 0,\n              maxValue: 100,\n              step: 1,\n              haptics: true,\n              onChanged: (value) => setState(() => _currentIntValue = value),\n            ),\n            SizedBox(height: 32),\n\n            // Step 3: Implement Decimal NumberPicker\n            Text('Decimal NumberPicker'),\n            DecimalNumberPicker(\n              value: _currentDoubleValue,\n              minValue: 0,\n              maxValue: 10,\n              decimalPlaces: 2,\n              onChanged: (value) => setState(() => _currentDoubleValue = value),\n            ),\n            SizedBox(height: 32),\n\n            // Step 4: Implement Horizontal Integer NumberPicker\n            Text('Horizontal Integer NumberPicker'),\n            NumberPicker(\n              value: _currentHorizontalIntValue,\n              minValue: 0,\n              maxValue: 100,\n              step: 10,\n              itemWidth: 80,\n              axis: Axis.horizontal,\n              onChanged: (value) =>\n                  setState(() => _currentHorizontalIntValue = value),\n              decoration: BoxDecoration(\n                borderRadius: BorderRadius.circular(16),\n                border: Border.all(color: Colors.black26),\n              ),\n            ),\n            SizedBox(height: 32),\n\n            // Step 5: Display selected values\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text('Current Int Value: $_currentIntValue'),\n                SizedBox(width: 16),\n                Text('Current Double Value: $_currentDoubleValue'),\n              ],\n            ),\n            Text('Current Horizontal Int Value: $_currentHorizontalIntValue'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 6: Explain the flow of the application\n/*\nApplication Flow:\n1. The app starts with the RealFlutter widget, which sets up the MaterialApp and theme.\n2. The NumberPickerDemo widget is set as the home screen.\n3. In the NumberPickerDemo, we initialize three variables for different types of pickers.\n4. The build method creates a Scaffold with an AppBar and a SingleChildScrollView containing all the pickers.\n5. Three types of NumberPickers are implemented:\n   a. Vertical Integer NumberPicker\n   b. Decimal NumberPicker\n   c. Horizontal Integer NumberPicker\n6. Each NumberPicker is customized with different properties like min/max values, step size, and decorations.\n7. The onChanged callback for each picker updates the corresponding state variable.\n8. At the bottom, we display the current values of all pickers.\n9. As the user interacts with the pickers, the state is updated, and the UI reflects the changes in real-time.\n\nThis example demonstrates the versatility of the NumberPicker package, showing how it can be used for various number selection scenarios in a single app.\n*/\n```",
    "tags": [
      "picker",
      "number",
      "input",
      "ui",
      "widget"
    ],
    "_createdAt": "2024-08-28T22:19:38Z",
    "description": "# NumberPicker Package in Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe NumberPicker package is a versatile and customizable widget for Flutter applications that allows users to select numbers through various intuitive interfaces. It provides a range of picker types, including integer, decimal, and even customizable pickers for specific use cases.\n\n### Key Features:\n\n1. **Multiple Picker Types**: \n   - Integer NumberPicker\n   - Decimal NumberPicker\n   - Infinite Loop NumberPicker\n\n2. **Customization Options**:\n   - Adjustable text style for selected and unselected items\n   - Customizable decoration for the picker\n   - Configurable item count and item extent\n\n3. **Flexibility**:\n   - Vertical and horizontal orientations\n   - Step size configuration for value increments\n   - Minimum and maximum value constraints\n\n4. **Performance**:\n   - Efficient scrolling and rendering\n   - Smooth animations for a polished user experience\n\n5. **Accessibility**:\n   - Support for screen readers\n   - Haptic feedback options\n\nThe NumberPicker package simplifies the implementation of number selection interfaces in Flutter apps, making it an excellent choice for scenarios like setting dates, times, quantities, or any numeric input where a slider or text input might be less user-friendly.\n\nIn the following sections, we'll dive into a tutorial on how to implement the NumberPicker in your Flutter project and explore a comprehensive example showcasing its features.",
    "shortDescription": "NumberPicker is a widget allowing user to choose numbers by scrolling spinners.",
    "subCategories": [
      {
        "_key": "0n4g7682",
        "_ref": "t8DYBEKn49O4mjbyRAfAkO",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "slug": {
      "current": "numberpicker",
      "_type": "slug"
    },
    "pubPoint": 160,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaDn",
        "_type": "reference",
        "_key": "63knqvbp"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPbUDE",
        "_type": "reference",
        "_key": "zz8lae3b"
      }
    ],
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the NumberPicker package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  numberpicker: ^2.1.2\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the package\n\nIn your Dart file, import the NumberPicker package:\n\n```dart\nimport 'package:numberpicker/numberpicker.dart';\n```\n\n### Step 3: Basic Implementation\n\nHere's a simple example of how to use the Integer NumberPicker:\n\n```dart\nint _currentValue = 0;\n\nNumberPicker(\n  value: _currentValue,\n  minValue: 0,\n  maxValue: 100,\n  onChanged: (value) => setState(() => _currentValue = value),\n)\n```\n\n### Step 4: Customization\n\nYou can customize the appearance of the NumberPicker:\n\n```dart\nNumberPicker(\n  value: _currentValue,\n  minValue: 0,\n  maxValue: 100,\n  step: 10,\n  haptics: true,\n  onChanged: (value) => setState(() => _currentValue = value),\n  decoration: BoxDecoration(\n    borderRadius: BorderRadius.circular(16),\n    border: Border.all(color: Colors.black26),\n  ),\n)\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n- Ensure smooth scrolling by setting an appropriate `itemExtent`.\n- Consider using the Cupertino style for a more native iOS look:\n\n```dart\nNumberPicker(\n  value: _currentValue,\n  minValue: 0,\n  maxValue: 100,\n  onChanged: (value) => setState(() => _currentValue = value),\n  textStyle: const TextStyle(color: CupertinoColors.black),\n  selectedTextStyle: const TextStyle(color: CupertinoColors.activeBlue),\n  decoration: BoxDecoration(\n    border: Border(\n      top: BorderSide(color: CupertinoColors.separator),\n      bottom: BorderSide(color: CupertinoColors.separator),\n    ),\n  ),\n)\n```\n\n#### Android\n- Use Material Design theming for consistency with Android guidelines:\n\n```dart\nNumberPicker(\n  value: _currentValue,\n  minValue: 0,\n  maxValue: 100,\n  onChanged: (value) => setState(() => _currentValue = value),\n  textStyle: Theme.of(context).textTheme.bodyText2,\n  selectedTextStyle: Theme.of(context).textTheme.headline6,\n  decoration: BoxDecoration(\n    borderRadius: BorderRadius.circular(8),\n    border: Border.all(color: Theme.of(context).primaryColor),\n  ),\n)\n```\n\n#### Web\n- Ensure proper keyboard navigation support:\n- Implement responsive design for various screen sizes:\n\n```dart\nLayoutBuilder(\n  builder: (BuildContext context, BoxConstraints constraints) {\n    return NumberPicker(\n      value: _currentValue,\n      minValue: 0,\n      maxValue: 100,\n      onChanged: (value) => setState(() => _currentValue = value),\n      itemWidth: constraints.maxWidth > 600 ? 80 : 60,\n      itemHeight: 50,\n      textMapper: (numberText) => numberText.padLeft(3, '0'),\n    );\n  },\n)\n```\n\nBy following these steps and considerations, you can effectively implement and customize the NumberPicker package in your Flutter application across different platforms.",
    "_updatedAt": "2024-09-06T04:11:11Z",
    "tutorialIncluded": true,
    "_rev": "ezMiwuUkJkbYMWycA6RYH8",
    "_type": "package",
    "likesCount": 611,
    "packageImage": null,
    "lastUpdate": "2023-04-10T18:30:00.000Z",
    "name": "numberpicker",
    "_id": "Rx1Nho763d29lawKra1njr"
  },
  {
    "tutorialIncluded": true,
    "subCategories": [
      {
        "_key": "wvey4jsg",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference"
      }
    ],
    "tutorial": "# Custom Refresh Indicator: Implementation Tutorial\n\nIn this tutorial, we'll walk through the process of implementing a custom refresh indicator using the `custom_refresh_indicator` package in Flutter. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `custom_refresh_indicator` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  custom_refresh_indicator: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nHere's a simple example of how to use the `CustomRefreshIndicator` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:custom_refresh_indicator/custom_refresh_indicator.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomRefreshIndicator(\n      onRefresh: () async {\n        // Perform your refresh operation here\n        await Future.delayed(Duration(seconds: 2));\n      },\n      builder: (\n        BuildContext context,\n        Widget child,\n        IndicatorController controller,\n      ) {\n        return Stack(\n          children: <Widget>[\n            child,\n            Positioned(\n              top: 0,\n              left: 0,\n              right: 0,\n              child: AnimatedBuilder(\n                animation: controller,\n                builder: (BuildContext context, _) {\n                  return Container(\n                    height: controller.value * 100,\n                    color: Colors.blue.withOpacity(0.3),\n                    child: Center(\n                      child: Text('Pull to refresh'),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        );\n      },\n      child: ListView.builder(\n        itemCount: 20,\n        itemBuilder: (context, index) => ListTile(\n          title: Text('Item $index'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## Step 3: Platform-Specific Considerations\n\n### iOS-style \"Rubber-band\" Effect\n\nTo implement the iOS-style rubber-band effect, you can use the `StretchMode` parameter:\n\n```dart\nCustomRefreshIndicator(\n  // ... other parameters\n  offsetToArmed: 100.0,\n  stretchMode: StretchMode.adaptiveStretch,\n  // ... rest of your implementation\n)\n```\n\n### Android-style Edge Glow\n\nFor Android-style edge glow, you can customize the `builder` function:\n\n```dart\nbuilder: (context, child, controller) {\n  return Stack(\n    children: [\n      child,\n      if (controller.isLoading)\n        Positioned(\n          top: 0,\n          left: 0,\n          right: 0,\n          child: Container(\n            height: 5,\n            child: LinearProgressIndicator(\n              valueColor: AlwaysStoppedAnimation<Color>(Colors.blue),\n              backgroundColor: Colors.transparent,\n            ),\n          ),\n        ),\n    ],\n  );\n},\n```\n\n## Step 4: Advanced Customization\n\nYou can further customize the refresh indicator by adjusting parameters like `offsetToArmed`, `autoRebuild`, and `leadingScrollIndicatorVisible`. Experiment with these to achieve the desired behavior and appearance.\n\nRemember to test your implementation on both iOS and Android devices to ensure a consistent experience across platforms.\n\nIn the next section, we'll explore a more comprehensive example that demonstrates the full potential of the `custom_refresh_indicator` package.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "slug": {
      "current": "custom_refresh_indicator",
      "_type": "slug"
    },
    "_rev": "ezMiwuUkJkbYMWycA6RYOK",
    "_type": "package",
    "shortDescription": "Widget that makes it easy to implement a custom pull to refresh gesture.",
    "example": "import 'package:flutter/material.dart';\nimport 'package:custom_refresh_indicator/custom_refresh_indicator.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Custom Refresh Indicator Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: CustomRefreshDemo(),\n    );\n  }\n}\n\nclass CustomRefreshDemo extends StatefulWidget {\n  @override\n  _CustomRefreshDemoState createState() => _CustomRefreshDemoState();\n}\n\nclass _CustomRefreshDemoState extends State<CustomRefreshDemo> {\n  List<String> items = List.generate(20, (index) => 'Item ${index + 1}');\n\n  // Step 1: Define a custom indicator\n  Widget _buildIndicator(BuildContext context, IndicatorController controller) {\n    return AnimatedBuilder(\n      animation: controller,\n      builder: (BuildContext context, _) {\n        return Container(\n          height: controller.value * 100, // Adjust height based on pull\n          color: Colors.blue.withOpacity(0.3),\n          child: Center(\n            child: controller.isLoading\n                ? CircularProgressIndicator()\n                : Text('Pull to refresh: ${(controller.value * 100).toInt()}%'),\n          ),\n        );\n      },\n    );\n  }\n\n  // Step 2: Implement refresh logic\n  Future<void> _handleRefresh() async {\n    // Simulate a network request\n    await Future.delayed(Duration(seconds: 2));\n    setState(() {\n      items.insert(0, 'New Item ${items.length + 1}');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Wrap your main content with CustomRefreshIndicator\n    return Scaffold(\n      appBar: AppBar(title: Text('Custom Refresh Indicator Demo')),\n      body: CustomRefreshIndicator(\n        onRefresh: _handleRefresh,\n        builder: (BuildContext context, Widget child,\n            IndicatorController controller) {\n          return Stack(\n            children: <Widget>[\n              child,\n              Positioned(\n                top: 0,\n                left: 0,\n                right: 0,\n                child: _buildIndicator(context, controller),\n              ),\n            ],\n          );\n        },\n        // Step 4: Configure advanced options\n        offsetToArmed: 100.0, // Distance to pull before refresh triggers\n        autoRebuild: true, // Automatically rebuild on state changes\n        strokeWidth: 2.0, // Width of the progress indicator stroke\n        leadingScrollIndicatorVisible: false, // Hide the leading scroll indicator\n        child: ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (context, index) => ListTile(\n            title: Text(items[index]),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a list of items.\n// 2. When the user pulls down on the list, the custom indicator appears and grows based on the pull distance.\n// 3. If the user pulls past the 'offsetToArmed' threshold (100.0 in this case), releasing will trigger a refresh.\n// 4. During refresh, the indicator shows a loading animation.\n// 5. After the refresh completes, a new item is added to the top of the list.\n// 6. The list automatically updates due to the setState() call in _handleRefresh().\n\n// Key Points:\n// - The CustomRefreshIndicator wraps the main content (ListView in this case).\n// - The builder function allows for complete customization of the indicator's appearance.\n// - The onRefresh callback handles the actual data refresh logic.\n// - Advanced options like offsetToArmed and autoRebuild provide fine-grained control over the refresh behavior.\n// - The stack in the builder function ensures the indicator appears above the main content.\n\n// This example demonstrates a basic implementation. You can further customize the indicator's\n// appearance, add animations, or implement platform-specific behaviors as needed.",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-8f4e4fd1c96e4a91101a6384f6dbdd8d072039ad-750x750-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:19:43Z",
    "lastUpdate": "2024-07-17T18:30:00.000Z",
    "name": "custom_refresh_indicator",
    "pubPoint": 160,
    "author": "klyta.it",
    "_updatedAt": "2024-09-06T04:11:12Z",
    "likesCount": 759,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "abuhngrs",
        "_ref": "uQRNMiDfrp20RZ8Id8CWqB"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "m7adxxlu"
      }
    ],
    "_id": "Rx1Nho763d29lawKra1ny3",
    "description": "# Custom Refresh Indicator: Elevate Your Flutter App's Refresh Experience\n\nIn the world of mobile app development, user experience is paramount. One of the most common interactions users have with apps is refreshing content. Flutter, Google's UI toolkit for building natively compiled applications, offers a default refresh indicator. However, for developers looking to create a unique and branded experience, the `custom_refresh_indicator` package is a game-changer.\n\n## What is custom_refresh_indicator?\n\nThe `custom_refresh_indicator` package is a powerful tool that allows Flutter developers to create highly customizable refresh indicators. Unlike the standard RefreshIndicator widget, this package provides complete control over the indicator's appearance and behavior.\n\n## Key Features\n\n1. **Full Customization**: Design your refresh indicator from scratch or modify existing ones to match your app's theme.\n2. **Flexible Animations**: Create complex animations that respond to the user's pull-to-refresh gesture.\n3. **Multi-directional Support**: Implement refresh indicators that work with various scroll directions.\n4. **Platform-specific Behaviors**: Easily implement iOS-style \"rubber-band\" effects or Android-style edge glow.\n5. **Advanced Control**: Fine-tune the refresh trigger threshold and animation durations.\n\n## Why Use custom_refresh_indicator?\n\n1. **Brand Consistency**: Create a refresh experience that aligns perfectly with your app's design language.\n2. **Enhanced User Engagement**: Delight users with interactive and visually appealing refresh animations.\n3. **Performance**: The package is optimized for smooth performance, even with complex animations.\n4. **Flexibility**: Adapt the refresh indicator to various use cases, from simple lists to complex data visualizations.\n\nIn the following sections, we'll dive into a tutorial on how to implement the `custom_refresh_indicator` package and explore a comprehensive example showcasing its features.",
    "tags": [
      "widget",
      "animation",
      "pull-to-refresh",
      "refresh-indicator",
      "p2r",
      "custom"
    ]
  },
  {
    "similarPackages": [
      {
        "_key": "egp9gp41",
        "_ref": "uQRNMiDfrp20RZ8Id8CfnT",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "tags": [
      "interop",
      "ffi",
      "codegen",
      "native",
      "bindings"
    ],
    "_id": "Rx1Nho763d29lawKra1o8h",
    "pubPoint": 160,
    "author": "dart.dev",
    "tutorial": "# FFI in Flutter: A Comprehensive Tutorial\n\nThis tutorial will guide you through the process of implementing FFI in your Flutter project, including platform-specific details.\n\n## Step 1: Set Up Your Project\n\n1. Create a new Flutter project:\n   ```\n   flutter create ffi_demo\n   cd ffi_demo\n   ```\n\n2. Add the FFI package to your `pubspec.yaml`:\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     ffi: ^2.0.1\n   ```\n\n3. Run `flutter pub get` to install the dependencies.\n\n## Step 2: Create C Library\n\nCreate a `native` directory in your project root and add a C file:\n\n```c\n// native/math_operations.c\n#include <stdint.h>\n\nint32_t add(int32_t a, int32_t b) {\n    return a + b;\n}\n```\n\n## Step 3: Compile C Library\n\n### For Android:\n\n1. Create an Android.mk file in the `native` directory:\n   ```makefile\n   LOCAL_PATH := $(call my-dir)\n\n   include $(CLEAR_VARS)\n   LOCAL_MODULE := math_operations\n   LOCAL_SRC_FILES := math_operations.c\n   include $(BUILD_SHARED_LIBRARY)\n   ```\n\n2. Create an Application.mk file:\n   ```makefile\n   APP_ABI := armeabi-v7a arm64-v8a x86 x86_64\n   APP_PLATFORM := android-21\n   ```\n\n3. Compile the library:\n   ```\n   cd native\n   ndk-build\n   ```\n\n### For iOS:\n\n1. Compile the C file:\n   ```\n   clang -c math_operations.c -o math_operations.o\n   ```\n\n2. Create a static library:\n   ```\n   ar rcs libmath_operations.a math_operations.o\n   ```\n\n## Step 4: Load the Library in Dart\n\nCreate a new file `lib/ffi_bridge.dart`:\n\n```dart\nimport 'dart:ffi' as ffi;\nimport 'dart:io' show Platform;\n\nclass RealFlutter {\n  late ffi.DynamicLibrary _nativeLib;\n  late ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;\n\n  RealFlutter() {\n    _nativeLib = _openLibrary();\n    _lookup = _nativeLib.lookup;\n  }\n\n  ffi.DynamicLibrary _openLibrary() {\n    if (Platform.isAndroid) {\n      return ffi.DynamicLibrary.open('libmath_operations.so');\n    } else if (Platform.isIOS) {\n      return ffi.DynamicLibrary.process();\n    }\n    throw UnsupportedError('Unsupported platform');\n  }\n\n  int add(int a, int b) {\n    final addFunc = _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>('add')\n        .asFunction<int Function(int, int)>();\n    return addFunc(a, b);\n  }\n}\n```\n\nThis code sets up the FFI bridge, loads the native library, and defines a method to call the C function.\n\n## Step 5: Use the FFI Bridge in Your Flutter App\n\nUpdate your `lib/main.dart` to use the FFI bridge:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'ffi_bridge.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  final RealFlutter _ffi = RealFlutter();\n  int _result = 0;\n\n  void _calculateSum() {\n    setState(() {\n      _result = _ffi.add(5, 3);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('FFI Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Result: $_result'),\n            ElevatedButton(\n              onPressed: _calculateSum,\n              child: Text('Calculate 5 + 3'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis example demonstrates how to use the FFI bridge in a Flutter app to perform a simple addition operation using the native C function.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:13Z",
    "slug": {
      "current": "ffi",
      "_type": "slug"
    },
    "example": "```\nimport 'dart:ffi' as ffi;\nimport 'dart:io' show Platform;\nimport 'package:flutter/material.dart';\n\n// Step 1: Define the FFI signatures for C functions\ntypedef AddFunc = ffi.Int32 Function(ffi.Int32 a, ffi.Int32 b);\ntypedef AddFuncDart = int Function(int a, int b);\n\ntypedef MultiplyFunc = ffi.Float Function(ffi.Float a, ffi.Float b);\ntypedef MultiplyFuncDart = double Function(double a, double b);\n\ntypedef ConcatStringsFunc = ffi.Pointer<ffi.Char> Function(\n    ffi.Pointer<ffi.Char> a, ffi.Pointer<ffi.Char> b);\ntypedef ConcatStringsFuncDart = ffi.Pointer<ffi.Char> Function(\n    ffi.Pointer<ffi.Char> a, ffi.Pointer<ffi.Char> b);\n\nclass RealFlutter {\n  late ffi.DynamicLibrary _nativeLib;\n  late ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)\n      _lookup;\n\n  // Step 2: Initialize the FFI bridge\n  RealFlutter() {\n    _nativeLib = _openLibrary();\n    _lookup = _nativeLib.lookup;\n  }\n\n  // Step 3: Open the native library based on the platform\n  ffi.DynamicLibrary _openLibrary() {\n    if (Platform.isAndroid) {\n      return ffi.DynamicLibrary.open('libmath_operations.so');\n    } else if (Platform.isIOS) {\n      return ffi.DynamicLibrary.process();\n    }\n    throw UnsupportedError('Unsupported platform');\n  }\n\n  // Step 4: Implement methods to call C functions\n  int add(int a, int b) {\n    final addFunc = _lookup<ffi.NativeFunction<AddFunc>>('add')\n        .asFunction<AddFuncDart>();\n    return addFunc(a, b);\n  }\n\n  double multiply(double a, double b) {\n    final multiplyFunc = _lookup<ffi.NativeFunction<MultiplyFunc>>('multiply')\n        .asFunction<MultiplyFuncDart>();\n    return multiplyFunc(a, b);\n  }\n\n  String concatenateStrings(String a, String b) {\n    final concatFunc =\n        _lookup<ffi.NativeFunction<ConcatStringsFunc>>('concatenate_strings')\n            .asFunction<ConcatStringsFuncDart>();\n\n    final aPointer = a.toNativeUtf8();\n    final bPointer = b.toNativeUtf8();\n\n    final resultPointer = concatFunc(aPointer, bPointer);\n    final result = resultPointer.toDartString();\n\n    // Free allocated memory\n    ffi.calloc.free(aPointer);\n    ffi.calloc.free(bPointer);\n    ffi.calloc.free(resultPointer);\n\n    return result;\n  }\n}\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter FFI Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  final RealFlutter _ffi = RealFlutter();\n  int _addResult = 0;\n  double _multiplyResult = 0;\n  String _concatResult = '';\n\n  // Step 5: Implement UI interaction methods\n  void _performAddition() {\n    setState(() {\n      _addResult = _ffi.add(5, 3);\n    });\n  }\n\n  void _performMultiplication() {\n    setState(() {\n      _multiplyResult = _ffi.multiply(2.5, 3.0);\n    });\n  }\n\n  void _performConcatenation() {\n    setState(() {\n      _concatResult = _ffi.concatenateStrings(\"Hello, \", \"World!\");\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('FFI Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Addition Result: $_addResult'),\n            ElevatedButton(\n              onPressed: _performAddition,\n              child: Text('Add 5 + 3'),\n            ),\n            SizedBox(height: 20),\n            Text('Multiplication Result: $_multiplyResult'),\n            ElevatedButton(\n              onPressed: _performMultiplication,\n              child: Text('Multiply 2.5 * 3.0'),\n            ),\n            SizedBox(height: 20),\n            Text('Concatenation Result: $_concatResult'),\n            ElevatedButton(\n              onPressed: _performConcatenation,\n              child: Text('Concatenate \"Hello, \" and \"World!\"'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 6: Application Flow Explanation\n/*\n1. The application starts by initializing the RealFlutter class, which sets up the FFI bridge.\n2. The main screen (HomePage) is displayed with three sections, each demonstrating a different FFI operation.\n3. When a user presses a button:\n   a. The corresponding method in the _HomePageState class is called.\n   b. This method invokes the appropriate function in the RealFlutter class.\n   c. The RealFlutter class uses FFI to call the native C function.\n   d. The result is returned and stored in the state.\n   e. setState() is called to update the UI with the new result.\n4. The process repeats for each operation (addition, multiplication, concatenation).\n\nThis example demonstrates three key features of FFI:\n- Calling a simple integer operation (addition)\n- Working with floating-point numbers (multiplication)\n- Handling strings, which requires manual memory management\n\nThe RealFlutter class encapsulates all FFI-related operations, providing a clean interface for the rest of the application to use native functions without directly dealing with FFI complexities.\n*/\n```",
    "_createdAt": "2024-08-28T22:19:45Z",
    "packageImage": null,
    "name": "ffi",
    "_type": "package",
    "description": "# FFI in Flutter: Bridging Dart and Native Code\n\nFlutter's Foreign Function Interface (FFI) package is a powerful tool that allows developers to call native C functions directly from Dart code. This capability is essential for scenarios where you need to interact with platform-specific APIs or leverage existing C libraries for performance-critical operations.\n\n## Key Features of Flutter FFI\n\n1. **Direct C Function Calls**: FFI enables Dart code to call C functions without the overhead of method channels.\n\n2. **Performance Boost**: For computationally intensive tasks, FFI can significantly improve performance by leveraging native code.\n\n3. **Platform-Specific Functionality**: Access platform-specific APIs that are not available through Flutter's standard plugins.\n\n4. **Legacy Code Integration**: Easily integrate existing C libraries into your Flutter projects.\n\n5. **Type Safety**: The `dart:ffi` library provides type-safe bindings between Dart and C.\n\n## When to Use FFI\n\n- When you need to perform CPU-intensive calculations\n- For accessing platform-specific APIs not covered by existing Flutter plugins\n- To integrate legacy C libraries into your Flutter application\n- When you require lower-level system access\n\nBy using FFI, developers can create more powerful and efficient Flutter applications that can fully utilize the capabilities of the underlying platform.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXwR",
        "_type": "reference",
        "_key": "str5qowa"
      }
    ],
    "likesCount": 277,
    "dependentPackages": [
      {
        "_key": "ek8g2n69",
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPah4K",
        "_type": "reference",
        "_key": "xg69e5fw"
      }
    ],
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "_rev": "ezMiwuUkJkbYMWycA6RYVW",
    "shortDescription": "Utilities for working with Foreign Function Interface (FFI) code."
  },
  {
    "_updatedAt": "2024-09-06T04:11:14Z",
    "shortDescription": "This package allows you to draw dotted lines with Flutter. You can draw a beautiful dotted line.",
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:dotted_line/dotted_line.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Dotted Line Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: DottedLineDemo(),\n    );\n  }\n}\n\nclass DottedLineDemo extends StatefulWidget {\n  @override\n  _DottedLineDemoState createState() => _DottedLineDemoState();\n}\n\nclass _DottedLineDemoState extends State<DottedLineDemo> {\n  // Step 1: Initialize variables for customization\n  double _lineThickness = 1.0;\n  double _dashLength = 4.0;\n  double _dashGapLength = 4.0;\n  Color _dashColor = Colors.black;\n  Color _dashGapColor = Colors.transparent;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Dotted Line Demo')),\n      body: SingleChildScrollView(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 2: Display a basic horizontal dotted line\n            Text('Basic Horizontal Dotted Line', style: TextStyle(fontWeight: FontWeight.bold)),\n            SizedBox(height: 10),\n            DottedLine(),\n            SizedBox(height: 20),\n\n            // Step 3: Display a vertical dotted line\n            Text('Vertical Dotted Line', style: TextStyle(fontWeight: FontWeight.bold)),\n            SizedBox(height: 10),\n            Container(\n              height: 100,\n              child: DottedLine(\n                direction: Axis.vertical,\n                lineLength: 100,\n              ),\n            ),\n            SizedBox(height: 20),\n\n            // Step 4: Display a customized dotted line\n            Text('Customized Dotted Line', style: TextStyle(fontWeight: FontWeight.bold)),\n            SizedBox(height: 10),\n            DottedLine(\n              lineThickness: _lineThickness,\n              dashLength: _dashLength,\n              dashColor: _dashColor,\n              dashGapLength: _dashGapLength,\n              dashGapColor: _dashGapColor,\n            ),\n            SizedBox(height: 20),\n\n            // Step 5: Add sliders for customization\n            Text('Customize the Dotted Line', style: TextStyle(fontWeight: FontWeight.bold)),\n            SizedBox(height: 10),\n            _buildSlider('Line Thickness', _lineThickness, 1.0, 10.0, (value) {\n              setState(() => _lineThickness = value);\n            }),\n            _buildSlider('Dash Length', _dashLength, 1.0, 20.0, (value) {\n              setState(() => _dashLength = value);\n            }),\n            _buildSlider('Dash Gap Length', _dashGapLength, 1.0, 20.0, (value) {\n              setState(() => _dashGapLength = value);\n            }),\n            SizedBox(height: 10),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: () => setState(() => _dashColor = Colors.blue),\n                  child: Text('Blue Dash'),\n                ),\n                ElevatedButton(\n                  onPressed: () => setState(() => _dashColor = Colors.red),\n                  child: Text('Red Dash'),\n                ),\n                ElevatedButton(\n                  onPressed: () => setState(() => _dashGapColor = Colors.grey.withOpacity(0.3)),\n                  child: Text('Grey Gap'),\n                ),\n                ElevatedButton(\n                  onPressed: () => setState(() => _dashGapColor = Colors.transparent),\n                  child: Text('Clear Gap'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 6: Helper method to build sliders\n  Widget _buildSlider(String label, double value, double min, double max, ValueChanged<double> onChanged) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label),\n        Slider(\n          value: value,\n          min: min,\n          max: max,\n          divisions: ((max - min) * 10).toInt(),\n          label: value.toStringAsFixed(1),\n          onChanged: onChanged,\n        ),\n      ],\n    );\n  }\n}\n\n// Application flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The DottedLineDemo widget is the main screen, containing various examples of dotted lines.\n// 3. The screen displays different types of dotted lines: basic horizontal, vertical, and customized.\n// 4. Users can interact with sliders and buttons to customize the appearance of the dotted line in real-time.\n// 5. The setState method is called whenever a customization option is changed, triggering a rebuild of the widget tree.\n// 6. The customized dotted line updates immediately to reflect the new settings.\n// 7. This interactive demo allows users to experiment with different configurations of the dotted_line package.\n```",
    "tags": [
      "ui",
      "widget",
      "decoration",
      "custom-paint"
    ],
    "likesCount": 275,
    "lastUpdate": "2023-06-12T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1oJL",
    "pubPoint": 160,
    "description": "# Dotted Line Package for Flutter: An Overview\n\nThe `dotted_line` package is a versatile Flutter library that allows developers to easily create customizable dotted lines in their applications. This package is particularly useful for creating visually appealing separators, borders, or decorative elements in your Flutter UI.\n\n## Key Features\n\n1. **Customizable Appearance**: Adjust the line color, thickness, dash length, and space between dashes to suit your design needs.\n\n2. **Flexible Orientation**: Create both horizontal and vertical dotted lines with ease.\n\n3. **Responsive Design**: The package automatically adjusts the number of dashes based on the available space, ensuring consistent appearance across different screen sizes.\n\n4. **Lightweight**: With minimal dependencies, the `dotted_line` package adds negligible overhead to your Flutter project.\n\n5. **Easy Integration**: Simple to incorporate into existing Flutter projects with just a few lines of code.\n\n## Use Cases\n\n- Creating stylish dividers between list items\n- Adding decorative borders to containers or cards\n- Designing custom progress indicators\n- Enhancing UI elements in forms or data entry screens\n\nThe `dotted_line` package offers a simple yet powerful way to elevate the visual appeal of your Flutter applications. In the following sections, we'll explore how to implement and customize dotted lines in your projects.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "slug": {
      "current": "dotted_line",
      "_type": "slug"
    },
    "author": "",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "1j1dhktd"
      }
    ],
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:19:46Z",
    "tutorial": "# Dotted Line Package: A Step-by-Step Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the `dotted_line` package in a Flutter project. We'll cover installation, basic usage, and customization options.\n\n## Step 1: Installation\n\nAdd the `dotted_line` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  dotted_line: ^3.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:dotted_line/dotted_line.dart';\n```\n\n## Step 3: Basic Usage\n\nTo create a simple dotted line, use the `DottedLine` widget:\n\n```dart\nDottedLine()\n```\n\nThis will create a horizontal dotted line with default settings.\n\n## Step 4: Customization\n\nThe `DottedLine` widget offers several parameters for customization:\n\n```dart\nDottedLine(\n  direction: Axis.horizontal,\n  lineLength: double.infinity,\n  lineThickness: 1.0,\n  dashLength: 4.0,\n  dashColor: Colors.black,\n  dashRadius: 0.0,\n  dashGapLength: 4.0,\n  dashGapColor: Colors.transparent,\n  dashGapRadius: 0.0,\n)\n```\n\n- `direction`: Set to `Axis.horizontal` for horizontal lines or `Axis.vertical` for vertical lines.\n- `lineLength`: Total length of the line (use `double.infinity` for full width/height).\n- `lineThickness`: Thickness of the line.\n- `dashLength`: Length of each dash.\n- `dashColor`: Color of the dashes.\n- `dashRadius`: Radius for rounded dash corners.\n- `dashGapLength`: Length of gaps between dashes.\n- `dashGapColor`: Color of the gaps (usually transparent).\n- `dashGapRadius`: Radius for rounded gap corners.\n\n## Step 5: Platform-Specific Considerations\n\n### iOS\nFor iOS, ensure that your `Info.plist` file has the necessary permissions if you're using the dotted line in conjunction with other features (e.g., if you're drawing on a canvas):\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for saving screenshots.</string>\n```\n\n### Android\nFor Android, no specific configuration is needed for the `dotted_line` package. However, if you're using it with other drawing features, you might need to add permissions to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n```\n\n## Step 6: Example Usage\n\nHere's a simple example of how to use the `DottedLine` widget in a Flutter app:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:dotted_line/dotted_line.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Dotted Line Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Horizontal Dotted Line'),\n            SizedBox(height: 10),\n            DottedLine(),\n            SizedBox(height: 20),\n            Text('Vertical Dotted Line'),\n            SizedBox(height: 10),\n            Container(\n              height: 100,\n              child: DottedLine(\n                direction: Axis.vertical,\n                lineLength: 100,\n                lineThickness: 2.0,\n                dashLength: 4.0,\n                dashColor: Colors.blue,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis example demonstrates both horizontal and vertical dotted lines with different customizations. Experiment with the parameters to achieve the desired look for your app!",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaPsc",
    "packageImage": null,
    "name": "dotted_line"
  },
  {
    "packageImage": null,
    "lastUpdate": "2024-08-04T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1oTz",
    "_updatedAt": "2024-09-06T04:11:15Z",
    "author": "quis.co",
    "_rev": "AE3hjGWNkNE6aGQMMbaPvo",
    "_type": "package",
    "platforms": [
      "android",
      "ios"
    ],
    "slug": {
      "current": "flutter_contacts",
      "_type": "slug"
    },
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_contacts/flutter_contacts.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  List<Contact> _contacts = [];\n  bool _permissionDenied = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _fetchContacts();\n  }\n\n  // Step 1: Request permission and fetch contacts\n  Future<void> _fetchContacts() async {\n    if (!await FlutterContacts.requestPermission(readonly: true)) {\n      setState(() => _permissionDenied = true);\n      return;\n    }\n\n    final contacts = await FlutterContacts.getContacts(\n      withProperties: true,\n      withPhoto: true,\n    );\n    setState(() => _contacts = contacts);\n  }\n\n  // Step 2: Create a new contact\n  Future<void> _addContact() async {\n    final newContact = Contact()\n      ..name.first = 'John'\n      ..name.last = 'Doe'\n      ..phones = [Phone('1234567890')];\n\n    await newContact.insert();\n    _fetchContacts(); // Refresh the contact list\n  }\n\n  // Step 3: Update a contact\n  Future<void> _updateContact(Contact contact) async {\n    contact.name.first = 'Updated';\n    await contact.update();\n    _fetchContacts(); // Refresh the contact list\n  }\n\n  // Step 4: Delete a contact\n  Future<void> _deleteContact(Contact contact) async {\n    await contact.delete();\n    _fetchContacts(); // Refresh the contact list\n  }\n\n  // Step 5: View contact details\n  void _viewContactDetails(BuildContext context, Contact contact) async {\n    final fullContact = await FlutterContacts.getContact(contact.id);\n    Navigator.of(context).push(\n      MaterialPageRoute(\n        builder: (_) => ContactDetailsPage(contact: fullContact!),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_permissionDenied) {\n      return Center(child: Text('Permission denied'));\n    }\n\n    if (_contacts.isEmpty) {\n      return Center(child: CircularProgressIndicator());\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Contacts')),\n      body: ListView.builder(\n        itemCount: _contacts.length,\n        itemBuilder: (context, i) => ListTile(\n          leading: _contacts[i].photo == null\n              ? null\n              : CircleAvatar(backgroundImage: MemoryImage(_contacts[i].photo!)),\n          title: Text(_contacts[i].displayName),\n          onTap: () => _viewContactDetails(context, _contacts[i]),\n          trailing: Row(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              IconButton(\n                icon: Icon(Icons.edit),\n                onPressed: () => _updateContact(_contacts[i]),\n              ),\n              IconButton(\n                icon: Icon(Icons.delete),\n                onPressed: () => _deleteContact(_contacts[i]),\n              ),\n            ],\n          ),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addContact,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\nclass ContactDetailsPage extends StatelessWidget {\n  final Contact contact;\n\n  ContactDetailsPage({required this.contact});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(contact.displayName)),\n      body: ListView(\n        children: [\n          ListTile(\n            title: Text('Name'),\n            subtitle: Text('${contact.name.first} ${contact.name.last}'),\n          ),\n          ...contact.phones.map((phone) => ListTile(\n                title: Text('Phone'),\n                subtitle: Text(phone.number),\n              )),\n          ...contact.emails.map((email) => ListTile(\n                title: Text('Email'),\n                subtitle: Text(email.address),\n              )),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and immediately requests contact permissions.\n// 2. If permission is granted, it fetches all contacts and displays them in a list.\n// 3. Each contact in the list can be tapped to view details, updated, or deleted.\n// 4. The floating action button allows adding a new contact.\n// 5. When a contact is tapped, a new page opens showing more detailed information.\n\n// The RealFlutter class manages the main functionality:\n// - _fetchContacts(): Requests permission and retrieves all contacts.\n// - _addContact(): Creates a new contact with sample data.\n// - _updateContact(): Updates the first name of a contact.\n// - _deleteContact(): Removes a contact from the device.\n// - _viewContactDetails(): Opens a new page with detailed contact information.\n\n// The build method creates the UI, showing either an error message if permission\n// is denied, a loading indicator while fetching contacts, or the list of contacts.\n\n// The ContactDetailsPage is a separate widget that displays detailed information\n// for a single contact, including name, phone numbers, and email addresses.\n\n// This example demonstrates the core features of the flutter_contacts package,\n// including reading, creating, updating, and deleting contacts, as well as\n// handling permissions and displaying contact photos.\n```",
    "tags": [
      "contacts",
      "address-book",
      "phone",
      "permission"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7E4",
        "_type": "reference",
        "_key": "ta2prfk1"
      },
      {
        "_type": "reference",
        "_key": "9n22nyl4",
        "_ref": "uQRNMiDfrp20RZ8Id8CVRl"
      }
    ],
    "tutorial": "## 2. Tutorial\n\nIn this section, we'll walk through the process of integrating and using the `flutter_contacts` package in your Flutter application. We'll cover installation, permission handling, and basic CRUD operations.\n\n### Step 1: Installation\n\nAdd the `flutter_contacts` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_contacts: ^1.1.5\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_contacts/flutter_contacts.dart';\n```\n\n### Step 3: Request Permissions\n\nBefore accessing contacts, you need to request permissions from the user. Here's how to do it:\n\n```dart\nclass RealFlutter {\n  Future<void> requestContactPermission() async {\n    if (await FlutterContacts.requestPermission()) {\n      // Permission granted, proceed with contact operations\n    } else {\n      // Permission denied, handle accordingly\n    }\n  }\n}\n```\n\n### Step 4: Fetching Contacts\n\nTo retrieve all contacts:\n\n```dart\nclass RealFlutter {\n  Future<List<Contact>> getAllContacts() async {\n    return await FlutterContacts.getContacts(withProperties: true, withPhoto: true);\n  }\n}\n```\n\n### Step 5: Creating a New Contact\n\nHere's how to create a new contact:\n\n```dart\nclass RealFlutter {\n  Future<void> createNewContact() async {\n    final newContact = Contact()\n      ..name.first = 'John'\n      ..name.last = 'Doe'\n      ..phones = [Phone('1234567890')];\n    \n    await newContact.insert();\n  }\n}\n```\n\n### Step 6: Updating a Contact\n\nTo update an existing contact:\n\n```dart\nclass RealFlutter {\n  Future<void> updateContact(Contact contact) async {\n    contact.name.first = 'Jane';\n    await contact.update();\n  }\n}\n```\n\n### Step 7: Deleting a Contact\n\nTo delete a contact:\n\n```dart\nclass RealFlutter {\n  Future<void> deleteContact(Contact contact) async {\n    await contact.delete();\n  }\n}\n```\n\n### Platform-Specific Considerations\n\n#### Android\n- Add the following permission to your `AndroidManifest.xml`:\n  ```xml\n  <uses-permission android:name=\"android.permission.READ_CONTACTS\" />\n  <uses-permission android:name=\"android.permission.WRITE_CONTACTS\" />\n  ```\n\n#### iOS\n- Add the following keys to your `Info.plist`:\n  ```xml\n  <key>NSContactsUsageDescription</key>\n  <string>This app requires contacts access to function properly.</string>\n  ```\n\nBy following these steps, you'll have a basic implementation of contact management in your Flutter application using the `flutter_contacts` package. In the next section, we'll look at a more comprehensive example that demonstrates all the features of this package.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "description": "# Flutter Contacts Package: A Comprehensive Guide\n\n## 1. Description\n\nThe `flutter_contacts` package is a powerful and versatile tool for managing contacts within Flutter applications. It provides a seamless interface to interact with the device's contact list, offering functionalities such as reading, writing, and updating contacts across both Android and iOS platforms.\n\n### Key Features:\n\n1. **Cross-Platform Compatibility**: Works on both Android and iOS with a unified API.\n2. **CRUD Operations**: Supports Create, Read, Update, and Delete operations for contacts.\n3. **Detailed Contact Information**: Access to various contact fields including name, phone numbers, emails, addresses, and more.\n4. **Contact Photo Management**: Ability to read and write contact photos.\n5. **Group Management**: Create, modify, and delete contact groups.\n6. **Efficient Querying**: Powerful query capabilities for filtering and searching contacts.\n7. **Permissions Handling**: Built-in methods for requesting and checking contact permissions.\n\n### Why Choose flutter_contacts?\n\nThe `flutter_contacts` package stands out due to its comprehensive feature set and ease of use. It abstracts away the platform-specific complexities, allowing developers to focus on building robust contact management features in their Flutter apps.\n\nIn the following sections, we'll dive deeper into how to integrate and utilize this package in your Flutter projects, demonstrating its capabilities through practical examples and a fully functional implementation.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfEuY",
        "_type": "reference",
        "_key": "sh8tn13y"
      }
    ],
    "likesCount": 378,
    "shortDescription": "Flutter plugin to read, create, update, delete and observe native contacts on Android and iOS, with group support, vCard support, and contact permission handling",
    "_createdAt": "2024-08-28T22:19:48Z",
    "name": "flutter_contacts"
  },
  {
    "author": "google.dev",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "kgmxmkww"
      }
    ],
    "likesCount": 938,
    "shortDescription": "A plug-in to add support for payments on Flutter applications.",
    "lastUpdate": "2024-02-26T18:30:00.000Z",
    "tutorialIncluded": true,
    "slug": {
      "current": "pay",
      "_type": "slug"
    },
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1nDv",
        "_type": "reference",
        "_key": "wbnmbnmk"
      },
      {
        "_type": "reference",
        "_key": "ahwbd7md",
        "_ref": "V06bsD4sX3T8NTHrBPacvI"
      }
    ],
    "name": "pay",
    "tutorial": "# Pay Package for Flutter: Tutorial\n\n## Installation\n\nTo get started with the Pay package, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  pay: ^1.1.0\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Platform-Specific Setup\n\n### iOS Setup\n\n1. In your Xcode project, go to \"Signing & Capabilities\".\n2. Add the \"In-App Purchase\" capability.\n3. Configure your App ID for in-app purchases in the Apple Developer portal.\n\n### Android Setup\n\n1. In your `app/build.gradle` file, add the following permission:\n\n```gradle\nandroid {\n    ...\n    defaultConfig {\n        ...\n        manifestPlaceholders = [\n            ...\n            'appAuthRedirectScheme': 'com.example.app'\n        ]\n    }\n}\n```\n\n2. In your `AndroidManifest.xml`, add the billing permission:\n\n```xml\n<uses-permission android:name=\"com.android.vending.BILLING\" />\n```\n\n## Basic Usage\n\n1. Import the package:\n\n```dart\nimport 'package:pay/pay.dart';\n```\n\n2. Initialize the Pay client:\n\n```dart\nfinal pay = Pay();\n```\n\n3. Fetch available products:\n\n```dart\nfinal products = await pay.queryProductDetails(['product_id_1', 'product_id_2']);\n```\n\n4. Make a purchase:\n\n```dart\ntry {\n  final purchaseDetails = await pay.buyConsumable(productDetails: products[0]);\n  if (purchaseDetails.status == PurchaseStatus.purchased) {\n    // Handle successful purchase\n  }\n} catch (e) {\n  // Handle error\n}\n```\n\n5. Restore purchases:\n\n```dart\nfinal restoredPurchases = await pay.restorePurchases();\n```\n\nBy following these steps, you'll have a basic implementation of in-app purchases in your Flutter app using the Pay package.",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmNsY",
    "_type": "package",
    "platforms": [
      "android",
      "ios"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:51Z",
    "_id": "Rx1Nho763d29lawKra1p3T",
    "_updatedAt": "2024-09-06T04:11:16Z",
    "description": "# Pay Package for Flutter: Simplifying In-App Purchases\n\n## Introduction\n\nThe Pay package for Flutter is a powerful tool that simplifies the implementation of in-app purchases in your Flutter applications. It provides a unified API for handling transactions across multiple platforms, including iOS, Android, and web.\n\n## Key Features\n\n1. **Cross-Platform Support**: Seamlessly integrate in-app purchases on iOS, Android, and web platforms.\n2. **Unified API**: Use a single, consistent API for all supported platforms, reducing code complexity.\n3. **Product Management**: Easily manage and retrieve product information from app stores.\n4. **Purchase Handling**: Streamlined process for initiating and completing purchases.\n5. **Subscription Support**: Manage recurring subscriptions with ease.\n6. **Receipt Validation**: Built-in functionality for verifying purchase receipts.\n7. **Restore Purchases**: Allow users to restore their previous purchases across devices.\n\n## Benefits\n\n- **Simplified Development**: Reduce the time and effort required to implement in-app purchases.\n- **Consistent User Experience**: Provide a uniform purchasing experience across all platforms.\n- **Improved Maintainability**: Centralize your purchase-related code for easier updates and bug fixes.\n- **Increased Revenue**: Easily monetize your app with various purchase options.\n\nBy leveraging the Pay package, Flutter developers can focus on creating great app experiences while leaving the complexities of in-app purchase implementation to a robust and reliable solution.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "fr2evk65",
        "_ref": "V06bsD4sX3T8NTHrBPak0O"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:pay/pay.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pay Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const PayHomePage(title: 'Pay Package Demo Home Page'),\n    );\n  }\n}\n\nclass PayHomePage extends StatefulWidget {\n  const PayHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  State<PayHomePage> createState() => _PayHomePageState();\n}\n\nclass _PayHomePageState extends State<PayHomePage> {\n  final Pay _payClient = Pay();\n  List<ProductDetails> _products = [];\n  List<PurchaseDetails> _purchases = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _initPayClient();\n  }\n\n  // Step 1: Initialize the Pay client and fetch products\n  Future<void> _initPayClient() async {\n    try {\n      // Initialize the Pay client\n      await _payClient.init();\n      \n      // Fetch available products\n      final products = await _payClient.queryProductDetails(['product_id_1', 'product_id_2']);\n      \n      setState(() {\n        _products = products;\n      });\n    } catch (e) {\n      print('Error initializing Pay client: $e');\n    }\n  }\n\n  // Step 2: Make a purchase\n  Future<void> _makePurchase(ProductDetails product) async {\n    try {\n      final purchaseDetails = await _payClient.buyConsumable(productDetails: product);\n      \n      if (purchaseDetails.status == PurchaseStatus.purchased) {\n        setState(() {\n          _purchases.add(purchaseDetails);\n        });\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Successfully purchased ${product.title}'))\n        );\n      }\n    } catch (e) {\n      print('Error making purchase: $e');\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Failed to purchase ${product.title}'))\n      );\n    }\n  }\n\n  // Step 3: Restore purchases\n  Future<void> _restorePurchases() async {\n    try {\n      final restoredPurchases = await _payClient.restorePurchases();\n      \n      setState(() {\n        _purchases = restoredPurchases;\n      });\n      \n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Purchases restored successfully'))\n      );\n    } catch (e) {\n      print('Error restoring purchases: $e');\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Failed to restore purchases'))\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(widget.title)),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Available Products:'),\n            ..._products.map((product) => ElevatedButton(\n              onPressed: () => _makePurchase(product),\n              child: Text('Buy ${product.title} (${product.price})'),\n            )),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _restorePurchases,\n              child: const Text('Restore Purchases'),\n            ),\n            const SizedBox(height: 20),\n            const Text('Purchased Items:'),\n            ..._purchases.map((purchase) => Text(purchase.productID)),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the Pay client in the initState method.\n// 2. Available products are fetched and displayed as buttons.\n// 3. When a user taps a product button, the _makePurchase method is called.\n// 4. If the purchase is successful, it's added to the _purchases list and displayed.\n// 5. The user can restore previous purchases by tapping the \"Restore Purchases\" button.\n// 6. Restored purchases are then displayed in the list of purchased items.\n\n// Note: This example assumes you have properly set up your app for in-app purchases\n// on both iOS and Android platforms as described in the tutorial section.\n```",
    "tags": [
      "payment",
      "google-pay",
      "apple-pay",
      "transaction"
    ]
  },
  {
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:54Z",
    "lastUpdate": "2024-08-13T18:30:00.000Z",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "synchronized"
    },
    "name": "synchronized",
    "tutorial": "# Tutorial: Implementing Synchronized Operations in Flutter\n\nThis tutorial will guide you through the process of implementing synchronized operations in your Flutter application using the `synchronized` package.\n\n## Step 1: Add the Package to Your Project\n\nFirst, add the `synchronized` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  synchronized: ^3.0.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:synchronized/synchronized.dart';\n```\n\n## Step 3: Create a Lock Object\n\nCreate a `Lock` object to synchronize your code:\n\n```dart\nfinal _lock = Lock();\n```\n\n## Step 4: Use the Synchronized Block\n\nWrap the code you want to synchronize in a `synchronized` block:\n\n```dart\nawait _lock.synchronized(() async {\n  // Your synchronized code here\n});\n```\n\n## Step 5: Handling Timeouts\n\nYou can add a timeout to prevent indefinite waiting:\n\n```dart\ntry {\n  await _lock.synchronized(() async {\n    // Your synchronized code here\n  }, timeout: Duration(seconds: 5));\n} catch (e) {\n  print('Operation timed out: $e');\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, the `synchronized` package utilizes Dart's built-in synchronization mechanisms, which are based on isolates. No additional configuration is needed.\n\n### iOS\n\nSimilar to Android, iOS doesn't require any specific configuration for the `synchronized` package to work.\n\n### Web\n\nWhen targeting web platforms, be aware that Dart's concurrency model on the web is based on event loops rather than true multithreading. The `synchronized` package still works, but its behavior might differ slightly from native platforms.\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, the `synchronized` package works as expected without any additional configuration. However, be mindful of potential performance implications when using synchronization in desktop applications, especially those with heavy computational tasks.\n\n## Best Practices\n\n1. Keep synchronized blocks as short as possible to avoid blocking other parts of your application.\n2. Use synchronization only when necessary, typically for shared resources or critical sections.\n3. Consider using other concurrency patterns (like Streams or Isolates) for long-running or CPU-intensive tasks.\n4. Always test your synchronized code thoroughly across different platforms to ensure consistent behavior.\n\nBy following these steps and considerations, you can effectively implement synchronized operations in your Flutter application, ensuring thread-safety and preventing race conditions across all supported platforms.",
    "_updatedAt": "2024-09-06T04:11:17Z",
    "author": "tekartik.com",
    "description": "# Synchronized Package for Flutter: Ensuring Thread-Safe Operations\n\n## Introduction\n\nIn the world of mobile app development, managing concurrent operations is crucial for maintaining data integrity and preventing race conditions. Flutter, being a popular framework for cross-platform development, offers various solutions to handle synchronization. One such powerful tool is the `synchronized` package.\n\nThe `synchronized` package provides a simple and effective way to ensure that critical sections of your code are executed by only one thread at a time. This is particularly useful when dealing with shared resources or when you need to coordinate access to certain parts of your application.\n\n## Key Features\n\n1. **Lock Mechanism**: The package implements a lock mechanism that prevents multiple threads from executing the same block of code simultaneously.\n\n2. **Reentrant Locks**: Supports reentrant locks, allowing a thread that holds a lock to reacquire it without deadlocking.\n\n3. **Timeout Support**: You can specify timeouts for synchronized blocks, preventing indefinite waiting.\n\n4. **Zone-Based Synchronization**: Utilizes Dart's Zone mechanism for efficient and reliable synchronization.\n\n5. **Cross-Platform Compatibility**: Works seamlessly across all platforms supported by Flutter.\n\nIn the following sections, we'll dive deeper into how to use the `synchronized` package in your Flutter projects, providing a step-by-step tutorial and a comprehensive example demonstrating its features.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "lyhp8mp8"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:synchronized/synchronized.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Synchronized Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const SynchronizedDemo(),\n    );\n  }\n}\n\nclass SynchronizedDemo extends StatefulWidget {\n  const SynchronizedDemo({Key? key}) : super(key: key);\n\n  @override\n  _SynchronizedDemoState createState() => _SynchronizedDemoState();\n}\n\nclass _SynchronizedDemoState extends State<SynchronizedDemo> {\n  // Step 1: Create a Lock object\n  final _lock = Lock();\n  int _counter = 0;\n  List<String> _log = [];\n\n  // Step 2: Create a method to increment the counter with synchronization\n  Future<void> _incrementCounter() async {\n    // Step 3: Use the synchronized block\n    await _lock.synchronized(() async {\n      // Simulate a time-consuming operation\n      await Future.delayed(const Duration(seconds: 1));\n      setState(() {\n        _counter++;\n        _log.add('Counter incremented to $_counter');\n      });\n    });\n  }\n\n  // Step 4: Create a method to demonstrate timeout\n  Future<void> _demonstrateTimeout() async {\n    try {\n      // Step 5: Add a timeout to the synchronized block\n      await _lock.synchronized(() async {\n        // Simulate a long-running operation\n        await Future.delayed(const Duration(seconds: 3));\n        setState(() {\n          _counter += 10;\n          _log.add('Counter increased by 10 to $_counter');\n        });\n      }, timeout: const Duration(seconds: 2));\n    } catch (e) {\n      setState(() {\n        _log.add('Operation timed out: $e');\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Synchronized Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Counter: $_counter', style: const TextStyle(fontSize: 24)),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _incrementCounter,\n              child: const Text('Increment Counter (Synchronized)'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _demonstrateTimeout,\n              child: const Text('Demonstrate Timeout'),\n            ),\n            const SizedBox(height: 20),\n            Expanded(\n              child: ListView.builder(\n                itemCount: _log.length,\n                itemBuilder: (context, index) {\n                  return ListTile(title: Text(_log[index]));\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a counter initialized to 0.\n// 2. When the user taps \"Increment Counter\", the _incrementCounter method is called.\n// 3. The _incrementCounter method uses a synchronized block to ensure thread-safety.\n// 4. Inside the synchronized block, we simulate a time-consuming operation with a 1-second delay.\n// 5. After the delay, the counter is incremented, and the log is updated.\n// 6. When the user taps \"Demonstrate Timeout\", the _demonstrateTimeout method is called.\n// 7. This method attempts to run a synchronized block with a 2-second timeout.\n// 8. The operation inside the block takes 3 seconds, so it will always time out.\n// 9. When the timeout occurs, it's caught in the try-catch block, and an error message is added to the log.\n// 10. The UI updates after each operation, showing the current counter value and the log of operations.\n\n// Note: This example demonstrates basic usage of the synchronized package.\n// In a real-world scenario, you might use synchronization for more complex operations,\n// such as accessing shared resources or ensuring data consistency in multi-threaded environments.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1vIF",
        "_type": "reference",
        "_key": "6vpn0gcq"
      }
    ],
    "likesCount": 491,
    "_id": "Rx1Nho763d29lawKra1pE7",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmO2N",
    "_type": "package",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "shortDescription": "Lock mechanism to prevent concurrent access to asynchronous code.",
    "tags": [
      "mutex",
      "lock",
      "concurrency",
      "synchronization"
    ]
  },
  {
    "_type": "package",
    "description": "# Android Intent Plus: Unleashing the Power of Intents in Flutter\n\n## Introduction\n\nIn the world of cross-platform mobile development, Flutter has emerged as a powerful framework for creating beautiful and performant applications. However, when it comes to platform-specific functionality, developers often need to bridge the gap between Flutter's abstraction and native capabilities. This is where the `android_intent_plus` package comes into play, specifically for Android development.\n\n## What is android_intent_plus?\n\nThe `android_intent_plus` package is a Flutter plugin that provides a seamless way to launch Android Intents directly from your Flutter code. It's an enhanced version of the original `android_intent` package, offering more features and better compatibility with recent Flutter versions.\n\n## Key Features\n\n1. **Launch Activities**: Easily start new activities within your Android app or external applications.\n2. **Send Broadcasts**: Trigger system-wide broadcasts to communicate with other components.\n3. **Start Services**: Initiate background services for long-running operations.\n4. **Rich Intent Creation**: Build intents with various parameters such as action, category, data, and extras.\n5. **platform_channel Integration**: Utilize Flutter's platform channel to communicate with native Android code.\n\n## Why Use android_intent_plus?\n\n- **Native Functionality**: Access Android-specific features that are not directly available in Flutter.\n- **System Integration**: Interact with other apps and system components on the Android device.\n- **Enhanced User Experience**: Provide a more native feel to your Flutter app on Android devices.\n- **Flexibility**: Combine the power of Flutter's cross-platform development with Android's native capabilities.\n\nIn the following sections, we'll dive deeper into how to use `android_intent_plus` in your Flutter projects, providing a comprehensive tutorial and practical examples to help you harness the full potential of this package.",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "wvn5ccl8"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:android_intent_plus/android_intent.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Android Intent Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const IntentDemoScreen(),\n    );\n  }\n}\n\nclass IntentDemoScreen extends StatefulWidget {\n  const IntentDemoScreen({Key? key}) : super(key: key);\n\n  @override\n  _IntentDemoScreenState createState() => _IntentDemoScreenState();\n}\n\nclass _IntentDemoScreenState extends State<IntentDemoScreen> {\n  // Step 1: Initialize variables to store intent results\n  String _lastLaunchedIntent = '';\n  bool _canResolveIntent = false;\n\n  // Step 2: Create a method to launch a web URL intent\n  Future<void> _launchWebIntent() async {\n    final intent = AndroidIntent(\n      action: 'action_view',\n      data: 'https://flutter.dev',\n    );\n    try {\n      await intent.launch();\n      setState(() {\n        _lastLaunchedIntent = 'Launched web intent: https://flutter.dev';\n      });\n    } on PlatformException catch (e) {\n      setState(() {\n        _lastLaunchedIntent = 'Error launching web intent: ${e.message}';\n      });\n    }\n  }\n\n  // Step 3: Create a method to send a custom broadcast\n  Future<void> _sendCustomBroadcast() async {\n    final intent = AndroidIntent(\n      action: 'com.example.MY_CUSTOM_ACTION',\n      extras: <String, dynamic>{'key': 'value'},\n    );\n    try {\n      await intent.sendBroadcast();\n      setState(() {\n        _lastLaunchedIntent = 'Sent custom broadcast: MY_CUSTOM_ACTION';\n      });\n    } on PlatformException catch (e) {\n      setState(() {\n        _lastLaunchedIntent = 'Error sending broadcast: ${e.message}';\n      });\n    }\n  }\n\n  // Step 4: Create a method to check if an intent can be resolved\n  Future<void> _checkIntent() async {\n    final intent = AndroidIntent(\n      action: 'action_view',\n      data: 'https://www.example.com',\n    );\n    try {\n      bool canResolve = await intent.canResolveActivity();\n      setState(() {\n        _canResolveIntent = canResolve;\n      });\n    } on PlatformException catch (e) {\n      print('Error checking intent: ${e.message}');\n    }\n  }\n\n  // Step 5: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Android Intent Plus Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: _launchWebIntent,\n              child: const Text('Launch Web Intent'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _sendCustomBroadcast,\n              child: const Text('Send Custom Broadcast'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _checkIntent,\n              child: const Text('Check Web Intent'),\n            ),\n            const SizedBox(height: 20),\n            Text('Last Launched Intent: $_lastLaunchedIntent'),\n            Text('Can Resolve Web Intent: $_canResolveIntent'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with three buttons and two text fields.\n// 2. When the user taps \"Launch Web Intent\", it attempts to open https://flutter.dev in the default browser.\n// 3. When the user taps \"Send Custom Broadcast\", it sends a custom broadcast with the action \"com.example.MY_CUSTOM_ACTION\".\n// 4. When the user taps \"Check Web Intent\", it checks if the device can handle opening a web URL.\n// 5. After each action, the app updates the UI to show the result of the last action and whether the web intent can be resolved.\n\n// Note: This example demonstrates basic usage of android_intent_plus. In a real-world scenario,\n// you'd want to add more error handling, possibly use a BLoC pattern for state management,\n// and consider how to handle these intents on iOS (since this package is Android-specific).\n```",
    "tags": [
      "android",
      "intent",
      "utils",
      "platform-specific"
    ],
    "likesCount": 384,
    "pubPoint": 160,
    "_id": "Rx1Nho763d29lawKra1pSJ",
    "platforms": [
      "android"
    ],
    "packageImage": null,
    "lastUpdate": "2024-07-28T18:30:00.000Z",
    "shortDescription": "Flutter plugin for launching Android Intents. Not supported on iOS.",
    "dependentPackages": [
      {
        "_key": "p0zmvq30",
        "_ref": "uQRNMiDfrp20RZ8Id8CVRl",
        "_type": "reference"
      }
    ],
    "name": "android_intent_plus",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "android_intent_plus"
    },
    "author": "fluttercommunity.dev",
    "_createdAt": "2024-08-28T22:19:55Z",
    "tutorial": "# Android Intent Plus: A Comprehensive Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the `android_intent_plus` package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Installation\n\n1. Add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  android_intent_plus: ^3.1.2\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n## Basic Usage\n\n### Importing the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:android_intent_plus/android_intent.dart';\n```\n\n### Creating an Intent\n\nTo create an intent, use the `AndroidIntent` class:\n\n```dart\nfinal intent = AndroidIntent(\n  action: 'action_view',\n  data: 'https://www.example.com',\n);\n```\n\n### Launching the Intent\n\nTo launch the intent, call the `launch()` method:\n\n```dart\nawait intent.launch();\n```\n\n## Platform-Specific Details\n\n### Android Manifest\n\nEnsure that your `AndroidManifest.xml` file includes the necessary permissions and intent filters for your app to handle the intents you're trying to launch.\n\nFor example, to allow your app to open web URLs:\n\n```xml\n<manifest ...>\n    <application ...>\n        <activity ...>\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <data android:scheme=\"https\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n### iOS Considerations\n\nThe `android_intent_plus` package is specifically designed for Android. For iOS, you might want to use the `url_launcher` package or implement platform-specific code using method channels.\n\n## Advanced Usage\n\n### Adding Extras\n\nYou can add extra data to your intent using the `extras` parameter:\n\n```dart\nfinal intent = AndroidIntent(\n  action: 'action_send',\n  type: 'text/plain',\n  extras: <String, dynamic>{\n    'android.intent.extra.SUBJECT': 'Email subject',\n    'android.intent.extra.TEXT': 'Email body',\n  },\n);\n```\n\n### Checking if an Intent Can Be Resolved\n\nBefore launching an intent, you can check if there's an app that can handle it:\n\n```dart\nbool canResolve = await intent.canResolveActivity();\nif (canResolve) {\n  await intent.launch();\n} else {\n  print('No app can handle this intent');\n}\n```\n\n### Sending Broadcasts\n\nTo send a broadcast, use the `sendBroadcast()` method:\n\n```dart\nfinal intent = AndroidIntent(\n  action: 'com.example.MY_CUSTOM_ACTION',\n);\nawait intent.sendBroadcast();\n```\n\nBy following this tutorial, you should now have a solid understanding of how to use the `android_intent_plus` package in your Flutter projects. In the next section, we'll look at a complete example that demonstrates various features of this powerful package.",
    "_updatedAt": "2024-09-06T04:11:18Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaPz0"
  },
  {
    "tutorial": "# Riverpod Tutorial: Getting Started\n\nThis tutorial will guide you through setting up and using Riverpod in your Flutter project. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nFirst, add the necessary dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.4.0\n  riverpod_annotation: ^2.1.5\n\ndev_dependencies:\n  build_runner: ^2.4.6\n  riverpod_generator: ^2.3.2\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Setting up Riverpod\n\nWrap your root widget with `ProviderScope`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: RealFlutter(),\n    ),\n  );\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: HomePage(),\n    );\n  }\n}\n```\n\n## Step 3: Creating Providers\n\nLet's create a simple provider:\n\n```dart\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'providers.g.dart';\n\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello, Riverpod!';\n}\n```\n\nRun the code generator:\n\n```\nflutter pub run build_runner build\n```\n\n## Step 4: Using Providers in Widgets\n\nNow, let's use the provider in a widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'providers.dart';\n\nclass HomePage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final message = ref.watch(helloWorldProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Example')),\n      body: Center(child: Text(message)),\n    );\n  }\n}\n```\n\n## Step 5: State Management with StateNotifier\n\nFor more complex state management, use `StateNotifier`:\n\n```dart\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'counter_provider.g.dart';\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n```\n\nUse it in a widget:\n\n```dart\nclass CounterPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Counter Example')),\n      body: Center(child: Text('Count: $counter')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).increment(),\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n- Ensure your `minSdkVersion` is set to 16 or higher in `android/app/build.gradle`.\n- For better performance, enable R8 full mode in `android/gradle.properties`:\n  ```\n  android.enableR8=true\n  android.useAndroidX=true\n  android.enableJetifier=true\n  ```\n\n### iOS\n- Set the minimum deployment target to iOS 11.0 or higher in your Xcode project settings.\n- If using CocoaPods, ensure your `Podfile` has:\n  ```ruby\n  platform :ios, '11.0'\n  ```\n\n### Web\n- No specific setup is required for web, but ensure you're using a recent version of Chrome, Firefox, or Safari for the best performance.\n\nThis tutorial covers the basics of Riverpod. In the next section, we'll look at a more comprehensive example that demonstrates various features of the package.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:19Z",
    "description": "# Riverpod: A State Management Solution for Flutter\n\n## Introduction\n\nRiverpod is a powerful state management library for Flutter applications, designed to address the limitations of the `provider` package. Created by Remi Rousselet, the same developer behind `provider`, Riverpod offers a more robust and flexible approach to managing application state.\n\n## Key Features of Riverpod\n\n1. **Type Safety**: Riverpod leverages Dart's strong typing system to catch errors at compile-time rather than runtime.\n\n2. **Testability**: It provides excellent support for unit testing, making it easier to write and maintain tests for your application's state management logic.\n\n3. **Code Generation**: With the `riverpod_generator` package, you can reduce boilerplate code and improve maintainability.\n\n4. **Dependency Override**: Riverpod allows for easy overriding of dependencies, which is particularly useful for testing and development scenarios.\n\n5. **Provider Composition**: You can easily combine multiple providers to create more complex state management solutions.\n\n6. **Auto-disposal**: Providers are automatically disposed of when they're no longer needed, helping to prevent memory leaks.\n\n## Why Choose Riverpod?\n\nRiverpod addresses several pain points that developers often encounter with other state management solutions:\n\n- It eliminates the need for a `BuildContext` to read providers.\n- It provides better support for asynchronous operations.\n- It offers more granular control over when providers should rebuild.\n- It integrates seamlessly with Flutter's widget tree, allowing for efficient and predictable state updates.\n\nIn the following sections, we'll dive deeper into how to use Riverpod in your Flutter applications, providing a tutorial and a comprehensive example to demonstrate its capabilities.",
    "shortDescription": "A reactive caching and data-binding framework. Riverpod makes working with asynchronous code a breeze.",
    "name": "riverpod",
    "likesCount": 3338,
    "slug": {
      "current": "riverpod",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmOIk",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:19:57Z",
    "lastUpdate": "2024-03-09T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1pcx",
    "similarPackages": [
      {
        "_key": "nwjgb3hv",
        "_ref": "uQRNMiDfrp20RZ8Id8CWqB",
        "_type": "reference"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CbaN",
        "_type": "reference",
        "_key": "9ryyrc93"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n// Step 1: Define providers\n@riverpod\nString helloWorld(HelloWorldRef ref) => 'Hello, Riverpod!';\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n\n@riverpod\nFuture<List<String>> fetchItems(FetchItemsRef ref) async {\n  // Simulating an API call\n  await Future.delayed(Duration(seconds: 2));\n  return ['Item 1', 'Item 2', 'Item 3'];\n}\n\n// Step 2: Create the main app widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Riverpod Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\n// Step 3: Create the home page\nclass HomePage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final message = ref.watch(helloWorldProvider);\n    final counter = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(message, style: TextStyle(fontSize: 24)),\n            SizedBox(height: 20),\n            Text('Counter: $counter', style: TextStyle(fontSize: 20)),\n            SizedBox(height: 20),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(\n                  onPressed: () => ref.read(counterProvider.notifier).decrement(),\n                  child: Text('-'),\n                ),\n                SizedBox(width: 20),\n                ElevatedButton(\n                  onPressed: () => ref.read(counterProvider.notifier).increment(),\n                  child: Text('+'),\n                ),\n              ],\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => Navigator.push(\n                context,\n                MaterialPageRoute(builder: (context) => ItemsPage()),\n              ),\n              child: Text('Fetch Items'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 4: Create a page to demonstrate async data fetching\nclass ItemsPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final itemsAsyncValue = ref.watch(fetchItemsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Fetched Items')),\n      body: Center(\n        child: itemsAsyncValue.when(\n          data: (items) => ListView.builder(\n            itemCount: items.length,\n            itemBuilder: (context, index) => ListTile(title: Text(items[index])),\n          ),\n          loading: () => CircularProgressIndicator(),\n          error: (error, stackTrace) => Text('Error: $error'),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 5: Run the app\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: RealFlutter(),\n    ),\n  );\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget wrapped in a ProviderScope.\n// 2. The HomePage is displayed, showing:\n//    - A hello message from the helloWorldProvider\n//    - A counter value from the counterProvider\n//    - Buttons to increment and decrement the counter\n//    - A button to navigate to the ItemsPage\n// 3. When the user taps the increment or decrement buttons, the counter state is updated.\n// 4. When the user taps the \"Fetch Items\" button, they navigate to the ItemsPage.\n// 5. The ItemsPage uses the fetchItemsProvider to asynchronously load data.\n// 6. While loading, a CircularProgressIndicator is displayed.\n// 7. Once data is loaded, it's displayed in a ListView.\n// 8. If an error occurs during loading, an error message is displayed.\n\n// This example demonstrates:\n// - Basic providers (helloWorldProvider)\n// - StateNotifier providers for mutable state (counterProvider)\n// - Async providers for data fetching (fetchItemsProvider)\n// - Using providers in widgets with ref.watch()\n// - Updating provider state (increment/decrement methods)\n// - Handling async states with .when()\n// - Navigation between pages while maintaining state\n```",
    "tags": [
      "state-management",
      "dependency-injection",
      "provider"
    ],
    "dependentPackages": [],
    "author": "dash-overflow.net",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfBIU",
        "_type": "reference",
        "_key": "6l72l62k"
      }
    ]
  },
  {
    "shortDescription": "A PageView widget adjusting it's height to currently displayed page",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFlU",
        "_type": "reference",
        "_key": "6ncjfz4b"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "pageview",
      "expandable",
      "ui",
      "widget",
      "scrollable"
    ],
    "name": "expandable_page_view",
    "author": "",
    "description": "# ExpandablePageView: A Dynamic Flutter Package\n\nThe `expandable_page_view` package is a powerful and flexible solution for creating dynamic page views in Flutter applications. This package extends the functionality of the standard `PageView` widget, allowing for pages of varying heights while maintaining smooth scrolling and intuitive navigation.\n\n## Key Features\n\n1. **Dynamic Height Adjustment**: Unlike the standard `PageView`, `ExpandablePageView` automatically adjusts its height to match the tallest page currently in view.\n\n2. **Smooth Transitions**: The package ensures smooth transitions between pages of different heights, providing a seamless user experience.\n\n3. **Customizable**: Developers can easily customize various aspects of the `ExpandablePageView`, including scroll direction, physics, and controller.\n\n4. **Compatibility**: Works well with existing Flutter widgets and can be easily integrated into your project.\n\n5. **Performance Optimized**: Designed to maintain high performance even with complex page layouts.\n\n## When to Use ExpandablePageView\n\nThe `expandable_page_view` package is particularly useful in scenarios where:\n\n- You need to display a series of pages with varying content lengths.\n- You want to avoid fixed-height constraints that might cut off content or leave excessive blank space.\n- You're building dynamic user interfaces that adapt to content size.\n\nBy using `ExpandablePageView`, developers can create more responsive and user-friendly interfaces, especially in apps dealing with variable content such as news feeds, product catalogs, or multi-step forms.\n\nIn the following sections, we'll dive into a tutorial on how to implement `ExpandablePageView` in your Flutter project and explore a comprehensive example showcasing its features.",
    "likesCount": 428,
    "packageImage": null,
    "_id": "Rx1Nho763d29lawKra1q1n",
    "tutorial": "# ExpandablePageView Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the `expandable_page_view` package in a Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nTo begin using `expandable_page_view`, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  expandable_page_view: ^1.0.17\n```\n\nThen, run `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:expandable_page_view/expandable_page_view.dart';\n```\n\n## Step 3: Basic Implementation\n\nHere's a simple example of how to use `ExpandablePageView`:\n\n```dart\nExpandablePageView(\n  children: <Widget>[\n    Container(\n      color: Colors.red,\n      height: 100,\n      child: Center(child: Text('Page 1')),\n    ),\n    Container(\n      color: Colors.green,\n      height: 200,\n      child: Center(child: Text('Page 2')),\n    ),\n    Container(\n      color: Colors.blue,\n      height: 300,\n      child: Center(child: Text('Page 3')),\n    ),\n  ],\n)\n```\n\nThis will create a page view with three pages of different heights.\n\n## Step 4: Customization\n\nYou can customize `ExpandablePageView` using various parameters:\n\n```dart\nExpandablePageView(\n  children: <Widget>[...],\n  scrollDirection: Axis.horizontal,\n  controller: PageController(),\n  physics: BouncingScrollPhysics(),\n  onPageChanged: (int page) {\n    print('Page changed to $page');\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, the `ExpandablePageView` works seamlessly with the default `CupertinoApp` theme. However, for the best user experience, consider using `CupertinoPageScaffold` for a more iOS-native feel:\n\n```dart\nCupertinoPageScaffold(\n  navigationBar: CupertinoNavigationBar(\n    middle: Text('ExpandablePageView Demo'),\n  ),\n  child: ExpandablePageView(\n    // Your pages here\n  ),\n)\n```\n\n### Android\n\nFor Android, the Material Design guidelines suggest using tabs or a bottom navigation bar for switching between pages. You can integrate `ExpandablePageView` with `TabBarView`:\n\n```dart\nDefaultTabController(\n  length: 3,\n  child: Scaffold(\n    appBar: AppBar(\n      bottom: TabBar(\n        tabs: [\n          Tab(icon: Icon(Icons.directions_car)),\n          Tab(icon: Icon(Icons.directions_transit)),\n          Tab(icon: Icon(Icons.directions_bike)),\n        ],\n      ),\n      title: Text('ExpandablePageView Demo'),\n    ),\n    body: ExpandablePageView(\n      // Your pages here\n    ),\n  ),\n)\n```\n\nBy following these steps and considering platform-specific guidelines, you can effectively implement `ExpandablePageView` in your Flutter project, creating a dynamic and responsive user interface across both iOS and Android platforms.",
    "slug": {
      "current": "expandable_page_view",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "dependentPackages": [
      {
        "_key": "jt93uvgp",
        "_ref": "uQRNMiDfrp20RZ8Id8CWf9",
        "_type": "reference"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPanie",
        "_type": "reference",
        "_key": "jtysofij"
      }
    ],
    "_createdAt": "2024-08-28T22:19:58Z",
    "lastUpdate": "2022-07-02T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:20Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaQ3n",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:expandable_page_view/expandable_page_view.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'ExpandablePageView Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  final PageController _pageController = PageController();\n  int _currentPage = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('ExpandablePageView Demo')),\n      body: Column(\n        children: [\n          // Step 1: Implement ExpandablePageView\n          Expanded(\n            child: ExpandablePageView(\n              controller: _pageController,\n              children: [\n                _buildPage('Page 1', Colors.red, 100),\n                _buildPage('Page 2', Colors.green, 200),\n                _buildPage('Page 3', Colors.blue, 300),\n              ],\n              onPageChanged: (int page) {\n                setState(() {\n                  _currentPage = page;\n                });\n              },\n            ),\n          ),\n          // Step 2: Add navigation controls\n          _buildNavigationControls(),\n        ],\n      ),\n    );\n  }\n\n  // Step 3: Create a method to build individual pages\n  Widget _buildPage(String text, Color color, double height) {\n    return Container(\n      color: color,\n      height: height,\n      child: Center(\n        child: Text(\n          text,\n          style: TextStyle(color: Colors.white, fontSize: 24),\n        ),\n      ),\n    );\n  }\n\n  // Step 4: Implement navigation controls\n  Widget _buildNavigationControls() {\n    return Padding(\n      padding: const EdgeInsets.all(16.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          ElevatedButton(\n            onPressed: _currentPage > 0\n                ? () => _pageController.previousPage(\n                      duration: Duration(milliseconds: 300),\n                      curve: Curves.easeInOut,\n                    )\n                : null,\n            child: Text('Previous'),\n          ),\n          Text('Page ${_currentPage + 1} of 3'),\n          ElevatedButton(\n            onPressed: _currentPage < 2\n                ? () => _pageController.nextPage(\n                      duration: Duration(milliseconds: 300),\n                      curve: Curves.easeInOut,\n                    )\n                : null,\n            child: Text('Next'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _pageController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. HomePage is displayed as the home screen.\n// 3. In HomePage, an ExpandablePageView is implemented with three pages of different heights.\n// 4. The ExpandablePageView automatically adjusts its height based on the tallest visible page.\n// 5. Navigation controls are added below the ExpandablePageView.\n// 6. Users can navigate between pages using the 'Previous' and 'Next' buttons or by swiping.\n// 7. The current page number is displayed and updated as the user navigates.\n// 8. The buttons are disabled when reaching the first or last page to prevent out-of-bounds navigation.\n// 9. The PageController is properly disposed of when the widget is removed from the tree.\n\n// This example demonstrates the core features of ExpandablePageView:\n// - Dynamic height adjustment\n// - Smooth transitions between pages\n// - Integration with navigation controls\n// - Proper state management and resource disposal\n```"
  },
  {
    "platforms": [
      "android",
      "ios"
    ],
    "description": "# Quick Actions in Flutter: Enhancing User Experience with Shortcuts\n\n## Introduction\n\nThe `quick_actions` package in Flutter is a powerful tool that allows developers to add shortcuts to specific actions within their app. These shortcuts, also known as Quick Actions, provide users with rapid access to key features directly from the app icon, enhancing the overall user experience and increasing engagement.\n\n## What are Quick Actions?\n\nQuick Actions are essentially shortcuts that appear when a user long-presses the app icon on their device's home screen. These actions allow users to jump directly to specific parts of the app or trigger particular functions without having to navigate through the app's interface.\n\n## Key Features of the quick_actions Package\n\n1. **Easy Integration**: The package seamlessly integrates with both iOS and Android platforms.\n2. **Customizable Actions**: Developers can define custom actions with unique identifiers and labels.\n3. **Icon Support**: Each action can be associated with a platform-specific icon for visual recognition.\n4. **Dynamic Updates**: Quick actions can be updated at runtime, allowing for context-specific shortcuts.\n5. **Callback Handling**: The package provides a simple way to handle callbacks when a quick action is selected.\n\n## Benefits of Using Quick Actions\n\n- **Improved User Experience**: Users can access frequently used features faster.\n- **Increased Engagement**: By providing quick access to key features, apps can encourage more frequent use.\n- **Personalization**: Actions can be tailored to user preferences or app state.\n- **Cross-Platform Consistency**: The package ensures a similar experience on both iOS and Android.\n\n## Use Cases\n\nQuick Actions are particularly useful for:\n\n- Social media apps (e.g., \"New Post\", \"Open Camera\")\n- Productivity apps (e.g., \"New Note\", \"Start Timer\")\n- E-commerce apps (e.g., \"Search\", \"View Cart\")\n- Navigation apps (e.g., \"Navigate Home\", \"Find Nearby\")\n\nBy implementing Quick Actions, developers can significantly enhance the usability and appeal of their Flutter applications, providing users with a more efficient and enjoyable experience.",
    "tags": [
      "quick-actions",
      "os-integration",
      "shortcuts",
      "home-screen"
    ],
    "likesCount": 913,
    "lastUpdate": "2024-01-08T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1qJX",
    "_updatedAt": "2024-09-06T04:11:21Z",
    "author": "flutter.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaQ6z",
    "shortDescription": "Flutter plugin for creating shortcuts on home screen, also known as Quick Actions on iOS and App Shortcuts on Android.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:quick_actions/quick_actions.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Quick Actions Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  final QuickActions quickActions = QuickActions();\n  String _lastAction = \"None\";\n\n  @override\n  void initState() {\n    super.initState();\n    _setupQuickActions();\n  }\n\n  // Step 1: Set up Quick Actions\n  void _setupQuickActions() {\n    quickActions.initialize((shortcutType) {\n      setState(() {\n        if (shortcutType != null) {\n          _lastAction = shortcutType;\n        }\n      });\n      _handleQuickAction(shortcutType);\n    });\n\n    // Step 2: Define Quick Action items\n    quickActions.setShortcutItems(<ShortcutItem>[\n      const ShortcutItem(\n        type: 'action_main',\n        localizedTitle: 'Main Screen',\n        icon: 'icon_main',\n      ),\n      const ShortcutItem(\n        type: 'action_search',\n        localizedTitle: 'Search',\n        icon: 'icon_search',\n      ),\n      const ShortcutItem(\n        type: 'action_settings',\n        localizedTitle: 'Settings',\n        icon: 'icon_settings',\n      ),\n    ]);\n  }\n\n  // Step 3: Handle Quick Actions\n  void _handleQuickAction(String? shortcutType) {\n    if (shortcutType == 'action_main') {\n      // Navigate to main screen (we're already here, so just show a message)\n      _showMessage('Welcome to the Main Screen!');\n    } else if (shortcutType == 'action_search') {\n      // Navigate to search screen\n      Navigator.of(context).push(MaterialPageRoute(\n        builder: (context) => const SearchScreen(),\n      ));\n    } else if (shortcutType == 'action_settings') {\n      // Navigate to settings screen\n      Navigator.of(context).push(MaterialPageRoute(\n        builder: (context) => const SettingsScreen(),\n      ));\n    }\n  }\n\n  void _showMessage(String message) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text(message)),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Quick Actions Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Last Quick Action: $_lastAction'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _handleQuickAction('action_search'),\n              child: const Text('Go to Search'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: () => _handleQuickAction('action_settings'),\n              child: const Text('Go to Settings'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatelessWidget {\n  const SearchScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Search')),\n      body: const Center(child: Text('This is the Search Screen')),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  const SettingsScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Settings')),\n      body: const Center(child: Text('This is the Settings Screen')),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the Quick Actions in the HomePage's initState method.\n// 2. Three Quick Action shortcuts are defined: Main Screen, Search, and Settings.\n// 3. When a Quick Action is triggered, the _handleQuickAction method is called.\n// 4. Depending on the Quick Action type, the app either shows a message or navigates to the appropriate screen.\n// 5. The HomePage displays the last triggered Quick Action and provides buttons to navigate to Search and Settings screens.\n// 6. The SearchScreen and SettingsScreen are simple placeholder screens to demonstrate navigation.\n\n// Note: To test Quick Actions:\n// - Run the app on a physical device or emulator.\n// - Press the home button to minimize the app.\n// - Long-press the app icon to reveal the Quick Action shortcuts.\n// - Tap on a Quick Action to see it in action when the app relaunches.\n```",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:00Z",
    "name": "quick_actions",
    "slug": {
      "current": "quick_actions",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "cr3p5kkk"
      }
    ],
    "dependentPackages": [
      {
        "_key": "rvns19fk",
        "_ref": "Rx1Nho763d29lawKra1err",
        "_type": "reference"
      }
    ],
    "tutorial": "# Quick Actions in Flutter: A Comprehensive Tutorial\n\nThis tutorial will guide you through the process of implementing Quick Actions in your Flutter application using the `quick_actions` package.\n\n## Step 1: Add Dependencies\n\nFirst, add the `quick_actions` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  quick_actions: ^1.0.5\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:quick_actions/quick_actions.dart';\n```\n\n## Step 3: Initialize Quick Actions\n\nCreate an instance of the QuickActions class:\n\n```dart\nfinal QuickActions quickActions = QuickActions();\n```\n\n## Step 4: Set Up Quick Actions\n\nDefine your quick actions in the `initState` method of your main widget:\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  \n  quickActions.initialize((shortcutType) {\n    if (shortcutType == 'action_main') {\n      print('The user tapped on the \"Main\" action.');\n    } else if (shortcutType == 'action_help') {\n      print('The user tapped on the \"Help\" action.');\n    }\n  });\n\n  quickActions.setShortcutItems(<ShortcutItem>[\n    const ShortcutItem(\n      type: 'action_main',\n      localizedTitle: 'Main',\n      icon: 'icon_main',\n    ),\n    const ShortcutItem(\n      type: 'action_help',\n      localizedTitle: 'Help',\n      icon: 'icon_help',\n    ),\n  ]);\n}\n```\n\n## Step 5: Handle Quick Actions\n\nImplement the logic to handle each quick action in your app. This usually involves navigating to a specific screen or performing a particular action based on the `shortcutType`.\n\n## Platform-Specific Setup\n\n### iOS Setup\n\n1. Open your iOS project in Xcode.\n2. Select your project in the Project Navigator.\n3. Select your target and go to the \"Info\" tab.\n4. Expand \"URL Types\" and add a new item.\n5. In the \"URL Schemes\" field, enter a unique identifier for your app (e.g., \"com.example.myapp\").\n\n### Android Setup\n\n1. Open your `android/app/src/main/AndroidManifest.xml` file.\n2. Add the following inside the `<application>` tag:\n\n```xml\n<meta-data\n    android:name=\"flutter_deeplinking_enabled\"\n    android:value=\"true\" />\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data\n        android:scheme=\"quickactions\"\n        android:host=\"example.com\" />\n</intent-filter>\n```\n\n## Step 6: Add Icons (Optional)\n\n### iOS\n\n1. Add your icon files to the `ios/Runner/Assets.xcassets` directory.\n2. Create a new Image Set for each icon and name them accordingly (e.g., \"icon_main\", \"icon_help\").\n\n### Android\n\n1. Add your icon files to the appropriate `android/app/src/main/res/mipmap-*` directories.\n2. Name your icons with the same names you used in the `setShortcutItems` method (e.g., \"icon_main\", \"icon_help\").\n\nBy following these steps, you'll have successfully implemented Quick Actions in your Flutter application, providing your users with convenient shortcuts to key features of your app.",
    "tutorialIncluded": true
  },
  {
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG2s",
        "_type": "reference",
        "_key": "wl4j3sys"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_zoom_drawer/flutter_zoom_drawer.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Zoom Drawer Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\n// Step 1: Create the main RealFlutter class\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final ZoomDrawerController _drawerController = ZoomDrawerController();\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 2: Implement WillPopScope for handling back button on Android\n    return WillPopScope(\n      onWillPop: () async {\n        if (_drawerController.isOpen!()) {\n          _drawerController.close!();\n          return false;\n        }\n        return true;\n      },\n      // Step 3: Set up the ZoomDrawer widget\n      child: ZoomDrawer(\n        controller: _drawerController,\n        style: DrawerStyle.defaultStyle,\n        menuScreen: MenuScreen(\n          onPageSelected: (String page) {\n            _drawerController.close!();\n            // Handle page selection\n          },\n        ),\n        mainScreen: MainScreen(),\n        borderRadius: 24.0,\n        showShadow: true,\n        angle: -12.0,\n        backgroundColor: Colors.grey[300]!,\n        slideWidth: MediaQuery.of(context).size.width * 0.65,\n        openCurve: Curves.fastOutSlowIn,\n        closeCurve: Curves.bounceIn,\n      ),\n    );\n  }\n}\n\n// Step 4: Implement the MenuScreen\nclass MenuScreen extends StatelessWidget {\n  final Function(String) onPageSelected;\n\n  const MenuScreen({Key? key, required this.onPageSelected}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.blue,\n      padding: const EdgeInsets.only(top: 50.0),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Padding(\n            padding: const EdgeInsets.only(left: 16.0, bottom: 16.0),\n            child: Text(\n              \"Menu\",\n              style: TextStyle(fontSize: 24, color: Colors.white),\n            ),\n          ),\n          ListTile(\n            leading: Icon(Icons.home, color: Colors.white),\n            title: Text(\"Home\", style: TextStyle(color: Colors.white)),\n            onTap: () => onPageSelected(\"Home\"),\n          ),\n          ListTile(\n            leading: Icon(Icons.settings, color: Colors.white),\n            title: Text(\"Settings\", style: TextStyle(color: Colors.white)),\n            onTap: () => onPageSelected(\"Settings\"),\n          ),\n          // Add more menu items as needed\n        ],\n      ),\n    );\n  }\n}\n\n// Step 5: Implement the MainScreen\nclass MainScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Zoom Drawer Demo\"),\n        leading: IconButton(\n          icon: Icon(Icons.menu),\n          onPressed: () {\n            // Step 6: Toggle the drawer\n            ZoomDrawer.of(context)!.toggle();\n          },\n        ),\n      ),\n      body: Center(\n        child: Text(\n          \"Main Content\",\n          style: TextStyle(fontSize: 24),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the ZoomDrawer.\n// 2. ZoomDrawer is configured with MenuScreen and MainScreen.\n// 3. MenuScreen contains a list of pages that can be selected.\n// 4. MainScreen displays the main content and has a menu button to open the drawer.\n// 5. When a menu item is tapped, it calls onPageSelected, which closes the drawer.\n// 6. The WillPopScope widget handles the back button press on Android,\n//    closing the drawer if it's open or exiting the app if it's closed.\n\n// Key Features Demonstrated:\n// - Custom drawer style and animation\n// - Gesture control for opening/closing the drawer\n// - Programmatic control of the drawer (toggle, open, close)\n// - Platform-specific handling (Android back button)\n// - Customizable menu items and main content\n// - Responsive design (slideWidth based on screen width)\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tutorialIncluded": true,
    "_id": "Rx1Nho763d29lawKra1qwZ",
    "_type": "package",
    "tags": [
      "drawer",
      "navigation",
      "ui",
      "zoom",
      "menu"
    ],
    "_createdAt": "2024-08-28T22:20:04Z",
    "lastUpdate": "2024-02-25T18:30:00.000Z",
    "name": "flutter_zoom_drawer",
    "similarPackages": [],
    "likesCount": 1025,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CeP3",
        "_type": "reference",
        "_key": "20b3qz1m"
      }
    ],
    "pubPoint": 160,
    "author": "medyas.ml",
    "_rev": "AE3hjGWNkNE6aGQMMbaQAB",
    "description": "# Flutter Zoom Drawer Package: A Comprehensive Overview\n\nThe `flutter_zoom_drawer` package is a powerful and customizable solution for implementing a zoom-style drawer navigation in your Flutter applications. This package provides a sleek and modern navigation drawer that slides out from the side of the screen, revealing a menu while scaling down the main content.\n\n## Key Features\n\n1. **Smooth Animation**: The package offers fluid animations for opening and closing the drawer, enhancing the user experience.\n\n2. **Customizable**: Developers can easily customize the drawer's appearance, including background color, shadow, border radius, and more.\n\n3. **Gesture Control**: Users can open and close the drawer using swipe gestures, making navigation intuitive.\n\n4. **RTL Support**: The package supports right-to-left (RTL) layouts, making it suitable for various language requirements.\n\n5. **Responsive Design**: The drawer adapts well to different screen sizes, ensuring a consistent experience across devices.\n\n6. **Main Screen Scaling**: As the drawer opens, the main screen can be configured to scale down, creating a visually appealing effect.\n\n7. **Event Callbacks**: The package provides callbacks for various drawer events, allowing developers to implement custom logic.\n\n## Why Choose flutter_zoom_drawer?\n\nThe `flutter_zoom_drawer` package stands out for its ease of implementation and the professional look it adds to your application. It's particularly useful for:\n\n- Apps requiring a clean, modern navigation system\n- Projects that need a customizable drawer solution\n- Developers looking to improve user engagement through interactive UI elements\n\nIn the following sections, we'll dive deeper into how to implement and customize the `flutter_zoom_drawer` in your Flutter project.",
    "shortDescription": "A Flutter package with custom implementation of the Side Menu (Drawer)",
    "tutorial": "# Flutter Zoom Drawer Package: Implementation Tutorial\n\nThis tutorial will guide you through the process of implementing the `flutter_zoom_drawer` package in your Flutter application. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `flutter_zoom_drawer` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_zoom_drawer: ^[latest_version]\n```\n\nReplace `[latest_version]` with the current version of the package. Then, run:\n\n```\nflutter pub get\n```\n\n## Step 2: Basic Implementation\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:flutter_zoom_drawer/flutter_zoom_drawer.dart';\n```\n\n2. Create a `ZoomDrawer` widget in your main layout:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ZoomDrawer(\n      controller: ZoomDrawerController(),\n      menuScreen: MenuScreen(),\n      mainScreen: MainScreen(),\n      borderRadius: 24.0,\n      showShadow: true,\n      angle: -12.0,\n      drawerShadowsBackgroundColor: Colors.grey[300]!,\n      slideWidth: MediaQuery.of(context).size.width * 0.65,\n    );\n  }\n}\n```\n\n3. Implement your `MenuScreen` and `MainScreen` widgets.\n\n## Step 3: Customization\n\nCustomize the `ZoomDrawer` by adjusting its properties:\n\n- `angle`: The angle of rotation for the main screen.\n- `backgroundColor`: The color of the drawer background.\n- `slideWidth`: The width of the menu drawer.\n- `mainScreenScale`: The scale factor for the main screen when the drawer is open.\n\n## Step 4: Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to consider the safe area at the top of the screen:\n\n```dart\nimport 'dart:io' show Platform;\n\n// Inside your build method\ndouble topPadding = Platform.isIOS ? 20.0 : 0.0;\n\nreturn ZoomDrawer(\n  // ... other properties\n  menuScreen: Padding(\n    padding: EdgeInsets.only(top: topPadding),\n    child: MenuScreen(),\n  ),\n);\n```\n\n### Android\n\nFor Android, you might want to handle the back button to close the drawer:\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return WillPopScope(\n    onWillPop: () async {\n      if (ZoomDrawer.of(context)!.isOpen()) {\n        ZoomDrawer.of(context)!.close();\n        return false;\n      }\n      return true;\n    },\n    child: ZoomDrawer(\n      // ... your ZoomDrawer configuration\n    ),\n  );\n}\n```\n\n## Step 5: Gesture Control\n\nTo open and close the drawer programmatically:\n\n```dart\nZoomDrawer.of(context)!.toggle();\n```\n\nTo check if the drawer is open:\n\n```dart\nbool isOpen = ZoomDrawer.of(context)!.isOpen();\n```\n\nBy following these steps, you'll have a functional and customizable zoom drawer in your Flutter application. In the next section, we'll look at a complete example that demonstrates all the features of this package.",
    "_updatedAt": "2024-09-06T04:11:22Z",
    "slug": {
      "current": "flutter_zoom_drawer",
      "_type": "slug"
    },
    "packageImage": null
  },
  {
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "jh3mrxo8"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWkf",
        "_type": "reference",
        "_key": "ato2oz2r"
      }
    ],
    "packageImage": null,
    "tutorial": "# Google ML Kit for Flutter: A Comprehensive Tutorial\n\nThis tutorial will guide you through the process of integrating Google ML Kit into your Flutter application. We'll focus on setting up the package and implementing text recognition as an example feature.\n\n## Prerequisites\n\n- Flutter SDK installed\n- Basic knowledge of Flutter and Dart\n- An IDE (e.g., Android Studio, VS Code)\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  google_ml_kit: ^0.7.3\n  image_picker: ^0.8.4+4\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Platform-specific Configuration\n\n### Android Configuration\n\n1. Open `android/app/build.gradle` and ensure the minimum SDK version is set to 21 or higher:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n    }\n}\n```\n\n2. In `android/app/src/main/AndroidManifest.xml`, add the following permission:\n\n```xml\n<uses-permission android:name=\"android.permission.CAMERA\" />\n```\n\n### iOS Configuration\n\n1. Open `ios/Runner/Info.plist` and add the following keys:\n\n```xml\n<key>NSCameraUsageDescription</key>\n<string>This app needs camera access to scan text.</string>\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app needs photos access to get images for text recognition.</string>\n```\n\n## Step 3: Implement Text Recognition\n\nCreate a new file called `text_recognition_page.dart` and add the following code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:google_ml_kit/google_ml_kit.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'dart:io';\n\nclass TextRecognitionPage extends StatefulWidget {\n  @override\n  _TextRecognitionPageState createState() => _TextRecognitionPageState();\n}\n\nclass _TextRecognitionPageState extends State<TextRecognitionPage> {\n  File? _image;\n  String _recognizedText = '';\n\n  Future<void> _pickImage() async {\n    final pickedFile = await ImagePicker().pickImage(source: ImageSource.camera);\n    if (pickedFile != null) {\n      setState(() {\n        _image = File(pickedFile.path);\n      });\n      _recognizeText();\n    }\n  }\n\n  Future<void> _recognizeText() async {\n    if (_image == null) return;\n\n    final inputImage = InputImage.fromFile(_image!);\n    final textDetector = GoogleMlKit.vision.textDetector();\n    final RecognisedText recognisedText = await textDetector.processImage(inputImage);\n\n    setState(() {\n      _recognizedText = recognisedText.text;\n    });\n\n    textDetector.close();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Text Recognition')),\n      body: Column(\n        children: [\n          if (_image != null) Image.file(_image!),\n          ElevatedButton(\n            onPressed: _pickImage,\n            child: Text('Take Picture'),\n          ),\n          Expanded(\n            child: SingleChildScrollView(\n              child: Text(_recognizedText),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Add the Text Recognition Page to Your App\n\nIn your `main.dart` file, import the `TextRecognitionPage` and add it to your app's navigation:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'text_recognition_page.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: TextRecognitionPage(),\n    );\n  }\n}\n```\n\nNow you have a basic implementation of text recognition using Google ML Kit in your Flutter app!",
    "_updatedAt": "2024-09-06T04:11:23Z",
    "pubPoint": 160,
    "author": "flutter-ml.dev",
    "shortDescription": "A Flutter plugin to use all APIs from Google's standalone ML Kit for mobile platforms.",
    "tags": [
      "ml",
      "machine-learning",
      "vision",
      "text-recognition",
      "face-detection"
    ],
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaQDN",
    "_type": "package",
    "name": "google_ml_kit",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPH0w",
        "_type": "reference",
        "_key": "xuyb8lzb"
      }
    ],
    "_createdAt": "2024-08-28T22:20:12Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:google_ml_kit/google_ml_kit.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MLKitDemo(),\n    );\n  }\n}\n\nclass MLKitDemo extends StatefulWidget {\n  @override\n  _MLKitDemoState createState() => _MLKitDemoState();\n}\n\nclass _MLKitDemoState extends State<MLKitDemo> {\n  File? _image;\n  String _result = '';\n\n  // Step 1: Initialize ML Kit detectors\n  final textDetector = GoogleMlKit.vision.textDetector();\n  final faceDetector = GoogleMlKit.vision.faceDetector();\n  final imageLabeler = GoogleMlKit.vision.imageLabeler();\n  final barcodeScanner = GoogleMlKit.vision.barcodeScanner();\n\n  // Step 2: Function to pick image from camera or gallery\n  Future<void> _getImage(ImageSource source) async {\n    final pickedFile = await ImagePicker().pickImage(source: source);\n    if (pickedFile != null) {\n      setState(() {\n        _image = File(pickedFile.path);\n        _result = ''; // Clear previous results\n      });\n    }\n  }\n\n  // Step 3: Function to process image with selected ML Kit feature\n  Future<void> _processImage(String feature) async {\n    if (_image == null) return;\n\n    final inputImage = InputImage.fromFile(_image!);\n    String result = '';\n\n    switch (feature) {\n      case 'Text Recognition':\n        final RecognisedText recognisedText = await textDetector.processImage(inputImage);\n        result = recognisedText.text;\n        break;\n      case 'Face Detection':\n        final List<Face> faces = await faceDetector.processImage(inputImage);\n        result = 'Detected ${faces.length} faces';\n        break;\n      case 'Image Labeling':\n        final List<ImageLabel> labels = await imageLabeler.processImage(inputImage);\n        result = labels.map((label) => '${label.label}: ${label.confidence.toStringAsFixed(2)}').join('\\n');\n        break;\n      case 'Barcode Scanning':\n        final List<Barcode> barcodes = await barcodeScanner.processImage(inputImage);\n        result = barcodes.map((barcode) => 'Barcode: ${barcode.rawValue}').join('\\n');\n        break;\n    }\n\n    setState(() {\n      _result = result;\n    });\n  }\n\n  // Step 4: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('ML Kit Demo')),\n      body: SingleChildScrollView(\n        child: Column(\n          children: [\n            // Step 5: Display selected image\n            if (_image != null) Image.file(_image!),\n            \n            // Step 6: Buttons to select image source\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: () => _getImage(ImageSource.camera),\n                  child: Text('Camera'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _getImage(ImageSource.gallery),\n                  child: Text('Gallery'),\n                ),\n              ],\n            ),\n            \n            // Step 7: Buttons to select ML Kit feature\n            Wrap(\n              spacing: 10,\n              children: [\n                ElevatedButton(\n                  onPressed: () => _processImage('Text Recognition'),\n                  child: Text('Text Recognition'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _processImage('Face Detection'),\n                  child: Text('Face Detection'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _processImage('Image Labeling'),\n                  child: Text('Image Labeling'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _processImage('Barcode Scanning'),\n                  child: Text('Barcode Scanning'),\n                ),\n              ],\n            ),\n            \n            // Step 8: Display results\n            Padding(\n              padding: EdgeInsets.all(16.0),\n              child: Text(_result),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 9: Dispose of resources\n  @override\n  void dispose() {\n    textDetector.close();\n    faceDetector.close();\n    imageLabeler.close();\n    barcodeScanner.close();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays the main screen with options to select an image and ML Kit features.\n// 2. User selects an image from the camera or gallery using the respective buttons.\n// 3. The selected image is displayed on the screen.\n// 4. User chooses an ML Kit feature by pressing one of the feature buttons.\n// 5. The app processes the image using the selected ML Kit feature.\n// 6. Results are displayed on the screen.\n// 7. User can select a different feature or choose a new image to process.\n// 8. When the app is closed, resources are properly disposed of in the dispose() method.\n```",
    "platforms": [
      "android",
      "ios"
    ],
    "likesCount": 1008,
    "lastUpdate": "2024-04-24T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1s1z",
    "slug": {
      "current": "google_ml_kit",
      "_type": "slug"
    },
    "description": "# Google ML Kit for Flutter: Empowering Mobile Apps with Machine Learning\n\n## Introduction\n\nGoogle ML Kit is a powerful suite of machine learning tools designed to enhance mobile applications. The `google_ml_kit` package brings these capabilities to Flutter, allowing developers to integrate advanced ML features into their cross-platform apps with ease.\n\n## Key Features\n\n1. **Text Recognition**: Extract text from images, including handwritten and printed content.\n2. **Face Detection**: Detect and analyze faces in images or live camera feed.\n3. **Pose Detection**: Identify and track human body poses in real-time.\n4. **Image Labeling**: Automatically categorize and label objects within images.\n5. **Barcode Scanning**: Quickly scan and process various barcode formats.\n6. **Language Identification**: Detect the language of text input.\n7. **Smart Reply**: Generate contextually relevant reply suggestions for messages.\n\n## Why Use Google ML Kit in Flutter?\n\n- **Cross-platform Compatibility**: Develop ML-powered apps for both iOS and Android using a single codebase.\n- **On-device Processing**: Many features work offline, ensuring user privacy and reducing latency.\n- **Easy Integration**: Simple API makes it straightforward to add ML capabilities to your app.\n- **Continuous Updates**: Regular updates from Google ensure access to the latest ML algorithms and models.\n\nBy leveraging the `google_ml_kit` package, Flutter developers can create sophisticated, intelligent applications that provide enhanced user experiences and unlock new possibilities in mobile app development.",
    "similarPackages": []
  },
  {
    "tags": [
      "shimmer",
      "animation",
      "loading",
      "ui",
      "effect"
    ],
    "_createdAt": "2024-08-28T22:20:17Z",
    "slug": {
      "current": "shimmer_animation",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaQGZ",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "npnqpcto"
      }
    ],
    "subCategories": [
      {
        "_key": "d60yk1it",
        "_ref": "t8DYBEKn49O4mjbyRAfAQu",
        "_type": "reference"
      }
    ],
    "shortDescription": "This shimmer animation widget can help you bring simple yet beautiful skeleton loaders to your project with ease.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:shimmer_animation/shimmer_animation.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Shimmer Animation Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const ShimmerDemoPage(),\n    );\n  }\n}\n\nclass ShimmerDemoPage extends StatefulWidget {\n  const ShimmerDemoPage({Key? key}) : super(key: key);\n\n  @override\n  _ShimmerDemoPageState createState() => _ShimmerDemoPageState();\n}\n\nclass _ShimmerDemoPageState extends State<ShimmerDemoPage> {\n  bool _isShimmerEnabled = true;\n  ShimmerDirection _direction = ShimmerDirection.fromLTRB();\n  Color _shimmerColor = Colors.white;\n  double _shimmerOpacity = 0.3;\n  Duration _duration = const Duration(seconds: 3);\n  Duration _interval = const Duration(seconds: 5);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Shimmer Animation Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              // Step 1: Basic Shimmer Example\n              const Text('Basic Shimmer Example:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n              Shimmer(\n                duration: _duration,\n                interval: _interval,\n                color: _shimmerColor,\n                colorOpacity: _shimmerOpacity,\n                enabled: _isShimmerEnabled,\n                direction: _direction,\n                child: Container(\n                  width: double.infinity,\n                  height: 100,\n                  color: Colors.grey[300],\n                ),\n              ),\n              const SizedBox(height: 20),\n\n              // Step 2: Shimmer on Text\n              const Text('Shimmer on Text:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n              Shimmer(\n                duration: _duration,\n                interval: _interval,\n                color: _shimmerColor,\n                colorOpacity: _shimmerOpacity,\n                enabled: _isShimmerEnabled,\n                direction: _direction,\n                child: const Text(\n                  'This is a shimmering text!',\n                  style: TextStyle(fontSize: 24),\n                ),\n              ),\n              const SizedBox(height: 20),\n\n              // Step 3: Shimmer on Image\n              const Text('Shimmer on Image:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n              Shimmer(\n                duration: _duration,\n                interval: _interval,\n                color: _shimmerColor,\n                colorOpacity: _shimmerOpacity,\n                enabled: _isShimmerEnabled,\n                direction: _direction,\n                child: Image.network(\n                  'https://via.placeholder.com/300x200',\n                  width: 300,\n                  height: 200,\n                ),\n              ),\n              const SizedBox(height: 20),\n\n              // Step 4: Customization Controls\n              const Text('Customization:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n              Switch(\n                value: _isShimmerEnabled,\n                onChanged: (value) {\n                  setState(() {\n                    _isShimmerEnabled = value;\n                  });\n                },\n              ),\n              const Text('Enable/Disable Shimmer'),\n              DropdownButton<ShimmerDirection>(\n                value: _direction,\n                items: ShimmerDirection.values.map((ShimmerDirection direction) {\n                  return DropdownMenuItem<ShimmerDirection>(\n                    value: direction,\n                    child: Text(direction.toString().split('.').last),\n                  );\n                }).toList(),\n                onChanged: (ShimmerDirection? newValue) {\n                  if (newValue != null) {\n                    setState(() {\n                      _direction = newValue;\n                    });\n                  }\n                },\n              ),\n              Slider(\n                value: _shimmerOpacity,\n                min: 0.0,\n                max: 1.0,\n                divisions: 10,\n                label: _shimmerOpacity.toStringAsFixed(1),\n                onChanged: (double value) {\n                  setState(() {\n                    _shimmerOpacity = value;\n                  });\n                },\n              ),\n              const Text('Shimmer Opacity'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 5: Application Flow Explanation\n/*\nApplication Flow:\n1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n2. The home page is set to ShimmerDemoPage, a stateful widget that demonstrates various shimmer effects.\n3. In the build method of _ShimmerDemoPageState:\n   a. A basic shimmer effect is applied to a container.\n   b. A shimmer effect is applied to a text widget.\n   c. A shimmer effect is applied to an image loaded from a URL.\n4. Customization controls are provided:\n   a. A switch to enable/disable the shimmer effect.\n   b. A dropdown to change the shimmer direction.\n   c. A slider to adjust the shimmer opacity.\n5. As the user interacts with the controls, the setState method is called, which rebuilds the widget tree with the new shimmer settings.\n6. The Shimmer widget wraps each child widget (container, text, and image) and applies the current shimmer settings.\n\nThis example demonstrates how to use the shimmer_animation package with various types of widgets and how to customize the shimmer effect dynamically.\n*/\n```",
    "packageImage": null,
    "lastUpdate": "2024-06-18T18:30:00.000Z",
    "_id": "Rx1Nho763d29lawKra1sCd",
    "tutorial": "# Tutorial: Implementing Shimmer Animation in Flutter\n\nThis tutorial will guide you through the process of adding shimmer animations to your Flutter application using the `shimmer_animation` package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nFirst, add the `shimmer_animation` package to your project's `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  shimmer_animation: ^2.1.0+1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:shimmer_animation/shimmer_animation.dart';\n```\n\n## Step 3: Basic Usage\n\nTo add a shimmer effect to any widget, wrap it with the `Shimmer` widget:\n\n```dart\nShimmer(\n  duration: Duration(seconds: 3), // The duration of one animation cycle\n  interval: Duration(seconds: 5), // The interval between animation cycles\n  color: Colors.white,  // The color of the shimmer effect\n  colorOpacity: 0.3,    // The opacity of the shimmer effect\n  enabled: true,        // Enables the shimmer effect\n  direction: ShimmerDirection.fromLTRB(),  // The direction of the shimmer effect\n  child: YourWidget(),  // The widget to apply the shimmer effect to\n)\n```\n\n## Step 4: Customization\n\nThe `Shimmer` widget offers several customization options:\n\n- `duration`: Controls how long each shimmer animation cycle lasts.\n- `interval`: Sets the time between shimmer animation cycles.\n- `color`: Defines the color of the shimmer effect.\n- `colorOpacity`: Adjusts the opacity of the shimmer effect.\n- `enabled`: Turns the shimmer effect on or off.\n- `direction`: Sets the direction of the shimmer animation (e.g., left to right, top to bottom).\n\n## Step 5: Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional setup is required. The shimmer animation should work out of the box.\n\n### iOS\n\nFor iOS, ensure that your `Info.plist` file includes the following key-value pair to enable metal rendering:\n\n```xml\n<key>CADisableMinimumFrameDurationOnPhone</key>\n<true/>\n```\n\nThis setting allows for smoother animations on iOS devices.\n\n### Web\n\nFor web applications, the shimmer effect is implemented using CSS animations. Ensure that your web renderer is set to HTML in your `index.html` file:\n\n```html\n<script>\n  window.flutterWebRenderer = \"html\";\n</script>\n```\n\n### Desktop (Windows, macOS, Linux)\n\nThe shimmer animation should work on desktop platforms without any additional configuration. However, be mindful of performance on lower-end devices, as the animation can be resource-intensive.\n\n## Step 6: Best Practices\n\n1. **Performance**: While shimmer animations are generally lightweight, be cautious when applying them to large or numerous widgets simultaneously, as this may impact performance.\n\n2. **Accessibility**: Ensure that your app remains accessible when using shimmer animations. Provide alternative ways to convey information for users who may have visual impairments or are sensitive to animations.\n\n3. **Testing**: Test your shimmer animations on various devices and platforms to ensure consistent behavior and performance.\n\nBy following these steps and considerations, you can effectively implement shimmer animations in your Flutter application across different platforms, adding a polished and engaging element to your user interface.",
    "author": "",
    "description": "# Shimmer Animation in Flutter: Adding Sparkle to Your UI\n\n## Introduction\n\nIn the world of mobile app development, creating engaging and visually appealing user interfaces is crucial. One way to add a touch of elegance and interactivity to your Flutter applications is by using shimmer animations. The `shimmer_animation` package provides an easy and efficient way to implement these eye-catching effects in your Flutter projects.\n\n## What is Shimmer Animation?\n\nShimmer animation is a visual effect that creates a shimmering or glowing appearance on UI elements. It's often used to indicate loading states, highlight important information, or simply add a dynamic and attractive element to your app's design. The effect is achieved by animating a gradient overlay across the target widget, creating a subtle, shimmering light effect.\n\n## The `shimmer_animation` Package\n\nThe `shimmer_animation` package for Flutter simplifies the process of adding shimmer effects to your app. It offers a highly customizable `Shimmer` widget that can be wrapped around any existing widget in your Flutter application. Some key features of this package include:\n\n1. **Easy Integration**: Implement shimmer effects with just a few lines of code.\n2. **Customizable Appearance**: Control various aspects of the animation, such as color, direction, and duration.\n3. **Flexible Usage**: Apply shimmer effects to any widget, from simple shapes to complex layouts.\n4. **Performance Optimized**: Designed to be efficient and lightweight, ensuring smooth animations without compromising app performance.\n\n## When to Use Shimmer Animations\n\nShimmer animations can be particularly effective in the following scenarios:\n\n- **Loading Indicators**: Use shimmer effects on placeholder content while actual data is being fetched.\n- **Highlighting Features**: Draw attention to new or important elements in your UI.\n- **Enhancing User Experience**: Add a layer of polish and interactivity to static elements.\n- **Branding**: Incorporate shimmer effects that align with your app's brand colors and style.\n\nIn the following sections, we'll dive deeper into how to implement shimmer animations in your Flutter projects using the `shimmer_animation` package, complete with a step-by-step tutorial and a comprehensive example.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 399,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:24Z",
    "_type": "package",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cakt",
        "_type": "reference",
        "_key": "it044io0"
      }
    ],
    "name": "shimmer_animation"
  },
  {
    "pubPoint": 160,
    "subCategories": [
      {
        "_type": "reference",
        "_key": "dka965ch",
        "_ref": "t8DYBEKn49O4mjbyRAfIgM"
      }
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:25Z",
    "author": "dart.dev",
    "_type": "package",
    "description": "# Understanding the http_parser Package in Flutter\n\nThe `http_parser` package is a crucial tool for Flutter developers working with HTTP requests and responses. It provides a set of utilities for parsing and manipulating HTTP headers, dates, and other elements of HTTP messages.\n\n## Key Features\n\n1. **Header Parsing**: Easily parse HTTP headers into a more manageable format.\n2. **Date Parsing**: Convert HTTP date strings into DateTime objects and vice versa.\n3. **Media Type Parsing**: Parse and manipulate media type (MIME type) information.\n4. **Authentication Parsing**: Handle HTTP authentication headers.\n\n## Why Use http_parser?\n\nWhile Flutter's `http` package provides basic functionality for making HTTP requests, the `http_parser` package offers more advanced parsing capabilities. This is particularly useful when you need to:\n\n- Work with complex HTTP headers\n- Handle dates in HTTP-specific formats\n- Parse and manipulate media types\n- Deal with authentication headers\n\nBy using `http_parser`, you can ensure that your app correctly interprets and generates HTTP-compliant data structures, leading to more robust and reliable networking code.\n\nIn the following sections, we'll dive deeper into how to use this package in your Flutter projects.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1LSx",
        "_type": "reference",
        "_key": "qlorsizt"
      }
    ],
    "dependentPackages": [
      {
        "_key": "ozzr1wcn",
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference"
      }
    ],
    "tutorial": "# HTTP Parser Package Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the `http_parser` package in your Flutter project.\n\n## Step 1: Add the Package\n\nFirst, add the `http_parser` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  http_parser: ^4.0.2\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the necessary components:\n\n```dart\nimport 'package:http_parser/http_parser.dart';\n```\n\n## Step 3: Using HTTP Date Parsing\n\nLet's start with parsing HTTP dates:\n\n```dart\nvoid parseHttpDate() {\n  String httpDate = 'Wed, 21 Oct 2015 07:28:00 GMT';\n  DateTime parsedDate = HttpDate.parse(httpDate);\n  print('Parsed date: $parsedDate');\n\n  String formattedDate = HttpDate.format(DateTime.now());\n  print('Formatted current date: $formattedDate');\n}\n```\n\n## Step 4: Parsing Media Types\n\nNext, let's look at parsing media types:\n\n```dart\nvoid parseMediaType() {\n  MediaType mediaType = MediaType.parse('application/json; charset=utf-8');\n  print('Type: ${mediaType.type}');\n  print('Subtype: ${mediaType.subtype}');\n  print('Parameters: ${mediaType.parameters}');\n}\n```\n\n## Step 5: Working with Authentication Headers\n\nHere's how to parse authentication headers:\n\n```dart\nvoid parseAuthHeader() {\n  String authHeader = 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==';\n  AuthenticationChallenge challenge = AuthenticationChallenge.parse(authHeader);\n  print('Scheme: ${challenge.scheme}');\n  print('Parameters: ${challenge.parameters}');\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure that you have the internet permission in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file to allow non-HTTPS connections (if needed):\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\nBy following these steps, you'll have a solid foundation for using the `http_parser` package in your Flutter projects across different platforms.",
    "name": "http_parser",
    "slug": {
      "current": "http_parser",
      "_type": "slug"
    },
    "shortDescription": "A platform-independent package for parsing and serializing HTTP formats.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:http_parser/http_parser.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'HTTP Parser Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HttpParserDemo(),\n    );\n  }\n}\n\nclass HttpParserDemo extends StatefulWidget {\n  @override\n  _HttpParserDemoState createState() => _HttpParserDemoState();\n}\n\nclass _HttpParserDemoState extends State<HttpParserDemo> {\n  String _output = '';\n\n  // Step 1: Parse HTTP Date\n  void _parseHttpDate() {\n    String httpDate = 'Wed, 21 Oct 2015 07:28:00 GMT';\n    DateTime parsedDate = HttpDate.parse(httpDate);\n    String formattedDate = HttpDate.format(DateTime.now());\n\n    setState(() {\n      _output = 'Parsed date: $parsedDate\\nFormatted current date: $formattedDate';\n    });\n  }\n\n  // Step 2: Parse Media Type\n  void _parseMediaType() {\n    MediaType mediaType = MediaType.parse('application/json; charset=utf-8');\n\n    setState(() {\n      _output = 'Type: ${mediaType.type}\\nSubtype: ${mediaType.subtype}\\nParameters: ${mediaType.parameters}';\n    });\n  }\n\n  // Step 3: Parse Authentication Header\n  void _parseAuthHeader() {\n    String authHeader = 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==';\n    AuthenticationChallenge challenge = AuthenticationChallenge.parse(authHeader);\n\n    setState(() {\n      _output = 'Scheme: ${challenge.scheme}\\nParameters: ${challenge.parameters}';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('HTTP Parser Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: _parseHttpDate,\n              child: Text('Parse HTTP Date'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _parseMediaType,\n              child: Text('Parse Media Type'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _parseAuthHeader,\n              child: Text('Parse Auth Header'),\n            ),\n            SizedBox(height: 20),\n            Text(_output),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays three buttons for different parsing operations.\n// 2. When a button is pressed, it calls the corresponding method:\n//    - _parseHttpDate(): Demonstrates parsing and formatting HTTP dates.\n//    - _parseMediaType(): Shows how to parse a media type string.\n//    - _parseAuthHeader(): Illustrates parsing an authentication header.\n// 3. Each method updates the _output string using setState(), which triggers a rebuild.\n// 4. The updated _output is displayed on the screen, showing the results of the parsing operation.\n// \n// This example showcases the main features of the http_parser package in a simple, interactive manner.\n// Users can easily see how each parsing function works by pressing the corresponding button.\n```",
    "tags": [
      "http",
      "parser",
      "network",
      "mime"
    ],
    "likesCount": 229,
    "_createdAt": "2024-08-28T22:20:20Z",
    "lastUpdate": "2024-06-16T18:30:00.000Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaQJl",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "Rx1Nho763d29lawKra1sm7"
  },
  {
    "pubPoint": 160,
    "author": "bloclibrary.dev",
    "_rev": "ezMiwuUkJkbYMWycA6Ra12",
    "_type": "package",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-b3e61443a361f2a4fe2fd8e5e155780608954d87-546x650-webp",
        "_type": "reference"
      }
    },
    "_id": "Rx1Nho763d29lawKra1swl",
    "tutorialIncluded": true,
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXCi",
        "_type": "reference",
        "_key": "511jl7yq"
      }
    ],
    "tags": [
      "bloc",
      "state-management",
      "testing",
      "unit-test"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Ca4b",
        "_type": "reference",
        "_key": "x02mdkg4"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "t1jzhb1t"
      }
    ],
    "_createdAt": "2024-08-28T22:20:23Z",
    "tutorial": "# bloc_test Package Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the `bloc_test` package in your Flutter project.\n\n## Step 1: Add the Package\n\nFirst, add the `bloc_test` package to your `pubspec.yaml` file:\n\n```yaml\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  bloc_test: ^9.1.3\n  mocktail: ^0.3.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your test file, import the necessary components:\n\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:bloc_test/bloc_test.dart';\nimport 'package:mocktail/mocktail.dart';\n```\n\n## Step 3: Create a Simple BLoC for Testing\n\nLet's create a simple counter BLoC to demonstrate testing:\n\n```dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n\nclass CounterBloc extends Bloc<CounterEvent, int> {\n  CounterBloc() : super(0) {\n    on<IncrementEvent>((event, emit) => emit(state + 1));\n    on<DecrementEvent>((event, emit) => emit(state - 1));\n  }\n}\n```\n\n## Step 4: Writing BLoC Tests\n\nNow, let's write tests for our CounterBloc:\n\n```dart\nvoid main() {\n  group('CounterBloc', () {\n    blocTest<CounterBloc, int>(\n      'emits [1] when IncrementEvent is added',\n      build: () => CounterBloc(),\n      act: (bloc) => bloc.add(IncrementEvent()),\n      expect: () => [1],\n    );\n\n    blocTest<CounterBloc, int>(\n      'emits [-1] when DecrementEvent is added',\n      build: () => CounterBloc(),\n      act: (bloc) => bloc.add(DecrementEvent()),\n      expect: () => [-1],\n    );\n  });\n}\n```\n\n## Step 5: Testing Error Scenarios\n\nLet's add an error scenario to our BLoC and test it:\n\n```dart\nclass CounterBloc extends Bloc<CounterEvent, int> {\n  CounterBloc() : super(0) {\n    on<IncrementEvent>((event, emit) => emit(state + 1));\n    on<DecrementEvent>((event, emit) {\n      if (state == 0) throw Exception('Cannot go below zero');\n      emit(state - 1);\n    });\n  }\n}\n\n// In the test file:\nblocTest<CounterBloc, int>(\n  'throws exception when decrementing at 0',\n  build: () => CounterBloc(),\n  act: (bloc) => bloc.add(DecrementEvent()),\n  errors: () => [isA<Exception>()],\n);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no specific configuration is needed for testing. Ensure that your `android/app/build.gradle` file has the correct test dependencies:\n\n```gradle\ndependencies {\n    testImplementation 'junit:junit:4.13.2'\n}\n```\n\n### iOS\n\nFor iOS, no additional configuration is required for running bloc tests. However, ensure that your `ios/Runner.xcodeproj/project.pbxproj` file includes the correct test target:\n\n```\n/* Begin PBXNativeTarget section */\n\t\t97C146ED1CF9000F007C117D /* Runner */ = {\n\t\t\tisa = PBXNativeTarget;\n\t\t\tbuildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget \"Runner\" */;\n\t\t\tbuildPhases = (\n\t\t\t\t9740EEB61CF901F6004384FC /* Run Script */,\n\t\t\t\t97C146EA1CF9000F007C117D /* Sources */,\n\t\t\t\t97C146EB1CF9000F007C117D /* Frameworks */,\n\t\t\t\t97C146EC1CF9000F007C117D /* Resources */,\n\t\t\t\t9705A1C41CF9048500538489 /* Embed Frameworks */,\n\t\t\t\t3B06AD1E1E4923F5004D2608 /* Thin Binary */,\n\t\t\t);\n\t\t\tbuildRules = (\n\t\t\t);\n\t\t\tdependencies = (\n\t\t\t);\n\t\t\tname = Runner;\n\t\t\tproductName = Runner;\n\t\t\tproductReference = 97C146EE1CF9000F007C117D /* Runner.app */;\n\t\t\tproductType = \"com.apple.product-type.application\";\n\t\t};\n/* End PBXNativeTarget section */\n```\n\nBy following these steps, you'll have a solid foundation for using the `bloc_test` package in your Flutter projects across different platforms.",
    "_updatedAt": "2024-09-06T04:11:26Z",
    "slug": {
      "current": "bloc_test",
      "_type": "slug"
    },
    "description": "# Understanding the bloc_test Package in Flutter\n\nThe `bloc_test` package is an essential tool for Flutter developers working with the BLoC (Business Logic Component) pattern. It provides a robust set of utilities for testing BLoCs, making it easier to ensure the correctness and reliability of your application's business logic.\n\n## Key Features\n\n1. **BLoC-specific Matchers**: Custom matchers tailored for BLoC testing scenarios.\n2. **Mock BLoC Creation**: Easily create mock BLoCs for isolated testing.\n3. **Event Simulation**: Simulate the emission of events and observe state changes.\n4. **State Verification**: Verify the sequence and content of emitted states.\n5. **Integration with flutter_test**: Seamless integration with Flutter's built-in testing framework.\n\n## Why Use bloc_test?\n\nWhile Flutter's standard testing utilities are powerful, the `bloc_test` package offers specialized tools for BLoC pattern implementations. This is particularly useful when you need to:\n\n- Verify complex state transitions in your BLoCs\n- Test error handling and edge cases in your business logic\n- Ensure that your BLoCs emit the correct states in response to events\n- Mock dependencies and isolate BLoC behavior for unit testing\n\nBy using `bloc_test`, you can write more comprehensive and reliable tests for your BLoC-based Flutter applications. This leads to more robust code, fewer bugs, and easier maintenance of your application's core logic.\n\nIn the following sections, we'll explore how to integrate and use this package in your Flutter projects, providing you with the tools to thoroughly test your BLoCs.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:bloc_test/bloc_test.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\n// Step 1: Define Events and States\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n\n// Step 2: Create the BLoC\nclass CounterBloc extends Bloc<CounterEvent, int> {\n  CounterBloc() : super(0) {\n    on<IncrementEvent>((event, emit) => emit(state + 1));\n    on<DecrementEvent>((event, emit) {\n      if (state > 0) {\n        emit(state - 1);\n      } else {\n        addError(Exception('Counter cannot go below zero'));\n      }\n    });\n  }\n}\n\n// Step 3: Create the main app widget\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: CounterPage(),\n      ),\n    );\n  }\n}\n\n// Step 4: Create the counter page\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Counter App')),\n      body: Center(\n        child: BlocBuilder<CounterBloc, int>(\n          builder: (context, count) {\n            return Text('Count: $count', style: TextStyle(fontSize: 24));\n          },\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        children: [\n          FloatingActionButton(\n            child: Icon(Icons.add),\n            onPressed: () => context.read<CounterBloc>().add(IncrementEvent()),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            child: Icon(Icons.remove),\n            onPressed: () => context.read<CounterBloc>().add(DecrementEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 5: Write tests for the CounterBloc\nvoid main() {\n  group('CounterBloc', () {\n    blocTest<CounterBloc, int>(\n      'emits [1] when IncrementEvent is added',\n      build: () => CounterBloc(),\n      act: (bloc) => bloc.add(IncrementEvent()),\n      expect: () => [1],\n    );\n\n    blocTest<CounterBloc, int>(\n      'emits [] when DecrementEvent is added at 0',\n      build: () => CounterBloc(),\n      act: (bloc) => bloc.add(DecrementEvent()),\n      expect: () => [],\n      errors: () => [isA<Exception>()],\n    );\n\n    blocTest<CounterBloc, int>(\n      'emits [1, 0] for Increment and Decrement',\n      build: () => CounterBloc(),\n      act: (bloc) {\n        bloc.add(IncrementEvent());\n        bloc.add(DecrementEvent());\n      },\n      expect: () => [1, 0],\n    );\n  });\n\n  testWidgets('CounterPage has a title and displays the count', (WidgetTester tester) async {\n    await tester.pumpWidget(RealFlutter());\n    expect(find.text('Counter App'), findsOneWidget);\n    expect(find.text('Count: 0'), findsOneWidget);\n  });\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the BlocProvider for CounterBloc.\n// 2. CounterPage is displayed, showing the current count and two buttons.\n// 3. When the user presses the \"+\" button, an IncrementEvent is added to the CounterBloc.\n// 4. When the user presses the \"-\" button, a DecrementEvent is added to the CounterBloc.\n// 5. The CounterBloc processes these events and emits new states (updated count).\n// 6. The BlocBuilder in CounterPage rebuilds the UI with the new count.\n// 7. If the user tries to decrement below zero, an error is added to the bloc (but not displayed in this simple UI).\n// \n// The tests demonstrate:\n// - How to use blocTest to verify the behavior of the CounterBloc.\n// - Testing for state changes and error conditions.\n// - How to use testWidgets to verify the initial state of the UI.\n//\n// This example showcases a simple implementation of the BLoC pattern and how to test it using the bloc_test package.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-03-23T18:30:00.000Z",
    "shortDescription": "A testing library which makes it easy to test blocs. Built to be used with the bloc state management package.",
    "similarPackages": [
      {
        "_key": "yfuk46dn",
        "_ref": "Rx1Nho763d29lawKra1mhz",
        "_type": "reference"
      }
    ],
    "likesCount": 582,
    "name": "bloc_test"
  },
  {
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVnc",
        "_type": "reference",
        "_key": "b2jrkwj8"
      }
    ],
    "example": "```\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:adaptive_theme/adaptive_theme.dart';\n\n// Step 1: Main function\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  final savedThemeMode = await AdaptiveTheme.getThemeMode();\n  runApp(RealFlutter(savedThemeMode: savedThemeMode));\n}\n\n// Step 2: RealFlutter class\nclass RealFlutter extends StatelessWidget {\n  final AdaptiveThemeMode? savedThemeMode;\n  \n  const RealFlutter({Key? key, this.savedThemeMode}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Define custom themes\n    final lightTheme = ThemeData(\n      primarySwatch: Colors.blue,\n      brightness: Brightness.light,\n      scaffoldBackgroundColor: Colors.white,\n    );\n\n    final darkTheme = ThemeData(\n      primarySwatch: Colors.indigo,\n      brightness: Brightness.dark,\n      scaffoldBackgroundColor: Colors.grey[900],\n    );\n\n    // Step 4: Wrap MaterialApp with AdaptiveTheme\n    return AdaptiveTheme(\n      light: lightTheme,\n      dark: darkTheme,\n      initial: savedThemeMode ?? AdaptiveThemeMode.light,\n      builder: (theme, darkTheme) => MaterialApp(\n        title: 'Adaptive Theme Demo',\n        theme: theme,\n        darkTheme: darkTheme,\n        home: HomePage(),\n      ),\n    );\n  }\n}\n\n// Step 5: HomePage class\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Adaptive Theme Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 6: Display current theme mode\n            Text(\n              'Current Theme Mode:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            Text(\n              '${AdaptiveTheme.of(context).mode}',\n              style: Theme.of(context).textTheme.subtitle1,\n            ),\n            SizedBox(height: 20),\n            // Step 7: Theme switching buttons\n            ElevatedButton(\n              onPressed: () => AdaptiveTheme.of(context).setLight(),\n              child: Text('Set Light Theme'),\n            ),\n            ElevatedButton(\n              onPressed: () => AdaptiveTheme.of(context).setDark(),\n              child: Text('Set Dark Theme'),\n            ),\n            ElevatedButton(\n              onPressed: () => AdaptiveTheme.of(context).setSystem(),\n              child: Text('Set System Theme'),\n            ),\n            // Step 8: Custom theme toggle\n            ElevatedButton(\n              onPressed: () {\n                final currentBrightness = Theme.of(context).brightness;\n                AdaptiveTheme.of(context).setTheme(\n                  light: currentBrightness == Brightness.dark\n                      ? ThemeData.light()\n                      : ThemeData(\n                          primarySwatch: Colors.orange,\n                          brightness: Brightness.light,\n                        ),\n                  dark: currentBrightness == Brightness.light\n                      ? ThemeData.dark()\n                      : ThemeData(\n                          primarySwatch: Colors.deepPurple,\n                          brightness: Brightness.dark,\n                        ),\n                );\n              },\n              child: Text('Toggle Custom Theme'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by checking for a saved theme mode.\n// 2. RealFlutter widget is created with the saved theme mode (if any).\n// 3. Custom light and dark themes are defined.\n// 4. AdaptiveTheme wraps the MaterialApp, providing theme management.\n// 5. HomePage is set as the initial route.\n// 6. In HomePage, the current theme mode is displayed.\n// 7. Buttons are provided to switch between light, dark, and system themes.\n// 8. A custom theme toggle button demonstrates how to switch between different custom themes.\n// 9. When a theme change occurs, AdaptiveTheme automatically updates the UI and saves the preference.\n```",
    "likesCount": 773,
    "_createdAt": "2024-08-28T22:20:26Z",
    "_updatedAt": "2024-09-06T04:11:27Z",
    "author": "birju.dev",
    "shortDescription": "Allows to change between light and dark theme dynamically and add system adaptive theme support.",
    "similarPackages": [],
    "lastUpdate": "2024-01-29T18:30:00.000Z",
    "description": "# Adaptive Theme Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `adaptive_theme` package is a powerful tool for Flutter developers who want to implement dynamic theming in their applications. It provides an easy way to switch between light and dark themes, as well as custom themes, at runtime. This package is particularly useful for creating apps that respect the user's system-wide theme preferences while also allowing manual theme changes.\n\n### Key Features:\n\n1. **Dynamic Theme Switching**: Easily switch between light, dark, and custom themes at runtime.\n2. **System Theme Detection**: Automatically detect and apply the system theme.\n3. **Theme Persistence**: Save the user's theme preference across app restarts.\n4. **Custom Theme Support**: Create and use custom themes beyond just light and dark.\n5. **Smooth Transitions**: Seamless transitions when switching between themes.\n\n### Why Use Adaptive Theme?\n\n- **Improved User Experience**: Allows users to choose their preferred theme, enhancing readability and comfort.\n- **System Integration**: Respects the user's system-wide theme settings, providing a consistent experience across the device.\n- **Flexibility**: Offers developers the ability to create and switch between multiple custom themes.\n- **Performance**: Efficiently manages theme changes without requiring a full app restart.\n\nIn the following sections, we'll dive into a tutorial on how to implement the adaptive_theme package in your Flutter project, followed by a comprehensive example showcasing all its features.",
    "tags": [
      "theme",
      "theming",
      "dynamic-theme",
      "adaptive-theme",
      "theme-switcher",
      "dark-mode"
    ],
    "dependentPackages": [
      {
        "_key": "no1kn3bo",
        "_ref": "uQRNMiDfrp20RZ8Id8CTzf",
        "_type": "reference"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "jevob3xy"
      }
    ],
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "adaptive_theme",
    "_id": "Rx1Nho763d29lawKra1tP9",
    "tutorial": "## 2. Tutorial: Implementing Adaptive Theme in Flutter\n\nFollow these steps to integrate the `adaptive_theme` package into your Flutter project:\n\n### Step 1: Add the dependency\n\nAdd the following line to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  adaptive_theme: ^3.1.1\n```\n\nRun `flutter pub get` to fetch the package.\n\n### Step 2: Wrap your app with AdaptiveTheme\n\nIn your `main.dart` file, wrap your `MaterialApp` with `AdaptiveTheme`:\n\n```dart\nimport 'package:adaptive_theme/adaptive_theme.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  final savedThemeMode = await AdaptiveTheme.getThemeMode();\n  runApp(RealFlutter(savedThemeMode: savedThemeMode));\n}\n\nclass RealFlutter extends StatelessWidget {\n  final AdaptiveThemeMode? savedThemeMode;\n  \n  const RealFlutter({Key? key, this.savedThemeMode}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return AdaptiveTheme(\n      light: ThemeData.light(),\n      dark: ThemeData.dark(),\n      initial: savedThemeMode ?? AdaptiveThemeMode.light,\n      builder: (theme, darkTheme) => MaterialApp(\n        theme: theme,\n        darkTheme: darkTheme,\n        home: HomePage(),\n      ),\n    );\n  }\n}\n```\n\n### Step 3: Implement theme switching\n\nIn your widgets, you can now switch themes using `AdaptiveTheme.of(context)`:\n\n```dart\nElevatedButton(\n  onPressed: () => AdaptiveTheme.of(context).setLight(),\n  child: Text('Set Light Theme'),\n),\nElevatedButton(\n  onPressed: () => AdaptiveTheme.of(context).setDark(),\n  child: Text('Set Dark Theme'),\n),\nElevatedButton(\n  onPressed: () => AdaptiveTheme.of(context).setSystem(),\n  child: Text('Set System Theme'),\n),\n```\n\n### Step 4: Access current theme mode\n\nYou can check the current theme mode using:\n\n```dart\nfinal currentMode = AdaptiveTheme.of(context).mode;\n```\n\n### Step 5: Create custom themes (optional)\n\nTo use custom themes, define them and pass them to `AdaptiveTheme`:\n\n```dart\nfinal lightTheme = ThemeData(\n  primarySwatch: Colors.blue,\n  brightness: Brightness.light,\n);\n\nfinal darkTheme = ThemeData(\n  primarySwatch: Colors.indigo,\n  brightness: Brightness.dark,\n);\n\n// In your build method\nreturn AdaptiveTheme(\n  light: lightTheme,\n  dark: darkTheme,\n  initial: savedThemeMode ?? AdaptiveThemeMode.light,\n  builder: (theme, darkTheme) => MaterialApp(\n    theme: theme,\n    darkTheme: darkTheme,\n    home: HomePage(),\n  ),\n);\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n- In iOS, you might want to use `CupertinoAdaptiveTheme` for a more native look:\n\n```dart\nimport 'package:adaptive_theme/adaptive_theme.dart';\nimport 'package:flutter/cupertino.dart';\n\n// ...\n\nreturn CupertinoAdaptiveTheme(\n  light: CupertinoThemeData(brightness: Brightness.light),\n  dark: CupertinoThemeData(brightness: Brightness.dark),\n  initial: savedThemeMode ?? AdaptiveThemeMode.light,\n  builder: (theme) => CupertinoApp(\n    theme: theme,\n    home: HomePage(),\n  ),\n);\n```\n\n#### Android\n- For Android, you might want to consider using Material 3 design:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// ...\n\nfinal lightTheme = ThemeData(\n  useMaterial3: true,\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue, brightness: Brightness.light),\n);\n\nfinal darkTheme = ThemeData(\n  useMaterial3: true,\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue, brightness: Brightness.dark),\n);\n\n// Use these themes in AdaptiveTheme\n```\n\n#### Web\n- For web applications, ensure that your theme changes are reflected in the browser's theme-color meta tag:\n\n```dart\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\n\n// In your build method\nif (kIsWeb) {\n  SystemChrome.setApplicationSwitcherDescription(\n    ApplicationSwitcherDescription(\n      label: 'My Flutter App',\n      primaryColor: Theme.of(context).primaryColor.value,\n    ),\n  );\n}\n```\n\nBy following these steps and considering platform-specific details, you can effectively implement the adaptive_theme package in your Flutter project across different platforms.",
    "tutorialIncluded": true,
    "slug": {
      "current": "adaptive_theme",
      "_type": "slug"
    },
    "_rev": "ezMiwuUkJkbYMWycA6Ra8E",
    "_type": "package",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-84485064960c0ec8aae77676fa65dedef3fc0b9a-800x720-webp",
        "_type": "reference"
      }
    }
  },
  {
    "likesCount": 738,
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPamQK",
        "_type": "reference",
        "_key": "oid1vtfi"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CcrR",
        "_type": "reference",
        "_key": "lsthbbxh"
      }
    ],
    "lastUpdate": "2024-05-19T18:30:00.000Z",
    "tutorialIncluded": true,
    "shortDescription": "A powerful grid layout system for Flutter, optimized for complex user interface design.",
    "author": "madewithfelt.com",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFlU",
        "_type": "reference",
        "_key": "rxfwf0cb"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_layout_grid/flutter_layout_grid.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Layout Grid Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  bool _isWideLayout = true;\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Use LayoutBuilder to determine the available width\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Layout Grid Demo')),\n      body: LayoutBuilder(\n        builder: (context, constraints) {\n          _isWideLayout = constraints.maxWidth > 600;\n          // Step 2: Call the appropriate layout method based on screen width\n          return _isWideLayout ? _buildWideLayout() : _buildNarrowLayout();\n        },\n      ),\n    );\n  }\n\n  Widget _buildWideLayout() {\n    // Step 3: Define a wide layout for larger screens\n    return LayoutGrid(\n      columnSizes: [1.fr, 1.fr, 1.fr],\n      rowSizes: [auto, 1.fr, 1.fr],\n      columnGap: 12,\n      rowGap: 12,\n      children: [\n        // Step 4: Place widgets in the grid using GridArea\n        GridArea(\n          columnStart: 0,\n          columnSpan: 3,\n          rowStart: 0,\n          rowSpan: 1,\n          child: _buildHeader(),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 2,\n          rowStart: 1,\n          rowSpan: 1,\n          child: _buildChart(),\n        ),\n        GridArea(\n          columnStart: 2,\n          columnSpan: 1,\n          rowStart: 1,\n          rowSpan: 2,\n          child: _buildSidebar(),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 2,\n          rowSpan: 1,\n          child: _buildInfoCard('Sales', '\\$15,000', Colors.green),\n        ),\n        GridArea(\n          columnStart: 1,\n          columnSpan: 1,\n          rowStart: 2,\n          rowSpan: 1,\n          child: _buildInfoCard('Orders', '150', Colors.orange),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildNarrowLayout() {\n    // Step 5: Define a narrow layout for smaller screens\n    return LayoutGrid(\n      columnSizes: [1.fr],\n      rowSizes: [auto, 1.fr, auto, auto, auto],\n      rowGap: 12,\n      children: [\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 0,\n          rowSpan: 1,\n          child: _buildHeader(),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 1,\n          rowSpan: 1,\n          child: _buildChart(),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 2,\n          rowSpan: 1,\n          child: _buildInfoCard('Sales', '\\$15,000', Colors.green),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 3,\n          rowSpan: 1,\n          child: _buildInfoCard('Orders', '150', Colors.orange),\n        ),\n        GridArea(\n          columnStart: 0,\n          columnSpan: 1,\n          rowStart: 4,\n          rowSpan: 1,\n          child: _buildSidebar(),\n        ),\n      ],\n    );\n  }\n\n  // Step 6: Helper methods to build individual widgets\n  Widget _buildHeader() {\n    return Container(\n      color: Colors.blue,\n      height: 60,\n      child: Center(child: Text('Dashboard', style: TextStyle(color: Colors.white, fontSize: 24))),\n    );\n  }\n\n  Widget _buildChart() {\n    return Container(\n      color: Colors.grey[200],\n      child: Center(child: Text('Chart Placeholder')),\n    );\n  }\n\n  Widget _buildSidebar() {\n    return Container(\n      color: Colors.grey[300],\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text('Sidebar'),\n          SizedBox(height: 10),\n          ElevatedButton(\n            onPressed: () {\n              // Step 7: Add interactivity\n              ScaffoldMessenger.of(context).showSnackBar(\n                SnackBar(content: Text('Button pressed!')),\n              );\n            },\n            child: Text('Action'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildInfoCard(String title, String value, Color color) {\n    return Container(\n      color: color.withOpacity(0.2),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(title, style: TextStyle(fontSize: 18)),\n          SizedBox(height: 8),\n          Text(value, style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 8: Application Flow Explanation\n/*\n1. The app starts by running MyApp, which sets up the MaterialApp and sets RealFlutter as the home widget.\n2. RealFlutter is a StatefulWidget that builds its UI based on the available screen width.\n3. LayoutBuilder is used to determine the screen width and choose between wide and narrow layouts.\n4. The chosen layout (_buildWideLayout or _buildNarrowLayout) creates a LayoutGrid with appropriate column and row sizes.\n5. Widgets are placed in the grid using GridArea, specifying their position and span.\n6. Helper methods (_buildHeader, _buildChart, _buildSidebar, _buildInfoCard) create individual widgets for the layout.\n7. The layout adapts to screen size changes, reorganizing widgets for optimal display on different devices.\n8. Interactivity is added through the button in the sidebar, demonstrating how to handle user actions within the grid layout.\n\nThis example showcases the key features of flutter_layout_grid:\n- Responsive design with LayoutBuilder\n- Flexible sizing using fr units\n- Precise item placement with GridArea\n- Gap settings between rows and columns\n- Combining fixed (auto) and flexible (fr) sizes\n- Creating complex layouts that adapt to different screen sizes\n*/\n```",
    "tutorial": "# Flutter Layout Grid: Tutorial\n\nIn this tutorial, we'll walk through the process of implementing a layout using the `flutter_layout_grid` package. We'll create a simple dashboard layout that adapts to different screen sizes.\n\n## Step 1: Add Dependencies\n\nFirst, add the `flutter_layout_grid` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_layout_grid: ^2.0.1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_layout_grid/flutter_layout_grid.dart';\n```\n\n## Step 3: Create a Grid Layout\n\nLet's create a basic grid layout with four widgets:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Layout Grid Example')),\n      body: LayoutGrid(\n        columnSizes: [1.fr, 1.fr],\n        rowSizes: [1.fr, 1.fr],\n        children: [\n          GridArea(\n            columnStart: 0,\n            columnSpan: 1,\n            rowStart: 0,\n            rowSpan: 1,\n            child: Container(color: Colors.red, child: Center(child: Text('Widget 1'))),\n          ),\n          GridArea(\n            columnStart: 1,\n            columnSpan: 1,\n            rowStart: 0,\n            rowSpan: 1,\n            child: Container(color: Colors.green, child: Center(child: Text('Widget 2'))),\n          ),\n          GridArea(\n            columnStart: 0,\n            columnSpan: 1,\n            rowStart: 1,\n            rowSpan: 1,\n            child: Container(color: Colors.blue, child: Center(child: Text('Widget 3'))),\n          ),\n          GridArea(\n            columnStart: 1,\n            columnSpan: 1,\n            rowStart: 1,\n            rowSpan: 1,\n            child: Container(color: Colors.yellow, child: Center(child: Text('Widget 4'))),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Responsive Layout\n\nTo make the layout responsive, we can use `LayoutBuilder` and adjust the grid based on the available width:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Responsive Flutter Layout Grid')),\n      body: LayoutBuilder(\n        builder: (context, constraints) {\n          if (constraints.maxWidth > 600) {\n            // Tablet and desktop layout\n            return _buildWideLayout();\n          } else {\n            // Mobile layout\n            return _buildNarrowLayout();\n          }\n        },\n      ),\n    );\n  }\n\n  Widget _buildWideLayout() {\n    return LayoutGrid(\n      columnSizes: [1.fr, 1.fr, 1.fr],\n      rowSizes: [1.fr, 1.fr],\n      children: [\n        // ... (place widgets in a 3x2 grid)\n      ],\n    );\n  }\n\n  Widget _buildNarrowLayout() {\n    return LayoutGrid(\n      columnSizes: [1.fr],\n      rowSizes: [1.fr, 1.fr, 1.fr, 1.fr],\n      children: [\n        // ... (place widgets in a 1x4 grid)\n      ],\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, ensure that you've set up your `Info.plist` file correctly, especially if you're using any platform-specific features or permissions.\n\n### Android\nFor Android, make sure your `AndroidManifest.xml` file is properly configured. If you're targeting Android 12 (API level 31) or higher, you may need to add the following to your manifest file:\n\n```xml\n<manifest ...>\n  <uses-sdk tools:overrideLibrary=\"net.baseflow.flutter_layout_grid\"/>\n  ...\n</manifest>\n```\n\n### Web\nFor web deployment, no additional setup is required. However, ensure that your web renderer is set to either HTML or CanvasKit based on your performance needs.\n\nBy following these steps and considering platform-specific details, you can create a responsive layout using `flutter_layout_grid` that works well across different devices and platforms.",
    "_updatedAt": "2024-09-06T04:11:28Z",
    "pubPoint": 160,
    "description": "# Flutter Layout Grid: A Powerful Layout Package\n\n## Introduction\n\nIn the world of Flutter development, creating complex and responsive layouts can be a challenging task. The `flutter_layout_grid` package offers a solution by providing a powerful grid-based layout system inspired by CSS Grid Layout. This package allows developers to create flexible and dynamic layouts with ease, making it an essential tool for building sophisticated user interfaces.\n\n## Key Features\n\n1. **Two-dimensional layout**: Unlike Flutter's built-in Row and Column widgets, `flutter_layout_grid` enables you to create layouts in both horizontal and vertical directions simultaneously.\n\n2. **Flexible sizing**: Define track sizes using fixed, flexible, or content-based dimensions, allowing for highly adaptable layouts.\n\n3. **Item placement**: Precisely control the position and span of child widgets within the grid.\n\n4. **Automatic placement**: Let the grid automatically place items for you, simplifying the layout process.\n\n5. **Responsive design**: Create layouts that adapt to different screen sizes and orientations with ease.\n\n6. **Named grid areas**: Define named areas within your grid for more intuitive item placement.\n\n## When to Use Flutter Layout Grid\n\nThe `flutter_layout_grid` package is particularly useful in the following scenarios:\n\n- Creating complex dashboard layouts\n- Designing responsive web layouts\n- Building grid-based game boards\n- Implementing magazine-style layouts\n- Crafting flexible form layouts\n\nBy leveraging the power of `flutter_layout_grid`, developers can create sophisticated and responsive user interfaces that work seamlessly across various devices and screen sizes.",
    "similarPackages": [],
    "name": "flutter_layout_grid",
    "slug": {
      "_type": "slug",
      "current": "flutter_layout_grid"
    },
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "layout",
      "grid",
      "responsive",
      "ui",
      "widget"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:38Z",
    "_id": "Rx1Nho763d29lawKra1tZn",
    "_rev": "ezMiwuUkJkbYMWycA6RaFQ"
  },
  {
    "_id": "Rx1Nho763d29lawKra1u2B",
    "tutorialIncluded": true,
    "_createdAt": "2024-08-28T22:20:40Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmOSZ",
    "shortDescription": "A Styled Toast Flutter package. You can highly customize toast ever.Beautify toast with a series of animations and make toast more beautiful.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_styled_toast/flutter_styled_toast.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Styled Toast Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ToastDemo(),\n    );\n  }\n}\n\nclass ToastDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Styled Toast Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Show Basic Toast'),\n              onPressed: () => _showBasicToast(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Customized Toast'),\n              onPressed: () => _showCustomizedToast(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Positioned Toast'),\n              onPressed: () => _showPositionedToast(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Animated Toast'),\n              onPressed: () => _showAnimatedToast(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Platform-Specific Toast'),\n              onPressed: () => _showPlatformSpecificToast(context),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Basic Toast\n  void _showBasicToast(BuildContext context) {\n    showToast(\n      'This is a basic toast message',\n      context: context,\n      duration: Duration(seconds: 3),\n    );\n  }\n\n  // Step 2: Customized Toast\n  void _showCustomizedToast(BuildContext context) {\n    showToast(\n      'This is a customized toast',\n      context: context,\n      backgroundColor: Colors.purple,\n      textStyle: TextStyle(fontSize: 18.0, color: Colors.white),\n      borderRadius: BorderRadius.circular(15.0),\n      textPadding: EdgeInsets.symmetric(horizontal: 25.0, vertical: 15.0),\n    );\n  }\n\n  // Step 3: Positioned Toast\n  void _showPositionedToast(BuildContext context) {\n    showToast(\n      'This toast is at the top',\n      context: context,\n      position: StyledToastPosition.top,\n    );\n  }\n\n  // Step 4: Animated Toast\n  void _showAnimatedToast(BuildContext context) {\n    showToast(\n      'This toast has custom animation',\n      context: context,\n      animation: StyledToastAnimation.scale,\n      reverseAnimation: StyledToastAnimation.fade,\n      position: StyledToastPosition.center,\n      animDuration: Duration(seconds: 1),\n      duration: Duration(seconds: 4),\n      curve: Curves.elasticOut,\n      reverseCurve: Curves.linear,\n    );\n  }\n\n  // Step 5: Platform-Specific Toast\n  void _showPlatformSpecificToast(BuildContext context) {\n    if (Theme.of(context).platform == TargetPlatform.iOS) {\n      showToast(\n        'iOS-style Toast',\n        context: context,\n        position: StyledToastPosition.center,\n        borderRadius: BorderRadius.circular(20.0),\n        backgroundColor: Colors.black.withOpacity(0.8),\n        textStyle: TextStyle(color: Colors.white),\n      );\n    } else {\n      showToast(\n        'Android-style Toast',\n        context: context,\n        position: StyledToastPosition.bottom,\n        animation: StyledToastAnimation.slideFromBottom,\n        backgroundColor: Colors.grey[800],\n        textStyle: TextStyle(color: Colors.white),\n      );\n    }\n  }\n}\n\n// Application Flow Explanation:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen (ToastDemo) displays buttons for different toast types.\n// 3. Each button triggers a specific toast function when pressed:\n//    - _showBasicToast: Displays a simple toast with default settings.\n//    - _showCustomizedToast: Shows a toast with custom colors, styles, and shape.\n//    - _showPositionedToast: Demonstrates how to position the toast on the screen.\n//    - _showAnimatedToast: Showcases custom animations for the toast.\n//    - _showPlatformSpecificToast: Adapts the toast style based on the platform (iOS or Android).\n// 4. The showToast function from flutter_styled_toast is used to display each toast.\n// 5. Various parameters of showToast are utilized to customize the appearance and behavior of each toast.\n// 6. The app provides a comprehensive demo of flutter_styled_toast's capabilities, allowing users to see different toast styles and configurations in action.\n```",
    "likesCount": 412,
    "packageImage": null,
    "lastUpdate": "2023-08-26T18:30:00.000Z",
    "author": "tookit.cn",
    "_type": "package",
    "description": "# Flutter Styled Toast: Elevate Your App's Notifications\n\nIn the world of mobile app development, providing clear and visually appealing feedback to users is crucial. Enter `flutter_styled_toast`, a powerful Flutter package that allows developers to create customizable, animated toast notifications with ease.\n\n## What is flutter_styled_toast?\n\n`flutter_styled_toast` is a Flutter package that enhances the standard toast notification system. It offers a wide range of customization options, allowing developers to create notifications that perfectly match their app's design language and user experience requirements.\n\n## Key Features:\n\n1. **Customizable Appearance**: Modify colors, fonts, borders, and more to match your app's theme.\n2. **Flexible Positioning**: Place toasts anywhere on the screen with precise control.\n3. **Animation Options**: Choose from various pre-built animations or create custom ones.\n4. **Duration Control**: Set how long toasts should remain visible.\n5. **Queueing System**: Manage multiple toasts with an intelligent display queue.\n6. **Platform-Specific Behavior**: Adapt to iOS and Android design guidelines automatically.\n\n## Why Choose flutter_styled_toast?\n\n- **Improved User Experience**: Provide clear, visually appealing feedback to users.\n- **Brand Consistency**: Ensure notifications match your app's overall design.\n- **Developer-Friendly**: Easy to implement with a straightforward API.\n- **Performance Optimized**: Efficiently manage multiple notifications without impacting app performance.\n\nIn the following sections, we'll dive into a tutorial on how to implement `flutter_styled_toast` in your Flutter project and explore its features through a comprehensive example.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "mgbfcx4e",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "toast",
      "notification",
      "message",
      "ui",
      "customizable"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CblP",
        "_type": "reference",
        "_key": "0zb3daol"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8ChOl",
        "_type": "reference",
        "_key": "c9ka4exh"
      }
    ],
    "slug": {
      "_type": "slug",
      "current": "flutter_styled_toast"
    },
    "pubPoint": 160,
    "name": "flutter_styled_toast",
    "tutorial": "# Flutter Styled Toast: Elevate Your App's Notifications\n\nIn the world of mobile app development, providing clear and visually appealing feedback to users is crucial. Enter `flutter_styled_toast`, a powerful Flutter package that allows developers to create customizable, animated toast notifications with ease.\n\n## What is flutter_styled_toast?\n\n`flutter_styled_toast` is a Flutter package that enhances the standard toast notification system. It offers a wide range of customization options, allowing developers to create notifications that perfectly match their app's design language and user experience requirements.\n\n## Key Features:\n\n1. **Customizable Appearance**: Modify colors, fonts, borders, and more to match your app's theme.\n2. **Flexible Positioning**: Place toasts anywhere on the screen with precise control.\n3. **Animation Options**: Choose from various pre-built animations or create custom ones.\n4. **Duration Control**: Set how long toasts should remain visible.\n5. **Queueing System**: Manage multiple toasts with an intelligent display queue.\n6. **Platform-Specific Behavior**: Adapt to iOS and Android design guidelines automatically.\n\n## Why Choose flutter_styled_toast?\n\n- **Improved User Experience**: Provide clear, visually appealing feedback to users.\n- **Brand Consistency**: Ensure notifications match your app's overall design.\n- **Developer-Friendly**: Easy to implement with a straightforward API.\n- **Performance Optimized**: Efficiently manage multiple notifications without impacting app performance.\n\nIn the following sections, we'll dive into a tutorial on how to implement `flutter_styled_toast` in your Flutter project and explore its features through a comprehensive example.",
    "_updatedAt": "2024-09-06T04:11:29Z",
    "similarPackages": []
  },
  {
    "slug": {
      "_type": "slug",
      "current": "popover"
    },
    "pubPoint": 160,
    "_type": "package",
    "description": "# Flutter Popover Package: Enhancing User Interactions\n\nIn the world of mobile app development, creating intuitive and visually appealing user interfaces is crucial. Flutter, Google's UI toolkit for building natively compiled applications, offers a wide range of widgets and packages to achieve this goal. One such package that stands out for its ability to enhance user interactions is the `popover` package.\n\n## What is the Popover Package?\n\nThe `popover` package is a powerful tool for Flutter developers that allows for the creation of context-sensitive pop-up windows or menus. These popovers appear above the current content, providing additional information or options without navigating away from the current screen.\n\n## Key Features:\n\n1. **Customizable Appearance**: Developers can easily customize the look and feel of the popover to match their app's design language.\n2. **Flexible Positioning**: The popover can be positioned relative to any widget on the screen, offering flexibility in UI design.\n3. **Animation Support**: Smooth enter and exit animations enhance the user experience.\n4. **Dismissible**: Users can dismiss the popover by tapping outside its boundaries, ensuring a non-intrusive experience.\n5. **Platform Adaptability**: The package works seamlessly across different platforms, including iOS and Android.\n\n## Use Cases:\n\n- **Context Menus**: Provide additional options when a user long-presses an item.\n- **Information Tooltips**: Display extra information about UI elements without cluttering the main interface.\n- **Form Input Helpers**: Show suggestions or validation messages for form inputs.\n- **Custom Dialogs**: Create unique dialog experiences that go beyond standard alert dialogs.\n\nBy leveraging the `popover` package, Flutter developers can create more interactive and user-friendly applications, improving overall user engagement and satisfaction.",
    "shortDescription": "A popover is a transient view that appears above other content onscreen when you tap a control or in an area.",
    "_createdAt": "2024-08-28T22:20:43Z",
    "tutorialIncluded": true,
    "similarPackages": [],
    "likesCount": 557,
    "packageImage": null,
    "name": "popover",
    "_id": "Rx1Nho763d29lawKra1uCp",
    "_updatedAt": "2024-09-06T04:11:30Z",
    "author": "minikin.me",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "popover",
      "tooltip",
      "ui",
      "widget",
      "overlay"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cgrf",
        "_type": "reference",
        "_key": "tplnkh9u"
      }
    ],
    "lastUpdate": "2024-08-10T18:30:00.000Z",
    "tutorial": "# Tutorial: Implementing Popovers in Flutter\n\nThis tutorial will guide you through the process of implementing popovers in your Flutter application using the `popover` package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `popover` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  popover: ^0.2.8+2  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nTo use a popover, you typically need to wrap the widget that will trigger the popover with a `GestureDetector` or `InkWell`. Here's a basic example:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:popover/popover.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Popover Example')),\n      body: Center(\n        child: GestureDetector(\n          onTap: () {\n            showPopover(\n              context: context,\n              bodyBuilder: (context) => ListItems(),\n              direction: PopoverDirection.bottom,\n              width: 200,\n              height: 400,\n              arrowHeight: 15,\n              arrowWidth: 30,\n            );\n          },\n          child: Container(\n            width: 80,\n            height: 40,\n            decoration: BoxDecoration(\n              color: Colors.blue,\n              borderRadius: BorderRadius.circular(5),\n            ),\n            child: Center(child: Text('Press Me')),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass ListItems extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: ListView(\n        padding: const EdgeInsets.all(8),\n        children: [\n          ListTile(title: Text('Item 1')),\n          ListTile(title: Text('Item 2')),\n          ListTile(title: Text('Item 3')),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 3: Customizing the Popover\n\nYou can customize various aspects of the popover:\n\n```dart\nshowPopover(\n  context: context,\n  bodyBuilder: (context) => ListItems(),\n  direction: PopoverDirection.top,\n  backgroundColor: Colors.grey[200],\n  barrierColor: Colors.black54,\n  transitionDuration: Duration(milliseconds: 150),\n  radius: 8,\n);\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, you might want to use a more native-looking popover. Consider using `CupertinoPopoverButton` for a more iOS-like feel:\n\n```dart\nimport 'package:flutter/cupertino.dart';\n\nCupertinoPopoverButton(\n  child: Text('Show Popover'),\n  popoverBuilder: (BuildContext context) {\n    return CupertinoPopoverMenuList(\n      children: [\n        CupertinoPopoverMenuItem(child: Text('Option 1')),\n        CupertinoPopoverMenuItem(child: Text('Option 2')),\n        CupertinoPopoverMenuItem(child: Text('Option 3')),\n      ],\n    );\n  },\n)\n```\n\n### Android\n\nFor Android, the Material Design guidelines suggest using bottom sheets for similar functionality. However, if you want to stick with popovers, consider adjusting the style to match Material Design principles:\n\n```dart\nshowPopover(\n  context: context,\n  bodyBuilder: (context) => ListItems(),\n  backgroundColor: Theme.of(context).cardColor,\n  boxShadow: [\n    BoxShadow(\n      color: Colors.black12,\n      blurRadius: 5,\n    ),\n  ],\n  radius: 8,\n);\n```\n\nBy following these steps and considerations, you can effectively implement and customize popovers in your Flutter application across different platforms.",
    "_rev": "eaCZ7mIhmiYZX5KGqJmOZ7",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "gurcydn4"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:popover/popover.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Popover Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: PopoverDemo(),\n    );\n  }\n}\n\nclass PopoverDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Popover Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 1: Basic Popover\n            ElevatedButton(\n              child: Text('Basic Popover'),\n              onPressed: () => _showBasicPopover(context),\n            ),\n            SizedBox(height: 20),\n            // Step 2: Custom Styled Popover\n            ElevatedButton(\n              child: Text('Custom Styled Popover'),\n              onPressed: () => _showCustomStyledPopover(context),\n            ),\n            SizedBox(height: 20),\n            // Step 3: Popover with Different Directions\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  child: Text('Top'),\n                  onPressed: () => _showDirectionalPopover(context, PopoverDirection.top),\n                ),\n                ElevatedButton(\n                  child: Text('Bottom'),\n                  onPressed: () => _showDirectionalPopover(context, PopoverDirection.bottom),\n                ),\n                ElevatedButton(\n                  child: Text('Left'),\n                  onPressed: () => _showDirectionalPopover(context, PopoverDirection.left),\n                ),\n                ElevatedButton(\n                  child: Text('Right'),\n                  onPressed: () => _showDirectionalPopover(context, PopoverDirection.right),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Basic Popover Implementation\n  void _showBasicPopover(BuildContext context) {\n    showPopover(\n      context: context,\n      bodyBuilder: (context) => ListItems(),\n      onPop: () => print('Popover was popped!'),\n      direction: PopoverDirection.bottom,\n      width: 200,\n      height: 400,\n      arrowHeight: 15,\n      arrowWidth: 30,\n    );\n  }\n\n  // Step 2: Custom Styled Popover Implementation\n  void _showCustomStyledPopover(BuildContext context) {\n    showPopover(\n      context: context,\n      bodyBuilder: (context) => ListItems(),\n      backgroundColor: Colors.grey[200],\n      barrierColor: Colors.black54,\n      transitionDuration: Duration(milliseconds: 150),\n      radius: 8,\n      contentDyOffset: 0,\n      contentDxOffset: 0,\n      constraints: BoxConstraints(maxWidth: 250, maxHeight: 300),\n    );\n  }\n\n  // Step 3: Directional Popover Implementation\n  void _showDirectionalPopover(BuildContext context, PopoverDirection direction) {\n    showPopover(\n      context: context,\n      bodyBuilder: (context) => ListItems(),\n      direction: direction,\n      backgroundColor: Colors.lightBlue[100],\n      width: 200,\n      height: 200,\n    );\n  }\n}\n\nclass ListItems extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8),\n      child: ListView(\n        padding: const EdgeInsets.all(8),\n        children: [\n          ListTile(\n            title: Text('Item 1'),\n            onTap: () {\n              print('Item 1 tapped');\n              Navigator.of(context).pop();\n            },\n          ),\n          ListTile(\n            title: Text('Item 2'),\n            onTap: () {\n              print('Item 2 tapped');\n              Navigator.of(context).pop();\n            },\n          ),\n          ListTile(\n            title: Text('Item 3'),\n            onTap: () {\n              print('Item 3 tapped');\n              Navigator.of(context).pop();\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen (PopoverDemo) is displayed with three main sections:\n//    a. Basic Popover\n//    b. Custom Styled Popover\n//    c. Directional Popovers (Top, Bottom, Left, Right)\n// 3. When a user taps on any button:\n//    - The corresponding _show...Popover method is called.\n//    - This method uses showPopover to display the popover with specified options.\n//    - The popover content is provided by the ListItems widget.\n// 4. The ListItems widget creates a scrollable list of three items.\n// 5. When an item in the popover is tapped:\n//    - It prints a message to the console.\n//    - The popover is dismissed using Navigator.of(context).pop().\n// 6. For the basic and custom styled popovers, additional options demonstrate\n//    various customization possibilities of the popover package.\n// 7. The directional popovers show how to change the popover's position\n//    relative to the tapped button.\n\n// This example showcases the flexibility and ease of use of the popover package,\n// allowing developers to create interactive and customizable popovers in Flutter apps.\n```"
  },
  {
    "similarPackages": [],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "4zfsahuw"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWqB",
        "_type": "reference",
        "_key": "xzrmn6dd"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:44Z",
    "tutorial": "# Tutorial: Implementing `after_layout` in Your Flutter Project\n\nThis tutorial will guide you through the process of integrating and using the `after_layout` package in your Flutter application.\n\n## Step 1: Add the Dependency\n\nFirst, add the `after_layout` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  after_layout: ^1.2.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:after_layout/after_layout.dart';\n```\n\n## Step 3: Implement the Mixin\n\nCreate a `StatefulWidget` and add the `AfterLayoutMixin` to its State class:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> with AfterLayoutMixin<RealFlutter> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('After Layout Example')),\n      body: Center(child: Text('Check the console for after layout message')),\n    );\n  }\n\n  @override\n  void afterFirstLayout(BuildContext context) {\n    print('This runs after the layout is complete!');\n    // Your post-layout code here\n  }\n}\n```\n\n## Step 4: Utilize Platform-Specific Features\n\nYou can use platform checks within the `afterFirstLayout` method to perform platform-specific actions:\n\n```dart\nimport 'dart:io' show Platform;\n\n@override\nvoid afterFirstLayout(BuildContext context) {\n  if (Platform.isAndroid) {\n    print('Performing Android-specific layout adjustments');\n    // Android-specific code\n  } else if (Platform.isIOS) {\n    print('Performing iOS-specific layout adjustments');\n    // iOS-specific code\n  }\n}\n```\n\n## Step 5: Accessing Widget Dimensions\n\nAfter the layout is complete, you can access the widget's dimensions:\n\n```dart\n@override\nvoid afterFirstLayout(BuildContext context) {\n  final RenderBox renderBox = context.findRenderObject() as RenderBox;\n  final size = renderBox.size;\n  print('Widget size: ${size.width} x ${size.height}');\n}\n```\n\nBy following these steps, you can effectively use the `after_layout` package to perform actions after the initial layout is complete, ensuring your app responds correctly to the rendered layout.",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmOff",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFxL",
        "_type": "reference",
        "_key": "1ru83f30"
      }
    ],
    "lastUpdate": "2022-05-15T18:30:00.000Z",
    "slug": {
      "current": "after_layout",
      "_type": "slug"
    },
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:after_layout/after_layout.dart';\nimport 'dart:io' show Platform;\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'After Layout Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> with AfterLayoutMixin<RealFlutter> {\n  String _message = 'Initial State';\n  double _widgetWidth = 0;\n  double _widgetHeight = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Build the initial layout\n    return Scaffold(\n      appBar: AppBar(title: Text('After Layout Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(_message),\n            SizedBox(height: 20),\n            Text('Widget Size: $_widgetWidth x $_widgetHeight'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void afterFirstLayout(BuildContext context) {\n    // Step 2: This method is called after the layout is complete\n\n    // Step 3: Perform platform-specific actions\n    if (Platform.isAndroid) {\n      setState(() {\n        _message = 'Running on Android';\n      });\n    } else if (Platform.isIOS) {\n      setState(() {\n        _message = 'Running on iOS';\n      });\n    } else {\n      setState(() {\n        _message = 'Running on ${Platform.operatingSystem}';\n      });\n    }\n\n    // Step 4: Access widget dimensions\n    final RenderBox renderBox = context.findRenderObject() as RenderBox;\n    final size = renderBox.size;\n    setState(() {\n      _widgetWidth = size.width;\n      _widgetHeight = size.height;\n    });\n\n    // Step 5: Perform any other post-layout actions\n    print('After layout actions completed');\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the initial layout is built with default values.\n// 2. Once the layout is complete, the afterFirstLayout method is called.\n// 3. In afterFirstLayout:\n//    - The platform is checked and the message is updated accordingly.\n//    - The widget's dimensions are measured and stored.\n//    - Any other post-layout actions are performed.\n// 4. setState is called, triggering a rebuild of the widget with the updated values.\n// 5. The new layout is displayed, showing the platform-specific message and widget dimensions.\n\n// Note: The afterFirstLayout method is only called once per widget lifecycle,\n// ensuring that these actions are performed exactly once after the initial layout.\n```",
    "likesCount": 718,
    "name": "after_layout",
    "tutorialIncluded": true,
    "author": "fluttercommunity.dev",
    "_type": "package",
    "description": "# Understanding the `after_layout` Package in Flutter\n\nThe `after_layout` package is a powerful tool for Flutter developers who need to perform actions after the initial layout of widgets is complete. This package provides a mixin that allows you to execute code once the widget's layout has been calculated and rendered on the screen.\n\n## Key Features\n\n1. **Post-Layout Execution**: Run code after the widget's layout is complete.\n2. **Single Execution**: Ensures the callback is only called once per widget lifecycle.\n3. **Easy Integration**: Simple to add to any widget with minimal boilerplate.\n4. **Access to Widget State**: Provides access to the widget's state and context.\n\n## When to Use `after_layout`\n\nThe `after_layout` package is particularly useful in scenarios where you need to:\n\n- Measure the size or position of a widget after it's been rendered.\n- Trigger animations or state changes based on the final layout.\n- Perform initialization that depends on the widget's final size or position.\n- Handle platform-specific layout adjustments.\n\nBy leveraging `after_layout`, developers can create more responsive and dynamic user interfaces that adapt to the actual rendered layout of the application.",
    "shortDescription": "Execute code after the first layout of your widget has been performed, i.e. after the first frame has been displayed.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "layout",
      "widget",
      "callback",
      "lifecycle"
    ],
    "_id": "Rx1Nho763d29lawKra1ubf",
    "_updatedAt": "2024-09-06T04:11:31Z"
  },
  {
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-03-09T18:30:00.000Z",
    "_rev": "ezMiwuUkJkbYMWycA6RaMc",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "sea9bo4r",
        "_ref": "uQRNMiDfrp20RZ8Id8CfWv"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPaovc",
        "_type": "reference",
        "_key": "6r8f41zc"
      }
    ],
    "_createdAt": "2024-08-28T22:20:57Z",
    "author": "",
    "description": "# Pretty QR Code Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `pretty_qr_code` package is a powerful and flexible Flutter library that allows developers to generate customizable QR codes within their applications. This package stands out for its ability to create visually appealing QR codes with various styling options, making it an excellent choice for developers who want to integrate QR codes seamlessly into their app's design.\n\n### Key Features:\n\n1. **Customizable Appearance**: Modify colors, shapes, and styles of QR codes.\n2. **Error Correction**: Supports different levels of error correction for improved readability.\n3. **Image Embedding**: Ability to embed images within the QR code.\n4. **Size Control**: Adjust the size of the QR code to fit your layout needs.\n5. **Data Capacity**: Generate QR codes for various data types and lengths.\n\n### Why Choose pretty_qr_code?\n\n- **Ease of Use**: Simple API for quick integration into Flutter projects.\n- **Design Flexibility**: Create QR codes that match your app's aesthetic.\n- **Performance**: Efficient generation of QR codes without compromising app performance.\n- **Cross-Platform**: Works seamlessly on both iOS and Android platforms.\n\nIn the following sections, we'll dive into a tutorial on how to use this package and explore a comprehensive example showcasing its features.",
    "shortDescription": "Pretty QR code for Flutter. You can round the edges with parameter or use the standard view.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "bqpzjb6p",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGrS"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:pretty_qr_code/pretty_qr_code.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pretty QR Code Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const QRCodeDemo(),\n    );\n  }\n}\n\nclass QRCodeDemo extends StatefulWidget {\n  const QRCodeDemo({Key? key}) : super(key: key);\n\n  @override\n  _QRCodeDemoState createState() => _QRCodeDemoState();\n}\n\nclass _QRCodeDemoState extends State<QRCodeDemo> {\n  // Step 1: Initialize variables\n  String qrData = 'https://flutter.dev';\n  Color qrColor = Colors.black;\n  Color backgroundColor = Colors.white;\n  bool roundEdges = false;\n  QrErrorCorrectLevel errorCorrectLevel = QrErrorCorrectLevel.L;\n  double size = 200;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pretty QR Code Demo')),\n      body: SingleChildScrollView(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Step 2: Display the QR code\n              PrettyQrView(\n                data: qrData,\n                size: size,\n                color: qrColor,\n                backgroundColor: backgroundColor,\n                roundEdges: roundEdges,\n                errorCorrectLevel: errorCorrectLevel,\n              ),\n              const SizedBox(height: 20),\n              // Step 3: Add controls for customization\n              Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Column(\n                  children: [\n                    TextField(\n                      decoration: const InputDecoration(labelText: 'QR Data'),\n                      onChanged: (value) => setState(() => qrData = value),\n                    ),\n                    const SizedBox(height: 10),\n                    Row(\n                      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                      children: [\n                        ElevatedButton(\n                          onPressed: () => _pickColor(true),\n                          child: const Text('QR Color'),\n                        ),\n                        ElevatedButton(\n                          onPressed: () => _pickColor(false),\n                          child: const Text('Background Color'),\n                        ),\n                      ],\n                    ),\n                    const SizedBox(height: 10),\n                    Row(\n                      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                      children: [\n                        const Text('Round Edges'),\n                        Switch(\n                          value: roundEdges,\n                          onChanged: (value) => setState(() => roundEdges = value),\n                        ),\n                      ],\n                    ),\n                    const SizedBox(height: 10),\n                    DropdownButton<QrErrorCorrectLevel>(\n                      value: errorCorrectLevel,\n                      onChanged: (QrErrorCorrectLevel? newValue) {\n                        if (newValue != null) {\n                          setState(() => errorCorrectLevel = newValue);\n                        }\n                      },\n                      items: QrErrorCorrectLevel.values.map((QrErrorCorrectLevel level) {\n                        return DropdownMenuItem<QrErrorCorrectLevel>(\n                          value: level,\n                          child: Text('Error Correction: ${level.toString().split('.').last}'),\n                        );\n                      }).toList(),\n                    ),\n                    const SizedBox(height: 10),\n                    Slider(\n                      value: size,\n                      min: 100,\n                      max: 300,\n                      divisions: 20,\n                      label: size.round().toString(),\n                      onChanged: (double value) {\n                        setState(() => size = value);\n                      },\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Step 4: Implement color picker\n  void _pickColor(bool forQr) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text(forQr ? 'Pick QR Color' : 'Pick Background Color'),\n        content: SingleChildScrollView(\n          child: ColorPicker(\n            pickerColor: forQr ? qrColor : backgroundColor,\n            onColorChanged: (color) {\n              setState(() {\n                if (forQr) {\n                  qrColor = color;\n                } else {\n                  backgroundColor = color;\n                }\n              });\n            },\n          ),\n        ),\n        actions: [\n          ElevatedButton(\n            child: const Text('Done'),\n            onPressed: () => Navigator.of(context).pop(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 5: Application Flow Explanation\n/*\n1. The app starts by initializing the RealFlutter widget, which sets up the MaterialApp.\n2. The QRCodeDemo widget is created as the home screen.\n3. In the QRCodeDemo, we initialize variables for QR code customization.\n4. The build method creates the UI:\n   a. It displays the PrettyQrView with current settings.\n   b. Below the QR code, it provides various controls for customization:\n      - TextField for changing QR data\n      - Buttons for changing QR and background colors\n      - Switch for toggling rounded edges\n      - Dropdown for selecting error correction level\n      - Slider for adjusting QR code size\n5. Each control is connected to a setState call, which updates the respective variable and rebuilds the widget.\n6. The _pickColor method opens a color picker dialog for changing colors.\n7. As the user interacts with the controls, the QR code updates in real-time, demonstrating the flexibility of the pretty_qr_code package.\n\nThis example showcases all major features of the pretty_qr_code package in an interactive manner,\nallowing users to experiment with different customizations and see the results immediately.\n*/\n```",
    "_updatedAt": "2024-09-06T04:11:32Z",
    "slug": {
      "current": "pretty_qr_code",
      "_type": "slug"
    },
    "pubPoint": 160,
    "similarPackages": [],
    "tags": [
      "qr",
      "pretty-qr",
      "pretty-widgets",
      "barcode",
      "generator"
    ],
    "likesCount": 356,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-352ecc7769a1bd04385e5177cb9e8a7b04841142-512x512-webp",
        "_type": "reference"
      }
    },
    "name": "pretty_qr_code",
    "_id": "Rx1Nho763d29lawKra1v7b",
    "tutorial": "## 2. Tutorial\n\nIn this section, we'll walk through the process of integrating the `pretty_qr_code` package into your Flutter project and using its basic features.\n\n### Step 1: Add the package to your pubspec.yaml\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  pretty_qr_code: ^2.0.3\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the package in your Dart file\n\n```dart\nimport 'package:pretty_qr_code/pretty_qr_code.dart';\n```\n\n### Step 3: Create a basic QR code\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Pretty QR Code Example')),\n      body: Center(\n        child: PrettyQr(\n          data: 'https://flutter.dev',\n          size: 200,\n          errorCorrectLevel: QrErrorCorrectLevel.M,\n        ),\n      ),\n    );\n  }\n}\n```\n\n### Step 4: Customize the QR code\n\n```dart\nPrettyQr(\n  data: 'https://flutter.dev',\n  size: 200,\n  errorCorrectLevel: QrErrorCorrectLevel.H,\n  roundEdges: true,\n  elementColor: Colors.blue,\n  typeNumber: 3,\n)\n```\n\n### Platform-specific considerations\n\n#### iOS\nFor iOS, no additional setup is required. The package works out of the box.\n\n#### Android\nFor Android, ensure that your `minSdkVersion` is set to 16 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // ... other configurations\n    }\n}\n```\n\n### Advanced Features\n\n1. **Embedding Images**: Use the `image` parameter to add a logo or image to your QR code.\n\n```dart\nPrettyQr(\n  data: 'https://flutter.dev',\n  size: 200,\n  image: AssetImage('assets/logo.png'),\n)\n```\n\n2. **Custom Shapes**: Experiment with `roundEdges` and `elementShape` for unique designs.\n\n3. **Error Correction Levels**: Adjust `errorCorrectLevel` based on your needs (L, M, Q, H).\n\nBy following this tutorial, you'll be able to create and customize QR codes in your Flutter application using the `pretty_qr_code` package.",
    "_type": "package",
    "tutorialIncluded": true
  },
  {
    "description": "# Understanding the `stream_transform` Package in Flutter\n\n## Introduction\n\nThe `stream_transform` package is a powerful tool for Flutter developers who want to manipulate and transform streams efficiently. It provides a set of extension methods on the `Stream` class, allowing for easy composition and transformation of stream data.\n\n## Key Features\n\n1. **Throttling**: Limit the rate at which events are emitted.\n2. **Debouncing**: Delay events and only emit when a specified duration has passed without new events.\n3. **Windowing**: Group stream events into windows based on count or time.\n4. **Combining**: Merge multiple streams or combine their latest values.\n5. **Scanning**: Accumulate values over time, similar to `reduce` for streams.\n\n## When to Use `stream_transform`\n\n- Real-time data processing\n- User input handling (e.g., search suggestions)\n- Reactive programming patterns\n- Event-driven architectures\n\n## Benefits\n\n- Improved performance by reducing unnecessary computations\n- Enhanced control over stream behavior\n- Simplified complex stream operations\n- Increased code readability and maintainability\n\nIn the following sections, we'll explore how to implement these features in your Flutter applications using the `RealFlutter` class as our main example.",
    "name": "stream_transform",
    "author": "tools.dart.dev",
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 249,
    "tutorial": "# Stream Transform Tutorial: Implementing in Flutter\n\nIn this tutorial, we'll walk through how to use the `stream_transform` package in a Flutter application. We'll use the `RealFlutter` class to demonstrate various transformations.\n\n## Setup\n\nFirst, add the `stream_transform` package to your `pubspec.yaml`:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  stream_transform: ^2.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Basic Usage\n\nLet's start with a simple example using the `RealFlutter` class:\n\n```dart\nimport 'package:stream_transform/stream_transform.dart';\n\nclass RealFlutter {\n  Stream<int> countStream() {\n    return Stream.periodic(Duration(seconds: 1), (count) => count);\n  }\n\n  void demonstrateThrottle() {\n    countStream()\n        .throttle(Duration(seconds: 2))\n        .listen((event) => print('Throttled: $event'));\n  }\n}\n```\n\nThis example creates a stream that emits a count every second, then throttles it to emit at most once every two seconds.\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, be mindful of the `FlutterEngine` lifecycle. Ensure that you dispose of your streams properly in the `onDestroy` method of your activity:\n\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    flutterEngine?.dartExecutor?.binaryMessenger?.let { messenger ->\n        // Dispose your streams here\n    }\n}\n```\n\n### iOS\n\nFor iOS, handle stream disposal in the `viewWillDisappear` method of your `FlutterViewController`:\n\n```swift\noverride func viewWillDisappear(_ animated: Bool) {\n    super.viewWillDisappear(animated)\n    // Dispose your streams here\n}\n```\n\n## Advanced Transformations\n\nHere's how you can implement more advanced transformations:\n\n```dart\nclass RealFlutter {\n  // ... previous code ...\n\n  void demonstrateDebounce() {\n    countStream()\n        .debounce(Duration(seconds: 3))\n        .listen((event) => print('Debounced: $event'));\n  }\n\n  void demonstrateWindowing() {\n    countStream()\n        .windowCount(3)\n        .listen((window) => window.forEach(print));\n  }\n}\n```\n\nThese examples show how to debounce a stream and how to group stream events into windows.\n\nIn the next section, we'll see a complete example that demonstrates all the major features of the `stream_transform` package.",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "stream_transform"
    },
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:stream_transform/stream_transform.dart';\nimport 'dart:async';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: RealFlutterDemo(),\n    );\n  }\n}\n\nclass RealFlutterDemo extends StatefulWidget {\n  @override\n  _RealFlutterDemoState createState() => _RealFlutterDemoState();\n}\n\nclass _RealFlutterDemoState extends State<RealFlutterDemo> {\n  final RealFlutter _realFlutter = RealFlutter();\n  final _textController = TextEditingController();\n  List<String> _results = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _realFlutter.setup();\n  }\n\n  @override\n  void dispose() {\n    _realFlutter.dispose();\n    _textController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Stream Transform Demo')),\n      body: Column(\n        children: [\n          TextField(\n            controller: _textController,\n            onChanged: _realFlutter.handleInput,\n            decoration: InputDecoration(labelText: 'Enter text'),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _results.length,\n              itemBuilder: (context, index) => ListTile(\n                title: Text(_results[index]),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass RealFlutter {\n  // Step 1: Create a StreamController for user input\n  final _inputController = StreamController<String>();\n\n  // Step 2: Create a StreamController for processed results\n  final _outputController = StreamController<String>();\n\n  // Step 3: Setup method to initialize stream transformations\n  void setup() {\n    // Apply transformations to the input stream\n    _inputController.stream\n        .debounce(Duration(milliseconds: 300)) // Debounce to reduce API calls\n        .distinct() // Only process distinct values\n        .transform(validateAndProcess) // Custom transformer\n        .throttle(Duration(seconds: 1)) // Throttle output\n        .listen(_outputController.add); // Listen and add to output stream\n  }\n\n  // Step 4: Method to handle user input\n  void handleInput(String input) {\n    _inputController.add(input);\n  }\n\n  // Step 5: Custom transformer for validation and processing\n  StreamTransformer<String, String> get validateAndProcess {\n    return StreamTransformer<String, String>.fromHandlers(\n      handleData: (data, sink) {\n        if (data.length < 3) {\n          sink.addError('Input too short');\n        } else {\n          sink.add('Processed: ${data.toUpperCase()}');\n        }\n      },\n    );\n  }\n\n  // Step 6: Method to get the output stream\n  Stream<String> get outputStream => _outputController.stream;\n\n  // Step 7: Dispose method to clean up resources\n  void dispose() {\n    _inputController.close();\n    _outputController.close();\n  }\n}\n\n// Application Flow:\n// 1. User enters text in the TextField.\n// 2. The input is added to _inputController stream.\n// 3. The stream is debounced to wait for user to stop typing.\n// 4. Distinct values are filtered to avoid unnecessary processing.\n// 5. The custom transformer validates and processes the input.\n// 6. The output is throttled to control the rate of updates.\n// 7. Processed results are added to _outputController stream.\n// 8. The UI listens to the output stream and updates accordingly.\n\n// This example demonstrates several key features of stream_transform:\n// - Debouncing: Reduces the frequency of operations on rapidly changing input.\n// - Distinct: Eliminates duplicate events in the stream.\n// - Custom Transformation: Allows for complex data processing.\n// - Throttling: Controls the rate at which results are emitted.\n\n// The RealFlutter class encapsulates all stream logic, making it easy to\n// integrate with any Flutter widget. This separation of concerns improves\n// code maintainability and testability.\n```",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "6twisukv",
        "_ref": "Rx1Nho763d29lawKra1Jyh"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:58Z",
    "_id": "Rx1Nho763d29lawKra1vIF",
    "_rev": "eaCZ7mIhmiYZX5KGqJmOmD",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXlY",
        "_type": "reference",
        "_key": "g9q57h14"
      }
    ],
    "tags": [
      "stream",
      "async",
      "reactive",
      "transformation"
    ],
    "lastUpdate": "2022-11-02T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:11:33Z",
    "pubPoint": 160,
    "shortDescription": "A collection of utilities to transform and manipulate streams."
  },
  {
    "shortDescription": "A Flutter plugin to redirect users to an app page in Google Play Store and Apple App Store.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios"
    ],
    "lastUpdate": "2024-03-13T18:30:00.000Z",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:store_redirect/store_redirect.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Store Redirect Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatelessWidget {\n  // Step 1: Define app IDs for different platforms\n  final String androidAppId = 'com.example.app';\n  final String iOSAppId = '123456789';\n  final String huaweiAppId = 'com.example.app';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Store Redirect Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Create buttons for different redirection scenarios\n            ElevatedButton(\n              child: Text('Redirect to App Store'),\n              onPressed: () => _redirectToStore(),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Redirect to Play Store'),\n              onPressed: () => _redirectToPlayStore(),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Redirect to Huawei AppGallery'),\n              onPressed: () => _redirectToHuaweiAppGallery(),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 3: Implement redirection to app store based on platform\n  void _redirectToStore() {\n    RealFlutter.redirect(\n      androidAppId: androidAppId,\n      iOSAppId: iOSAppId,\n    );\n  }\n\n  // Step 4: Implement redirection specifically to Play Store\n  void _redirectToPlayStore() {\n    RealFlutter.redirect(androidAppId: androidAppId);\n  }\n\n  // Step 5: Implement redirection specifically to Huawei AppGallery\n  void _redirectToHuaweiAppGallery() {\n    RealFlutter.redirect(huaweiAppId: huaweiAppId);\n  }\n\n  // Step 6: Static method for redirection with error handling\n  static Future<void> redirect({\n    String? androidAppId,\n    String? iOSAppId,\n    String? huaweiAppId,\n  }) async {\n    try {\n      final result = await StoreRedirect.redirect(\n        androidAppId: androidAppId,\n        iOSAppId: iOSAppId,\n        huaweiAppId: huaweiAppId,\n      );\n      if (result) {\n        print('Successfully redirected to store');\n      } else {\n        print('Failed to redirect to store');\n      }\n    } catch (e) {\n      print('Error occurred during redirection: $e');\n    }\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with three buttons.\n// 2. Each button corresponds to a different store redirection scenario.\n// 3. When a button is pressed, it calls the corresponding method.\n// 4. The method then calls the static 'redirect' method of RealFlutter.\n// 5. The 'redirect' method uses StoreRedirect.redirect with appropriate parameters.\n// 6. If successful, the user is taken to the respective app store.\n// 7. If unsuccessful, an error message is printed to the console.\n// 8. The app handles potential errors and provides feedback in the console.\n\n// Note: In a real-world scenario, you would replace the print statements\n// with more user-friendly feedback, such as showing a SnackBar or Dialog.\n```",
    "tags": [
      "store",
      "redirect",
      "app-store",
      "play-store"
    ],
    "likesCount": 253,
    "_createdAt": "2024-08-28T22:21:01Z",
    "_updatedAt": "2024-09-06T04:11:34Z",
    "slug": {
      "_type": "slug",
      "current": "store_redirect"
    },
    "description": "# Store Redirect Package for Flutter: Simplifying App Store Navigation\n\nThe `store_redirect` package is a powerful tool for Flutter developers looking to seamlessly redirect users to their app's page on various app stores. This package provides a straightforward way to open the app store page for your application, whether it's on the Google Play Store, Apple App Store, or even the Huawei AppGallery.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Works seamlessly on both Android and iOS platforms.\n2. **Multiple Store Support**: Supports Google Play Store, Apple App Store, and Huawei AppGallery.\n3. **Flexible Usage**: Can be used with or without the app's ID, making it versatile for different scenarios.\n4. **Simple API**: Offers an easy-to-use API that requires minimal setup and configuration.\n\n## Why Use Store Redirect?\n\n- **Improved User Experience**: Quickly guide users to your app's store page for updates or reviews.\n- **Streamlined Marketing**: Easily create deep links to your app's store page in promotional materials.\n- **Cross-Promotion**: Effortlessly promote your other apps by redirecting users to their store pages.\n\nIn the following sections, we'll dive into a detailed tutorial on how to implement this package in your Flutter project and explore a comprehensive example showcasing all its features.",
    "packageImage": null,
    "name": "store_redirect",
    "_id": "Rx1Nho763d29lawKra1vZz",
    "tutorial": "# Tutorial: Implementing Store Redirect in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the `store_redirect` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `store_redirect` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  store_redirect: ^2.0.1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:store_redirect/store_redirect.dart';\n```\n\n## Step 3: Basic Usage\n\nTo redirect to your app's store page, use the `StoreRedirect.redirect()` method:\n\n```dart\nRealFlutter.redirect(\n  androidAppId: \"com.example.app\",\n  iOSAppId: \"123456789\"\n);\n```\n\nReplace `\"com.example.app\"` with your Android package name and `\"123456789\"` with your iOS app ID.\n\n## Step 4: Platform-Specific Considerations\n\n### Android\n\nFor Android, you need to provide the package name of your app. You can find this in your `AndroidManifest.xml` file or in the Google Play Console.\n\n```dart\nRealFlutter.redirect(androidAppId: \"com.example.app\");\n```\n\n### iOS\n\nFor iOS, you need to provide the App Store ID of your app. You can find this in App Store Connect or in the URL of your app's App Store page.\n\n```dart\nRealFlutter.redirect(iOSAppId: \"123456789\");\n```\n\n### Huawei AppGallery\n\nTo support Huawei AppGallery, you need to provide the Huawei app ID:\n\n```dart\nRealFlutter.redirect(huaweiAppId: \"com.example.app\");\n```\n\n## Step 5: Error Handling\n\nThe `redirect()` method returns a `Future<bool>`. You can use this to handle cases where the redirection might fail:\n\n```dart\ntry {\n  final result = await RealFlutter.redirect(\n    androidAppId: \"com.example.app\",\n    iOSAppId: \"123456789\"\n  );\n  if (result) {\n    print(\"Store page opened successfully\");\n  } else {\n    print(\"Failed to open store page\");\n  }\n} catch (e) {\n  print(\"Error occurred: $e\");\n}\n```\n\nBy following these steps, you'll have successfully integrated the `store_redirect` package into your Flutter application, allowing for easy redirection to your app's store page across different platforms.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaQOY",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPH3J",
        "_type": "reference",
        "_key": "prbcln2m"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPafbI",
        "_type": "reference",
        "_key": "t4w4yi7s"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1WL9",
        "_type": "reference",
        "_key": "q7908acn"
      }
    ],
    "author": ""
  },
  {
    "description": "# Responsive Sizer: Simplifying Flutter Responsiveness\n\nIn the world of mobile app development, creating responsive user interfaces that adapt seamlessly to various screen sizes and orientations is crucial. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful solution to this challenge: the `responsive_sizer` package.\n\n## What is Responsive Sizer?\n\nResponsive Sizer is a Flutter package that simplifies the process of creating responsive layouts. It provides a set of extension methods and utilities that allow developers to easily scale their widgets based on the screen size and orientation of the device.\n\n## Key Features\n\n1. **Percentage-based sizing**: Easily set widget dimensions as a percentage of screen width or height.\n2. **Device-specific sizing**: Adjust sizes based on whether the app is running on a mobile, tablet, or desktop.\n3. **Orientation-aware**: Automatically adapt layouts for portrait and landscape modes.\n4. **Font scaling**: Adjust text sizes proportionally to the screen size.\n5. **Adaptive widgets**: Create widgets that automatically resize based on the device type.\n\n## Why Use Responsive Sizer?\n\n- **Simplicity**: Reduces boilerplate code and complex calculations for responsive designs.\n- **Consistency**: Ensures a uniform look across different devices and screen sizes.\n- **Flexibility**: Offers various methods to achieve the desired responsiveness for any widget.\n- **Performance**: Lightweight and efficient, with minimal impact on app performance.\n\nBy leveraging the power of Responsive Sizer, Flutter developers can create fluid, adaptive interfaces that provide an optimal user experience across a wide range of devices, from small smartphones to large tablets and desktops.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbYZd",
        "_type": "reference",
        "_key": "h8lwic6z"
      }
    ],
    "tags": [
      "responsive",
      "sizing",
      "ui",
      "layout",
      "adaptive"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPamQK",
        "_type": "reference",
        "_key": "k9dd7r9k"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CcrR",
        "_type": "reference",
        "_key": "gs73knu4"
      }
    ],
    "lastUpdate": "2024-03-23T18:30:00.000Z",
    "slug": {
      "current": "responsive_sizer",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "hanstan.link",
    "_rev": "ezMiwuUkJkbYMWycA6RaXP",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:responsive_sizer/responsive_sizer.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Wrap the entire app with ResponsiveSizer\n    return ResponsiveSizer(\n      builder: (context, orientation, screenType) {\n        return MaterialApp(\n          title: 'Responsive Sizer Demo',\n          theme: ThemeData(primarySwatch: Colors.blue),\n          home: ResponsivePage(),\n        );\n      },\n    );\n  }\n}\n\nclass ResponsivePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 2: Use Responsive Sizer methods in your widgets\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Responsive Sizer Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 3: Create a container with responsive width and height\n            Container(\n              width: 80.w,  // 80% of screen width\n              height: 20.h,  // 20% of screen height\n              color: Colors.blue,\n              child: Center(\n                child: Text(\n                  'Responsive Container',\n                  style: TextStyle(fontSize: 18.sp, color: Colors.white),\n                ),\n              ),\n            ),\n            SizedBox(height: 5.h),  // Responsive vertical spacing\n            \n            // Step 4: Use Device class to check device type\n            Text(\n              'Device Type: ${Device.deviceType}',\n              style: TextStyle(fontSize: 16.sp),\n            ),\n            SizedBox(height: 2.h),\n            \n            // Step 5: Create responsive buttons\n            ElevatedButton(\n              onPressed: () {},\n              child: Text('Responsive Button'),\n              style: ElevatedButton.styleFrom(\n                padding: EdgeInsets.symmetric(horizontal: 5.w, vertical: 2.h),\n              ),\n            ),\n            SizedBox(height: 2.h),\n            \n            // Step 6: Demonstrate adaptive widget\n            if (Device.screenType == ScreenType.tablet)\n              Text('This text only appears on tablets', style: TextStyle(fontSize: 14.sp)),\n            \n            // Step 7: Use orientation to adjust layout\n            if (Orientation.landscape == MediaQuery.of(context).orientation)\n              Row(\n                mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n                children: [\n                  Icon(Icons.landscape, size: 10.w),\n                  Text('Landscape Mode', style: TextStyle(fontSize: 14.sp)),\n                ],\n              )\n            else\n              Column(\n                children: [\n                  Icon(Icons.portrait, size: 10.w),\n                  Text('Portrait Mode', style: TextStyle(fontSize: 14.sp)),\n                ],\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter wraps the entire app with ResponsiveSizer, enabling responsive features.\n// 3. The ResponsivePage is set as the home page of the app.\n// 4. In ResponsivePage, we demonstrate various features of Responsive Sizer:\n//    - A container with responsive width (80% of screen width) and height (20% of screen height).\n//    - Text with scalable font size using the 'sp' extension.\n//    - Responsive spacing using percentage of screen height (5.h, 2.h).\n//    - Device type detection using the Device class.\n//    - A button with responsive padding.\n//    - Conditional rendering based on device type (tablet-specific text).\n//    - Orientation-specific layout adjustments.\n// 5. The app automatically adjusts its layout and sizes based on the device's screen size and orientation.\n// 6. This structure ensures that the app looks consistent and properly scaled across different devices and orientations.\n```",
    "likesCount": 556,
    "name": "responsive_sizer",
    "shortDescription": "Responsive Sizer helps implement a reponsive layout by providing helper widgets and extensions.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "Rx1Nho763d29lawKra1vkd",
    "tutorialIncluded": true,
    "_type": "package",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:21:03Z",
    "tutorial": "# Responsive Sizer Tutorial\n\nThis tutorial will guide you through the process of implementing the Responsive Sizer package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Installation\n\nTo get started with Responsive Sizer, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  responsive_sizer: ^3.1.1\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Basic Usage\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:responsive_sizer/responsive_sizer.dart';\n```\n\n2. Wrap your `MaterialApp` or `CupertinoApp` with the `ResponsiveSizer` widget:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ResponsiveSizer(\n      builder: (context, orientation, screenType) {\n        return MaterialApp(\n          home: MyHomePage(),\n        );\n      },\n    );\n  }\n}\n```\n\n3. Use the extension methods provided by Responsive Sizer to create responsive layouts:\n\n```dart\nContainer(\n  width: 50.w, // 50% of screen width\n  height: 20.h, // 20% of screen height\n  child: Text(\n    'Responsive Text',\n    style: TextStyle(fontSize: 16.sp), // Scalable font size\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android devices, you may want to consider the system UI overlays, such as the status bar and navigation bar. Use `SystemChrome` to adjust the UI:\n\n```dart\nimport 'package:flutter/services.dart';\n\n// In your app's initialization\nSystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(\n  statusBarColor: Colors.transparent,\n  systemNavigationBarColor: Colors.black,\n));\n```\n\n### iOS\n\nFor iOS, be mindful of the safe area, especially for devices with notches:\n\n```dart\nSafeArea(\n  child: Scaffold(\n    // Your app content\n  ),\n)\n```\n\n### Web\n\nWhen deploying for web, consider using the `Device` class to adjust layouts based on browser window size:\n\n```dart\nif (Device.web) {\n  // Web-specific layout adjustments\n}\n```\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, you might want to set a minimum window size:\n\n```dart\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:window_size/window_size.dart';\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  if (kIsWeb) {\n    // Web-specific setup\n  } else {\n    if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) {\n      setWindowMinSize(Size(600, 800));\n    }\n  }\n  runApp(RealFlutter());\n}\n```\n\nBy following these guidelines and leveraging the Responsive Sizer package, you can create a truly adaptive Flutter application that works seamlessly across all platforms and device sizes.",
    "_updatedAt": "2024-09-06T04:11:35Z"
  },
  {
    "tutorial": "# Tutorial: Implementing Salomon Bottom Bar in Flutter\n\nIn this tutorial, we'll walk through the process of adding the `salomon_bottom_bar` package to your Flutter project and implementing it in a basic application.\n\n## Step 1: Add the Package\n\nFirst, add the `salomon_bottom_bar` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  salomon_bottom_bar: ^3.3.2\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:salomon_bottom_bar/salomon_bottom_bar.dart';\n```\n\n## Step 3: Implement Salomon Bottom Bar\n\nHere's a basic implementation of `SalomonBottomBar` within a `Scaffold`:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  int _currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Salomon Bottom Bar Demo')),\n      body: Center(child: Text('Page $_currentIndex')),\n      bottomNavigationBar: SalomonBottomBar(\n        currentIndex: _currentIndex,\n        onTap: (i) => setState(() => _currentIndex = i),\n        items: [\n          SalomonBottomBarItem(\n            icon: Icon(Icons.home),\n            title: Text(\"Home\"),\n            selectedColor: Colors.purple,\n          ),\n          SalomonBottomBarItem(\n            icon: Icon(Icons.search),\n            title: Text(\"Search\"),\n            selectedColor: Colors.orange,\n          ),\n          SalomonBottomBarItem(\n            icon: Icon(Icons.person),\n            title: Text(\"Profile\"),\n            selectedColor: Colors.teal,\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to consider wrapping your `SalomonBottomBar` with a `SafeArea` widget to ensure it doesn't overlap with the home indicator on newer iPhone models:\n\n```dart\nbottomNavigationBar: SafeArea(\n  child: SalomonBottomBar(\n    // ... your existing configuration\n  ),\n),\n```\n\n### Android\n\nFor Android, you may want to add some padding to the bottom of the `SalomonBottomBar` to account for the navigation bar on some devices:\n\n```dart\nbottomNavigationBar: Padding(\n  padding: EdgeInsets.only(bottom: 8.0),\n  child: SalomonBottomBar(\n    // ... your existing configuration\n  ),\n),\n```\n\n## Customization Options\n\n`SalomonBottomBar` offers various customization options:\n\n- `margin`: Set custom margins around the bar.\n- `itemPadding`: Adjust padding for individual items.\n- `selectedItemColor`: Change the color of the selected item.\n- `unselectedItemColor`: Set the color for unselected items.\n- `itemShape`: Modify the shape of the items (e.g., `StadiumBorder()`, `RoundedRectangleBorder()`).\n\nExample:\n\n```dart\nSalomonBottomBar(\n  margin: EdgeInsets.symmetric(horizontal: 20, vertical: 8),\n  itemPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),\n  selectedItemColor: Colors.purple,\n  unselectedItemColor: Colors.grey,\n  itemShape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),\n  // ... other properties\n)\n```\n\nBy following these steps and exploring the customization options, you can easily implement and tailor the Salomon Bottom Bar to fit your Flutter application's needs.",
    "_createdAt": "2024-08-28T22:21:07Z",
    "slug": {
      "current": "salomon_bottom_bar",
      "_type": "slug"
    },
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:salomon_bottom_bar/salomon_bottom_bar.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Salomon Bottom Bar Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  // Step 1: Initialize current index\n  int _currentIndex = 0;\n\n  // Step 2: Create a list of pages\n  final List<Widget> _pages = [\n    Center(child: Text('Home Page', style: TextStyle(fontSize: 24))),\n    Center(child: Text('Search Page', style: TextStyle(fontSize: 24))),\n    Center(child: Text('Profile Page', style: TextStyle(fontSize: 24))),\n    Center(child: Text('Settings Page', style: TextStyle(fontSize: 24))),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Salomon Bottom Bar Demo')),\n      // Step 3: Display the current page\n      body: _pages[_currentIndex],\n      // Step 4: Implement Salomon Bottom Bar\n      bottomNavigationBar: SalomonBottomBar(\n        currentIndex: _currentIndex,\n        onTap: (i) => setState(() => _currentIndex = i),\n        items: [\n          // Step 5: Define bottom bar items\n          SalomonBottomBarItem(\n            icon: Icon(Icons.home),\n            title: Text(\"Home\"),\n            selectedColor: Colors.purple,\n          ),\n          SalomonBottomBarItem(\n            icon: Icon(Icons.search),\n            title: Text(\"Search\"),\n            selectedColor: Colors.orange,\n          ),\n          SalomonBottomBarItem(\n            icon: Icon(Icons.person),\n            title: Text(\"Profile\"),\n            selectedColor: Colors.teal,\n          ),\n          SalomonBottomBarItem(\n            icon: Icon(Icons.settings),\n            title: Text(\"Settings\"),\n            selectedColor: Colors.pink,\n          ),\n        ],\n        // Step 6: Customize the appearance\n        curve: Curves.easeOutQuint,\n        duration: Duration(milliseconds: 500),\n        selectedItemColor: Colors.white,\n        unselectedItemColor: Colors.white.withOpacity(0.5),\n        itemShape: RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(10),\n        ),\n        itemPadding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),\n        margin: EdgeInsets.symmetric(horizontal: 12, vertical: 8),\n      ),\n    );\n  }\n}\n\n// Flow of the application:\n// 1. The app starts with the HomePage widget.\n// 2. The HomePage maintains a current index state (_currentIndex) to keep track of the selected tab.\n// 3. A list of pages (_pages) is defined, corresponding to each tab in the bottom bar.\n// 4. The Scaffold's body displays the current page based on the _currentIndex.\n// 5. The SalomonBottomBar is implemented in the bottomNavigationBar of the Scaffold.\n// 6. When a user taps on a tab, the onTap callback updates the _currentIndex.\n// 7. Updating _currentIndex triggers a rebuild of the widget, showing the corresponding page.\n// 8. The SalomonBottomBar handles the visual feedback and animations automatically.\n// 9. Customization options like curve, duration, colors, and shapes are applied to enhance the look and feel.\n\n// This example demonstrates key features of the salomon_bottom_bar package:\n// - Multiple tabs with icons and labels\n// - Custom colors for selected and unselected items\n// - Animated transitions between tabs\n// - Customizable item shape and padding\n// - Margin control for the entire bar\n```",
    "shortDescription": "Yet another bottom navigation bar, but with a few key promises.",
    "similarPackages": [
      {
        "_key": "fkokh0x4",
        "_ref": "uQRNMiDfrp20RZ8Id8CbUr",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 971,
    "packageImage": null,
    "pubPoint": 160,
    "author": "lukepighetti.com",
    "subCategories": [
      {
        "_key": "sl1lser4",
        "_ref": "EyMM3FfV3Ih5n1NWrhPG0V",
        "_type": "reference"
      }
    ],
    "tags": [
      "bottom-bar",
      "navigation",
      "ui",
      "widget",
      "custom"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CeP3",
        "_type": "reference",
        "_key": "772j91yc"
      }
    ],
    "lastUpdate": "2023-03-30T18:30:00.000Z",
    "name": "salomon_bottom_bar",
    "_id": "Rx1Nho763d29lawKra1vvH",
    "_rev": "eaCZ7mIhmiYZX5KGqJmOw2",
    "description": "# Salomon Bottom Bar: A Sleek Navigation Solution for Flutter\n\n## Introduction\n\nIn the world of mobile app development, creating an intuitive and visually appealing navigation system is crucial for enhancing user experience. Flutter, Google's UI toolkit for building natively compiled applications, offers various options for implementing bottom navigation bars. One standout package that has gained popularity among developers is the `salomon_bottom_bar`.\n\n## What is Salomon Bottom Bar?\n\n`salomon_bottom_bar` is a custom implementation of Flutter's `BottomNavigationBar` widget. It provides a modern, animated, and highly customizable bottom navigation bar that can significantly enhance the look and feel of your Flutter application.\n\n## Key Features\n\n1. **Smooth Animations**: The package offers fluid transitions between selected items, providing a polished user experience.\n\n2. **Customizable Design**: Developers can easily modify colors, shapes, and sizes to match their app's theme.\n\n3. **Flexible Item Count**: Unlike the standard `BottomNavigationBar`, `salomon_bottom_bar` doesn't limit you to a specific number of items.\n\n4. **Support for Icons and Labels**: Each navigation item can include both an icon and a label, with options to show or hide labels as needed.\n\n5. **Easy Integration**: The package is straightforward to implement and integrates seamlessly with existing Flutter projects.\n\n6. **Cross-Platform Compatibility**: Works flawlessly on both iOS and Android platforms.\n\n## Why Choose Salomon Bottom Bar?\n\n1. **Aesthetic Appeal**: Its modern design and smooth animations can significantly enhance your app's visual appeal.\n\n2. **Improved User Experience**: The clear, intuitive interface makes navigation effortless for users.\n\n3. **Developer-Friendly**: With its simple API and high customizability, it's a joy for developers to work with.\n\n4. **Performance**: Built with efficiency in mind, it doesn't compromise on app performance.\n\nIn the following sections, we'll dive into a tutorial on how to implement `salomon_bottom_bar` in your Flutter project and explore a comprehensive example showcasing all its features.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:36Z"
  },
  {
    "tutorial": "# Tutorial: Implementing Internet Connection Checker Plus in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the `internet_connection_checker_plus` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  internet_connection_checker_plus: ^1.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:internet_connection_checker_plus/internet_connection_checker_plus.dart';\n```\n\nCreate an instance of `InternetConnectionCheckerPlus`:\n\n```dart\nfinal RealFlutter internetChecker = InternetConnectionCheckerPlus();\n```\n\n## Step 3: Check Current Connection Status\n\nTo check the current connection status:\n\n```dart\nbool result = await internetChecker.hasConnection;\nif (result) {\n  print('Connected to the internet');\n} else {\n  print('No internet connection');\n}\n```\n\n## Step 4: Listen for Connection Changes\n\nTo continuously monitor the connection status:\n\n```dart\nStream<InternetConnectionStatus> listener = internetChecker.onStatusChange;\nlistener.listen((InternetConnectionStatus status) {\n  switch (status) {\n    case InternetConnectionStatus.connected:\n      print('Connected to the internet');\n      break;\n    case InternetConnectionStatus.disconnected:\n      print('Disconnected from the internet');\n      break;\n  }\n});\n```\n\n## Step 5: Customize Check Behavior\n\nYou can customize the checker's behavior:\n\n```dart\nRealFlutter internetChecker = InternetConnectionCheckerPlus.createInstance(\n  checkTimeout: const Duration(seconds: 5),\n  checkInterval: const Duration(seconds: 60),\n  addresses: [\n    AddressCheckOptions(\n      Uri.parse('https://example.com'),\n      port: 80,\n      timeout: const Duration(seconds: 5),\n    ),\n  ],\n);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, add the following permission to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### iOS\n\nFor iOS, add the following keys to your `Info.plist`:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\nThis allows your app to make network connections.\n\nBy following these steps, you'll have successfully integrated `internet_connection_checker_plus` into your Flutter application, enabling robust internet connectivity monitoring across both Android and iOS platforms.",
    "_updatedAt": "2024-09-06T04:11:37Z",
    "_rev": "ezMiwuUkJkbYMWycA6RapO",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference",
        "_key": "ct9m13jq"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "Rx1Nho763d29lawKra1w5v",
    "name": "internet_connection_checker_plus",
    "tutorialIncluded": true,
    "author": "outdatedguy.rocks",
    "description": "# Internet Connection Checker Plus: A Comprehensive Flutter Package\n\nIn the world of mobile app development, ensuring a stable internet connection is crucial for delivering a seamless user experience. Enter `internet_connection_checker_plus`, a powerful Flutter package designed to simplify the process of monitoring and managing internet connectivity in your applications.\n\n## Key Features\n\n1. **Real-time Connection Monitoring**: Keep track of your app's internet connection status in real-time, allowing you to respond instantly to changes.\n\n2. **Cross-platform Compatibility**: Works seamlessly on both Android and iOS platforms, providing a consistent experience across devices.\n\n3. **Customizable Check Interval**: Adjust the frequency of connection checks to suit your app's specific needs and optimize performance.\n\n4. **Flexible Configuration**: Fine-tune the package's behavior with customizable timeout durations, addresses to check, and more.\n\n5. **Stream-based Updates**: Utilize Dart streams to receive continuous updates about the connection status, making it easy to integrate with reactive programming patterns.\n\n6. **Minimal Dependencies**: Lightweight and efficient, with minimal external dependencies to keep your app's footprint small.\n\n7. **Easy Integration**: Simple to set up and use, with clear documentation and examples to get you started quickly.\n\nWhether you're building a data-intensive application, a real-time communication tool, or simply want to enhance your app's reliability, `internet_connection_checker_plus` provides the tools you need to manage internet connectivity effectively.\n\nIn the following sections, we'll dive into a detailed tutorial on how to implement this package in your Flutter projects, followed by a comprehensive example showcasing all its features. Let's get connected!",
    "tags": [
      "connectivity",
      "network",
      "internet",
      "checker"
    ],
    "_createdAt": "2024-08-28T22:21:09Z",
    "dependentPackages": [
      {
        "_key": "kdrxtt5p",
        "_ref": "uQRNMiDfrp20RZ8Id8CW83",
        "_type": "reference"
      },
      {
        "_key": "e3169gli",
        "_ref": "V06bsD4sX3T8NTHrBPb4Yq",
        "_type": "reference"
      }
    ],
    "lastUpdate": "2024-07-31T18:30:00.000Z",
    "slug": {
      "current": "internet_connection_checker_plus",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [
      {
        "_key": "t4dbjozb",
        "_ref": "V06bsD4sX3T8NTHrBPaluC",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:stack_trace/stack_trace.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Stack Trace Demo'),\n        ),\n        body: const StackTraceDemo(),\n      ),\n    );\n  }\n}\n\nclass StackTraceDemo extends StatefulWidget {\n  const StackTraceDemo({Key? key}) : super(key: key);\n\n  @override\n  _StackTraceDemoState createState() => _StackTraceDemoState();\n}\n\nclass _StackTraceDemoState extends State<StackTraceDemo> {\n  String _output = '';\n\n  // Step 1: Function to demonstrate basic stack trace parsing\n  void _parseStackTrace() {\n    try {\n      throw Exception('Test error');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      setState(() {\n        _output = 'Parsed Stack Trace:\\n$trace';\n      });\n    }\n  }\n\n  // Step 2: Function to demonstrate stack trace formatting\n  void _formatStackTrace() {\n    try {\n      throw Exception('Test error for formatting');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      setState(() {\n        _output = 'Default format:\\n$trace\\n\\n'\n            'Terse format:\\n${trace.terse}\\n\\n'\n            'Foldable format:\\n${trace.foldFrames((frame) => frame.isCore)}';\n      });\n    }\n  }\n\n  // Step 3: Function to demonstrate platform-specific handling\n  void _platformSpecificTrace() {\n    try {\n      throw Exception('Platform-specific test error');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      String result;\n      if (Theme.of(context).platform == TargetPlatform.android) {\n        result = 'Android Trace:\\n${trace.terse}';\n      } else if (Theme.of(context).platform == TargetPlatform.iOS) {\n        result = 'iOS Trace:\\n${trace.foldFrames((frame) => frame.library.startsWith('dart:'))}';\n      } else {\n        result = 'Web Trace:\\n${Chain.forTrace(stackTrace).terse}';\n      }\n      setState(() {\n        _output = result;\n      });\n    }\n  }\n\n  // Step 4: Function to demonstrate custom formatting\n  String _customFormat(Trace trace) {\n    return trace.frames.map((frame) => '${frame.member} (${frame.uri}:${frame.line})').join('\\n');\n  }\n\n  void _showCustomFormat() {\n    Trace currentTrace = Trace.current();\n    setState(() {\n      _output = 'Custom Formatted Trace:\\n${_customFormat(currentTrace)}';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      child: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            ElevatedButton(\n              onPressed: _parseStackTrace,\n              child: const Text('Parse Stack Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _formatStackTrace,\n              child: const Text('Format Stack Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _platformSpecificTrace,\n              child: const Text('Platform-Specific Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _showCustomFormat,\n              child: const Text('Custom Format'),\n            ),\n            const SizedBox(height: 20),\n            const Text('Output:', style: TextStyle(fontWeight: FontWeight.bold)),\n            const SizedBox(height: 10),\n            Text(_output),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons and an output area.\n// 2. When \"Parse Stack Trace\" is pressed, it simulates an error and parses the resulting stack trace.\n// 3. \"Format Stack Trace\" demonstrates different formatting options for stack traces.\n// 4. \"Platform-Specific Trace\" shows how to handle traces differently based on the platform.\n// 5. \"Custom Format\" applies a custom formatting function to the current stack trace.\n// 6. Each action updates the output area with the result of the stack trace operation.\n// \n// This example showcases the key features of the stack_trace package:\n// - Parsing stack traces\n// - Various formatting options\n// - Platform-specific handling\n// - Custom formatting\n// \n// The app provides an interactive way to explore these features, making it easier to understand\n// how the package works in a real Flutter application context.\n```",
    "shortDescription": "A Flutter package to check your internet connection with subsecond response times, even on mobile networks!",
    "likesCount": 234,
    "packageImage": null
  },
  {
    "lastUpdate": "2023-07-06T18:30:00.000Z",
    "tutorialIncluded": true,
    "description": "# Understanding the stack_trace Package in Flutter\n\n## Introduction\n\nThe `stack_trace` package is a powerful tool in the Flutter ecosystem that provides enhanced functionality for working with stack traces. It offers a robust set of features for parsing, manipulating, and formatting stack traces, which can be invaluable for debugging and error reporting in Flutter applications.\n\n## Key Features\n\n1. **Stack Trace Parsing**: The package can parse stack traces from various formats, including strings and lists of strings.\n\n2. **Frame Manipulation**: It allows you to manipulate individual stack frames, giving you fine-grained control over the information you work with.\n\n3. **Formatting Options**: The package provides multiple formatting options to display stack traces in a way that best suits your needs.\n\n4. **Cross-Platform Support**: It works seamlessly across different platforms, including iOS, Android, and web.\n\n5. **Integration with Flutter**: While it's a standalone package, it integrates well with Flutter's error handling mechanisms.\n\n## Why Use stack_trace?\n\n- **Enhanced Debugging**: The package helps in creating more informative error reports, making debugging easier.\n- **Customization**: It allows developers to customize how stack traces are displayed and processed.\n- **Performance**: It's designed to be efficient, even when dealing with large stack traces.\n\nIn the following sections, we'll dive deeper into how to use this package effectively in your Flutter projects.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPas2O",
        "_type": "reference",
        "_key": "02atjxww"
      }
    ],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfI3O",
        "_type": "reference",
        "_key": "ifsx45cd"
      }
    ],
    "likesCount": 276,
    "_createdAt": "2024-08-28T22:21:11Z",
    "author": "tools.dart.dev",
    "_rev": "ezMiwuUkJkbYMWycA6Rawa",
    "dependentPackages": [],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:11:38Z",
    "pubPoint": 160,
    "_type": "package",
    "tags": [
      "debugging",
      "error-handling",
      "stack-trace",
      "exceptions"
    ],
    "_id": "Rx1Nho763d29lawKra1wGZ",
    "tutorial": "# Tutorial: Using the stack_trace Package in Flutter\n\n## Setup\n\n1. Add the `stack_trace` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  stack_trace: ^1.10.0\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:stack_trace/stack_trace.dart';\n```\n\n## Basic Usage\n\n### Parsing a Stack Trace\n\n```dart\nvoid parseStackTrace() {\n  try {\n    // Simulate an error\n    throw Exception('Test error');\n  } catch (e, stackTrace) {\n    // Parse the stack trace\n    Trace trace = Trace.from(stackTrace);\n    print(trace);\n  }\n}\n```\n\n### Formatting a Stack Trace\n\n```dart\nvoid formatStackTrace() {\n  try {\n    throw Exception('Test error');\n  } catch (e, stackTrace) {\n    Trace trace = Trace.from(stackTrace);\n    \n    // Default formatting\n    print(trace.toString());\n    \n    // Terse formatting (more compact)\n    print(trace.terse);\n    \n    // Foldable formatting (for collapsible UI elements)\n    print(trace.foldFrames((frame) => frame.isCore).toString());\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, stack traces may include additional system-specific information. You can filter these out using:\n\n```dart\nTrace androidTrace = Trace.from(stackTrace).terse;\n```\n\n### iOS\n\niOS stack traces are generally cleaner, but you might want to focus on your app's frames:\n\n```dart\nTrace iosTrace = Trace.from(stackTrace).foldFrames((frame) => frame.library.startsWith('dart:'));\n```\n\n### Web\n\nFor web applications, consider using the `Chain` class to handle asynchronous stack traces:\n\n```dart\nimport 'package:stack_trace/stack_trace.dart';\n\nvoid handleWebError() {\n  Chain.capture(() {\n    // Your code here\n  }, onError: (error, chain) {\n    print(chain.terse);\n  });\n}\n```\n\n## Advanced Usage\n\n### Custom Trace Formatting\n\nYou can create custom formatting for your traces:\n\n```dart\nString customFormat(Trace trace) {\n  return trace.frames.map((frame) => '${frame.member} (${frame.uri}:${frame.line})').join('\\n');\n}\n\n// Usage\nprint(customFormat(Trace.current()));\n```\n\nThis tutorial covers the basics of using the `stack_trace` package in Flutter. In the next section, we'll look at a complete example that demonstrates these concepts in action.",
    "shortDescription": "A package for manipulating stack traces and printing them readably.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:stack_trace/stack_trace.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Stack Trace Demo'),\n        ),\n        body: const StackTraceDemo(),\n      ),\n    );\n  }\n}\n\nclass StackTraceDemo extends StatefulWidget {\n  const StackTraceDemo({Key? key}) : super(key: key);\n\n  @override\n  _StackTraceDemoState createState() => _StackTraceDemoState();\n}\n\nclass _StackTraceDemoState extends State<StackTraceDemo> {\n  String _output = '';\n\n  // Step 1: Function to demonstrate basic stack trace parsing\n  void _parseStackTrace() {\n    try {\n      throw Exception('Test error');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      setState(() {\n        _output = 'Parsed Stack Trace:\\n$trace';\n      });\n    }\n  }\n\n  // Step 2: Function to demonstrate stack trace formatting\n  void _formatStackTrace() {\n    try {\n      throw Exception('Test error for formatting');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      setState(() {\n        _output = 'Default format:\\n$trace\\n\\n'\n            'Terse format:\\n${trace.terse}\\n\\n'\n            'Foldable format:\\n${trace.foldFrames((frame) => frame.isCore)}';\n      });\n    }\n  }\n\n  // Step 3: Function to demonstrate platform-specific handling\n  void _platformSpecificTrace() {\n    try {\n      throw Exception('Platform-specific test error');\n    } catch (e, stackTrace) {\n      Trace trace = Trace.from(stackTrace);\n      String result;\n      if (Theme.of(context).platform == TargetPlatform.android) {\n        result = 'Android Trace:\\n${trace.terse}';\n      } else if (Theme.of(context).platform == TargetPlatform.iOS) {\n        result = 'iOS Trace:\\n${trace.foldFrames((frame) => frame.library.startsWith('dart:'))}';\n      } else {\n        result = 'Web Trace:\\n${Chain.forTrace(stackTrace).terse}';\n      }\n      setState(() {\n        _output = result;\n      });\n    }\n  }\n\n  // Step 4: Function to demonstrate custom formatting\n  String _customFormat(Trace trace) {\n    return trace.frames.map((frame) => '${frame.member} (${frame.uri}:${frame.line})').join('\\n');\n  }\n\n  void _showCustomFormat() {\n    Trace currentTrace = Trace.current();\n    setState(() {\n      _output = 'Custom Formatted Trace:\\n${_customFormat(currentTrace)}';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      child: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            ElevatedButton(\n              onPressed: _parseStackTrace,\n              child: const Text('Parse Stack Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _formatStackTrace,\n              child: const Text('Format Stack Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _platformSpecificTrace,\n              child: const Text('Platform-Specific Trace'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _showCustomFormat,\n              child: const Text('Custom Format'),\n            ),\n            const SizedBox(height: 20),\n            const Text('Output:', style: TextStyle(fontWeight: FontWeight.bold)),\n            const SizedBox(height: 10),\n            Text(_output),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons and an output area.\n// 2. When \"Parse Stack Trace\" is pressed, it simulates an error and parses the resulting stack trace.\n// 3. \"Format Stack Trace\" demonstrates different formatting options for stack traces.\n// 4. \"Platform-Specific Trace\" shows how to handle traces differently based on the platform.\n// 5. \"Custom Format\" applies a custom formatting function to the current stack trace.\n// 6. Each action updates the output area with the result of the stack trace operation.\n// \n// This example showcases the key features of the stack_trace package:\n// - Parsing stack traces\n// - Various formatting options\n// - Platform-specific handling\n// - Custom formatting\n// \n// The app provides an interactive way to explore these features, making it easier to understand\n// how the package works in a real Flutter application context.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "stack_trace",
    "slug": {
      "current": "stack_trace",
      "_type": "slug"
    }
  },
  {
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbJ9o",
        "_type": "reference",
        "_key": "5031rw6u"
      }
    ],
    "tags": [
      "timer",
      "stopwatch",
      "countdown",
      "clock"
    ],
    "likesCount": 279,
    "lastUpdate": "2024-08-23T18:30:00.000Z",
    "pubPoint": 160,
    "shortDescription": "Simple CountUp timer / CountDown timer. It easily create app of stopwatch.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbYiL",
        "_type": "reference",
        "_key": "ydo76b8x"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:stop_watch_timer/stop_watch_timer.dart';\n\nvoid main() => runApp(const RealFlutter());\n\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize StopWatchTimer\n  final StopWatchTimer _stopWatchTimer = StopWatchTimer(\n    mode: StopWatchMode.countUp,\n    onChange: (value) => print('onChange $value'),\n    onChangeRawSecond: (value) => print('onChangeRawSecond $value'),\n    onChangeRawMinute: (value) => print('onChangeRawMinute $value'),\n  );\n\n  final _scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Optional - Set preset time\n    _stopWatchTimer.setPresetTime(mSec: 5000); // Preset to 5 seconds\n  }\n\n  @override\n  void dispose() async {\n    super.dispose();\n    // Step 3: Dispose of the timer when the widget is disposed\n    await _stopWatchTimer.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('StopWatch Timer Demo'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // Step 4: Display the timer\n              StreamBuilder<int>(\n                stream: _stopWatchTimer.rawTime,\n                initialData: _stopWatchTimer.rawTime.value,\n                builder: (context, snap) {\n                  final value = snap.data!;\n                  final displayTime = StopWatchTimer.getDisplayTime(value, hours: true);\n                  return Text(\n                    displayTime,\n                    style: const TextStyle(fontSize: 40, fontWeight: FontWeight.bold),\n                  );\n                },\n              ),\n              const SizedBox(height: 20),\n              // Step 5: Control buttons\n              Row(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  ElevatedButton(\n                    onPressed: () => _stopWatchTimer.onStartTimer(),\n                    child: const Text('Start'),\n                  ),\n                  const SizedBox(width: 10),\n                  ElevatedButton(\n                    onPressed: () => _stopWatchTimer.onStopTimer(),\n                    child: const Text('Stop'),\n                  ),\n                  const SizedBox(width: 10),\n                  ElevatedButton(\n                    onPressed: () => _stopWatchTimer.onResetTimer(),\n                    child: const Text('Reset'),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 20),\n              // Step 6: Lap times\n              ElevatedButton(\n                onPressed: () => _stopWatchTimer.onAddLap(),\n                child: const Text('Lap'),\n              ),\n              const SizedBox(height: 20),\n              // Step 7: Display lap times\n              SizedBox(\n                height: 100,\n                child: StreamBuilder<List<StopWatchRecord>>(\n                  stream: _stopWatchTimer.records,\n                  initialData: _stopWatchTimer.records.value,\n                  builder: (context, snap) {\n                    final value = snap.data!;\n                    return ListView.builder(\n                      controller: _scrollController,\n                      scrollDirection: Axis.vertical,\n                      itemBuilder: (BuildContext context, int index) {\n                        final item = value[index];\n                        return Text('Lap ${index + 1}: ${item.displayTime}');\n                      },\n                      itemCount: value.length,\n                    );\n                  },\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes with a StopWatchTimer set to count up.\n// 2. The main screen displays the current timer value, updated in real-time.\n// 3. Users can start, stop, and reset the timer using the provided buttons.\n// 4. The \"Lap\" button allows users to record lap times.\n// 5. Recorded lap times are displayed in a scrollable list below the main timer.\n// 6. The timer continues to run even when the app is in the background, thanks to the stream-based architecture.\n// 7. When the widget is disposed (e.g., app closed), the timer is properly disposed to prevent memory leaks.\n\n// Key Points:\n// - The StopWatchTimer is initialized in the State class and disposed when no longer needed.\n// - StreamBuilder widgets are used to reactively update the UI based on timer changes.\n// - Lap times are recorded and displayed, showcasing the package's advanced features.\n// - The code structure allows for easy expansion, such as adding countdown functionality or custom styling.\n```",
    "_id": "Rx1Nho763d29lawKra1wRD",
    "tutorial": "# Tutorial: Implementing Stop Watch Timer in Flutter\n\nThis tutorial will guide you through the process of integrating the `stop_watch_timer` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `stop_watch_timer` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  stop_watch_timer: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:stop_watch_timer/stop_watch_timer.dart';\n```\n\n## Step 3: Create a StopWatchTimer Instance\n\nInitialize the `StopWatchTimer` in your widget:\n\n```dart\nclass _RealFlutterState extends State<RealFlutter> {\n  final StopWatchTimer _stopWatchTimer = StopWatchTimer();\n\n  @override\n  void dispose() {\n    super.dispose();\n    _stopWatchTimer.dispose();\n  }\n\n  // ... rest of your widget code\n}\n```\n\n## Step 4: Basic Usage\n\nHere's how to use the basic functions of the timer:\n\n```dart\n// Start the timer\n_stopWatchTimer.onStartTimer();\n\n// Stop the timer\n_stopWatchTimer.onStopTimer();\n\n// Reset the timer\n_stopWatchTimer.onResetTimer();\n\n// Set preset time (e.g., 5 minutes)\n_stopWatchTimer.setPresetTime(mSec: 5 * 60 * 1000);\n```\n\n## Step 5: Displaying the Timer\n\nUse a `StreamBuilder` to display the timer value:\n\n```dart\nStreamBuilder<int>(\n  stream: _stopWatchTimer.rawTime,\n  initialData: _stopWatchTimer.rawTime.value,\n  builder: (context, snap) {\n    final value = snap.data!;\n    final displayTime = StopWatchTimer.getDisplayTime(value);\n    return Text(displayTime);\n  },\n),\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, no additional setup is required. The package works out of the box.\n\n### Android\n\nFor Android, ensure that your `compileSdkVersion` is set to 31 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    compileSdkVersion 31\n    // ...\n}\n```\n\n### Web\n\nFor web applications, the package is fully supported without any additional configuration.\n\n## Advanced Features\n\n1. **Lap Times**: Use `_stopWatchTimer.onAddLap()` to record lap times.\n2. **Custom Interval**: Adjust update frequency with `_stopWatchTimer.setPresetTime(mSec: ...)`.\n3. **Countdown Mode**: Initialize with `StopWatchTimer(mode: StopWatchMode.countDown)`.\n\nBy following this tutorial, you'll have a fully functional stopwatch/timer in your Flutter application, ready for further customization based on your specific needs.",
    "_updatedAt": "2024-09-06T04:11:39Z",
    "slug": {
      "current": "stop_watch_timer",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaQRk",
    "_type": "package",
    "description": "# Stop Watch Timer Package for Flutter\n\n## Introduction\n\nThe `stop_watch_timer` package is a powerful and flexible timer solution for Flutter applications. It provides a robust set of features for implementing stopwatch and timer functionality in your apps. This package is particularly useful for scenarios where precise time tracking is required, such as fitness apps, productivity tools, or any application that needs to measure elapsed time.\n\n## Key Features\n\n1. **Precision Timing**: Offers millisecond-level accuracy for precise time tracking.\n2. **Customizable Display**: Easily format the timer display to show hours, minutes, seconds, and milliseconds as needed.\n3. **Pause and Resume**: Allows pausing and resuming the timer, essential for user-controlled timing scenarios.\n4. **Lap Times**: Supports recording lap times, useful for tracking multiple intervals within a single timing session.\n5. **Countdown Mode**: Can be used as a countdown timer, starting from a specified duration and counting down to zero.\n6. **Stream-based Updates**: Utilizes Dart streams for real-time updates, ensuring smooth integration with Flutter's reactive framework.\n7. **Platform Independence**: Works consistently across iOS, Android, and web platforms.\n\n## Why Choose Stop Watch Timer?\n\nThe `stop_watch_timer` package stands out for its simplicity and flexibility. Whether you're building a sports timing app, a Pomodoro timer, or a general-purpose stopwatch, this package provides the foundation you need. Its stream-based architecture ensures efficient updates and easy integration with Flutter's state management solutions.\n\nIn the following sections, we'll dive into a tutorial on how to implement this package in your Flutter application and showcase a complete example demonstrating its features.",
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:21:14Z",
    "name": "stop_watch_timer",
    "tutorialIncluded": true,
    "author": "neverjp.com",
    "packageImage": null,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ]
  },
  {
    "author": "adaptant.io",
    "_type": "package",
    "description": "# Flutter Window Manager Package: Enhancing Your App's Security\n\n## Introduction\n\nIn the world of mobile app development, security is paramount. One crucial aspect of security is preventing sensitive information from being captured through screenshots or screen recordings. This is where the `flutter_windowmanager` package comes into play.\n\n## What is flutter_windowmanager?\n\nThe `flutter_windowmanager` package is a powerful tool for Flutter developers who want to add an extra layer of security to their applications. It provides a set of features that allow developers to control various aspects of the app window, particularly focusing on preventing unauthorized capture of sensitive information.\n\n## Key Features\n\n1. **Secure Flag**: This feature prevents the app's content from appearing in screenshots or when the app is shown on non-secure displays.\n\n2. **Keep Screen On**: Keeps the device's screen on and active, which can be useful for apps that require continuous display without user interaction.\n\n3. **Full Screen Mode**: Allows the app to use the entire screen, hiding system UI elements like the status bar.\n\n4. **Flag Secure**: Similar to Secure Flag, this prevents the app's content from appearing in screenshots or screen recordings.\n\n## Why Use flutter_windowmanager?\n\n1. **Enhanced Security**: Protect sensitive information from being captured through screenshots or screen recordings.\n\n2. **User Experience**: Control screen behavior for a better user experience in specific scenarios.\n\n3. **Cross-Platform**: Works on both Android and iOS platforms, providing a consistent security approach.\n\n4. **Easy Integration**: Simple to integrate into existing Flutter projects with minimal code changes.\n\nIn the following sections, we'll dive deeper into how to implement these features in your Flutter application, providing you with the tools to create more secure and user-friendly apps.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "8y1t67ax",
        "_ref": "Rx1Nho763d29lawKra1hDL"
      }
    ],
    "tags": [
      "window",
      "security",
      "screenshot",
      "android",
      "screen-capture",
      "privacy",
      "secure-flag"
    ],
    "platforms": [
      "android"
    ],
    "_createdAt": "2024-08-28T22:21:18Z",
    "_id": "Rx1Nho763d29lawKra1wbr",
    "name": "flutter_windowmanager",
    "tutorial": "# Flutter Window Manager Package: Implementation Tutorial\n\n## Getting Started\n\nTo begin using the `flutter_windowmanager` package in your Flutter project, follow these steps:\n\n1. Add the package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_windowmanager: ^0.2.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:flutter_windowmanager/flutter_windowmanager.dart';\n```\n\n## Implementation\n\n### Secure Flag\n\nTo enable the secure flag, which prevents content from appearing in screenshots:\n\n```dart\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_SECURE);\n```\n\n### Keep Screen On\n\nTo keep the device's screen on:\n\n```dart\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_KEEP_SCREEN_ON);\n```\n\n### Full Screen Mode\n\nTo enable full screen mode:\n\n```dart\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_FULLSCREEN);\n```\n\n### Flag Secure\n\nSimilar to Secure Flag, but more comprehensive:\n\n```dart\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_SECURE);\n```\n\n## Platform-Specific Details\n\n### Android\n\nOn Android, the `FLAG_SECURE` is implemented using the `WindowManager.LayoutParams.FLAG_SECURE` flag. This prevents the window's contents from appearing in screenshots or from being viewed on non-secure displays.\n\nTo add this flag in native Android code:\n\n```kotlin\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE)\n```\n\n### iOS\n\nOn iOS, screenshot prevention is achieved by setting the `windowScene.screen.isCaptured` property to `true`. This triggers the operating system to hide the app's content when a screenshot is attempted.\n\nTo implement this in native iOS code:\n\n```swift\nNotificationCenter.default.addObserver(forName: UIScreen.capturedDidChangeNotification, object: nil, queue: .main) { _ in\n    if UIScreen.main.isCaptured {\n        // Hide sensitive content\n    } else {\n        // Show content\n    }\n}\n```\n\nRemember that while these methods enhance security, they are not foolproof. Always implement additional security measures for highly sensitive data.\n\nIn the next section, we'll look at a complete example implementing all these features in a Flutter application.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaQUw",
    "shortDescription": "A Flutter plugin for manipulating Android WindowManager LayoutParams.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGhy",
        "_type": "reference",
        "_key": "c9p2gr49"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1mMh",
        "_type": "reference",
        "_key": "34rzghfz"
      }
    ],
    "slug": {
      "current": "flutter_windowmanager",
      "_type": "slug"
    },
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_windowmanager/flutter_windowmanager.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  bool _isSecure = false;\n  bool _isScreenOn = false;\n  bool _isFullScreen = false;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize the app\n    _initializeApp();\n  }\n\n  // Step 2: Initialize app settings\n  Future<void> _initializeApp() async {\n    // Initially, we don't apply any flags\n    await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_SECURE);\n    await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_KEEP_SCREEN_ON);\n    await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_FULLSCREEN);\n  }\n\n  // Step 3: Toggle secure flag\n  Future<void> _toggleSecureFlag() async {\n    setState(() {\n      _isSecure = !_isSecure;\n    });\n    if (_isSecure) {\n      await FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_SECURE);\n    } else {\n      await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_SECURE);\n    }\n  }\n\n  // Step 4: Toggle keep screen on\n  Future<void> _toggleKeepScreenOn() async {\n    setState(() {\n      _isScreenOn = !_isScreenOn;\n    });\n    if (_isScreenOn) {\n      await FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_KEEP_SCREEN_ON);\n    } else {\n      await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_KEEP_SCREEN_ON);\n    }\n  }\n\n  // Step 5: Toggle full screen mode\n  Future<void> _toggleFullScreen() async {\n    setState(() {\n      _isFullScreen = !_isFullScreen;\n    });\n    if (_isFullScreen) {\n      await FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_FULLSCREEN);\n    } else {\n      await FlutterWindowManager.clearFlags(FlutterWindowManager.FLAG_FULLSCREEN);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 6: Build the UI\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter Window Manager Demo'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // Step 7: Add toggle buttons for each feature\n              ElevatedButton(\n                onPressed: _toggleSecureFlag,\n                child: Text(_isSecure ? 'Disable Secure Flag' : 'Enable Secure Flag'),\n              ),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: _toggleKeepScreenOn,\n                child: Text(_isScreenOn ? 'Allow Screen Off' : 'Keep Screen On'),\n              ),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: _toggleFullScreen,\n                child: Text(_isFullScreen ? 'Exit Full Screen' : 'Enter Full Screen'),\n              ),\n              SizedBox(height: 20),\n              // Step 8: Add a text field to demonstrate secure flag\n              TextField(\n                decoration: InputDecoration(\n                  hintText: 'Enter sensitive information here',\n                  border: OutlineInputBorder(),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes without any window manager flags.\n// 2. The user is presented with three buttons to toggle different features:\n//    - Secure Flag: Prevents screenshots when enabled\n//    - Keep Screen On: Keeps the device screen on when enabled\n//    - Full Screen: Enters or exits full screen mode\n// 3. When a button is pressed, the corresponding flag is toggled on or off.\n// 4. The text field at the bottom demonstrates the effect of the secure flag:\n//    - When secure flag is on, attempts to screenshot will not capture this field\n//    - When secure flag is off, screenshots will work normally\n// 5. The app's state (which flags are active) is maintained and reflected in the UI\n//    through the button text changes.\n\n// Note: The actual visibility of system UI elements (status bar, navigation bar)\n// may vary depending on the device and OS version when using FLAG_FULLSCREEN.\n```",
    "likesCount": 324,
    "packageImage": null,
    "lastUpdate": "2021-08-25T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:11:40Z"
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:facebook_app_events/facebook_app_events.dart';\n\nvoid main() async {\n  // Step 1: Initialize the app and Facebook App Events\n  WidgetsFlutterBinding.ensureInitialized();\n  final facebookAppEvents = FacebookAppEvents();\n  await facebookAppEvents.setAdvertiserTracking(enabled: true);\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Facebook App Events Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: FacebookAppEventsDemo(),\n    );\n  }\n}\n\nclass FacebookAppEventsDemo extends StatefulWidget {\n  @override\n  _FacebookAppEventsDemoState createState() => _FacebookAppEventsDemoState();\n}\n\nclass _FacebookAppEventsDemoState extends State<FacebookAppEventsDemo> {\n  final FacebookAppEvents facebookAppEvents = FacebookAppEvents();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Log app launch event\n    facebookAppEvents.logActivatedApp();\n  }\n\n  // Step 3: Function to log a custom event\n  void _logCustomEvent() {\n    facebookAppEvents.logEvent(\n      name: 'button_clicked',\n      parameters: {\n        'button_id': 'custom_event_button',\n      },\n    );\n  }\n\n  // Step 4: Function to set user properties\n  void _setUserProperties() {\n    facebookAppEvents.setUserData(\n      email: 'user@example.com',\n      firstName: 'John',\n      lastName: 'Doe',\n    );\n  }\n\n  // Step 5: Function to log a purchase\n  void _logPurchase() {\n    facebookAppEvents.logPurchase(\n      amount: 4.99,\n      currency: 'USD',\n      parameters: {\n        'item_name': 'Premium Subscription',\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Facebook App Events Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: _logCustomEvent,\n              child: Text('Log Custom Event'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _setUserProperties,\n              child: Text('Set User Properties'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _logPurchase,\n              child: Text('Log Purchase'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes and sets up Facebook App Events in the main() function.\n// 2. The RealFlutter widget sets up the MaterialApp and navigates to the FacebookAppEventsDemo page.\n// 3. In the FacebookAppEventsDemo page:\n//    - The app launch event is logged in initState().\n//    - Three buttons are displayed, each demonstrating a different feature:\n//      a. Logging a custom event\n//      b. Setting user properties\n//      c. Logging a purchase\n// 4. When a button is pressed, it triggers the corresponding function, which interacts with the Facebook App Events API.\n// 5. These events and data are then sent to Facebook for analysis and tracking.\n\n// Note: Make sure you've properly configured your Facebook App ID and other necessary settings\n// in the Android and iOS project files as described in the tutorial section.\n```",
    "dependentPackages": [],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:11:41Z",
    "author": "oddbit.id",
    "_rev": "ezMiwuUkJkbYMWycA6Rb3m",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPHC0",
        "_type": "reference",
        "_key": "0ljkf5z9"
      }
    ],
    "pubPoint": 160,
    "likesCount": 268,
    "lastUpdate": "2024-04-03T18:30:00.000Z",
    "slug": {
      "current": "facebook_app_events",
      "_type": "slug"
    },
    "tutorial": "# Tutorial: Implementing Facebook App Events in Your Flutter App\n\nThis tutorial will guide you through the process of setting up and using the `facebook_app_events` package in your Flutter application.\n\n## Step 1: Add the Package\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  facebook_app_events: ^0.18.3\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Configure Platform-Specific Settings\n\n### Android Configuration\n\n1. Open your `android/app/src/main/AndroidManifest.xml` file and add the following meta-data tags inside the `<application>` tag:\n\n```xml\n<meta-data\n    android:name=\"com.facebook.sdk.ApplicationId\"\n    android:value=\"@string/facebook_app_id\"/>\n<meta-data \n    android:name=\"com.facebook.sdk.ClientToken\"\n    android:value=\"@string/facebook_client_token\"/>\n```\n\n2. Create a new file `android/app/src/main/res/values/strings.xml` if it doesn't exist, and add the following:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"facebook_app_id\">[YOUR_FACEBOOK_APP_ID]</string>\n    <string name=\"facebook_client_token\">[YOUR_CLIENT_TOKEN]</string>\n</resources>\n```\n\nReplace `[YOUR_FACEBOOK_APP_ID]` and `[YOUR_CLIENT_TOKEN]` with your actual Facebook App ID and Client Token.\n\n### iOS Configuration\n\n1. Open your `ios/Runner/Info.plist` file and add the following:\n\n```xml\n<key>FacebookAppID</key>\n<string>[YOUR_FACEBOOK_APP_ID]</string>\n<key>FacebookClientToken</key>\n<string>[YOUR_CLIENT_TOKEN]</string>\n<key>FacebookDisplayName</key>\n<string>[YOUR_APP_NAME]</string>\n```\n\nReplace `[YOUR_FACEBOOK_APP_ID]`, `[YOUR_CLIENT_TOKEN]`, and `[YOUR_APP_NAME]` with your actual values.\n\n## Step 3: Initialize the Package\n\nIn your `main.dart` file, import the package and initialize it:\n\n```dart\nimport 'package:facebook_app_events/facebook_app_events.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  final facebookAppEvents = FacebookAppEvents();\n  await facebookAppEvents.setAdvertiserTracking(enabled: true);\n  runApp(RealFlutter());\n}\n```\n\n## Step 4: Logging Events\n\nYou can now start logging events in your app. Here's an example of how to log a custom event:\n\n```dart\nfinal facebookAppEvents = FacebookAppEvents();\nfacebookAppEvents.logEvent(\n  name: 'button_clicked',\n  parameters: {\n    'button_id': 'sign_up_button',\n  },\n);\n```\n\n## Step 5: Setting User Properties\n\nTo set user properties, use the `setUserData` method:\n\n```dart\nfacebookAppEvents.setUserData(\n  email: 'user@example.com',\n  firstName: 'John',\n  lastName: 'Doe',\n);\n```\n\n## Step 6: Tracking App Installs\n\nThe package automatically tracks app installs. You don't need to add any additional code for this feature.\n\n## Step 7: Logging In-App Purchases\n\nTo log in-app purchases, use the `logPurchase` method:\n\n```dart\nfacebookAppEvents.logPurchase(\n  amount: 4.99,\n  currency: 'USD',\n  parameters: {\n    'item_name': 'Premium Subscription',\n  },\n);\n```\n\nBy following these steps, you'll have successfully integrated Facebook App Events into your Flutter application. In the next section, we'll look at a complete example that demonstrates all the features of this package.",
    "tutorialIncluded": true,
    "description": "# Facebook App Events Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nThe `facebook_app_events` package is a powerful tool for Flutter developers looking to integrate Facebook App Events into their applications. This package allows you to track user interactions, measure app performance, and gain valuable insights into user behavior.\n\n## Key Features\n\n1. **Event Logging**: Track custom events and predefined Facebook events.\n2. **User Properties**: Set and update user properties for better audience segmentation.\n3. **App Install Tracking**: Measure app installs and attribute them to your marketing efforts.\n4. **In-App Purchase Tracking**: Monitor and analyze in-app purchases.\n5. **Cross-Platform Support**: Works on both iOS and Android platforms.\n\n## Why Use Facebook App Events?\n\n- **Understand User Behavior**: Gain insights into how users interact with your app.\n- **Optimize Marketing**: Measure the effectiveness of your ad campaigns.\n- **Improve User Experience**: Use data to enhance app features and performance.\n- **Personalize Content**: Tailor content based on user interactions and preferences.\n\n## Getting Started\n\nTo start using the `facebook_app_events` package in your Flutter project, you'll need to:\n\n1. Add the package to your `pubspec.yaml` file.\n2. Configure your Facebook App ID.\n3. Initialize the package in your Flutter app.\n\nIn the next sections, we'll dive deeper into the setup process and explore how to implement various features of the `facebook_app_events` package in your RealFlutter app.",
    "platforms": [
      "android",
      "ios"
    ],
    "tags": [
      "facebook",
      "analytics",
      "events",
      "tracking",
      "social-media",
      "marketing"
    ],
    "name": "facebook_app_events",
    "shortDescription": "Flutter plugin for Facebook App Events, an app measurement solution that provides insight on app usage and user engagement in Facebook Analytics.",
    "similarPackages": [],
    "_createdAt": "2024-08-28T22:21:19Z",
    "_id": "Rx1Nho763d29lawKra1x0h"
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaQY8",
    "shortDescription": "Flutter library to load and cache network images. Can also be used with placeholder and error widgets.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGKG",
        "_type": "reference",
        "_key": "6bck7zt3"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-5ec92c106811c8b7b4faa4cc4f09f15047c11cc3-572x1174-png",
        "_type": "reference"
      }
    },
    "author": "baseflow.com",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1bY3",
        "_type": "reference",
        "_key": "eyg2ijls"
      }
    ],
    "tags": [
      "cache",
      "image",
      "network-image",
      "performance",
      "lazy-loading",
      "offline"
    ],
    "lastUpdate": "2024-08-12T18:30:00.000Z",
    "gallery": [
      {
        "_type": "image",
        "_key": "8a83c3346c92",
        "asset": {
          "_ref": "image-a28ed1e3e77d7d8175a34313b2827546ef9722e3-576x670-png",
          "_type": "reference"
        }
      }
    ],
    "description": "# Cached Network Image in Flutter: Efficient Image Loading and Caching\n\n## Introduction\n\nIn the world of mobile app development, efficient image loading and caching are crucial for providing a smooth user experience. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful package called `cached_network_image` that simplifies this process.\n\n## What is cached_network_image?\n\n`cached_network_image` is a Flutter package that provides a widget and a set of utilities for loading and caching network images. It offers several advantages over the standard `Image.network` widget:\n\n1. **Caching**: Images are automatically cached to the device's storage, reducing network requests for previously loaded images.\n2. **Placeholder support**: You can display a placeholder widget while the image is loading.\n3. **Error handling**: Custom widgets can be shown when image loading fails.\n4. **Progress indicators**: You can display loading progress for images.\n5. **Fade-in animation**: Smooth transition when images load.\n\n## Key Features\n\n- **Efficient caching**: Uses `flutter_cache_manager` for robust caching mechanisms.\n- **Customizable**: Offers various parameters to control image loading behavior.\n- **Memory efficient**: Automatically clears old cached files to prevent excessive storage usage.\n- **Cross-platform**: Works on both iOS and Android platforms.\n\n## When to Use cached_network_image\n\nConsider using this package when:\n- Your app heavily relies on loading images from the network.\n- You want to improve performance by reducing redundant network requests.\n- You need to handle various image loading scenarios (loading, error, success) elegantly.\n\nIn the next sections, we'll dive into a tutorial on how to use `cached_network_image` and explore a comprehensive example demonstrating its features.",
    "example": "import 'package:flutter/material.dart';\nimport 'package:cached_network_image/cached_network_image.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Cached Network Image Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ImageGalleryScreen(),\n    );\n  }\n}\n\nclass ImageGalleryScreen extends StatelessWidget {\n  // Step 1: Define a list of image URLs\n  final List<String> imageUrls = [\n    'https://picsum.photos/id/1/200/300',\n    'https://picsum.photos/id/10/200/300',\n    'https://picsum.photos/id/100/200/300',\n    'https://invalid-url.com/image.jpg', // Invalid URL to demonstrate error handling\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Image Gallery')),\n      // Step 2: Create a ListView to display multiple images\n      body: ListView.builder(\n        itemCount: imageUrls.length,\n        itemBuilder: (context, index) {\n          return Card(\n            margin: EdgeInsets.all(8.0),\n            child: Column(\n              children: [\n                // Step 3: Use CachedNetworkImage widget\n                CachedNetworkImage(\n                  imageUrl: imageUrls[index],\n                  // Step 4: Customize the image display\n                  imageBuilder: (context, imageProvider) => Container(\n                    height: 200,\n                    decoration: BoxDecoration(\n                      image: DecorationImage(\n                        image: imageProvider,\n                        fit: BoxFit.cover,\n                      ),\n                    ),\n                  ),\n                  // Step 5: Add a placeholder for loading state\n                  placeholder: (context, url) => Container(\n                    height: 200,\n                    child: Center(child: CircularProgressIndicator()),\n                  ),\n                  // Step 6: Handle loading errors\n                  errorWidget: (context, url, error) => Container(\n                    height: 200,\n                    color: Colors.grey[300],\n                    child: Center(\n                      child: Icon(Icons.error, color: Colors.red, size: 50),\n                    ),\n                  ),\n                  // Step 7: Add fade-in animation\n                  fadeInDuration: Duration(milliseconds: 500),\n                  // Step 8: Enable memory caching\n                  memCacheWidth: 200,\n                  memCacheHeight: 300,\n                ),\n                // Step 9: Add image information\n                Padding(\n                  padding: EdgeInsets.all(8.0),\n                  child: Text('Image ${index + 1}'),\n                ),\n              ],\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a list of image cards.\n// 2. For each image URL:\n//    a. CachedNetworkImage attempts to load the image.\n//    b. While loading, a circular progress indicator is shown.\n//    c. If the image loads successfully, it fades in with a smooth animation.\n//    d. If there's an error (e.g., invalid URL), an error icon is displayed.\n// 3. Images are cached for faster loading on subsequent app launches.\n// 4. Memory caching is enabled to optimize performance for scrolling.\n\n// Key Features Demonstrated:\n// - Basic image loading and display\n// - Placeholder widget during loading\n// - Error handling for failed image loads\n// - Image fade-in animation\n// - Memory caching for performance optimization\n// - Flexible layout using ListView.builder for efficient scrolling",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [],
    "_id": "V06bsD4sX3T8NTHrBPa6y0",
    "tutorial": "# Tutorial: Using cached_network_image in Flutter\n\nThis tutorial will guide you through the process of implementing `cached_network_image` in your Flutter project.\n\n## Step 1: Add the dependency\n\nAdd the following to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  cached_network_image: ^3.2.3\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:cached_network_image/cached_network_image.dart';\n```\n\n## Step 3: Basic Usage\n\nReplace your `Image.network` widgets with `CachedNetworkImage`:\n\n```dart\nCachedNetworkImage(\n  imageUrl: \"http://via.placeholder.com/350x150\",\n  placeholder: (context, url) => CircularProgressIndicator(),\n  errorWidget: (context, url, error) => Icon(Icons.error),\n),\n```\n\n## Step 4: Advanced Usage\n\nExplore more features:\n\n```dart\nCachedNetworkImage(\n  imageUrl: \"http://via.placeholder.com/350x150\",\n  imageBuilder: (context, imageProvider) => Container(\n    decoration: BoxDecoration(\n      image: DecorationImage(\n        image: imageProvider,\n        fit: BoxFit.cover,\n      ),\n    ),\n  ),\n  placeholder: (context, url) => CircularProgressIndicator(),\n  errorWidget: (context, url, error) => Icon(Icons.error),\n  fadeOutDuration: Duration(milliseconds: 1000),\n  fadeInDuration: Duration(milliseconds: 1000),\n),\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure you have internet permission in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n\n### iOS\n\nFor iOS, no additional configuration is needed for basic functionality. However, if you're using `https` URLs, you might need to configure App Transport Security (ATS) in your `Info.plist`:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSAllowsArbitraryLoads</key>\n  <true/>\n</dict>\n```\n\n## Additional Tips\n\n1. **Caching Strategy**: You can customize the caching strategy using the `cacheManager` parameter.\n2. **Memory Cache**: Control memory caching with `useOldImageOnUrlChange` and `memCacheWidth`/`memCacheHeight`.\n3. **Error Handling**: Implement retry logic or fallback images in the `errorWidget`.\n4. **Placeholder Optimization**: Use lightweight placeholders to improve initial load times.\n\nBy following this tutorial, you'll be able to efficiently implement image caching in your Flutter application, enhancing both performance and user experience.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:42Z",
    "pubPoint": 160,
    "_type": "package",
    "likesCount": 6116,
    "_createdAt": "2024-08-28T22:15:25Z",
    "name": "cached_network_image",
    "slug": {
      "current": "cached_network_image",
      "_type": "slug"
    }
  },
  {
    "_id": "V06bsD4sX3T8NTHrBPa7E4",
    "gallery": [
      {
        "_type": "image",
        "_key": "7f38785f3d9e",
        "asset": {
          "_ref": "image-517bde1ff3d94871a92df4bef40ec57ff92395f7-554x778-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "22305f3af950",
        "asset": {
          "_ref": "image-7055502dd2f86719153ec4165711ccc9b7b775cc-556x226-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "39847d67a1dc",
        "asset": {
          "_ref": "image-608f9a43db5bb3baeab4429a11e1650caaea84ca-568x536-png",
          "_type": "reference"
        }
      }
    ],
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "web",
      "windows"
    ],
    "likesCount": 5226,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-5bd10432b39c1362a190242109fc48f3b9a432a9-646x662-png",
        "_type": "reference"
      }
    },
    "name": "permission_handler",
    "author": "baseflow.com",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWze",
        "_type": "reference",
        "_key": "qe2d1wdg"
      }
    ],
    "tags": [
      "permissions",
      "android",
      "ios",
      "runtime-permissions",
      "security"
    ],
    "tutorialIncluded": true,
    "slug": {
      "current": "permission_handler",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaQbK",
    "description": "# Permission Handler in Flutter: Simplifying Runtime Permissions\n\n## Introduction\n\nIn the world of mobile app development, handling runtime permissions is crucial for accessing device features and user data. Flutter, being a cross-platform framework, needs a robust solution to manage permissions across both Android and iOS. This is where the `permission_handler` package comes to the rescue.\n\n## What is Permission Handler?\n\nThe `permission_handler` package is a Flutter plugin that provides a cross-platform (iOS, Android) API to request and check permissions. It simplifies the process of requesting permissions at runtime, checking their status, and handling user responses.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly on both Android and iOS.\n2. **Wide range of permissions**: Supports various permission types including camera, location, microphone, storage, and more.\n3. **Easy-to-use API**: Provides a simple and intuitive API for requesting and checking permissions.\n4. **Status checking**: Allows checking the current status of permissions.\n5. **Opening app settings**: Provides methods to open the app settings page for manual permission management.\n\n## Why Use Permission Handler?\n\n1. **Simplicity**: Reduces boilerplate code and simplifies permission management.\n2. **Consistency**: Provides a consistent API across platforms, reducing platform-specific code.\n3. **Flexibility**: Allows fine-grained control over permission requests and handling.\n4. **Maintenance**: Regularly updated to support the latest iOS and Android versions.\n\nIn the following sections, we'll dive into how to use the `permission_handler` package in your Flutter projects, including platform-specific configurations and a practical example.",
    "shortDescription": "Permission plugin for Flutter. This plugin provides a cross-platform (iOS, Android) API to request and check permissions.",
    "example": "```\n// Don't forget to add android or iOS specific permissions in manifest or Info.plist\n//\n// eg in Android:\n// Refer tutorial for details\n//\n// <uses-permission android:name=\"android.permission.CAMERA\" />\n// <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n// <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n\nimport 'package:flutter/material.dart';\nimport 'package:permission_handler/permission_handler.dart';\n\nvoid main() {\nrunApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\nconst RealFlutter({Key? key}) : super(key: key);\n\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntitle: 'Permission Handler Demo',\ntheme: ThemeData(primarySwatch: Colors.blue),\nhome: const PermissionHandlerDemo(),\n);\n}\n}\n\nclass PermissionHandlerDemo extends StatefulWidget {\nconst PermissionHandlerDemo({Key? key}) : super(key: key);\n\n@override\n_PermissionHandlerDemoState createState() => _PermissionHandlerDemoState();\n}\n\nclass _PermissionHandlerDemoState extends State<PermissionHandlerDemo> {\nMap<Permission, PermissionStatus> _permissionStatuses = {};\n\n@override\nvoid initState() {\nsuper.initState();\n_checkPermissions();\n}\n\n// Step 1: Check initial permission statuses\nFuture<void> _checkPermissions() async {\nMap<Permission, PermissionStatus> statuses = await [\nPermission.camera,\nPermission.microphone,\nPermission.storage,\nPermission.location,\n].request();\n\nsetState(() {\n_permissionStatuses = statuses;\n});\n}\n\n// Step 2: Request a specific permission\nFuture<void> _requestPermission(Permission permission) async {\nPermissionStatus status = await permission.request();\n\nsetState(() {\n_permissionStatuses[permission] = status;\n});\n}\n\n// Step 3: Open app settings\nFuture<void> _openAppSettings() async {\nawait openAppSettings();\n}\n\n// Step 4: Build UI for displaying and managing permissions\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Permission Handler Demo')),\nbody: ListView(\nchildren: [\n_buildPermissionTile(Permission.camera, 'Camera'),\n_buildPermissionTile(Permission.microphone, 'Microphone'),\n_buildPermissionTile(Permission.storage, 'Storage'),\n_buildPermissionTile(Permission.location, 'Location'),\nElevatedButton(\nonPressed: _openAppSettings,\nchild: const Text('Open App Settings'),\n),\n],\n),\n);\n}\n\n// Step 5: Helper method to build permission list tiles\nWidget _buildPermissionTile(Permission permission, String title) {\nreturn ListTile(\ntitle: Text(title),\nsubtitle: Text(_getPermissionStatus(permission)),\ntrailing: ElevatedButton(\nonPressed: () => _requestPermission(permission),\nchild: const Text('Request'),\n),\n);\n}\n\n// Step 6: Helper method to get readable permission status\nString _getPermissionStatus(Permission permission) {\nreturn _permissionStatuses[permission]?.toString() ?? 'Unknown';\n}\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. The PermissionHandlerDemo widget is created as the home screen.\n// 3. In initState, _checkPermissions is called to get initial permission statuses.\n// 4. The UI is built, displaying a list of permissions with their current statuses.\n// 5. Users can request individual permissions by tapping the 'Request' button.\n// 6. The _requestPermission method is called, which updates the permission status.\n// 7. Users can also open the app settings to manage permissions manually.\n// 8. The UI updates reactively as permission statuses change.\n\n// This example demonstrates:\n// - Checking multiple permission statuses\n// - Requesting individual permissions\n// - Displaying permission statuses in a user-friendly manner\n// - Providing an option to open app settings\n// - Reactive UI updates based on permission changes\n```",
    "lastUpdate": "2024-03-26T18:30:00.000Z",
    "similarPackages": [],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "apbkkzi9",
        "_ref": "Rx1Nho763d29lawKra1K9L"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "lu13xzts"
      }
    ],
    "_createdAt": "2024-08-28T22:15:27Z",
    "tutorial": "# Permission Handler: Tutorial\n\n## Installation\n\nTo use the `permission_handler` package in your Flutter project, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  permission_handler: ^10.2.0\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Platform-specific Configuration\n\n### Android Configuration\n\n1. Open the `android/app/build.gradle` file and ensure the `compileSdkVersion` is 33 or higher:\n\n```gradle\nandroid {\n    compileSdkVersion 33\n    ...\n}\n```\n\n2. In your `android/app/src/main/AndroidManifest.xml` file, add the permissions you need:\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.app\">\n    \n    <!-- Add the permissions you need -->\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    \n    <application\n        ...\n    </application>\n</manifest>\n```\n\n### iOS Configuration\n\n1. Open your `ios/Runner/Info.plist` file and add the permissions you need:\n\n```xml\n<dict>\n    ...\n    <key>NSCameraUsageDescription</key>\n    <string>This app needs access to the camera to take photos.</string>\n    <key>NSPhotoLibraryUsageDescription</key>\n    <string>This app needs access to photos for uploading images.</string>\n    ...\n</dict>\n```\n\n## Basic Usage\n\nHere's a basic example of how to use the `permission_handler` package:\n\n```dart\nimport 'package:permission_handler/permission_handler.dart';\n\nFuture<void> requestCameraPermission() async {\n  PermissionStatus status = await Permission.camera.request();\n  \n  if (status.isGranted) {\n    // Permission granted, proceed with camera operations\n    print('Camera permission granted');\n  } else if (status.isDenied) {\n    // Permission denied, handle accordingly\n    print('Camera permission denied');\n  } else if (status.isPermanentlyDenied) {\n    // Permission permanently denied, open app settings\n    openAppSettings();\n  }\n}\n```\n\nThis example demonstrates how to request camera permission and handle different permission statuses.\n\nIn the next section, we'll create a more comprehensive example that demonstrates various features of the `permission_handler` package.",
    "_updatedAt": "2024-09-06T04:11:43Z"
  },
  {
    "pubPoint": 160,
    "name": "font_awesome_flutter",
    "gallery": [
      {
        "_type": "image",
        "_key": "add594fc543e",
        "asset": {
          "_ref": "image-9be7db6f84c46b25faa9ef42432c3d64dfab2746-546x1094-png",
          "_type": "reference"
        }
      }
    ],
    "slug": {
      "current": "font_awesome_flutter",
      "_type": "slug"
    },
    "_type": "package",
    "shortDescription": "The Font Awesome Icon pack available as Flutter Icons. Provides 2000 additional icons to use in your apps.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:font_awesome_flutter/font_awesome_flutter.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Font Awesome Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const FontAwesomeDemo(),\n    );\n  }\n}\n\nclass FontAwesomeDemo extends StatefulWidget {\n  const FontAwesomeDemo({Key? key}) : super(key: key);\n\n  @override\n  _FontAwesomeDemoState createState() => _FontAwesomeDemoState();\n}\n\nclass _FontAwesomeDemoState extends State<FontAwesomeDemo>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    )..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Font Awesome Flutter Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 1: Basic Icon Usage\n            const FaIcon(\n              FontAwesomeIcons.house,\n              color: Colors.blue,\n              size: 50,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 2: Customized Icon\n            const FaIcon(\n              FontAwesomeIcons.user,\n              color: Colors.green,\n              size: 40,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 3: Icon Stack\n            SizedBox(\n              width: 60,\n              height: 60,\n              child: Stack(\n                children: const [\n                  FaIcon(FontAwesomeIcons.square, size: 60, color: Colors.orange),\n                  Positioned(\n                    right: 0,\n                    bottom: 0,\n                    child: FaIcon(FontAwesomeIcons.bell, size: 30, color: Colors.red),\n                  ),\n                ],\n              ),\n            ),\n            const SizedBox(height: 20),\n\n            // Step 4: Animated Icon\n            AnimatedBuilder(\n              animation: _controller,\n              builder: (_, child) {\n                return Transform.rotate(\n                  angle: _controller.value * 2 * 3.14159,\n                  child: const FaIcon(\n                    FontAwesomeIcons.spinner,\n                    color: Colors.purple,\n                    size: 50,\n                  ),\n                );\n              },\n            ),\n            const SizedBox(height: 20),\n\n            // Step 5: Using Icons in Buttons\n            ElevatedButton.icon(\n              icon: const FaIcon(FontAwesomeIcons.thumbsUp),\n              label: const Text('Like'),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen (FontAwesomeDemo) is displayed, showing various examples of Font Awesome icons.\n// 3. The screen demonstrates:\n//    a. Basic icon usage with customization (color and size)\n//    b. Icon stacking to create composite icons\n//    c. Animated icon using AnimationController\n//    d. Icons used within buttons\n// 4. The animated icon (spinner) continuously rotates due to the AnimationController.\n// 5. User can interact with the button, though no specific action is implemented in this demo.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 4471,
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbNIq",
        "_type": "reference",
        "_key": "x9bp0dm6"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-44bbf77d6118e8ea578cba61b4b1df45a9d3ccfd-494x496-png",
        "_type": "reference"
      }
    },
    "lastUpdate": "2024-01-26T18:30:00.000Z",
    "tutorial": "## 2. Tutorial\n\nIn this section, we'll walk through the process of setting up and using the `font_awesome_flutter` package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\n1. Open your `pubspec.yaml` file in your Flutter project.\n2. Add the following dependency under the `dependencies` section:\n\n   ```yaml\n   dependencies:\n     font_awesome_flutter: ^10.1.0\n   ```\n\n3. Run the following command in your terminal:\n\n   ```\n   flutter pub get\n   ```\n\n### Step 2: Importing the Package\n\nIn your Dart file where you want to use Font Awesome icons, add the following import statement:\n\n```dart\nimport 'package:font_awesome_flutter/font_awesome_flutter.dart';\n```\n\n### Step 3: Basic Usage\n\nTo use a Font Awesome icon in your Flutter app, simply use the `FaIcon` widget:\n\n```dart\nFaIcon(FontAwesomeIcons.house)\n```\n\nYou can customize the icon by passing additional parameters:\n\n```dart\nFaIcon(\n  FontAwesomeIcons.house,\n  color: Colors.blue,\n  size: 24.0,\n)\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n- No additional setup is required for iOS.\n- Ensure that you have the latest version of Xcode installed for optimal performance.\n\n#### Android\n- No specific setup is needed for Android.\n- Make sure your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher.\n\n#### Web\n- For web projects, add the following script tag to your `web/index.html` file:\n\n  ```html\n  <script src=\"https://kit.fontawesome.com/your-kit-code.js\" crossorigin=\"anonymous\"></script>\n  ```\n\n  Replace `your-kit-code` with your actual Font Awesome Kit code.\n\n### Advanced Usage\n\n1. **Duotone Icons**: Use the `FaDuotoneIcon` widget for duotone icons (Pro feature):\n\n   ```dart\n   FaDuotoneIcon(\n     FontAwesomeIcons.duotone.house,\n     primaryColor: Colors.blue,\n     secondaryColor: Colors.lightBlue,\n   )\n   ```\n\n2. **Icon Stacks**: Create composite icons using `IconStack`:\n\n   ```dart\n   IconStack(\n     children: [\n       FaIcon(FontAwesomeIcons.square, size: 50),\n       FaIcon(FontAwesomeIcons.heart, size: 25, color: Colors.red),\n     ],\n   )\n   ```\n\n3. **Animated Icons**: Combine with Flutter's animation classes for dynamic icons:\n\n   ```dart\n   AnimatedBuilder(\n     animation: _controller,\n     builder: (context, child) {\n       return Transform.rotate(\n         angle: _controller.value * 2.0 * pi,\n         child: FaIcon(FontAwesomeIcons.spinner),\n       );\n     },\n   )\n   ```\n\nBy following this tutorial, you should now have a good understanding of how to integrate and use the `font_awesome_flutter` package in your Flutter projects across different platforms.",
    "_updatedAt": "2024-09-06T04:11:44Z",
    "description": "# Font Awesome Flutter Package: A Comprehensive Guide\n\n## 1. Description\n\nThe `font_awesome_flutter` package is a powerful tool for Flutter developers who want to enhance their applications with a wide variety of scalable vector icons. This package brings the popular Font Awesome icon set to Flutter, providing easy access to over 1,600 icons that can be customized in size, color, and style.\n\n### Key Features:\n\n1. **Extensive Icon Library**: Access to the full Font Awesome icon set, including regular, solid, and brand icons.\n2. **Easy Integration**: Simple to add to your Flutter project and use within your widgets.\n3. **Customization**: Easily adjust icon size, color, and other properties to match your app's design.\n4. **Regular Updates**: The package is frequently updated to include the latest icons from Font Awesome.\n5. **Performance**: Uses Flutter's built-in IconData class for efficient rendering.\n\n### Why Use Font Awesome Flutter?\n\n- **Consistency**: Maintain a consistent look across different platforms and devices.\n- **Flexibility**: Choose from a vast array of icons for various use cases.\n- **Scalability**: Icons are vector-based, ensuring crisp rendering at any size.\n- **Familiarity**: Leverage the widely recognized Font Awesome icon set in your Flutter apps.\n\nIn the following sections, we'll dive into how to set up and use the `font_awesome_flutter` package in your Flutter projects, along with a comprehensive example showcasing its features.",
    "tags": [
      "icons",
      "font-awesome",
      "ui",
      "customization",
      "vector-icons"
    ],
    "_createdAt": "2024-08-28T22:15:42Z",
    "_id": "V06bsD4sX3T8NTHrBPa7pY",
    "tutorialIncluded": true,
    "author": "fluttercommunity.dev",
    "_rev": "eaCZ7mIhmiYZX5KGqJmP2a",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVh5",
        "_type": "reference",
        "_key": "2wq0z9l4"
      }
    ]
  },
  {
    "shortDescription": "Flutter plugin for Google Sign-In, a secure authentication system for signing in with a Google account.",
    "similarPackages": [
      {
        "_key": "kjah2yev",
        "_ref": "uQRNMiDfrp20RZ8Id8CYnX",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_key": "k830aaq4",
        "_ref": "4gmBGwifQuSypgRenUbWma",
        "_type": "reference"
      }
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "_id": "V06bsD4sX3T8NTHrBPaLDY",
    "tutorial": "# Google Sign-In Flutter Package: Tutorial\n\nThis tutorial will guide you through the process of integrating Google Sign-In into your Flutter application using the `google_sign_in` package.\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  google_sign_in: ^6.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Configure Platform-Specific Settings\n\n### Android Configuration\n\n1. In your `android/app/build.gradle` file, ensure you have the following:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n    }\n}\n```\n\n2. In your `android/app/src/main/AndroidManifest.xml` file, add the following permissions:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n\n3. Configure your OAuth client:\n   - Go to the [Google Cloud Console](https://console.cloud.google.com/)\n   - Create a new project or select an existing one\n   - Enable the Google Sign-In API\n   - Create OAuth 2.0 client credentials\n   - Download the `google-services.json` file and place it in `android/app/`\n\n### iOS Configuration\n\n1. In your `ios/Runner/Info.plist` file, add the following:\n\n```xml\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>com.googleusercontent.apps.YOUR-CLIENT-ID</string>\n        </array>\n    </dict>\n</array>\n```\n\nReplace `YOUR-CLIENT-ID` with your actual Google client ID.\n\n2. Configure your OAuth client:\n   - Go to the [Google Cloud Console](https://console.cloud.google.com/)\n   - Create a new project or select an existing one\n   - Enable the Google Sign-In API\n   - Create OAuth 2.0 client credentials\n   - Download the `GoogleService-Info.plist` file and add it to your Xcode project\n\n## Step 3: Implement Google Sign-In\n\nNow that we have set up the package and configured our platforms, let's implement the Google Sign-In functionality in our Flutter app. We'll create a `RealFlutter` class to handle the sign-in process.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:google_sign_in/google_sign_in.dart';\n\nclass RealFlutter {\n  final GoogleSignIn _googleSignIn = GoogleSignIn(scopes: ['email']);\n\n  Future<void> handleSignIn(BuildContext context) async {\n    try {\n      final GoogleSignInAccount? account = await _googleSignIn.signIn();\n      if (account != null) {\n        // User signed in successfully\n        print(\"Signed in: ${account.displayName}\");\n        // You can now use the account information or access tokens\n      }\n    } catch (error) {\n      print(\"Error signing in: $error\");\n      // Handle sign-in errors\n    }\n  }\n\n  Future<void> handleSignOut() async {\n    try {\n      await _googleSignIn.signOut();\n      print(\"User signed out\");\n    } catch (error) {\n      print(\"Error signing out: $error\");\n    }\n  }\n}\n```\n\nThis `RealFlutter` class provides two main methods:\n- `handleSignIn`: Initiates the Google Sign-In process\n- `handleSignOut`: Signs out the current user\n\nYou can now use these methods in your widgets to implement Google Sign-In functionality in your app.\n\nRemember to handle the UI accordingly, showing loading indicators during the sign-in process and updating the UI based on the authentication state.",
    "_updatedAt": "2024-09-06T04:11:45Z",
    "author": "flutter.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaQeW",
    "example": "import 'package:flutter/material.dart';\nimport 'package:google_sign_in/google_sign_in.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Google Sign-In Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: SignInDemo(),\n    );\n  }\n}\n\nclass SignInDemo extends StatefulWidget {\n  @override\n  _SignInDemoState createState() => _SignInDemoState();\n}\n\nclass _SignInDemoState extends State<SignInDemo> {\n  final RealFlutter _realFlutter = RealFlutter();\n  bool _isSignedIn = false;\n  String _userInfo = '';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Check if user is already signed in\n    _checkCurrentUser();\n  }\n\n  // Step 2: Check current user method\n  Future<void> _checkCurrentUser() async {\n    bool isSignedIn = await _realFlutter.isSignedIn();\n    if (isSignedIn) {\n      String userInfo = await _realFlutter.getUserInfo();\n      setState(() {\n        _isSignedIn = true;\n        _userInfo = userInfo;\n      });\n    }\n  }\n\n  // Step 3: Handle sign in\n  Future<void> _handleSignIn() async {\n    try {\n      await _realFlutter.handleSignIn(context);\n      String userInfo = await _realFlutter.getUserInfo();\n      setState(() {\n        _isSignedIn = true;\n        _userInfo = userInfo;\n      });\n    } catch (error) {\n      print(\"Error signing in: $error\");\n      // Handle sign-in errors (e.g., show a snackbar)\n    }\n  }\n\n  // Step 4: Handle sign out\n  Future<void> _handleSignOut() async {\n    await _realFlutter.handleSignOut();\n    setState(() {\n      _isSignedIn = false;\n      _userInfo = '';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Google Sign-In Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            if (!_isSignedIn)\n              ElevatedButton(\n                onPressed: _handleSignIn,\n                child: Text('Sign in with Google'),\n              )\n            else\n              Column(\n                children: [\n                  Text('Signed in successfully'),\n                  Text(_userInfo),\n                  ElevatedButton(\n                    onPressed: _handleSignOut,\n                    child: Text('Sign out'),\n                  ),\n                ],\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass RealFlutter {\n  final GoogleSignIn _googleSignIn = GoogleSignIn(scopes: ['email']);\n\n  // Step 5: Check if user is signed in\n  Future<bool> isSignedIn() async {\n    return await _googleSignIn.isSignedIn();\n  }\n\n  // Step 6: Get user info\n  Future<String> getUserInfo() async {\n    final GoogleSignInAccount? account = await _googleSignIn.signInSilently();\n    if (account != null) {\n      return \"Name: ${account.displayName}\\nEmail: ${account.email}\";\n    }\n    return '';\n  }\n\n  // Step 7: Handle sign in\n  Future<void> handleSignIn(BuildContext context) async {\n    try {\n      final GoogleSignInAccount? account = await _googleSignIn.signIn();\n      if (account != null) {\n        // User signed in successfully\n        print(\"Signed in: ${account.displayName}\");\n        // You can now use the account information or access tokens\n      }\n    } catch (error) {\n      print(\"Error signing in: $error\");\n      // Handle sign-in errors\n      rethrow; // Rethrow the error to be caught in the UI\n    }\n  }\n\n  // Step 8: Handle sign out\n  Future<void> handleSignOut() async {\n    try {\n      await _googleSignIn.signOut();\n      print(\"User signed out\");\n    } catch (error) {\n      print(\"Error signing out: $error\");\n      // Handle sign-out errors\n    }\n  }\n}\n\n// Application Flow:\n// 1. The app starts and checks if the user is already signed in (_checkCurrentUser).\n// 2. If signed in, it displays the user info and a sign-out button.\n// 3. If not signed in, it shows a \"Sign in with Google\" button.\n// 4. When the user taps \"Sign in with Google\", it triggers the sign-in process (_handleSignIn).\n// 5. After successful sign-in, the UI updates to show user info and a sign-out option.\n// 6. The user can sign out by tapping the \"Sign out\" button (_handleSignOut).\n// 7. After signing out, the UI reverts to showing the sign-in button.\n\n// The RealFlutter class encapsulates all Google Sign-In functionality:\n// - isSignedIn: Checks if a user is currently signed in\n// - getUserInfo: Retrieves the signed-in user's information\n// - handleSignIn: Manages the sign-in process\n// - handleSignOut: Manages the sign-out process\n\n// This example demonstrates a complete flow of Google Sign-In integration,\n// including checking the current user, signing in, displaying user info,\n// and signing out, all while properly handling the UI state.",
    "dependentPackages": [],
    "lastUpdate": "2023-12-12T18:30:00.000Z",
    "slug": {
      "current": "google_sign_in",
      "_type": "slug"
    },
    "pubPoint": 160,
    "description": "# Google Sign-In Flutter Package: Description\n\nThe `google_sign_in` package is a powerful tool for integrating Google Sign-In functionality into your Flutter applications. This package provides a seamless way to authenticate users with their Google accounts, allowing them to sign in to your app using their existing credentials.\n\n## Key Features\n\n1. **Easy Integration**: The package offers a simple API that makes it easy to add Google Sign-In to your Flutter app with minimal code.\n\n2. **Cross-Platform Support**: It works on both Android and iOS platforms, ensuring a consistent user experience across devices.\n\n3. **Access to Google Services**: Once authenticated, you can access various Google services and APIs on behalf of the user, such as Google Drive, Google Calendar, or Google Photos.\n\n4. **Customizable UI**: While the package uses the standard Google Sign-In button, you have the flexibility to customize the appearance to match your app's design.\n\n5. **Offline Access**: The package supports requesting offline access tokens, allowing your app to access Google services even when the user is not actively signed in.\n\n6. **Account Selection**: On devices with multiple Google accounts, users can choose which account to use for signing in.\n\n7. **Silent Sign-In**: The package provides methods for silent sign-in, which can automatically sign in a user without requiring interaction if they've previously authorized your app.\n\n## Use Cases\n\n- Social login for your app\n- Accessing Google APIs (e.g., Google Drive integration)\n- Personalizing user experience based on Google account information\n- Syncing app data with Google services\n\nBy leveraging the `google_sign_in` package, you can enhance your Flutter app's authentication process and provide a smooth, familiar sign-in experience for your users.",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "tags": [
      "authentication",
      "google-sign-in",
      "oauth",
      "social-login",
      "identity"
    ],
    "name": "google_sign_in",
    "_type": "package",
    "likesCount": 3082,
    "_createdAt": "2024-08-28T22:15:55Z"
  },
  {
    "description": "# Flutter Secure Storage: Secure Your App's Sensitive Data\n\n## Introduction\n\nIn today's mobile app landscape, securing sensitive user data is paramount. Enter `flutter_secure_storage`, a powerful Flutter package that provides a secure and encrypted storage solution for your app's critical information. This blog post will dive deep into the package, exploring its features, implementation, and best practices.\n\n## What is flutter_secure_storage?\n\n`flutter_secure_storage` is a Flutter plugin that allows you to securely store key-value pairs on both Android and iOS platforms. It leverages platform-specific security features to ensure that sensitive data, such as API keys, user tokens, or personal information, remains protected from unauthorized access.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly on both Android and iOS.\n2. **Encrypted storage**: Utilizes platform-specific encryption mechanisms for data protection.\n3. **Simple API**: Provides an easy-to-use interface for storing and retrieving data.\n4. **Customizable options**: Offers platform-specific configuration options for enhanced security.\n\n## Why Use flutter_secure_storage?\n\n1. **Enhanced security**: Protects sensitive data from unauthorized access and potential breaches.\n2. **Compliance**: Helps meet security requirements for apps handling personal or financial information.\n3. **User trust**: Demonstrates a commitment to protecting user data, building trust with your audience.\n4. **Simplified development**: Abstracts away complex encryption processes, allowing developers to focus on app functionality.\n\nIn the following sections, we'll explore how to implement `flutter_secure_storage` in your Flutter projects and showcase its features through practical examples.",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CTzf",
        "_type": "reference",
        "_key": "twufdz4x"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Secure Storage Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const SecureStorageDemo(),\n    );\n  }\n}\n\nclass SecureStorageDemo extends StatefulWidget {\n  const SecureStorageDemo({Key? key}) : super(key: key);\n\n  @override\n  _SecureStorageDemoState createState() => _SecureStorageDemoState();\n}\n\nclass _SecureStorageDemoState extends State<SecureStorageDemo> {\n  // Step 1: Create an instance of FlutterSecureStorage\n  final storage = FlutterSecureStorage();\n\n  // Step 2: Define controllers for input fields\n  final TextEditingController _keyController = TextEditingController();\n  final TextEditingController _valueController = TextEditingController();\n\n  // Step 3: Define a variable to store retrieved values\n  String? _retrievedValue;\n\n  // Step 4: Method to write data to secure storage\n  Future<void> _writeData() async {\n    await storage.write(key: _keyController.text, value: _valueController.text);\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Data saved securely')),\n    );\n  }\n\n  // Step 5: Method to read data from secure storage\n  Future<void> _readData() async {\n    String? value = await storage.read(key: _keyController.text);\n    setState(() {\n      _retrievedValue = value;\n    });\n  }\n\n  // Step 6: Method to delete data from secure storage\n  Future<void> _deleteData() async {\n    await storage.delete(key: _keyController.text);\n    setState(() {\n      _retrievedValue = null;\n    });\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Data deleted')),\n    );\n  }\n\n  // Step 7: Method to check if a key exists in secure storage\n  Future<void> _checkKeyExists() async {\n    bool containsKey = await storage.containsKey(key: _keyController.text);\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text(containsKey ? 'Key exists' : 'Key does not exist')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Secure Storage Demo'),\n      ),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 8: Input fields for key and value\n            TextField(\n              controller: _keyController,\n              decoration: InputDecoration(labelText: 'Key'),\n            ),\n            TextField(\n              controller: _valueController,\n              decoration: InputDecoration(labelText: 'Value'),\n            ),\n            SizedBox(height: 16),\n            // Step 9: Buttons to trigger actions\n            ElevatedButton(\n              onPressed: _writeData,\n              child: Text('Save Data'),\n            ),\n            ElevatedButton(\n              onPressed: _readData,\n              child: Text('Read Data'),\n            ),\n            ElevatedButton(\n              onPressed: _deleteData,\n              child: Text('Delete Data'),\n            ),\n            ElevatedButton(\n              onPressed: _checkKeyExists,\n              child: Text('Check Key Exists'),\n            ),\n            SizedBox(height: 16),\n            // Step 10: Display retrieved value\n            Text('Retrieved Value: ${_retrievedValue ?? \"No data\"}'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow Explanation:\n// 1. The app starts by creating an instance of FlutterSecureStorage.\n// 2. Users can enter a key and value in the input fields.\n// 3. The \"Save Data\" button triggers _writeData(), which securely stores the key-value pair.\n// 4. The \"Read Data\" button calls _readData(), retrieving and displaying the value for the given key.\n// 5. The \"Delete Data\" button invokes _deleteData(), removing the key-value pair from secure storage.\n// 6. The \"Check Key Exists\" button uses _checkKeyExists() to verify if a key is present in the storage.\n// 7. The retrieved value is displayed at the bottom of the screen, updating in real-time as actions are performed.\n// 8. SnackBar notifications provide feedback on the success of operations.\n//\n// This example demonstrates the core functionality of flutter_secure_storage,\n// including writing, reading, deleting, and checking for the existence of secure data.\n// It provides a simple interface for users to interact with these features and\n// observe the results in real-time.\n```",
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:15:59Z",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RbAy",
    "_type": "package",
    "packageImage": null,
    "name": "flutter_secure_storage",
    "tutorial": "# Flutter Secure Storage: Implementation Tutorial\n\nThis tutorial will guide you through the process of integrating `flutter_secure_storage` into your Flutter project, covering installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd `flutter_secure_storage` to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_secure_storage: ^8.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n```\n\n## Step 3: Create an Instance\n\nCreate an instance of `FlutterSecureStorage`:\n\n```dart\nfinal storage = FlutterSecureStorage();\n```\n\n## Step 4: Basic Usage\n\n### Writing Data\n\nTo store a key-value pair:\n\n```dart\nawait storage.write(key: 'auth_token', value: 'your_secret_token');\n```\n\n### Reading Data\n\nTo retrieve a value:\n\n```dart\nString? value = await storage.read(key: 'auth_token');\n```\n\n### Deleting Data\n\nTo remove a key-value pair:\n\n```dart\nawait storage.delete(key: 'auth_token');\n```\n\n### Checking for Key Existence\n\nTo check if a key exists:\n\n```dart\nbool containsKey = await storage.containsKey(key: 'auth_token');\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nAndroid uses AES encryption to secure the data. You can customize the encryption by providing `AndroidOptions`:\n\n```dart\nfinal androidOptions = AndroidOptions(\n  encryptedSharedPreferences: true,\n  keyCipherAlgorithm: KeyCipherAlgorithm.RSA_ECB_OAEPwithSHA_256andMGF1Padding,\n  storageCipherAlgorithm: StorageCipherAlgorithm.AES_GCM_NoPadding,\n);\n\nfinal storage = FlutterSecureStorage(aOptions: androidOptions);\n```\n\n### iOS\n\niOS uses the Keychain to store data securely. You can customize the accessibility and synchronization options:\n\n```dart\nfinal iOSOptions = IOSOptions(\n  accessibility: KeychainAccessibility.first_unlock,\n  synchronizable: true,\n);\n\nfinal storage = FlutterSecureStorage(iOptions: iOSOptions);\n```\n\n### Web\n\nFor web support, you need to add the following to your `index.html` file:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"></script>\n```\n\nThen, you can use `WebOptions` to configure the storage:\n\n```dart\nfinal webOptions = WebOptions(\n  dbName: 'myapp_secure_storage',\n  publicKey: 'my_public_key',\n);\n\nfinal storage = FlutterSecureStorage(webOptions: webOptions);\n```\n\nBy following these steps and considering platform-specific options, you can effectively implement `flutter_secure_storage` in your Flutter project, ensuring that sensitive data remains protected across different platforms.",
    "_updatedAt": "2024-09-06T04:11:46Z",
    "author": "steenbakker.dev",
    "shortDescription": "Flutter Secure Storage provides API to store data in secure storage. Keychain is used in iOS, KeyStore based solution is used in Android.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "security",
      "storage",
      "encryption",
      "keychain",
      "keystore"
    ],
    "likesCount": 3730,
    "tutorialIncluded": true,
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGEj",
        "_type": "reference",
        "_key": "hqxyc9a1"
      }
    ],
    "lastUpdate": "2024-05-21T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPaMLA",
    "slug": {
      "current": "flutter_secure_storage",
      "_type": "slug"
    }
  },
  {
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:16:25Z",
    "name": "badges",
    "_id": "V06bsD4sX3T8NTHrBPaOl6",
    "tutorial": "# Tutorial: Implementing Badges in Your Flutter App\n\nIn this tutorial, we'll walk through the process of adding badges to your Flutter application using the Badges package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the badges package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  badges: ^3.1.1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the badges package:\n\n```dart\nimport 'package:badges/badges.dart' as badges;\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use a badge:\n\n```dart\nbadges.Badge(\n  badgeContent: Text('3'),\n  child: Icon(Icons.shopping_cart),\n)\n```\n\nThis will display a badge with the number '3' on top of a shopping cart icon.\n\n## Step 4: Customizing Your Badge\n\nYou can customize various aspects of your badge:\n\n```dart\nbadges.Badge(\n  badgeContent: Text('NEW'),\n  badgeStyle: badges.BadgeStyle(\n    shape: badges.BadgeShape.square,\n    badgeColor: Colors.blue,\n    padding: EdgeInsets.all(8),\n    borderRadius: BorderRadius.circular(4),\n    borderSide: BorderSide(color: Colors.white, width: 2),\n    elevation: 0,\n  ),\n  position: badges.BadgePosition.topEnd(top: -12, end: -20),\n  child: Text('Your Product'),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- iOS uses SF Symbols for many of its icons. When using badges with these icons, ensure that the badge size and position complement the icon design.\n- Consider using slightly rounded corners for badges to match the iOS aesthetic.\n\n```dart\nbadges.Badge(\n  badgeContent: Text('1'),\n  badgeStyle: badges.BadgeStyle(\n    badgeColor: Colors.red,\n    borderRadius: BorderRadius.circular(8),\n  ),\n  child: Icon(CupertinoIcons.bell_fill),\n)\n```\n\n### Android\n- Material Design guidelines suggest using small, circular badges for most notifications.\n- For longer text, consider using chips instead of badges.\n\n```dart\nbadges.Badge(\n  badgeContent: Text('99+'),\n  badgeStyle: badges.BadgeStyle(\n    badgeColor: Colors.red,\n    padding: EdgeInsets.all(4),\n  ),\n  child: Icon(Icons.notifications),\n)\n```\n\n### Web\n- Ensure that badges are easily clickable on both desktop and mobile web views.\n- Use appropriate contrast ratios for badge colors to maintain readability across different screens.\n\n```dart\nbadges.Badge(\n  badgeContent: Text('4'),\n  badgeStyle: badges.BadgeStyle(\n    badgeColor: Colors.green,\n    padding: EdgeInsets.all(8),\n  ),\n  position: badges.BadgePosition.topEnd(top: -10, end: -10),\n  child: ElevatedButton(\n    onPressed: () {},\n    child: Text('Inbox'),\n  ),\n)\n```\n\nBy following these guidelines, you can create badges that look and function great across all platforms while maintaining a consistent user experience.",
    "tutorialIncluded": true,
    "_type": "package",
    "description": "# Flutter Badges Package: Enhancing Your UI with Eye-Catching Notifications\n\nIn the world of mobile app development, capturing user attention and providing real-time information is crucial. The Flutter Badges package offers an elegant solution to this challenge, allowing developers to add visually appealing and informative badges to various UI elements.\n\n## What are Badges?\n\nBadges are small visual indicators that typically appear as overlays on icons, buttons, or other UI components. They serve to notify users about updates, unread messages, or any other important information that requires immediate attention.\n\n## Key Features of the Badges Package\n\n1. **Customizable Appearance**: Easily adjust the size, shape, color, and position of badges to match your app's design.\n2. **Flexible Positioning**: Place badges on any corner of the target widget or at custom positions.\n3. **Dynamic Content**: Display numbers, text, or even custom widgets as badge content.\n4. **Animated Badges**: Add smooth animations to make your badges more engaging.\n5. **Platform Adaptability**: The package works seamlessly across iOS, Android, and web platforms.\n\n## Why Use the Badges Package?\n\n- **Improved User Experience**: Badges provide instant visual feedback, helping users stay informed without cluttering the UI.\n- **Consistency**: Maintain a uniform look and feel for notifications across your app.\n- **Time-Saving**: Implement complex badge designs with minimal code, speeding up your development process.\n- **Versatility**: Use badges for various purposes, from simple counters to more complex status indicators.\n\nIn the following sections, we'll dive into a hands-on tutorial and explore a comprehensive example showcasing the full potential of the Badges package in Flutter.",
    "_updatedAt": "2024-09-06T04:11:47Z",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "xk73oi8l"
      }
    ],
    "tags": [
      "ui",
      "notification",
      "badge",
      "counter",
      "indicator"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-bb12a2792cd1358017fde70728d55661224a7e6f-500x500-webp",
        "_type": "reference"
      }
    },
    "lastUpdate": "2023-08-27T18:30:00.000Z",
    "pubPoint": 160,
    "author": "yako.io",
    "_rev": "AE3hjGWNkNE6aGQMMbaQhi",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CblP",
        "_type": "reference",
        "_key": "gc3phica"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:badges/badges.dart' as badges;\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Badges Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: BadgesDemoPage(),\n    );\n  }\n}\n\nclass BadgesDemoPage extends StatefulWidget {\n  @override\n  _BadgesDemoPageState createState() => _BadgesDemoPageState();\n}\n\nclass _BadgesDemoPageState extends State<BadgesDemoPage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter Badges Demo'),\n        // Step 1: Adding a badge to the AppBar\n        actions: [\n          badges.Badge(\n            position: badges.BadgePosition.topEnd(top: 0, end: 3),\n            badgeContent: Text('$_counter'),\n            child: IconButton(\n              icon: Icon(Icons.notifications),\n              onPressed: _incrementCounter,\n            ),\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Basic badge with a number\n            badges.Badge(\n              badgeContent: Text('3'),\n              child: Icon(Icons.shopping_cart, size: 30),\n            ),\n            SizedBox(height: 20),\n            \n            // Step 3: Customized badge with text\n            badges.Badge(\n              badgeContent: Text('NEW'),\n              badgeStyle: badges.BadgeStyle(\n                shape: badges.BadgeShape.square,\n                badgeColor: Colors.blue,\n                padding: EdgeInsets.all(8),\n                borderRadius: BorderRadius.circular(4),\n                borderSide: BorderSide(color: Colors.white, width: 2),\n                elevation: 0,\n              ),\n              position: badges.BadgePosition.topEnd(top: -12, end: -20),\n              child: Text('Your Product', style: TextStyle(fontSize: 20)),\n            ),\n            SizedBox(height: 20),\n            \n            // Step 4: Animated badge\n            badges.Badge(\n              badgeAnimation: badges.BadgeAnimation.rotation(\n                animationDuration: Duration(seconds: 1),\n                colorChangeAnimationDuration: Duration(seconds: 1),\n                loopAnimation: false,\n                curve: Curves.fastOutSlowIn,\n                colorChangeAnimationCurve: Curves.easeInCubic,\n              ),\n              badgeContent: Text('1'),\n              child: Icon(Icons.person, size: 30),\n            ),\n            SizedBox(height: 20),\n            \n            // Step 5: Badge with custom content\n            badges.Badge(\n              badgeContent: Icon(Icons.check, color: Colors.white, size: 10),\n              badgeStyle: badges.BadgeStyle(\n                shape: badges.BadgeShape.circle,\n                badgeColor: Colors.green,\n              ),\n              position: badges.BadgePosition.bottomEnd(),\n              child: Icon(Icons.settings, size: 30),\n            ),\n            SizedBox(height: 20),\n            \n            // Step 6: Badge on a button\n            badges.Badge(\n              badgeContent: Text('$_counter'),\n              position: badges.BadgePosition.topEnd(top: -10, end: -10),\n              child: ElevatedButton(\n                onPressed: _incrementCounter,\n                child: Text('Increment'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. BadgesDemoPage is set as the home page.\n// 3. In BadgesDemoPage, we demonstrate various uses of the badges package:\n//    - A badge on the AppBar's notification icon, showing the current count.\n//    - A basic badge on a shopping cart icon.\n//    - A customized badge with \"NEW\" text on a product label.\n//    - An animated badge on a person icon.\n//    - A badge with a custom icon (checkmark) on a settings icon.\n//    - A badge on a button that updates when the button is pressed.\n// 4. The _incrementCounter method is called when either the notification icon\n//    or the \"Increment\" button is pressed, updating the counter displayed on\n//    their respective badges.\n// 5. setState is used to rebuild the widget tree when the counter changes,\n//    ensuring that the badges are updated in real-time.\n\n// This example showcases the versatility of the badges package, demonstrating\n// various styles, animations, and use cases for badges in a Flutter application.\n```",
    "likesCount": 3411,
    "slug": {
      "current": "badges",
      "_type": "slug"
    },
    "shortDescription": "A package for creating badges. Badges can be used for an additional marker for any widget, e.g. show a number of items in a shopping cart.",
    "similarPackages": []
  },
  {
    "description": "# Flutter Rating Bar Package: Enhancing User Feedback in Your App\n\nIn the world of mobile applications, user feedback is crucial for both developers and other users. The flutter_rating_bar package offers a flexible and customizable solution for implementing rating functionality in Flutter apps, allowing users to provide visual feedback through a familiar star-rating interface.\n\n## What is a Rating Bar?\n\nA rating bar is a UI component that allows users to rate items or experiences on a scale, typically represented by stars. It's widely used in e-commerce apps, review systems, and anywhere user opinions need to be quantified visually.\n\n## Key Features of the flutter_rating_bar Package\n\n1. **Customizable Appearance**: Easily adjust the size, color, and style of rating icons to match your app's design.\n2. **Flexible Rating Scale**: Set custom minimum and maximum ratings, as well as the number of rating items.\n3. **Half Ratings**: Support for half ratings, allowing for more precise feedback.\n4. **Interactive and Read-Only Modes**: Use as an input method or to display existing ratings.\n5. **Gesture Recognition**: Responsive to user input through taps and swipes.\n6. **Animation Support**: Smooth animations for a more engaging user experience.\n7. **RTL Support**: Works well with right-to-left languages.\n\n## Why Use the flutter_rating_bar Package?\n\n- **Improved User Engagement**: Provide an intuitive way for users to leave feedback.\n- **Versatility**: Suitable for various use cases, from product reviews to app ratings.\n- **Time-Saving**: Implement complex rating functionality with minimal code.\n- **Consistency**: Maintain a uniform look and feel for rating systems across your app.\n- **Cross-Platform Compatibility**: Works seamlessly on iOS, Android, and web platforms.\n\nIn the following sections, we'll dive into a hands-on tutorial and explore a comprehensive example showcasing the full potential of the flutter_rating_bar package in Flutter.",
    "packageImage": null,
    "lastUpdate": "2022-05-17T18:30:00.000Z",
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaQku",
    "tutorial": "# Tutorial: Implementing Rating Bars in Your Flutter App\n\nIn this tutorial, we'll walk through the process of adding rating bars to your Flutter application using the flutter_rating_bar package. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the flutter_rating_bar package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_rating_bar: ^4.0.1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the flutter_rating_bar package:\n\n```dart\nimport 'package:flutter_rating_bar/flutter_rating_bar.dart';\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use a rating bar:\n\n```dart\nRatingBar.builder(\n  initialRating: 3,\n  minRating: 1,\n  direction: Axis.horizontal,\n  allowHalfRating: true,\n  itemCount: 5,\n  itemPadding: EdgeInsets.symmetric(horizontal: 4.0),\n  itemBuilder: (context, _) => Icon(\n    Icons.star,\n    color: Colors.amber,\n  ),\n  onRatingUpdate: (rating) {\n    print(rating);\n  },\n)\n```\n\nThis will display a rating bar with 5 stars, an initial rating of 3, and allow half ratings.\n\n## Step 4: Customizing Your Rating Bar\n\nYou can customize various aspects of your rating bar:\n\n```dart\nRatingBar(\n  ratingWidget: RatingWidget(\n    full: Icon(Icons.star, color: Colors.amber),\n    half: Icon(Icons.star_half, color: Colors.amber),\n    empty: Icon(Icons.star_border, color: Colors.amber),\n  ),\n  onRatingUpdate: (rating) {\n    print(rating);\n  },\n  allowHalfRating: true,\n  itemCount: 5,\n  itemSize: 40.0,\n  unratedColor: Colors.grey,\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- iOS uses SF Symbols for many of its icons. Consider using SF Symbols-like icons for a more native iOS feel.\n- Adjust the touch area for easier interaction on smaller iOS devices.\n\n```dart\nRatingBar.builder(\n  itemBuilder: (context, _) => Icon(\n    CupertinoIcons.star_fill,\n    color: CupertinoColors.systemYellow,\n  ),\n  onRatingUpdate: (rating) {\n    print(rating);\n  },\n  itemSize: 30.0,\n  itemPadding: EdgeInsets.symmetric(horizontal: 2.0),\n)\n```\n\n### Android\n- Follow Material Design guidelines for rating bars.\n- Consider using the built-in Material Icons for stars.\n\n```dart\nRatingBar.builder(\n  itemBuilder: (context, _) => Icon(\n    Icons.star,\n    color: Colors.amber,\n  ),\n  onRatingUpdate: (rating) {\n    print(rating);\n  },\n  itemSize: 40.0,\n  glow: false, // Disable glow effect for a more Material look\n)\n```\n\n### Web\n- Ensure that the rating bar is easily clickable on both desktop and mobile web views.\n- Consider using larger item sizes and padding for better touch targets on mobile web.\n\n```dart\nRatingBar.builder(\n  itemBuilder: (context, _) => Icon(\n    Icons.star,\n    color: Colors.orange,\n  ),\n  onRatingUpdate: (rating) {\n    print(rating);\n  },\n  itemSize: 50.0,\n  itemPadding: EdgeInsets.symmetric(horizontal: 4.0),\n  updateOnDrag: true, // Enable smooth updates on drag for better web experience\n)\n```\n\nBy following these guidelines, you can create rating bars that look and function great across all platforms while maintaining a consistent user experience.",
    "_updatedAt": "2024-09-06T04:11:48Z",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAkO",
        "_type": "reference",
        "_key": "elkwg6a2"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaDn",
        "_type": "reference",
        "_key": "cwmmk1yd"
      }
    ],
    "tags": [
      "rating",
      "ui",
      "widget",
      "star-rating",
      "feedback"
    ],
    "_id": "V06bsD4sX3T8NTHrBPabiK",
    "tutorialIncluded": true,
    "slug": {
      "current": "flutter_rating_bar",
      "_type": "slug"
    },
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_rating_bar/flutter_rating_bar.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Rating Bar Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: RatingBarDemoPage(),\n    );\n  }\n}\n\nclass RatingBarDemoPage extends StatefulWidget {\n  @override\n  _RatingBarDemoPageState createState() => _RatingBarDemoPageState();\n}\n\nclass _RatingBarDemoPageState extends State<RatingBarDemoPage> {\n  double _rating = 3.0;\n  double _indicatorRating = 3.5;\n  IconData? _selectedIcon;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter Rating Bar Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              // Step 1: Basic RatingBar\n              Text('Basic Rating Bar:', style: TextStyle(fontSize: 18)),\n              RatingBar.builder(\n                initialRating: 3,\n                minRating: 1,\n                direction: Axis.horizontal,\n                allowHalfRating: true,\n                itemCount: 5,\n                itemPadding: EdgeInsets.symmetric(horizontal: 4.0),\n                itemBuilder: (context, _) => Icon(\n                  Icons.star,\n                  color: Colors.amber,\n                ),\n                onRatingUpdate: (rating) {\n                  setState(() {\n                    _rating = rating;\n                  });\n                },\n              ),\n              Text('Rating: $_rating', style: TextStyle(fontSize: 16)),\n              SizedBox(height: 20),\n\n              // Step 2: Custom Icon RatingBar\n              Text('Custom Icon Rating Bar:', style: TextStyle(fontSize: 18)),\n              RatingBar.builder(\n                initialRating: 3,\n                itemCount: 5,\n                itemBuilder: (context, index) {\n                  switch (index) {\n                    case 0:\n                      return Icon(Icons.sentiment_very_dissatisfied, color: Colors.red);\n                    case 1:\n                      return Icon(Icons.sentiment_dissatisfied, color: Colors.redAccent);\n                    case 2:\n                      return Icon(Icons.sentiment_neutral, color: Colors.amber);\n                    case 3:\n                      return Icon(Icons.sentiment_satisfied, color: Colors.lightGreen);\n                    case 4:\n                      return Icon(Icons.sentiment_very_satisfied, color: Colors.green);\n                    default:\n                      return Container();\n                  }\n                },\n                onRatingUpdate: (rating) {\n                  print(rating);\n                },\n              ),\n              SizedBox(height: 20),\n\n              // Step 3: Vertical RatingBar\n              Text('Vertical Rating Bar:', style: TextStyle(fontSize: 18)),\n              RatingBar.builder(\n                initialRating: 3,\n                itemCount: 5,\n                direction: Axis.vertical,\n                itemBuilder: (context, _) => Icon(\n                  Icons.star,\n                  color: Colors.amber,\n                ),\n                onRatingUpdate: (rating) {\n                  print(rating);\n                },\n              ),\n              SizedBox(height: 20),\n\n              // Step 4: RatingBar Indicator (Read-only)\n              Text('Rating Bar Indicator:', style: TextStyle(fontSize: 18)),\n              RatingBarIndicator(\n                rating: _indicatorRating,\n                itemBuilder: (context, index) => Icon(\n                  Icons.star,\n                  color: Colors.amber,\n                ),\n                itemCount: 5,\n                itemSize: 50.0,\n                direction: Axis.horizontal,\n              ),\n              Slider(\n                value: _indicatorRating,\n                min: 0,\n                max: 5,\n                divisions: 10,\n                label: _indicatorRating.toString(),\n                onChanged: (rating) {\n                  setState(() {\n                    _indicatorRating = rating;\n                  });\n                },\n              ),\n              SizedBox(height: 20),\n\n              // Step 5: Changeable Icon RatingBar\n              Text('Changeable Icon Rating Bar:', style: TextStyle(fontSize: 18)),\n              RatingBar.builder(\n                initialRating: 3,\n                itemCount: 5,\n                itemBuilder: (context, _) => Icon(\n                  _selectedIcon ?? Icons.star,\n                  color: Colors.amber,\n                ),\n                onRatingUpdate: (rating) {\n                  print(rating);\n                },\n              ),\n              SizedBox(height: 10),\n              Wrap(\n                children: [\n                  IconButton(\n                    icon: Icon(Icons.star),\n                    onPressed: () => setState(() => _selectedIcon = Icons.star),\n                  ),\n                  IconButton(\n                    icon: Icon(Icons.favorite),\n                    onPressed: () => setState(() => _selectedIcon = Icons.favorite),\n                  ),\n                  IconButton(\n                    icon: Icon(Icons.thumb_up),\n                    onPressed: () => setState(() => _selectedIcon = Icons.thumb_up),\n                  ),\n                ],\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. RatingBarDemoPage is set as the home page.\n// 3. In RatingBarDemoPage, we demonstrate various uses of the flutter_rating_bar package:\n//    - A basic rating bar that updates a state variable.\n//    - A custom icon rating bar using different emoji icons.\n//    - A vertical rating bar to show direction flexibility.\n//    - A read-only rating bar indicator with a slider to change its value.\n//    - A rating bar with changeable icons.\n// 4. Each rating bar is interactive (except the indicator) and will print the selected rating to the console.\n// 5. The indicator's value can be changed using the slider, demonstrating how to display a non-interactive rating.\n// 6. The changeable icon rating bar allows users to switch between different icon types using buttons.\n// 7. setState is used to rebuild the widget tree when ratings change or icons are selected, ensuring real-time updates.\n\n// This example showcases the versatility of the flutter_rating_bar package, demonstrating\n// various styles, directions, and use cases for rating bars in a Flutter application.\n```",
    "shortDescription": "A simple yet fully customizable ratingbar for flutter which also include a rating bar indicator, supporting any fraction of rating.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 2306,
    "_createdAt": "2024-08-28T22:16:28Z",
    "name": "flutter_rating_bar",
    "author": "sarbagyastha.com.np",
    "_type": "package"
  },
  {
    "tutorial": "# Pinput Tutorial: Implementing PIN Input in Flutter\n\nThis tutorial will guide you through the process of implementing the Pinput package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nFirst, add Pinput to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  pinput: ^2.2.31\n```\n\nThen, run:\n\n```\nflutter pub get\n```\n\n## Step 2: Import the Package\n\nIn your Dart file, import the Pinput package:\n\n```dart\nimport 'package:pinput/pinput.dart';\n```\n\n## Step 3: Basic Implementation\n\nHere's a basic implementation of Pinput:\n\n```dart\nPinput(\n  length: 4,\n  onCompleted: (pin) => print(pin),\n)\n```\n\nThis creates a 4-digit PIN input field that prints the entered PIN when completed.\n\n## Step 4: Customization\n\nPinput offers extensive customization options. Here's an example with some custom styling:\n\n```dart\nfinal defaultPinTheme = PinTheme(\n  width: 56,\n  height: 56,\n  textStyle: TextStyle(fontSize: 20, color: Color.fromRGBO(30, 60, 87, 1), fontWeight: FontWeight.w600),\n  decoration: BoxDecoration(\n    border: Border.all(color: Color.fromRGBO(234, 239, 243, 1)),\n    borderRadius: BorderRadius.circular(20),\n  ),\n);\n\nPinput(\n  defaultPinTheme: defaultPinTheme,\n  focusedPinTheme: defaultPinTheme.copyWith(\n    decoration: defaultPinTheme.decoration!.copyWith(\n      border: Border.all(color: Color.fromRGBO(114, 178, 238, 1)),\n    ),\n  ),\n  submittedPinTheme: defaultPinTheme.copyWith(\n    decoration: defaultPinTheme.decoration!.copyWith(\n      color: Color.fromRGBO(234, 239, 243, 1),\n    ),\n  ),\n  errorPinTheme: defaultPinTheme.copyWith(\n    decoration: defaultPinTheme.decoration!.copyWith(\n      border: Border.all(color: Colors.redAccent),\n    ),\n  ),\n  validator: (s) {\n    return s == '2222' ? null : 'Pin is incorrect';\n  },\n  pinputAutovalidateMode: PinputAutovalidateMode.onSubmit,\n  showCursor: true,\n  onCompleted: (pin) => print(pin),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to consider using the `CupertinoTextField` for a more native look:\n\n```dart\nPinput(\n  useNativeKeyboard: true,\n  textInputAction: TextInputAction.done,\n  keyboardType: TextInputType.number,\n  androidSmsAutofillMethod: AndroidSmsAutofillMethod.none,\n  buildContext: context,\n  iosCopyBehavior: IosCopyBehavior.disable,\n)\n```\n\n### Android\n\nFor Android, you can enable SMS autofill:\n\n```dart\nPinput(\n  androidSmsAutofillMethod: AndroidSmsAutofillMethod.smsUserConsentApi,\n  listenForMultipleSmsOnAndroid: true,\n)\n```\n\nRemember to add the necessary permissions in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.RECEIVE_SMS\"/>\n<uses-permission android:name=\"android.permission.READ_SMS\"/>\n```\n\n## Conclusion\n\nThis tutorial covered the basics of implementing Pinput in your Flutter project. The package offers many more features and customization options. Refer to the official documentation for more advanced usage and additional features.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "description": "# Pinput: A Powerful PIN Input Package for Flutter\n\n## Introduction\n\nIn the world of mobile app development, secure authentication is paramount. One common method for quick and secure access is the use of PINs (Personal Identification Numbers). Flutter developers looking for a customizable and feature-rich PIN input solution need look no further than the Pinput package.\n\n## What is Pinput?\n\nPinput is a Flutter package that provides a highly customizable PIN input widget. It offers a wide range of features and customization options, making it suitable for various use cases, from simple PIN entry to complex OTP (One-Time Password) verification systems.\n\n## Key Features\n\n1. **Customizable Appearance**: Pinput allows developers to customize every aspect of the PIN input fields, including size, color, shape, and animations.\n\n2. **Secure Input**: The package supports obscuring entered digits for enhanced security.\n\n3. **Haptic Feedback**: Pinput can provide haptic feedback on input, enhancing the user experience.\n\n4. **Auto-focus**: The widget automatically focuses on the next field after input, streamlining the user interaction.\n\n5. **Cursor Support**: Pinput includes a customizable cursor for better visual feedback.\n\n6. **Platform Adaptivity**: The package adapts to different platforms, ensuring a native look and feel on both iOS and Android.\n\n7. **Validation**: Built-in validation support helps ensure correct input format.\n\n8. **Accessibility**: Pinput is designed with accessibility in mind, supporting screen readers and other assistive technologies.\n\n## Why Choose Pinput?\n\nPinput stands out due to its extensive customization options and robust feature set. Whether you're building a banking app requiring secure PIN entry or an e-commerce platform with OTP verification, Pinput provides the flexibility and functionality needed to create a polished, user-friendly experience.\n\nIn the following sections, we'll dive deeper into how to implement Pinput in your Flutter project and explore its various features through a comprehensive tutorial and example.",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAkO",
        "_type": "reference",
        "_key": "2u25b131"
      }
    ],
    "likesCount": 2758,
    "slug": {
      "_type": "slug",
      "current": "pinput"
    },
    "author": "fman.ge",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:16:36Z",
    "name": "pinput",
    "_updatedAt": "2024-09-06T04:11:49Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaQo6",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:pinput/pinput.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pinput Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: PinputDemo(),\n    );\n  }\n}\n\nclass PinputDemo extends StatefulWidget {\n  @override\n  _PinputDemoState createState() => _PinputDemoState();\n}\n\nclass _PinputDemoState extends State<PinputDemo> {\n  final pinController = TextEditingController();\n  final focusNode = FocusNode();\n  final formKey = GlobalKey<FormState>();\n\n  @override\n  void dispose() {\n    pinController.dispose();\n    focusNode.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const focusedBorderColor = Color.fromRGBO(23, 171, 144, 1);\n    const fillColor = Color.fromRGBO(243, 246, 249, 0);\n    const borderColor = Color.fromRGBO(23, 171, 144, 0.4);\n\n    final defaultPinTheme = PinTheme(\n      width: 56,\n      height: 56,\n      textStyle: const TextStyle(\n        fontSize: 22,\n        color: Color.fromRGBO(30, 60, 87, 1),\n      ),\n      decoration: BoxDecoration(\n        borderRadius: BorderRadius.circular(19),\n        border: Border.all(color: borderColor),\n      ),\n    );\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pinput Example')),\n      body: Form(\n        key: formKey,\n        child: Column(\n          mainAxisAlignment: MainCenter,\n          children: [\n            const SizedBox(height: 30),\n            Text(\n              'Verification Code',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 20),\n            Directionality(\n              // Specify direction if desired\n              textDirection: TextDirection.ltr,\n              child: Pinput(\n                controller: pinController,\n                focusNode: focusNode,\n                androidSmsAutofillMethod:\n                    AndroidSmsAutofillMethod.smsUserConsentApi,\n                listenForMultipleSmsOnAndroid: true,\n                defaultPinTheme: defaultPinTheme,\n                validator: (value) {\n                  return value == '2222' ? null : 'Pin is incorrect';\n                },\n                // onClipboardFound: (value) {\n                //   debugPrint('onClipboardFound: $value');\n                //   pinController.setText(value);\n                // },\n                hapticFeedbackType: HapticFeedbackType.lightImpact,\n                onCompleted: (pin) {\n                  debugPrint('onCompleted: $pin');\n                },\n                onChanged: (value) {\n                  debugPrint('onChanged: $value');\n                },\n                cursor: Column(\n                  mainAxisAlignment: MainAxisAlignment.end,\n                  children: [\n                    Container(\n                      margin: const EdgeInsets.only(bottom: 9),\n                      width: 22,\n                      height: 1,\n                      color: focusedBorderColor,\n                    ),\n                  ],\n                ),\n                focusedPinTheme: defaultPinTheme.copyWith(\n                  decoration: defaultPinTheme.decoration!.copyWith(\n                    borderRadius: BorderRadius.circular(8),\n                    border: Border.all(color: focusedBorderColor),\n                  ),\n                ),\n                submittedPinTheme: defaultPinTheme.copyWith(\n                  decoration: defaultPinTheme.decoration!.copyWith(\n                    color: fillColor,\n                    borderRadius: BorderRadius.circular(19),\n                    border: Border.all(color: focusedBorderColor),\n                  ),\n                ),\n                errorPinTheme: defaultPinTheme.copyBorderWith(\n                  border: Border.all(color: Colors.redAccent),\n                ),\n              ),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () {\n                focusNode.unfocus();\n                formKey.currentState!.validate();\n              },\n              child: const Text('Validate'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen is set to PinputDemo, a stateful widget.\n// 3. In the PinputDemo, we set up a Form with a Pinput widget for PIN entry.\n// 4. The Pinput widget is highly customized:\n//    - It uses a custom theme for normal, focused, submitted, and error states.\n//    - It has a custom cursor.\n//    - It's set up for Android SMS autofill.\n//    - It provides haptic feedback.\n//    - It has validation (correct PIN is '2222').\n// 5. As the user types, onChanged is called, printing debug information.\n// 6. When 4 digits are entered, onCompleted is called, printing the full PIN.\n// 7. The user can press the 'Validate' button to manually trigger validation.\n// 8. If the entered PIN is incorrect, an error message is displayed.\n\n// This example demonstrates key features of Pinput:\n// - Custom styling\n// - Validation\n// - Haptic feedback\n// - Platform-specific features (Android SMS autofill)\n// - Event handling (onChanged, onCompleted)\n// - Integration with Flutter's Form widget for easy validation\n```",
    "packageImage": {
      "asset": {
        "_ref": "image-dff3beb4be9d326f61499742cf299ca18578c716-501x501-webp",
        "_type": "reference"
      },
      "_type": "image"
    },
    "_id": "V06bsD4sX3T8NTHrBPacfE",
    "_type": "package",
    "shortDescription": "Pin code input (OTP) text field, iOS SMS autofill, Android SMS autofill One Time Code, Password, Passcode, Captcha, Security, Coupon, Wowcher, 2FA, Two step verification",
    "tags": [
      "otp",
      "pin-input",
      "pin-code",
      "passcode",
      "sms-autofill",
      "verification"
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-06-06T18:30:00.000Z"
  },
  {
    "likesCount": 2226,
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPak0O",
        "_type": "reference",
        "_key": "pls5pr9u"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-05-07T18:30:00.000Z",
    "_type": "package",
    "description": "# Google Mobile Ads Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `google_mobile_ads` package is a powerful tool for integrating Google AdMob advertisements into your Flutter applications. It provides a seamless way to monetize your app by displaying various types of ads, including banner ads, interstitial ads, rewarded ads, and native ads.\n\n### Key Features:\n\n1. **Banner Ads**: Display rectangular ads at the top or bottom of the screen.\n2. **Interstitial Ads**: Full-screen ads that cover the interface of the app.\n3. **Rewarded Ads**: Full-screen ads that users can watch in exchange for in-app rewards.\n4. **Native Ads**: Customizable ad formats that match the look and feel of your app.\n\n### Benefits:\n\n- Easy integration with Flutter apps\n- Support for both Android and iOS platforms\n- Flexible ad formats to suit various app designs\n- Robust targeting options to reach the right audience\n- Real-time reporting and analytics\n\n### Getting Started:\n\nTo use the `google_mobile_ads` package in your Flutter project, you need to:\n\n1. Add the package to your `pubspec.yaml` file\n2. Initialize the mobile ads SDK\n3. Create and load ads\n4. Display ads in your app\n\nIn the following sections, we'll dive deeper into the implementation details and provide a comprehensive tutorial on how to integrate Google Mobile Ads into your Flutter application.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:google_mobile_ads/google_mobile_ads.dart';\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  MobileAds.instance.initialize();\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Google Mobile Ads Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatefulWidget {\n  @override\n  _HomeScreenState createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> {\n  // Step 1: Define ad unit IDs (use test IDs for development)\n  final String bannerAdUnitId = 'ca-app-pub-3940256099942544/6300978111';\n  final String interstitialAdUnitId = 'ca-app-pub-3940256099942544/1033173712';\n  final String rewardedAdUnitId = 'ca-app-pub-3940256099942544/5224354917';\n\n  // Step 2: Declare ad instances\n  BannerAd? _bannerAd;\n  InterstitialAd? _interstitialAd;\n  RewardedAd? _rewardedAd;\n\n  // Step 3: Initialize banner ad\n  void _initBannerAd() {\n    _bannerAd = BannerAd(\n      adUnitId: bannerAdUnitId,\n      size: AdSize.banner,\n      request: AdRequest(),\n      listener: BannerAdListener(\n        onAdLoaded: (_) {\n          setState(() {});\n        },\n        onAdFailedToLoad: (ad, error) {\n          ad.dispose();\n        },\n      ),\n    );\n    _bannerAd!.load();\n  }\n\n  // Step 4: Load interstitial ad\n  void _loadInterstitialAd() {\n    InterstitialAd.load(\n      adUnitId: interstitialAdUnitId,\n      request: AdRequest(),\n      adLoadCallback: InterstitialAdLoadCallback(\n        onAdLoaded: (ad) {\n          _interstitialAd = ad;\n        },\n        onAdFailedToLoad: (error) {\n          print('InterstitialAd failed to load: $error');\n        },\n      ),\n    );\n  }\n\n  // Step 5: Load rewarded ad\n  void _loadRewardedAd() {\n    RewardedAd.load(\n      adUnitId: rewardedAdUnitId,\n      request: AdRequest(),\n      rewardedAdLoadCallback: RewardedAdLoadCallback(\n        onAdLoaded: (ad) {\n          _rewardedAd = ad;\n        },\n        onAdFailedToLoad: (error) {\n          print('RewardedAd failed to load: $error');\n        },\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _initBannerAd();\n    _loadInterstitialAd();\n    _loadRewardedAd();\n  }\n\n  @override\n  void dispose() {\n    _bannerAd?.dispose();\n    _interstitialAd?.dispose();\n    _rewardedAd?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Google Mobile Ads Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              child: Text('Show Interstitial Ad'),\n              onPressed: () {\n                if (_interstitialAd != null) {\n                  _interstitialAd!.show();\n                  _loadInterstitialAd(); // Load the next interstitial\n                }\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Rewarded Ad'),\n              onPressed: () {\n                if (_rewardedAd != null) {\n                  _rewardedAd!.show(\n                    onUserEarnedReward: (_, reward) {\n                      print('User earned ${reward.amount} ${reward.type}');\n                    },\n                  );\n                  _loadRewardedAd(); // Load the next rewarded ad\n                }\n              },\n            ),\n          ],\n        ),\n      ),\n      bottomNavigationBar: _bannerAd == null\n          ? null\n          : Container(\n              height: 50,\n              child: AdWidget(ad: _bannerAd!),\n            ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes the Mobile Ads SDK in the main function.\n// 2. In the HomeScreen's initState, we initialize and load all ad types:\n//    - Banner ad is initialized and loaded\n//    - Interstitial ad is loaded\n//    - Rewarded ad is loaded\n// 3. The banner ad is displayed at the bottom of the screen using a Container and AdWidget.\n// 4. Two buttons are provided in the body:\n//    - \"Show Interstitial Ad\" button shows the interstitial ad when pressed\n//    - \"Show Rewarded Ad\" button shows the rewarded ad when pressed\n// 5. When an interstitial or rewarded ad is shown, a new one is immediately loaded to ensure\n//    an ad is always ready to be displayed.\n// 6. In the dispose method, we make sure to dispose of all ad instances to prevent memory leaks.\n\n// Note: This example uses test ad unit IDs. Replace them with your actual ad unit IDs\n// before publishing your app.\n```",
    "_id": "V06bsD4sX3T8NTHrBPacvI",
    "tutorialIncluded": true,
    "shortDescription": "Flutter plugin for Google Mobile Ads, supporting banner, interstitial (full-screen),  rewarded and native ads",
    "_createdAt": "2024-08-28T22:16:38Z",
    "name": "google_mobile_ads",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbY9V",
        "_type": "reference",
        "_key": "btzyxce2"
      }
    ],
    "platforms": [
      "android",
      "ios"
    ],
    "tags": [
      "ads",
      "google-ads",
      "monetization",
      "banner-ads",
      "interstitial-ads"
    ],
    "tutorial": "# Google Mobile Ads Package for Flutter: Tutorial\n\n## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `google_mobile_ads` package into your Flutter application. We'll cover both Android and iOS platform-specific details.\n\n### Step 1: Add the package to your project\n\nAdd the following line to your `pubspec.yaml` file under the `dependencies` section:\n\n```yaml\ndependencies:\n  google_mobile_ads: ^3.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Platform-specific setup\n\n#### Android Setup\n\n1. Open your `android/app/src/main/AndroidManifest.xml` file and add the following meta-data tag inside the `<application>` tag:\n\n```xml\n<meta-data\n    android:name=\"com.google.android.gms.ads.APPLICATION_ID\"\n    android:value=\"ca-app-pub-3940256099942544~3347511713\"/>\n```\n\nReplace the value with your actual AdMob app ID.\n\n2. Ensure that your `android/app/build.gradle` file has a `minSdkVersion` of at least 19:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 19\n        // ...\n    }\n}\n```\n\n#### iOS Setup\n\n1. Open your `ios/Runner/Info.plist` file and add the following:\n\n```xml\n<key>GADApplicationIdentifier</key>\n<string>ca-app-pub-3940256099942544~1458002511</string>\n```\n\nReplace the string with your actual AdMob app ID.\n\n2. Add the following to your `ios/Podfile`:\n\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    flutter_additional_ios_build_settings(target)\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '5.0'  # Add this line\n    end\n  end\nend\n```\n\n### Step 3: Initialize the Mobile Ads SDK\n\nIn your `main.dart` file, initialize the Mobile Ads SDK:\n\n```dart\nimport 'package:google_mobile_ads/google_mobile_ads.dart';\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  MobileAds.instance.initialize();\n  runApp(RealFlutter());\n}\n```\n\n### Step 4: Implement different ad types\n\nNow you're ready to implement different types of ads in your app. In the next section, we'll provide a complete example demonstrating various ad types and their implementation.",
    "_updatedAt": "2024-09-06T04:11:50Z",
    "slug": {
      "current": "google_mobile_ads",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "google.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaQrI"
  },
  {
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-677c828817c0b1c40cbd0a65c291d79e3399e341-639x829-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:16:41Z",
    "lastUpdate": "2024-08-07T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPadBM",
    "tutorialIncluded": true,
    "slug": {
      "current": "pdf",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaQuU",
    "_type": "package",
    "tags": [
      "pdf",
      "printer",
      "print",
      "printing",
      "report",
      "document-generation"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbBNs",
        "_type": "reference",
        "_key": "4fpy9n45"
      }
    ],
    "author": "nfet.net",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1adH",
        "_type": "reference",
        "_key": "c65t7wc3"
      }
    ],
    "shortDescription": "A pdf producer for Dart. It can create pdf files for both web or flutter.",
    "example": "```\nimport 'dart:io';\nimport 'package:flutter/material.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:pdf/pdf.dart';\nimport 'package:pdf/widgets.dart' as pw;\nimport 'package:open_file/open_file.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final pdf = pw.Document();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter PDF Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Create PDF'),\n              onPressed: _createPDF,\n            ),\n            ElevatedButton(\n              child: Text('Add Page'),\n              onPressed: _addPage,\n            ),\n            ElevatedButton(\n              child: Text('Save and Open PDF'),\n              onPressed: _saveAndOpenPDF,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Create a basic PDF\n  Future<void> _createPDF() async {\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Center(\n            child: pw.Text('Hello RealFlutter!'),\n          );\n        },\n      ),\n    );\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('PDF Created')),\n    );\n  }\n\n  // Step 2: Add a new page to the existing PDF\n  void _addPage() {\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Center(\n            child: pw.Text('This is page ${pdf.document.pdfPageList.pages.length}'),\n          );\n        },\n      ),\n    );\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Page Added')),\n    );\n  }\n\n  // Step 3: Save the PDF to a file and open it\n  Future<void> _saveAndOpenPDF() async {\n    try {\n      final dir = await getApplicationDocumentsDirectory();\n      final file = File('${dir.path}/realflutter_example.pdf');\n      await file.writeAsBytes(await pdf.save());\n      await OpenFile.open(file.path);\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: $e')),\n      );\n    }\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays three buttons: Create PDF, Add Page, and Save and Open PDF.\n// 2. When 'Create PDF' is pressed, it creates a new PDF with a single page containing \"Hello RealFlutter!\".\n// 3. 'Add Page' adds a new page to the existing PDF, numbering it based on its position.\n// 4. 'Save and Open PDF' saves the current state of the PDF to the device's documents directory and opens it using the default PDF viewer.\n// \n// Note: This example demonstrates basic PDF creation and manipulation. For more advanced features like merging PDFs or adding annotations,\n// you would need to expand on this code and possibly use additional packages or native APIs.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "pubPoint": 160,
    "description": "# PDF Package in Flutter: Unleash the Power of Document Manipulation\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, the ability to handle PDF documents has become increasingly important. Flutter, Google's UI toolkit for building natively compiled applications, offers a robust solution through its PDF package. This blog post will explore the capabilities of the PDF package in Flutter, demonstrating how it can be seamlessly integrated into your projects to enhance document handling and manipulation.\n\n## What is the PDF Package?\n\nThe PDF package in Flutter is a powerful tool that allows developers to create, modify, and render PDF documents within their applications. It provides a wide range of functionalities, from simple PDF viewing to complex operations like merging, splitting, and adding annotations to PDF files.\n\n## Key Features\n\n1. **PDF Rendering**: Display PDF documents with high fidelity and smooth scrolling.\n2. **Document Creation**: Generate PDF documents programmatically from scratch.\n3. **Manipulation**: Merge multiple PDFs, split documents, or extract specific pages.\n4. **Annotations**: Add text, images, and shapes to existing PDF documents.\n5. **Form Filling**: Interact with and fill PDF forms dynamically.\n6. **Password Protection**: Secure PDF documents with encryption and password protection.\n7. **Cross-Platform Compatibility**: Works seamlessly on both iOS and Android platforms.\n\n## Why Use the PDF Package?\n\nIntegrating the PDF package into your Flutter application opens up a world of possibilities:\n\n- **Enhanced User Experience**: Provide in-app PDF viewing without redirecting to external applications.\n- **Increased Productivity**: Manipulate PDF documents on-the-go, saving time and effort.\n- **Offline Capabilities**: Work with PDF files without requiring an internet connection.\n- **Customization**: Tailor PDF handling to your specific application needs.\n\nIn the following sections, we'll dive deeper into how to implement these features in your Flutter application using the RealFlutter class as our foundation.",
    "name": "pdf",
    "tutorial": "# PDF Package in Flutter: A Comprehensive Tutorial\n\nThis tutorial will guide you through the process of integrating the PDF package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Installation\n\nTo get started with the PDF package, you need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  pdf: ^3.8.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Basic Usage\n\nHere's a simple example of how to create a PDF document using the RealFlutter class:\n\n```dart\nimport 'package:pdf/pdf.dart';\nimport 'package:pdf/widgets.dart' as pw;\n\nclass RealFlutter {\n  Future<void> createPDF() async {\n    final pdf = pw.Document();\n\n    pdf.addPage(\n      pw.Page(\n        build: (pw.Context context) {\n          return pw.Center(\n            child: pw.Text('Hello, PDF!'),\n          );\n        },\n      ),\n    );\n\n    // Save the PDF\n    final file = File('example.pdf');\n    await file.writeAsBytes(await pdf.save());\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you need to add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n### iOS\n\nFor iOS, add the following keys to your `Info.plist` file:\n\n```xml\n<key>UIFileSharingEnabled</key>\n<true/>\n<key>LSSupportsOpeningDocumentsInPlace</key>\n<true/>\n```\n\n## Advanced Features\n\n### Merging PDFs\n\nTo merge multiple PDF documents:\n\n```dart\nFuture<void> mergePDFs(List<File> pdfFiles) async {\n  final mergedPdf = pw.Document();\n\n  for (var file in pdfFiles) {\n    final pdfFile = await PdfDocument.openFile(file.path);\n    for (var i = 0; i < pdfFile.pagesCount; i++) {\n      final page = await pdfFile.getPage(i + 1);\n      mergedPdf.addPage(pw.Page(build: (context) => pw.Image(pw.MemoryImage(page.render()))));\n    }\n  }\n\n  final output = File('merged.pdf');\n  await output.writeAsBytes(await mergedPdf.save());\n}\n```\n\n### Adding Annotations\n\nTo add text annotations to a PDF:\n\n```dart\nFuture<void> addAnnotation(File pdfFile, String text, int pageNumber) async {\n  final document = await PdfDocument.openFile(pdfFile.path);\n  final page = await document.getPage(pageNumber);\n\n  final annotation = PdfTextAnnotation(\n    Rect.fromLTRB(50, 50, 200, 100),\n    text,\n    author: 'RealFlutter',\n  );\n\n  await page.addAnnotation(annotation);\n  await document.save(pdfFile.path);\n}\n```\n\nThis tutorial provides a foundation for working with the PDF package in Flutter. In the next section, we'll explore a complete example that demonstrates these features in action.",
    "_updatedAt": "2024-09-06T04:11:51Z",
    "subCategories": [
      {
        "_key": "k91t1aiz",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGp5",
        "_type": "reference"
      }
    ],
    "likesCount": 2632
  },
  {
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:52Z",
    "tags": [
      "review",
      "app-store",
      "play-store",
      "feedback",
      "rating"
    ],
    "likesCount": 1938,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-ee9ec55f55244975afedfb64f8b5babfd625bed6-312x555-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:16:57Z",
    "name": "in_app_review",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RbIA",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfEfw",
        "_type": "reference",
        "_key": "e2zilnrz"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1vZz",
        "_type": "reference",
        "_key": "bwd9cwyy"
      },
      {
        "_key": "oe4szun7",
        "_ref": "Rx1Nho763d29lawKra1hNz",
        "_type": "reference"
      }
    ],
    "slug": {
      "current": "in_app_review",
      "_type": "slug"
    },
    "_type": "package",
    "description": "# In-App Review Package for Flutter: Boost Your App's Ratings\n\n## Introduction\n\nThe `in_app_review` package is a powerful tool for Flutter developers looking to improve their app's user engagement and ratings. This package provides a simple way to prompt users to review your app directly within the application, without redirecting them to the app store.\n\n## Key Features\n\n1. **Cross-platform support**: Works on both iOS and Android platforms.\n2. **Easy integration**: Simple API for requesting reviews.\n3. **Flexible usage**: Can be triggered at specific points in your app's user journey.\n4. **Rate limiting**: Respects platform-specific rate limiting to prevent excessive prompts.\n\n## Why Use In-App Reviews?\n\n1. **Improved user experience**: Users can leave reviews without leaving your app.\n2. **Higher review rates**: The convenience often leads to more users leaving reviews.\n3. **Better feedback loop**: Encourages users to share their thoughts, helping you improve your app.\n4. **Increased visibility**: More reviews can lead to better app store rankings.\n\n## Getting Started\n\nTo use the `in_app_review` package in your Flutter project, you'll need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  in_app_review: ^2.0.8\n```\n\nAfter adding the dependency, run `flutter pub get` to fetch the package.\n\nIn the next sections, we'll dive into a tutorial on how to implement in-app reviews in your Flutter application and provide a complete example showcasing all the features of this package.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:in_app_review/in_app_review.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'In-App Review Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const InAppReviewDemo(),\n    );\n  }\n}\n\nclass InAppReviewDemo extends StatefulWidget {\n  const InAppReviewDemo({Key? key}) : super(key: key);\n\n  @override\n  _InAppReviewDemoState createState() => _InAppReviewDemoState();\n}\n\nclass _InAppReviewDemoState extends State<InAppReviewDemo> {\n  // Step 1: Initialize the InAppReview instance\n  final InAppReview _inAppReview = InAppReview.instance;\n  \n  String _reviewStatus = 'Not requested';\n\n  // Step 2: Function to check availability and request review\n  Future<void> _requestReview() async {\n    try {\n      // Step 3: Check if the in-app review is available\n      final isAvailable = await _inAppReview.isAvailable();\n      \n      if (isAvailable) {\n        // Step 4: Request the review\n        await _inAppReview.requestReview();\n        setState(() {\n          _reviewStatus = 'Review requested successfully';\n        });\n      } else {\n        setState(() {\n          _reviewStatus = 'In-app review not available';\n        });\n        // Optional: Implement fallback option here, e.g., open store listing\n        await _openStoreListing();\n      }\n    } catch (e) {\n      setState(() {\n        _reviewStatus = 'Error requesting review: $e';\n      });\n    }\n  }\n\n  // Optional: Function to open store listing as a fallback\n  Future<void> _openStoreListing() async {\n    final isOpened = await _inAppReview.openStoreListing(\n      appStoreId: 'YOUR_IOS_APP_ID', // Replace with your iOS app ID\n    );\n    setState(() {\n      _reviewStatus = isOpened ? 'Store listing opened' : 'Failed to open store listing';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('In-App Review Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: _requestReview,\n              child: const Text('Request Review'),\n            ),\n            const SizedBox(height: 20),\n            Text('Status: $_reviewStatus'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a simple UI with a button to request a review.\n// 2. When the user taps the \"Request Review\" button, the _requestReview() function is called.\n// 3. The function first checks if in-app review is available on the device.\n// 4. If available, it requests a review using _inAppReview.requestReview().\n// 5. If not available, it attempts to open the store listing as a fallback.\n// 6. The status of the review request is updated and displayed on the screen.\n// 7. Error handling is implemented to catch and display any issues that occur during the process.\n\n// Note: Remember to replace 'YOUR_IOS_APP_ID' with your actual iOS app ID if you want to use the store listing fallback on iOS.\n```",
    "lastUpdate": "2024-03-16T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPafbI",
    "author": "britannio.dev",
    "shortDescription": "Flutter plugin for showing the In-App Review/System Rating pop up on Android, iOS and MacOS. It makes it easy for users to rate your app.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "macos"
    ],
    "tutorial": "# Tutorial: Implementing In-App Reviews in Flutter\n\nThis tutorial will guide you through the process of implementing in-app reviews in your Flutter application using the `in_app_review` package.\n\n## Step 1: Import the Package\n\nFirst, import the package in your Dart file:\n\n```dart\nimport 'package:in_app_review/in_app_review.dart';\n```\n\n## Step 2: Initialize the InAppReview Instance\n\nCreate an instance of `InAppReview`:\n\n```dart\nfinal InAppReview inAppReview = InAppReview.instance;\n```\n\n## Step 3: Check Availability\n\nBefore requesting a review, it's good practice to check if the functionality is available on the device:\n\n```dart\nif (await inAppReview.isAvailable()) {\n  // Request a review\n} else {\n  // Handle cases where review functionality is not available\n}\n```\n\n## Step 4: Request a Review\n\nTo request a review, simply call the `requestReview()` method:\n\n```dart\nawait inAppReview.requestReview();\n```\n\n## Step 5: Implement Platform-Specific Details\n\n### Android\n\nFor Android, you need to add the following to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file:\n\n```xml\n<key>LSApplicationQueriesSchemes</key>\n<array>\n  <string>itms-beta</string>\n  <string>itms</string>\n</array>\n```\n\n## Best Practices\n\n1. **Don't spam users**: Only request reviews at appropriate times, such as after a positive interaction with your app.\n2. **Respect rate limiting**: The `requestReview()` method is rate-limited by the underlying APIs to prevent excessive prompts.\n3. **Provide alternatives**: If in-app review is not available, consider redirecting users to your app's store listing.\n4. **Handle errors gracefully**: Always wrap your review requests in try-catch blocks to handle potential exceptions.\n\nBy following these steps and best practices, you can effectively implement in-app reviews in your Flutter application, potentially boosting your app's ratings and user engagement."
  },
  {
    "slug": {
      "current": "chewie",
      "_type": "slug"
    },
    "author": "fluttercommunity.dev",
    "description": "# Chewie: A Powerful Video Player Package for Flutter\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, video playback has become an essential feature for many applications. Flutter, Google's UI toolkit for building natively compiled applications, offers a robust ecosystem of packages to enhance your app's capabilities. One such package that stands out for video playback is Chewie.\n\n## What is Chewie?\n\nChewie is a video player package for Flutter that wraps around the `video_player` plugin to provide a more user-friendly and customizable video playback experience. It offers a set of pre-built controls and configurations that make it easier for developers to implement video playback in their Flutter applications.\n\n## Key Features of Chewie\n\n1. **Customizable Controls**: Chewie provides a set of default controls that can be easily customized to match your app's design.\n\n2. **Full-Screen Support**: Seamlessly switch between normal and full-screen modes.\n\n3. **Playback Speed Control**: Allow users to adjust video playback speed.\n\n4. **Autoplay and Looping**: Configure videos to play automatically or loop continuously.\n\n5. **Platform-Specific Behaviors**: Chewie adapts to platform-specific video behaviors for a native feel.\n\n6. **Subtitles Support**: Easily add and display subtitles for your videos.\n\n7. **Placeholder and Error Builders**: Customize the appearance during loading and error states.\n\n## Why Choose Chewie?\n\nWhile the `video_player` plugin provides basic video playback functionality, Chewie enhances the developer and user experience by:\n\n- Reducing boilerplate code for common video player features\n- Providing a consistent look and feel across platforms\n- Offering easy customization options for branding and unique UI requirements\n- Handling platform-specific nuances automatically\n\nIn the following sections, we'll dive deeper into how to integrate Chewie into your Flutter project and explore its features through a comprehensive example.",
    "similarPackages": [],
    "dependentPackages": [],
    "_id": "V06bsD4sX3T8NTHrBPagYC",
    "tutorial": "# Chewie Tutorial: Integrating Video Playback in Flutter\n\nThis tutorial will guide you through the process of adding Chewie to your Flutter project and implementing basic video playback functionality.\n\n## Step 1: Add Dependencies\n\nFirst, add the required dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  chewie: ^1.5.0\n  video_player: ^2.6.1\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Import Necessary Packages\n\nIn your Dart file, import the required packages:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:chewie/chewie.dart';\nimport 'package:video_player/video_player.dart';\n```\n\n## Step 3: Create a RealFlutter Class\n\nCreate a `RealFlutter` class that will handle the video player initialization and disposal:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  State<RealFlutter> createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late VideoPlayerController _videoPlayerController;\n  ChewieController? _chewieController;\n\n  @override\n  void initState() {\n    super.initState();\n    _initializePlayer();\n  }\n\n  @override\n  void dispose() {\n    _videoPlayerController.dispose();\n    _chewieController?.dispose();\n    super.dispose();\n  }\n\n  Future<void> _initializePlayer() async {\n    _videoPlayerController = VideoPlayerController.network(\n      'https://flutter.github.io/assets-for-api-docs/assets/videos/butterfly.mp4',\n    );\n    await _videoPlayerController.initialize();\n    _chewieController = ChewieController(\n      videoPlayerController: _videoPlayerController,\n      autoPlay: true,\n      looping: true,\n    );\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Chewie Video Player')),\n      body: _chewieController != null\n          ? Chewie(controller: _chewieController!)\n          : const Center(child: CircularProgressIndicator()),\n    );\n  }\n}\n```\n\n## Step 4: Platform-Specific Considerations\n\n### iOS\nFor iOS, you need to add the following to your `Info.plist` file to allow network access:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSAllowsArbitraryLoads</key>\n  <true/>\n</dict>\n```\n\n### Android\nFor Android, ensure you have the internet permission in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n\n## Step 5: Customizing Chewie\n\nChewie offers various customization options. Here's an example of how to customize the `ChewieController`:\n\n```dart\n_chewieController = ChewieController(\n  videoPlayerController: _videoPlayerController,\n  autoPlay: true,\n  looping: true,\n  aspectRatio: 16 / 9,\n  placeholder: Container(\n    color: Colors.grey,\n  ),\n  materialProgressColors: ChewieProgressColors(\n    playedColor: Colors.red,\n    handleColor: Colors.blue,\n    backgroundColor: Colors.grey,\n    bufferedColor: Colors.lightGreen,\n  ),\n  autoInitialize: true,\n);\n```\n\nThis tutorial covers the basics of integrating Chewie into your Flutter project. In the next section, we'll look at a more comprehensive example that demonstrates additional features of the Chewie package.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmP98",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfCJo",
        "_type": "reference",
        "_key": "0mskb0d5"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "tags": [
      "video-player",
      "media",
      "ui",
      "video",
      "playback"
    ],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:11:53Z",
    "_type": "package",
    "shortDescription": "A video player for Flutter with Cupertino and Material play controls",
    "_createdAt": "2024-08-28T22:16:59Z",
    "lastUpdate": "2024-08-04T18:30:00.000Z",
    "name": "chewie",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:chewie/chewie.dart';\nimport 'package:video_player/video_player.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Chewie Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  State<RealFlutter> createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Declare necessary controllers\n  late VideoPlayerController _videoPlayerController;\n  ChewieController? _chewieController;\n  int? _playBackTime;\n\n  // Step 2: Initialize the player in initState\n  @override\n  void initState() {\n    super.initState();\n    _initializePlayer();\n  }\n\n  // Step 3: Dispose of controllers when the widget is disposed\n  @override\n  void dispose() {\n    _videoPlayerController.dispose();\n    _chewieController?.dispose();\n    super.dispose();\n  }\n\n  // Step 4: Initialize the video player and Chewie controller\n  Future<void> _initializePlayer() async {\n    _videoPlayerController = VideoPlayerController.network(\n      'https://flutter.github.io/assets-for-api-docs/assets/videos/butterfly.mp4',\n    );\n    await _videoPlayerController.initialize();\n\n    // Step 5: Create and configure the Chewie controller\n    _chewieController = ChewieController(\n      videoPlayerController: _videoPlayerController,\n      autoPlay: true,\n      looping: true,\n      aspectRatio: 16 / 9,\n      placeholder: Container(\n        color: Colors.grey,\n        child: const Center(child: CircularProgressIndicator()),\n      ),\n      materialProgressColors: ChewieProgressColors(\n        playedColor: Colors.red,\n        handleColor: Colors.blue,\n        backgroundColor: Colors.grey,\n        bufferedColor: Colors.lightGreen,\n      ),\n      subtitle: Subtitles([\n        Subtitle(\n          index: 0,\n          start: Duration.zero,\n          end: const Duration(seconds: 10),\n          text: 'Flutter is awesome',\n        ),\n        Subtitle(\n          index: 1,\n          start: const Duration(seconds: 10),\n          end: const Duration(seconds: 20),\n          text: 'Chewie is a great video player',\n        ),\n      ]),\n      subtitleBuilder: (context, subtitle) => Container(\n        padding: const EdgeInsets.all(10.0),\n        child: Text(\n          subtitle,\n          style: const TextStyle(color: Colors.white, fontSize: 16),\n        ),\n      ),\n      allowedScreenSleep: false,\n      allowFullScreen: true,\n      deviceOrientationsAfterFullScreen: [DeviceOrientation.portraitUp],\n    );\n\n    // Step 6: Add a listener to track playback position\n    _videoPlayerController.addListener(() {\n      setState(() {\n        _playBackTime = _videoPlayerController.value.position.inSeconds;\n      });\n    });\n\n    setState(() {});\n  }\n\n  // Step 7: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('RealFlutter Chewie Demo')),\n      body: Column(\n        children: [\n          // Step 8: Display the video player\n          Expanded(\n            child: Center(\n              child: _chewieController != null\n                  ? Chewie(controller: _chewieController!)\n                  : const CircularProgressIndicator(),\n            ),\n          ),\n          // Step 9: Display playback information\n          if (_playBackTime != null)\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Text('Playback time: $_playBackTime seconds'),\n            ),\n          // Step 10: Add custom controls\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: () => _chewieController?.enterFullScreen(),\n                  child: const Text('Fullscreen'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _chewieController?.setPlaybackSpeed(1.5),\n                  child: const Text('1.5x Speed'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _chewieController?.setPlaybackSpeed(1.0),\n                  child: const Text('Normal Speed'),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutter.\n// 2. In initState, _initializePlayer is called to set up the video player.\n// 3. The VideoPlayerController is initialized with a network video.\n// 4. A ChewieController is created with various customizations.\n// 5. A listener is added to the VideoPlayerController to track playback time.\n// 6. The UI is built with the Chewie widget displaying the video.\n// 7. Custom controls are added for fullscreen and playback speed adjustment.\n// 8. The current playback time is displayed below the video player.\n// 9. Users can interact with the video using Chewie's built-in controls or the custom buttons.\n// 10. When the widget is disposed, all controllers are properly disposed to free up resources.\n```",
    "likesCount": 1993
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:path/path.dart' as path;\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Path Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const PathDemoScreen(),\n    );\n  }\n}\n\nclass PathDemoScreen extends StatefulWidget {\n  const PathDemoScreen({Key? key}) : super(key: key);\n\n  @override\n  _PathDemoScreenState createState() => _PathDemoScreenState();\n}\n\nclass _PathDemoScreenState extends State<PathDemoScreen> {\n  String _output = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _runPathOperations();\n  }\n\n  Future<void> _runPathOperations() async {\n    StringBuffer output = StringBuffer();\n\n    // Step 1: Join paths\n    output.writeln('Step 1: Joining paths');\n    String joinedPath = path.join('documents', 'reports', 'annual_report.pdf');\n    output.writeln('Joined path: $joinedPath');\n    output.writeln();\n\n    // Step 2: Get file information\n    output.writeln('Step 2: Getting file information');\n    String samplePath = '/home/user/documents/report.pdf';\n    output.writeln('Basename: ${path.basename(samplePath)}');\n    output.writeln('Extension: ${path.extension(samplePath)}');\n    output.writeln('Directory name: ${path.dirname(samplePath)}');\n    output.writeln();\n\n    // Step 3: Normalize paths\n    output.writeln('Step 3: Normalizing paths');\n    String messyPath = '/home/user/../user/./documents/report.pdf';\n    output.writeln('Original path: $messyPath');\n    output.writeln('Normalized path: ${path.normalize(messyPath)}');\n    output.writeln();\n\n    // Step 4: Platform-specific paths\n    output.writeln('Step 4: Platform-specific paths');\n    if (Platform.isWindows) {\n      String windowsPath = path.join('C:', 'Users', 'YourName', 'Documents');\n      output.writeln('Windows path: $windowsPath');\n    } else {\n      String unixPath = path.join('/home', 'user', 'documents');\n      output.writeln('Unix-like path: $unixPath');\n    }\n    output.writeln();\n\n    // Step 5: Working with app-specific directories\n    output.writeln('Step 5: Working with app-specific directories');\n    String appDocPath = await _getAppDocumentsPath();\n    String filePath = path.join(appDocPath, 'my_file.txt');\n    output.writeln('App-specific file path: $filePath');\n\n    setState(() {\n      _output = output.toString();\n    });\n  }\n\n  Future<String> _getAppDocumentsPath() async {\n    final directory = await getApplicationDocumentsDirectory();\n    return directory.path;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Path Demo'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Text(_output),\n      ),\n    );\n  }\n}\n\n// Application flow explanation:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen is set to PathDemoScreen, a stateful widget.\n// 3. In the initState of _PathDemoScreenState, we call _runPathOperations().\n// 4. _runPathOperations() performs several path-related operations:\n//    - Joining paths using path.join()\n//    - Extracting file information using path.basename(), path.extension(), and path.dirname()\n//    - Normalizing paths with path.normalize()\n//    - Demonstrating platform-specific path handling\n//    - Accessing app-specific directories using path_provider\n// 5. The results of these operations are collected in a StringBuffer.\n// 6. Once all operations are complete, setState() is called to update the UI with the results.\n// 7. The build method creates a Scaffold with an AppBar and a scrollable text area showing the output.\n// 8. As the user interacts with the app, they can see the results of various path operations,\n//    helping them understand how the path package works in different scenarios.\n```",
    "dependentPackages": [
      {
        "_key": "at43hov9",
        "_ref": "Rx1Nho763d29lawKra1LIJ",
        "_type": "reference"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPat4e",
        "_type": "reference",
        "_key": "ysl1z940"
      }
    ],
    "_createdAt": "2024-08-28T22:17:00Z",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmPFg",
    "tags": [
      "file-system",
      "path-manipulation",
      "io",
      "filesystem"
    ],
    "tutorial": "# Flutter Path Package Tutorial\n\nIn this tutorial, we'll explore how to use the path package in Flutter to handle file and directory paths effectively. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Installation\n\nTo get started with the path package, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  path: ^1.8.0\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Basic Usage\n\nImport the path package in your Dart file:\n\n```dart\nimport 'package:path/path.dart' as path;\n```\n\n### Joining Paths\n\nUse the `join()` function to create paths:\n\n```dart\nString filePath = path.join('documents', 'reports', 'annual_report.pdf');\nprint(filePath);\n// Output: documents/reports/annual_report.pdf (on Unix-like systems)\n// Output: documents\\reports\\annual_report.pdf (on Windows)\n```\n\n### Getting File Information\n\nExtract information from paths:\n\n```dart\nString filePath = '/home/user/documents/report.pdf';\n\nprint(path.basename(filePath)); // Output: report.pdf\nprint(path.extension(filePath)); // Output: .pdf\nprint(path.dirname(filePath)); // Output: /home/user/documents\n```\n\n### Normalizing Paths\n\nNormalize paths to remove redundancies:\n\n```dart\nString messyPath = '/home/user/../user/./documents/report.pdf';\nprint(path.normalize(messyPath));\n// Output: /home/user/documents/report.pdf\n```\n\n## Platform-Specific Considerations\n\n### Windows\n\nOn Windows, paths use backslashes (`\\`) as separators. The path package handles this automatically:\n\n```dart\nString windowsPath = path.join('C:', 'Users', 'YourName', 'Documents');\nprint(windowsPath);\n// Output: C:\\Users\\YourName\\Documents\n```\n\n### macOS and Linux\n\nOn Unix-like systems, paths use forward slashes (`/`):\n\n```dart\nString unixPath = path.join('/home', 'user', 'documents');\nprint(unixPath);\n// Output: /home/user/documents\n```\n\n### Mobile Platforms (iOS and Android)\n\nWhen working with mobile platforms, use the `path_provider` package in conjunction with the path package to access app-specific directories:\n\n```dart\nimport 'package:path_provider/path_provider.dart';\n\nFuture<String> getAppDocumentsPath() async {\n  final directory = await getApplicationDocumentsDirectory();\n  return directory.path;\n}\n\n// Usage\nString appDocPath = await getAppDocumentsPath();\nString filePath = path.join(appDocPath, 'my_file.txt');\n```\n\nBy following these guidelines and using the path package, you can ensure that your Flutter app handles paths correctly across all supported platforms.",
    "_updatedAt": "2024-09-06T04:11:54Z",
    "slug": {
      "current": "path",
      "_type": "slug"
    },
    "_type": "package",
    "shortDescription": "A string-based path manipulation library. All of the path operations you know and love, with solid support for Windows, POSIX (Linux and Mac OS X), and the web.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "j4le0yil"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "cpglqa8a",
        "_ref": "t8DYBEKn49O4mjbyRAfBX6"
      }
    ],
    "lastUpdate": "2023-12-04T18:30:00.000Z",
    "tutorialIncluded": true,
    "_id": "V06bsD4sX3T8NTHrBPah4K",
    "author": "dart.dev",
    "description": "# Understanding the Path Package in Flutter\n\nThe path package is an essential tool for Flutter developers working with file and directory paths. It provides a set of utilities to manipulate and work with paths across different platforms, ensuring consistency and reliability in your Flutter applications.\n\n## Key Features of the Path Package\n\n1. **Cross-platform compatibility**: The path package handles path-related operations seamlessly across different platforms, including Windows, macOS, Linux, and mobile operating systems.\n\n2. **Path manipulation**: It offers various functions to join, split, normalize, and manipulate paths efficiently.\n\n3. **Directory and file operations**: The package provides methods to work with directories and files, such as creating, deleting, and checking for existence.\n\n4. **Path information retrieval**: You can easily extract information from paths, such as file extensions, base names, and parent directories.\n\n5. **URI handling**: The path package supports converting between URIs and file paths, which is particularly useful when working with network resources or local files.\n\nBy incorporating the path package into your Flutter projects, you can ensure robust handling of file and directory paths across different platforms, leading to more reliable and maintainable code.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1485,
    "packageImage": null,
    "name": "path"
  },
  {
    "tutorial": "# Tutorial: Implementing In-App Purchases in Flutter\n\nThis tutorial will guide you through the process of implementing in-app purchases in your Flutter application using the `in_app_purchase` package.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  in_app_purchase: ^3.1.5\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Platform Configuration\n\n### iOS Configuration\n\n1. In Xcode, open your project's `Runner.xcworkspace`.\n2. Select the `Runner` project in the navigator, then select the `Runner` target.\n3. Select the \"Signing & Capabilities\" tab.\n4. Click the \"+ Capability\" button and add \"In-App Purchase\".\n\n### Android Configuration\n\n1. Open your app's `app/build.gradle` file.\n2. Ensure that the `com.android.billingclient:billing` dependency is included:\n\n```gradle\ndependencies {\n    implementation \"com.android.billingclient:billing:5.1.0\"\n}\n```\n\n## Step 3: Initialize the In-App Purchase Plugin\n\nIn your main Flutter file (e.g., `main.dart`), initialize the plugin:\n\n```dart\nimport 'package:in_app_purchase/in_app_purchase.dart';\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  InAppPurchase.instance.isAvailable();\n  runApp(MyApp());\n}\n```\n\n## Step 4: Implement Purchase Logic\n\nHere's a basic implementation of in-app purchase logic:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:in_app_purchase/in_app_purchase.dart';\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final InAppPurchase _inAppPurchase = InAppPurchase.instance;\n  List<ProductDetails> _products = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _initInAppPurchase();\n  }\n\n  Future<void> _initInAppPurchase() async {\n    final bool available = await _inAppPurchase.isAvailable();\n    if (available) {\n      final ProductDetailsResponse response = await _inAppPurchase.queryProductDetails({'your_product_id'});\n      setState(() {\n        _products = response.productDetails;\n      });\n    }\n  }\n\n  Future<void> _buyProduct(ProductDetails product) async {\n    final PurchaseParam purchaseParam = PurchaseParam(productDetails: product);\n    await _inAppPurchase.buyNonConsumable(purchaseParam: purchaseParam);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('In-App Purchases')),\n      body: ListView.builder(\n        itemCount: _products.length,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text(_products[index].title),\n            subtitle: Text(_products[index].description),\n            trailing: TextButton(\n              child: Text('Buy'),\n              onPressed: () => _buyProduct(_products[index]),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\nThis basic implementation initializes the in-app purchase plugin, queries available products, and provides a simple UI to display and purchase products.\n\nIn the next section, we'll explore a more comprehensive example that demonstrates all the features of the `in_app_purchase` package.",
    "_updatedAt": "2024-09-06T04:11:55Z",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbYG2",
        "_type": "reference",
        "_key": "sf33l8yv"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-cc944c52debde47a4c5780e89870fc708307907a-177x384-webp",
        "_type": "reference"
      }
    },
    "author": "flutter.dev",
    "shortDescription": "A Flutter plugin for in-app purchases. Exposes APIs for making in-app purchases through the App Store and Google Play.",
    "tutorialIncluded": true,
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPacvI",
        "_type": "reference",
        "_key": "yms040it"
      }
    ],
    "name": "in_app_purchase",
    "_id": "V06bsD4sX3T8NTHrBPak0O",
    "_rev": "AE3hjGWNkNE6aGQMMbaQxg",
    "_type": "package",
    "description": "# In-App Purchase Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nThe `in_app_purchase` package is a powerful tool for implementing in-app purchases in Flutter applications. It provides a unified API for handling purchases on both iOS (using StoreKit) and Android (using Google Play Billing). This package simplifies the process of integrating in-app purchases, subscriptions, and consumables into your Flutter app.\n\n## Key Features\n\n1. **Cross-platform support**: Works seamlessly on both iOS and Android.\n2. **Purchase types**: Supports one-time purchases, consumables, and subscriptions.\n3. **Purchase restoration**: Allows users to restore previously purchased items.\n4. **Product querying**: Fetches product information from the app stores.\n5. **Purchase verification**: Helps in verifying the validity of purchases.\n\n## Why Use In-App Purchases?\n\nImplementing in-app purchases can significantly enhance your app's monetization strategy:\n\n- **Freemium model**: Offer a free app with premium features unlocked through purchases.\n- **Subscriptions**: Provide ongoing services or content updates for a recurring fee.\n- **Consumables**: Sell in-game currency, power-ups, or other items that can be bought multiple times.\n\n## Getting Started\n\nTo use the `in_app_purchase` package, you'll need to:\n\n1. Add the package to your `pubspec.yaml` file.\n2. Configure your app in the respective app stores (App Store Connect for iOS, Google Play Console for Android).\n3. Implement the necessary code to handle purchases, as we'll explore in the following sections.\n\nStay tuned for a detailed tutorial on implementing in-app purchases and a comprehensive example showcasing all the features of this powerful package!",
    "tags": [
      "in-app-purchase",
      "payment",
      "monetization",
      "subscription",
      "e-commerce"
    ],
    "likesCount": 2069,
    "_createdAt": "2024-08-28T22:17:09Z",
    "lastUpdate": "2024-04-16T18:30:00.000Z",
    "slug": {
      "current": "in_app_purchase",
      "_type": "slug"
    },
    "pubPoint": 160,
    "example": "```\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:in_app_purchase/in_app_purchase.dart';\nimport 'package:in_app_purchase_android/in_app_purchase_android.dart';\nimport 'package:in_app_purchase_storekit/in_app_purchase_storekit.dart';\n\n// Step 1: Define your product IDs\nconst Set<String> _kProductIds = {'consumable_product', 'non_consumable_product', 'subscription_product'};\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 2: Initialize variables\n  final InAppPurchase _inAppPurchase = InAppPurchase.instance;\n  late StreamSubscription<List<PurchaseDetails>> _subscription;\n  List<ProductDetails> _products = [];\n  List<PurchaseDetails> _purchases = [];\n  bool _isAvailable = false;\n  bool _purchasePending = false;\n  bool _loading = true;\n  String? _queryProductError;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Initialize the in-app purchase plugin\n    final Stream<List<PurchaseDetails>> purchaseUpdated = _inAppPurchase.purchaseStream;\n    _subscription = purchaseUpdated.listen((purchaseDetailsList) {\n      _listenToPurchaseUpdated(purchaseDetailsList);\n    }, onDone: () {\n      _subscription.cancel();\n    }, onError: (error) {\n      // Handle error here\n    });\n    initStoreInfo();\n  }\n\n  // Step 4: Initialize store information\n  Future<void> initStoreInfo() async {\n    final bool isAvailable = await _inAppPurchase.isAvailable();\n    if (!isAvailable) {\n      setState(() {\n        _isAvailable = isAvailable;\n        _products = [];\n        _purchases = [];\n        _purchasePending = false;\n        _loading = false;\n      });\n      return;\n    }\n\n    ProductDetailsResponse productDetailResponse = await _inAppPurchase.queryProductDetails(_kProductIds);\n    if (productDetailResponse.error != null) {\n      setState(() {\n        _queryProductError = productDetailResponse.error!.message;\n        _isAvailable = isAvailable;\n        _products = productDetailResponse.productDetails;\n        _purchases = [];\n        _purchasePending = false;\n        _loading = false;\n      });\n      return;\n    }\n\n    if (productDetailResponse.productDetails.isEmpty) {\n      setState(() {\n        _queryProductError = null;\n        _isAvailable = isAvailable;\n        _products = productDetailResponse.productDetails;\n        _purchases = [];\n        _purchasePending = false;\n        _loading = false;\n      });\n      return;\n    }\n\n    setState(() {\n      _isAvailable = isAvailable;\n      _products = productDetailResponse.productDetails;\n      _purchasePending = false;\n      _loading = false;\n    });\n  }\n\n  // Step 5: Handle purchase updates\n  void _listenToPurchaseUpdated(List<PurchaseDetails> purchaseDetailsList) {\n    purchaseDetailsList.forEach((PurchaseDetails purchaseDetails) async {\n      if (purchaseDetails.status == PurchaseStatus.pending) {\n        setState(() {\n          _purchasePending = true;\n        });\n      } else {\n        if (purchaseDetails.status == PurchaseStatus.error) {\n          handleError(purchaseDetails.error!);\n        } else if (purchaseDetails.status == PurchaseStatus.purchased ||\n                   purchaseDetails.status == PurchaseStatus.restored) {\n          bool valid = await _verifyPurchase(purchaseDetails);\n          if (valid) {\n            deliverProduct(purchaseDetails);\n          } else {\n            _handleInvalidPurchase(purchaseDetails);\n          }\n        }\n        if (purchaseDetails.pendingCompletePurchase) {\n          await _inAppPurchase.completePurchase(purchaseDetails);\n        }\n        setState(() {\n          _purchases.add(purchaseDetails);\n          _purchasePending = false;\n        });\n      }\n    });\n  }\n\n  // Step 6: Verify the purchase (you should implement your own server-side verification)\n  Future<bool> _verifyPurchase(PurchaseDetails purchaseDetails) {\n    // IMPORTANT: Verify the purchase from your server to prevent fraud!\n    return Future<bool>.value(true);\n  }\n\n  // Step 7: Deliver the product\n  void deliverProduct(PurchaseDetails purchaseDetails) {\n    // IMPORTANT: Deliver the product to the user in your app.\n    // Remember to acknowledge the purchase if it hasn't been acknowledged.\n    if (purchaseDetails.pendingCompletePurchase) {\n      _inAppPurchase.completePurchase(purchaseDetails);\n    }\n  }\n\n  // Step 8: Handle invalid purchases\n  void _handleInvalidPurchase(PurchaseDetails purchaseDetails) {\n    // IMPORTANT: Handle invalid purchases here.\n  }\n\n  // Step 9: Handle errors\n  void handleError(IAPError error) {\n    setState(() {\n      _purchasePending = false;\n    });\n  }\n\n  // Step 10: Make a purchase\n  Future<void> _buyProduct(ProductDetails product) async {\n    final PurchaseParam purchaseParam = PurchaseParam(productDetails: product);\n    if (product.id == 'consumable_product') {\n      _inAppPurchase.buyConsumable(purchaseParam: purchaseParam);\n    } else {\n      _inAppPurchase.buyNonConsumable(purchaseParam: purchaseParam);\n    }\n  }\n\n  // Step 11: Restore purchases\n  Future<void> _restorePurchases() async {\n    await _inAppPurchase.restorePurchases();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('In-App Purchases Example'),\n      ),\n      body: _loading\n          ? Center(child: CircularProgressIndicator())\n          : !_isAvailable\n              ? Center(child: Text('Store not available'))\n              : ListView(\n                  children: [\n                    _buildProductList(),\n                    _buildRestoreButton(),\n                  ],\n                ),\n    );\n  }\n\n  Widget _buildProductList() {\n    if (_products.isEmpty) {\n      return Card(child: ListTile(title: Text('No products available.')));\n    }\n    return Column(\n      children: _products.map((product) {\n        return Card(\n          child: ListTile(\n            title: Text(product.title),\n            subtitle: Text(product.description),\n            trailing: TextButton(\n              child: Text('${product.price} - Buy'),\n              onPressed: () => _buyProduct(product),\n            ),\n          ),\n        );\n      }).toList(),\n    );\n  }\n\n  Widget _buildRestoreButton() {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: ElevatedButton(\n        child: Text('Restore Purchases'),\n        onPressed: () => _restorePurchases(),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription.cancel();\n    super.dispose();\n  }\n}\n\n// Main function to run the app\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\n// Application flow:\n// 1. The app initializes and checks if the store is available.\n// 2. It queries the store for product details.\n// 3. The app displays a list of available products.\n// 4. When a user taps the \"Buy\" button, it initiates a purchase.\n// 5. The app listens for purchase updates and handles them accordingly:\n//    - If the purchase is pending, it shows a loading indicator.\n//    - If the purchase is successful, it verifies the purchase and delivers the product.\n//    - If there's an error, it handles the error appropriately.\n// 6. The app also provides a \"Restore Purchases\" button to restore any previous purchases.\n// \n// This example demonstrates:\n// - Querying product information\n// - Making purchases (both consumable and non-consumable)\n// - Handling purchase status updates\n// - Verifying purchases (stub implementation, should be replaced with server-side verification)\n// - Delivering products\n// - Restoring purchases\n// \n// Note: This is a basic implementation. In a real-world scenario, you would need to add more robust error handling,\n// implement server-side purchase verification, and possibly use a state management solution for larger apps.\n```",
    "platforms": [
      "android",
      "ios",
      "macos"
    ]
  },
  {
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "connectivity",
      "network",
      "internet",
      "offline-detection"
    ],
    "dependentPackages": [
      {
        "_key": "nvlh3q1v",
        "_ref": "uQRNMiDfrp20RZ8Id8CW83",
        "_type": "reference"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPb4Yq",
        "_type": "reference",
        "_key": "jjwuf5bu"
      }
    ],
    "slug": {
      "current": "internet_connection_checker",
      "_type": "slug"
    },
    "tutorial": "# Internet Connection Checker Package Tutorial\n\n## Installation\n\nTo use the `internet_connection_checker` package in your Flutter project, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  internet_connection_checker: ^1.0.0\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Basic Usage\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:internet_connection_checker/internet_connection_checker.dart';\n```\n\n2. Create an instance of `InternetConnectionChecker`:\n\n```dart\nfinal InternetConnectionChecker internetChecker = InternetConnectionChecker();\n```\n\n3. Check for internet connectivity:\n\n```dart\nbool result = await internetChecker.hasConnection;\nif (result) {\n  print('Internet connection is available.');\n} else {\n  print('No internet connection.');\n}\n```\n\n## Advanced Features\n\n### Listening for connectivity changes\n\n```dart\ninternetChecker.onStatusChange.listen((InternetConnectionStatus status) {\n  switch (status) {\n    case InternetConnectionStatus.connected:\n      print('Connected to the internet.');\n      break;\n    case InternetConnectionStatus.disconnected:\n      print('Disconnected from the internet.');\n      break;\n  }\n});\n```\n\n### Customizing check parameters\n\n```dart\nInternetConnectionChecker customChecker = InternetConnectionChecker.createInstance(\n  checkInterval: Duration(seconds: 10),\n  checkTimeout: Duration(seconds: 5),\n  addresses: [\n    AddressCheckOptions(\n      address: InternetAddress('1.1.1.1'),\n      port: 53,\n    ),\n    AddressCheckOptions(\n      address: InternetAddress('8.8.8.8'),\n      port: 53,\n    ),\n  ],\n);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nAdd the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### iOS\n\nNo additional configuration is required for iOS.\n\n### Web\n\nFor web applications, ensure that your hosting environment allows outgoing connections to the addresses specified in your `InternetConnectionChecker` instance.\n\n## Best Practices\n\n1. **Avoid Excessive Checking**: While real-time monitoring is useful, avoid checking too frequently to conserve battery and network resources.\n\n2. **Handle Connectivity Changes Gracefully**: When detecting a loss of connectivity, consider caching data and providing offline functionality where possible.\n\n3. **Provide User Feedback**: Use the connectivity information to inform users about the current status and any limitations due to lack of internet access.\n\n4. **Consider Battery Impact**: On mobile devices, be mindful of the battery impact of continuous monitoring. Adjust check intervals based on the app's needs and user activity.\n\n5. **Test on Multiple Networks**: Ensure your implementation works correctly on various network types (Wi-Fi, cellular data, etc.) and in different connectivity scenarios.\n\nBy following these guidelines and utilizing the `internet_connection_checker` package effectively, you can create a more robust and user-friendly Flutter application that handles internet connectivity seamlessly.",
    "author": "",
    "_rev": "eaCZ7mIhmiYZX5KGqJmPME",
    "shortDescription": "A library designed for seamless internet connectivity checks.  This library enables you to verify your internet connection.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference",
        "_key": "wd97kvrh"
      }
    ],
    "packageImage": null,
    "name": "internet_connection_checker",
    "_createdAt": "2024-08-28T22:17:30Z",
    "_id": "V06bsD4sX3T8NTHrBPaluC",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:11:57Z",
    "_type": "package",
    "description": "# Internet Connection Checker Package for Flutter\n\n## Description\n\nThe `internet_connection_checker` package is a powerful and efficient tool for Flutter developers who need to monitor and verify internet connectivity in their applications. This package provides a robust solution for checking internet availability, which is crucial for many mobile and web applications that rely on network connectivity.\n\n### Key Features:\n\n1. **Real-time Connectivity Monitoring**: The package allows you to continuously monitor the device's internet connection status, providing real-time updates on connectivity changes.\n\n2. **Customizable Check Intervals**: Developers can set custom intervals for how frequently the package should check for internet connectivity, allowing for optimization based on the app's specific needs.\n\n3. **Multiple Address Checking**: Instead of relying on a single endpoint, the package can be configured to check multiple addresses, ensuring more accurate results and reducing false negatives.\n\n4. **Timeout Configuration**: The package allows you to set custom timeouts for connection attempts, giving you control over how long the app should wait before determining that a connection is unavailable.\n\n5. **Cross-platform Compatibility**: Works seamlessly across iOS, Android, and web platforms, providing a consistent API for internet connectivity checks.\n\n6. **Low Resource Usage**: Designed to be lightweight and efficient, minimizing impact on battery life and system resources.\n\n7. **Easy Integration**: With a simple and intuitive API, the package can be quickly integrated into existing Flutter projects with minimal setup required.\n\nBy utilizing the `internet_connection_checker` package, Flutter developers can enhance their applications with reliable internet connectivity monitoring, improving user experience by providing appropriate feedback and functionality based on the current network status.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1w5v",
        "_type": "reference",
        "_key": "c92sswv0"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:internet_connection_checker/internet_connection_checker.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Internet Connection Checker Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  // Step 1: Create an instance of InternetConnectionChecker\n  late InternetConnectionChecker internetChecker;\n  \n  // Step 2: Define variables to store connection status and history\n  bool isConnected = false;\n  List<String> connectionHistory = [];\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Initialize the InternetConnectionChecker with custom parameters\n    internetChecker = InternetConnectionChecker.createInstance(\n      checkInterval: const Duration(seconds: 5),\n      checkTimeout: const Duration(seconds: 3),\n      addresses: [\n        AddressCheckOptions(\n          address: InternetAddress('1.1.1.1'),\n          port: 53,\n        ),\n        AddressCheckOptions(\n          address: InternetAddress('8.8.8.8'),\n          port: 53,\n        ),\n      ],\n    );\n\n    // Step 4: Set up a listener for connectivity changes\n    internetChecker.onStatusChange.listen((InternetConnectionStatus status) {\n      setState(() {\n        isConnected = status == InternetConnectionStatus.connected;\n        connectionHistory.insert(0, '${DateTime.now()}: ${isConnected ? \"Connected\" : \"Disconnected\"}');\n        if (connectionHistory.length > 10) connectionHistory.removeLast();\n      });\n    });\n\n    // Step 5: Perform an initial check\n    checkConnection();\n  }\n\n  // Step 6: Function to check current connection status\n  Future<void> checkConnection() async {\n    final bool result = await internetChecker.hasConnection;\n    setState(() {\n      isConnected = result;\n      connectionHistory.insert(0, '${DateTime.now()}: ${isConnected ? \"Connected\" : \"Disconnected\"}');\n      if (connectionHistory.length > 10) connectionHistory.removeLast();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Internet Connection Checker Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 7: Display current connection status\n            Text(\n              'Internet Status: ${isConnected ? \"Connected\" : \"Disconnected\"}',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedBox(height: 20),\n            // Step 8: Button to manually check connection\n            ElevatedButton(\n              onPressed: checkConnection,\n              child: const Text('Check Connection'),\n            ),\n            const SizedBox(height: 20),\n            // Step 9: Display connection history\n            const Text('Connection History:'),\n            Expanded(\n              child: ListView.builder(\n                itemCount: connectionHistory.length,\n                itemBuilder: (context, index) {\n                  return ListTile(\n                    title: Text(connectionHistory[index]),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the InternetConnectionChecker with custom parameters.\n// 2. A listener is set up to monitor changes in internet connectivity.\n// 3. An initial check is performed to get the current connection status.\n// 4. The UI displays the current connection status and a history of status changes.\n// 5. Users can manually trigger a connection check using the \"Check Connection\" button.\n// 6. The connection history is updated in real-time as the status changes or manual checks are performed.\n// 7. The history list is limited to the last 10 entries to prevent excessive memory usage.\n\n// This example demonstrates:\n// - Custom initialization of InternetConnectionChecker\n// - Real-time monitoring of connection status\n// - Manual connection checking\n// - Displaying and updating connection status in the UI\n// - Maintaining a history of connection status changes\n\n// Note: For production apps, consider adding error handling and potentially \n// using a state management solution for more complex scenarios.\n```",
    "likesCount": 1140,
    "lastUpdate": "2024-08-16T18:30:00.000Z"
  },
  {
    "pubPoint": 160,
    "similarPackages": [],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "ebwndg0x",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP"
      }
    ],
    "dependentPackages": [],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:31Z",
    "_updatedAt": "2024-09-06T04:11:57Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmPSm",
    "name": "flutter_keyboard_visibility",
    "slug": {
      "current": "flutter_keyboard_visibility",
      "_type": "slug"
    },
    "tutorialIncluded": true,
    "_type": "package",
    "description": "# Flutter Keyboard Visibility Package: A Comprehensive Guide\n\n## Introduction\n\nThe `flutter_keyboard_visibility` package is an essential tool for Flutter developers who need to handle keyboard visibility events in their applications. This package provides a simple and efficient way to detect when the keyboard appears or disappears, allowing developers to create responsive user interfaces that adapt to the presence of the on-screen keyboard.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly on both iOS and Android platforms.\n2. **Real-time visibility detection**: Provides instant feedback on keyboard visibility changes.\n3. **Easy integration**: Simple to implement with minimal boilerplate code.\n4. **Customizable callbacks**: Allows developers to define custom actions when keyboard visibility changes.\n5. **Height information**: Provides keyboard height information on supported platforms.\n\n## Why Use flutter_keyboard_visibility?\n\nManaging keyboard visibility is crucial for creating a smooth user experience, especially in apps with form inputs or chat interfaces. The `flutter_keyboard_visibility` package simplifies this process by:\n\n- Eliminating the need for platform-specific code to detect keyboard visibility.\n- Providing a unified API for handling keyboard events across different devices.\n- Allowing developers to easily adjust layouts and scroll positions when the keyboard appears or disappears.\n- Enabling the creation of more responsive and user-friendly interfaces.\n\nIn the following sections, we'll dive deeper into how to implement this package in your Flutter projects and explore its various features through practical examples.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_keyboard_visibility/flutter_keyboard_visibility.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Keyboard Visibility Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: KeyboardDemo(),\n    );\n  }\n}\n\nclass KeyboardDemo extends StatefulWidget {\n  @override\n  _KeyboardDemoState createState() => _KeyboardDemoState();\n}\n\nclass _KeyboardDemoState extends State<KeyboardDemo> {\n  // Step 1: Initialize KeyboardVisibilityController\n  late KeyboardVisibilityController _keyboardVisibilityController;\n  bool _isKeyboardVisible = false;\n  double _keyboardHeight = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    \n    // Step 2: Set up the KeyboardVisibilityController\n    _keyboardVisibilityController = KeyboardVisibilityController();\n    \n    // Step 3: Add a listener to handle keyboard visibility changes\n    _keyboardVisibilityController.onChange.listen((bool visible) {\n      setState(() {\n        _isKeyboardVisible = visible;\n        if (visible) {\n          // Step 4: Get keyboard height when it becomes visible\n          _keyboardHeight = MediaQuery.of(context).viewInsets.bottom;\n        } else {\n          _keyboardHeight = 0.0;\n        }\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Keyboard Visibility Demo')),\n      // Step 5: Use KeyboardVisibilityBuilder for the body\n      body: KeyboardVisibilityBuilder(\n        builder: (context, isKeyboardVisible) {\n          return Column(\n            children: [\n              Expanded(\n                child: ListView(\n                  padding: EdgeInsets.all(16.0),\n                  children: [\n                    Text(\n                      'Keyboard Status:',\n                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                    ),\n                    Text(\n                      isKeyboardVisible ? 'Visible' : 'Hidden',\n                      style: TextStyle(fontSize: 16),\n                    ),\n                    SizedBox(height: 20),\n                    Text(\n                      'Keyboard Height:',\n                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                    ),\n                    Text(\n                      '${_keyboardHeight.toStringAsFixed(2)} pixels',\n                      style: TextStyle(fontSize: 16),\n                    ),\n                    SizedBox(height: 20),\n                    TextField(\n                      decoration: InputDecoration(\n                        hintText: 'Type something...',\n                        border: OutlineInputBorder(),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n              // Step 6: Add a bottom container that adjusts its height based on keyboard visibility\n              AnimatedContainer(\n                duration: Duration(milliseconds: 300),\n                height: isKeyboardVisible ? 50 : 100,\n                color: Colors.blue[100],\n                child: Center(\n                  child: Text(\n                    isKeyboardVisible\n                        ? 'Keyboard is open'\n                        : 'Tap the text field to open keyboard',\n                    style: TextStyle(fontSize: 16),\n                  ),\n                ),\n              ),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the KeyboardVisibilityController in the initState method.\n// 2. A listener is set up to track changes in keyboard visibility.\n// 3. The main UI is built using a KeyboardVisibilityBuilder, which rebuilds whenever the keyboard visibility changes.\n// 4. The app displays the current keyboard status (visible/hidden) and its height.\n// 5. A text field is provided for the user to interact with, triggering the keyboard.\n// 6. At the bottom, there's an animated container that changes its height based on keyboard visibility.\n// 7. When the user taps the text field:\n//    - The keyboard appears\n//    - The listener detects this change and updates the state\n//    - The UI rebuilds, showing the updated keyboard status and height\n//    - The bottom container animates to a smaller height\n// 8. When the keyboard is dismissed:\n//    - The listener detects this change and updates the state\n//    - The UI rebuilds again, reflecting the keyboard's hidden state\n//    - The bottom container animates back to its original height\n// \n// This example demonstrates real-time keyboard visibility detection, height measurement,\n// and UI adaptation based on keyboard state, showcasing the main features of the\n// flutter_keyboard_visibility package.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2023-12-20T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPamAG",
    "tutorial": "# Flutter Keyboard Visibility Package: Tutorial\n\n## Installation\n\nTo get started with the `flutter_keyboard_visibility` package, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_keyboard_visibility: ^5.4.0\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Basic Usage\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:flutter_keyboard_visibility/flutter_keyboard_visibility.dart';\n```\n\n2. Wrap your main widget with `KeyboardVisibilityBuilder`:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return KeyboardVisibilityBuilder(\n      builder: (context, isKeyboardVisible) {\n        return Scaffold(\n          appBar: AppBar(title: Text('Keyboard Visibility Demo')),\n          body: Center(\n            child: Text(\n              isKeyboardVisible ? 'Keyboard is visible' : 'Keyboard is hidden',\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n## Advanced Usage\n\n### Using KeyboardVisibilityController\n\nFor more control over keyboard visibility events, you can use `KeyboardVisibilityController`:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late KeyboardVisibilityController _keyboardVisibilityController;\n\n  @override\n  void initState() {\n    super.initState();\n    _keyboardVisibilityController = KeyboardVisibilityController();\n    _keyboardVisibilityController.onChange.listen((bool visible) {\n      print('Keyboard visibility changed. Is visible: $visible');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Advanced Keyboard Visibility Demo')),\n      body: Center(\n        child: TextField(\n          decoration: InputDecoration(hintText: 'Type something...'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nOn Android, the package uses a `ViewTreeObserver` to detect changes in the window's dimensions, which indicate keyboard visibility changes.\n\n### iOS\n\nFor iOS, the package utilizes `NotificationCenter` to observe keyboard show and hide notifications.\n\n### Web\n\nOn the web platform, the package listens for the `resize` event on the window object to detect potential keyboard visibility changes.\n\n### Desktop (macOS, Windows, Linux)\n\nFor desktop platforms, the package provides basic functionality, but keyboard detection might not be as reliable as on mobile platforms due to the nature of desktop keyboards.\n\n## Best Practices\n\n1. Always dispose of the `KeyboardVisibilityController` when it's no longer needed to prevent memory leaks.\n2. Use `KeyboardVisibilityBuilder` for simple use cases and `KeyboardVisibilityController` for more complex scenarios.\n3. Test your app on various devices and platforms to ensure consistent behavior.\n\nBy following this tutorial, you'll be able to effectively implement keyboard visibility detection in your Flutter applications, creating more responsive and user-friendly interfaces across different platforms.",
    "author": "jasonrai.ca",
    "shortDescription": "Flutter plugin for discovering the state of the soft-keyboard visibility on Android and iOS.",
    "tags": [
      "keyboard",
      "ui",
      "visibility",
      "input"
    ],
    "likesCount": 964
  },
  {
    "shortDescription": "Easily make Flutter apps responsive. Automatically adapt UI to different screen sizes. Responsiveness made simple.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "wwb7mhit",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFlU"
      }
    ],
    "tags": [
      "responsive",
      "adaptive",
      "layout",
      "ui",
      "cross-platform"
    ],
    "author": "codelessly.com",
    "_type": "package",
    "likesCount": 2967,
    "lastUpdate": "2024-08-25T18:30:00.000Z",
    "tutorial": "# Responsive Framework Tutorial: Implementing Adaptive UIs in Flutter\n\nIn this tutorial, we'll walk through the process of implementing the Responsive Framework in a Flutter project. We'll cover setup, basic usage, and some advanced features.\n\n## Step 1: Add the Package\n\nFirst, add the `responsive_framework` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  responsive_framework: ^1.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Wrap Your App with ResponsiveWrapper\n\nIn your `main.dart` file, wrap your `MaterialApp` with `ResponsiveWrapper`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:responsive_framework/responsive_framework.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      builder: (context, child) => ResponsiveWrapper.builder(\n        child,\n        maxWidth: 1200,\n        minWidth: 480,\n        defaultScale: true,\n        breakpoints: [\n          ResponsiveBreakpoint.resize(480, name: MOBILE),\n          ResponsiveBreakpoint.autoScale(800, name: TABLET),\n          ResponsiveBreakpoint.resize(1000, name: DESKTOP),\n        ],\n      ),\n      home: HomePage(),\n    );\n  }\n}\n```\n\n## Step 3: Create Responsive Layouts\n\nUse responsive widgets to create adaptive layouts:\n\n```dart\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Responsive Demo')),\n      body: ResponsiveRowColumn(\n        rowMainAxisAlignment: MainAxisAlignment.center,\n        rowPadding: EdgeInsets.all(30),\n        columnMainAxisAlignment: MainAxisAlignment.center,\n        columnPadding: EdgeInsets.all(30),\n        layout: ResponsiveWrapper.of(context).isSmallerThan(DESKTOP)\n            ? ResponsiveRowColumnType.COLUMN\n            : ResponsiveRowColumnType.ROW,\n        children: [\n          ResponsiveRowColumnItem(\n            child: Container(\n              width: 200,\n              height: 200,\n              color: Colors.blue,\n              child: Center(child: Text('Box 1')),\n            ),\n          ),\n          ResponsiveRowColumnItem(\n            child: Container(\n              width: 200,\n              height: 200,\n              color: Colors.green,\n              child: Center(child: Text('Box 2')),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Use ResponsiveValue for Dynamic Properties\n\nAdjust properties based on screen size:\n\n```dart\nResponsiveValue<double>(\n  context,\n  defaultValue: 24.0,\n  valueWhen: [\n    Condition.smallerThan(name: TABLET, value: 18.0),\n    Condition.largerThan(name: TABLET, value: 28.0),\n  ],\n).value\n```\n\n## Step 5: Implement Conditional Rendering\n\nShow or hide widgets based on screen size:\n\n```dart\nResponsiveVisibility(\n  visible: false,\n  visibleWhen: [Condition.largerThan(name: TABLET)],\n  child: Text('Only visible on large screens'),\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n- Use `SystemChrome.setPreferredOrientations()` to control allowed orientations.\n- Consider using `MediaQuery.of(context).padding` to account for system UI overlays.\n\n### iOS\n- Implement `safe area` to handle notches and home indicators.\n- Use `CupertinoApp` instead of `MaterialApp` for iOS-specific design.\n\n### Web\n- Test your app on various browsers and screen sizes.\n- Consider implementing different layouts for mobile and desktop web views.\n\nBy following these steps and considering platform-specific details, you can create a truly responsive and adaptive Flutter application using the Responsive Framework package.",
    "tutorialIncluded": true,
    "_rev": "eaCZ7mIhmiYZX5KGqJmPZK",
    "description": "# Responsive Framework in Flutter: Building Adaptive UIs\n\n## Introduction\n\nIn the ever-evolving world of mobile and web development, creating responsive user interfaces is crucial for providing a seamless experience across various devices and screen sizes. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful package called `responsive_framework` to address this challenge.\n\n## What is Responsive Framework?\n\nThe `responsive_framework` package is a comprehensive solution for implementing responsive design in Flutter applications. It provides a set of widgets and utilities that allow developers to create adaptive layouts with ease. This framework enables your app to automatically adjust its layout and content based on the screen size and orientation of the device it's running on.\n\n## Key Features\n\n1. **Breakpoints**: Define custom breakpoints to specify how your layout should change at different screen sizes.\n\n2. **Responsive Widgets**: Utilize widgets like `ResponsiveRowColumn` and `ResponsiveGridView` to create flexible layouts.\n\n3. **Scaling**: Automatically scale your UI elements based on the screen size.\n\n4. **Conditional Rendering**: Show or hide widgets based on the current screen size or device type.\n\n5. **Responsive Value**: Dynamically adjust values (like font sizes or padding) based on the screen dimensions.\n\n6. **Device Preview**: Test your app's responsiveness across various device sizes directly in your development environment.\n\n## Benefits of Using Responsive Framework\n\n- **Consistency**: Maintain a consistent user experience across different devices and orientations.\n- **Efficiency**: Reduce development time by avoiding the need to create separate layouts for different screen sizes.\n- **Flexibility**: Easily adapt your UI to new device sizes and form factors as they emerge.\n- **Maintainability**: Centralize your responsive logic, making it easier to update and maintain your codebase.\n\nIn the following sections, we'll dive deeper into how to implement and use the Responsive Framework in your Flutter projects, ensuring your applications look great on any device.",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1vkd",
        "_type": "reference",
        "_key": "t1kd1oao"
      }
    ],
    "_id": "V06bsD4sX3T8NTHrBPamQK",
    "slug": {
      "current": "responsive_framework",
      "_type": "slug"
    },
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CcrR",
        "_type": "reference",
        "_key": "txn70k5t"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:responsive_framework/responsive_framework.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Wrap MaterialApp with ResponsiveWrapper\n    return MaterialApp(\n      builder: (context, child) => ResponsiveWrapper.builder(\n        child,\n        maxWidth: 1200,\n        minWidth: 480,\n        defaultScale: true,\n        breakpoints: [\n          ResponsiveBreakpoint.resize(480, name: MOBILE),\n          ResponsiveBreakpoint.autoScale(800, name: TABLET),\n          ResponsiveBreakpoint.resize(1000, name: DESKTOP),\n        ],\n      ),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Responsive Framework Demo'),\n      ),\n      // Step 2: Use ResponsiveRowColumn for adaptive layout\n      body: ResponsiveRowColumn(\n        layout: ResponsiveWrapper.of(context).isSmallerThan(DESKTOP)\n            ? ResponsiveRowColumnType.COLUMN\n            : ResponsiveRowColumnType.ROW,\n        rowMainAxisAlignment: MainAxisAlignment.center,\n        rowPadding: EdgeInsets.all(30),\n        columnMainAxisAlignment: MainAxisAlignment.center,\n        columnPadding: EdgeInsets.all(30),\n        children: [\n          ResponsiveRowColumnItem(\n            child: _buildBox(context, 'Box 1', Colors.blue),\n          ),\n          ResponsiveRowColumnItem(\n            child: _buildBox(context, 'Box 2', Colors.green),\n          ),\n          // Step 3: Use ResponsiveVisibility for conditional rendering\n          ResponsiveRowColumnItem(\n            child: ResponsiveVisibility(\n              visible: false,\n              visibleWhen: [Condition.largerThan(name: TABLET)],\n              child: _buildBox(context, 'Large Screen Only', Colors.red),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildBox(BuildContext context, String text, Color color) {\n    // Step 4: Use ResponsiveValue for dynamic properties\n    final fontSize = ResponsiveValue<double>(\n      context,\n      defaultValue: 24.0,\n      valueWhen: [\n        Condition.smallerThan(name: TABLET, value: 18.0),\n        Condition.largerThan(name: TABLET, value: 28.0),\n      ],\n    ).value;\n\n    return Container(\n      width: 200,\n      height: 200,\n      color: color,\n      child: Center(\n        child: Text(\n          text,\n          style: TextStyle(fontSize: fontSize, color: Colors.white),\n        ),\n      ),\n    );\n  }\n}\n\n// Application flow explanation:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the ResponsiveWrapper, which will manage the app's responsiveness.\n// 3. The HomePage is displayed, which uses ResponsiveRowColumn for its layout.\n// 4. Depending on the screen size, the layout will be either a row (on larger screens) or a column (on smaller screens).\n// 5. Two boxes are always displayed, while a third box is only visible on screens larger than a tablet.\n// 6. The font size of the text in each box is dynamically adjusted based on the screen size.\n// 7. As the user resizes the window or rotates their device, the layout and sizes will automatically adjust.\n\n// This example demonstrates the key features of the responsive_framework package:\n// - Responsive layout using ResponsiveRowColumn\n// - Conditional rendering with ResponsiveVisibility\n// - Dynamic property adjustment with ResponsiveValue\n// - Breakpoint-based responsiveness set up in the ResponsiveWrapper\n```",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:33Z",
    "name": "responsive_framework",
    "_updatedAt": "2024-09-06T04:11:58Z",
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ]
  },
  {
    "_type": "package",
    "tags": [
      "deeplink",
      "app-links",
      "universal-links",
      "custom-url-schemes",
      "web-to-app",
      "navigation"
    ],
    "lastUpdate": "2024-08-23T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPamgO",
    "pubPoint": 160,
    "author": "openapi4j.org",
    "packageImage": null,
    "tutorial": "# App Links Package Tutorial\n\nThis tutorial will guide you through the process of implementing the `app_links` package in your Flutter application, including platform-specific configurations.\n\n## Step 1: Install the Package\n\nAdd the following to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  app_links: ^latest_version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:app_links/app_links.dart';\n```\n\n## Step 3: Initialize AppLinks\n\nIn your `RealFlutter` class, initialize the `AppLinks` instance:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late AppLinks _appLinks;\n\n  @override\n  void initState() {\n    super.initState();\n    initAppLinks();\n  }\n\n  Future<void> initAppLinks() async {\n    _appLinks = AppLinks();\n\n    // Check initial link if app was launched from terminated state\n    final appLink = await _appLinks.getInitialAppLink();\n    if (appLink != null) {\n      handleAppLink(appLink);\n    }\n\n    // Listen for app links while the app is running\n    _appLinks.uriLinkStream.listen((Uri? uri) {\n      if (uri != null) {\n        handleAppLink(uri);\n      }\n    });\n  }\n\n  void handleAppLink(Uri uri) {\n    // Handle the incoming link here\n    print('Received app link: $uri');\n    // Add your navigation logic here\n  }\n\n  // ... rest of your widget code\n}\n```\n\n## Step 4: Platform-Specific Configuration\n\n### Android Configuration\n\n1. Open `android/app/src/main/AndroidManifest.xml`\n2. Add the following inside the `<activity>` tag:\n\n```xml\n<intent-filter android:autoVerify=\"true\">\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"https\" android:host=\"your.domain.com\" />\n</intent-filter>\n```\n\n3. For custom URL schemes, add:\n\n```xml\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"yourapp\" />\n</intent-filter>\n```\n\n### iOS Configuration\n\n1. Open `ios/Runner/Info.plist`\n2. Add the following:\n\n```xml\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleTypeRole</key>\n        <string>Editor</string>\n        <key>CFBundleURLName</key>\n        <string>your.domain.com</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>yourapp</string>\n        </array>\n    </dict>\n</array>\n```\n\n3. For Universal Links, create an `apple-app-site-association` file and host it on your server at `https://your.domain.com/.well-known/apple-app-site-association`\n\n```json\n{\n  \"applinks\": {\n    \"apps\": [],\n    \"details\": [\n      {\n        \"appID\": \"TEAM_ID.BUNDLE_ID\",\n        \"paths\": [\"*\"]\n      }\n    ]\n  }\n}\n```\n\nReplace `TEAM_ID` with your Apple Developer Team ID and `BUNDLE_ID` with your app's bundle identifier.\n\nWith these configurations in place, your app will be able to handle both custom URL schemes and universal links on both Android and iOS platforms.",
    "_updatedAt": "2024-09-06T04:11:59Z",
    "slug": {
      "current": "app_links",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmPfs",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:app_links/app_links.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late AppLinks _appLinks;\n  String _lastLink = 'No link received';\n\n  @override\n  void initState() {\n    super.initState();\n    initAppLinks();\n  }\n\n  // Step 1: Initialize AppLinks\n  Future<void> initAppLinks() async {\n    _appLinks = AppLinks();\n\n    // Step 2: Check for initial link\n    final appLink = await _appLinks.getInitialAppLink();\n    if (appLink != null) {\n      setState(() {\n        _lastLink = appLink.toString();\n      });\n      handleAppLink(appLink);\n    }\n\n    // Step 3: Listen for app links while the app is running\n    _appLinks.uriLinkStream.listen((Uri? uri) {\n      if (uri != null) {\n        setState(() {\n          _lastLink = uri.toString();\n        });\n        handleAppLink(uri);\n      }\n    });\n  }\n\n  // Step 4: Handle the incoming link\n  void handleAppLink(Uri uri) {\n    // Here you can implement your navigation logic based on the URI\n    print('Handling app link: $uri');\n    \n    // Example: Navigate to a specific page based on the path\n    if (uri.path == '/products') {\n      navigateToProducts();\n    } else if (uri.path == '/profile') {\n      navigateToProfile();\n    }\n  }\n\n  // Step 5: Navigation methods (placeholders for this example)\n  void navigateToProducts() {\n    print('Navigating to products page');\n    // Implement actual navigation here\n  }\n\n  void navigateToProfile() {\n    print('Navigating to profile page');\n    // Implement actual navigation here\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('RealFlutter App Links Demo'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Text(\n                'Last received link:',\n                style: TextStyle(fontSize: 16),\n              ),\n              SizedBox(height: 8),\n              Text(\n                _lastLink,\n                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n                textAlign: TextAlign.center,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes and sets up AppLinks in the initState method.\n// 2. It checks for any initial link that might have launched the app.\n// 3. It sets up a listener for any incoming links while the app is running.\n// 4. When a link is received (either initial or while running), it updates the UI\n//    to display the link and calls handleAppLink().\n// 5. handleAppLink() processes the URI and determines which page to navigate to.\n// 6. The app then calls the appropriate navigation method (e.g., navigateToProducts).\n// 7. In a real application, these navigation methods would use Flutter's\n//    navigation system to push new routes onto the stack.\n\n// Note: To test this, you would need to set up your app to handle specific URLs\n// as described in the platform-specific configuration steps. You can then test\n// by opening these URLs on the device, which should launch or bring your app\n// to the foreground and trigger the appropriate navigation.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 712,
    "_createdAt": "2024-08-28T22:17:34Z",
    "name": "app_links",
    "tutorialIncluded": true,
    "description": "# Understanding the App Links Package in Flutter\n\n## Introduction\n\nThe `app_links` package is a powerful tool for Flutter developers looking to implement deep linking and app linking functionality in their applications. This package provides a seamless way to handle incoming links, whether your app is already running or needs to be launched.\n\n## Key Features\n\n1. **Universal Links Support**: Enables iOS Universal Links and Android App Links.\n2. **Custom Scheme Links**: Supports custom URL schemes for both Android and iOS.\n3. **Background Handling**: Can handle links even when the app is not running.\n4. **Configurable**: Offers various configuration options to suit different app requirements.\n\n## Why Use App Links?\n\nApp links are crucial for improving user experience and engagement. They allow users to directly access specific content within your app from external sources like websites, emails, or other apps. This seamless navigation enhances user satisfaction and can lead to increased app usage.\n\n## How It Works\n\nThe `app_links` package works by setting up listeners for incoming links. When a link is received, it triggers a callback in your Flutter application, allowing you to parse the link and navigate to the appropriate screen or perform specific actions based on the link's content.\n\n## Getting Started\n\nTo start using the `app_links` package in your Flutter project, you'll need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  app_links: ^latest_version\n```\n\nReplace `latest_version` with the current version of the package.\n\nIn the next sections, we'll dive deeper into how to implement and use this package in your Flutter applications.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "v7p4lsg1"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVRl",
        "_type": "reference",
        "_key": "2sj85smi"
      }
    ],
    "shortDescription": "Android App Links, Deep Links, iOs Universal Links and Custom URL schemes handler for Flutter (desktop included).",
    "similarPackages": []
  },
  {
    "_type": "package",
    "shortDescription": "Jiffy is a date time dart package for parsing, manipulating, querying and formatting dates and time",
    "lastUpdate": "2024-05-14T18:30:00.000Z",
    "tutorial": "# Jiffy Tutorial: Getting Started with Date and Time Manipulation in Flutter\n\n## Installation\n\nTo start using Jiffy in your Flutter project, follow these steps:\n\n1. Open your `pubspec.yaml` file.\n2. Add Jiffy to your dependencies:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  jiffy: ^6.2.1  # Use the latest version\n```\n\n3. Run `flutter pub get` in your terminal or click \"Pub get\" in your IDE.\n\n## Basic Usage\n\nFirst, import the Jiffy package in your Dart file:\n\n```dart\nimport 'package:jiffy/jiffy.dart';\n```\n\nNow you're ready to use Jiffy in your Flutter application!\n\n## Parsing Dates\n\nJiffy can parse dates in various formats:\n\n```dart\n// Parse from a string\nvar date1 = Jiffy.parse(\"2023-03-15\");\n\n// Parse from DateTime\nvar date2 = Jiffy.parseFromDateTime(DateTime.now());\n\n// Parse from ISO 8601\nvar date3 = Jiffy.parseFromIsoString(\"2023-03-15T14:30:00Z\");\n```\n\n## Formatting Dates\n\nJiffy provides flexible formatting options:\n\n```dart\nvar date = Jiffy.parse(\"2023-03-15\");\n\nprint(date.format()); // Default: 2023-03-15\nprint(date.format(pattern: \"MMMM do yyyy, h:mm:ss a\")); // March 15th 2023, 12:00:00 AM\nprint(date.yMMMd); // Mar 15, 2023\n```\n\n## Date Manipulation\n\nEasily add or subtract time units:\n\n```dart\nvar date = Jiffy.parse(\"2023-03-15\");\n\nprint(date.add(days: 5).format()); // 2023-03-20\nprint(date.subtract(months: 1).format()); // 2023-02-15\nprint(date.startOf(Unit.week).format()); // 2023-03-12 (assuming Sunday is the start of the week)\n```\n\n## Comparison\n\nCompare dates with ease:\n\n```dart\nvar date1 = Jiffy.parse(\"2023-03-15\");\nvar date2 = Jiffy.parse(\"2023-03-20\");\n\nprint(date1.isBefore(date2)); // true\nprint(date1.isAfter(date2)); // false\nprint(date1.isSame(date2, Unit.year)); // true\n```\n\n## Localization\n\nJiffy supports multiple languages:\n\n```dart\nawait Jiffy.locale(\"fr\"); // Set locale to French\nvar date = Jiffy.parse(\"2023-03-15\");\nprint(date.format(pattern: \"MMMM do yyyy\")); // mars 15e 2023\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional configuration is needed. Jiffy works out of the box.\n\n### iOS\n\nFor iOS, you need to update your `Info.plist` file to include the locales you want to support. Add the following keys:\n\n```xml\n<key>CFBundleLocalizations</key>\n<array>\n  <string>en</string>\n  <string>fr</string>\n  <!-- Add other languages as needed -->\n</array>\n```\n\n### Web\n\nFor web projects, make sure to include the necessary locale data files in your `web/index.html`:\n\n```html\n<script src=\"packages/intl/locale-data/jsonp/en.js\"></script>\n<script src=\"packages/intl/locale-data/jsonp/fr.js\"></script>\n<!-- Add other languages as needed -->\n```\n\nBy following these platform-specific considerations, you ensure that Jiffy works seamlessly across different platforms in your Flutter project.",
    "slug": {
      "current": "jiffy",
      "_type": "slug"
    },
    "author": "",
    "_rev": "eaCZ7mIhmiYZX5KGqJmPmQ",
    "similarPackages": [],
    "tutorialIncluded": true,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1001,
    "dependentPackages": [],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:36Z",
    "name": "jiffy",
    "pubPoint": 160,
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfCdI",
        "_type": "reference",
        "_key": "gfbnt01c"
      }
    ],
    "_id": "V06bsD4sX3T8NTHrBPamwS",
    "tags": [
      "date",
      "time",
      "datetime",
      "parsing",
      "formatting"
    ],
    "_updatedAt": "2024-09-06T04:12:00Z",
    "description": "# Jiffy: A Powerful Date and Time Manipulation Package for Flutter\n\n## Introduction\n\nIn the world of Flutter development, handling dates and times efficiently is crucial for many applications. While Dart provides basic date and time functionality, developers often need more advanced features for parsing, formatting, and manipulating date-time objects. This is where the Jiffy package comes to the rescue.\n\nJiffy is a lightweight yet powerful date and time manipulation library for Flutter and Dart. It offers a wide range of features that simplify working with dates, making it an essential tool for Flutter developers.\n\n## Key Features\n\n1. **Parsing**: Jiffy can parse various date formats, including ISO 8601, RFC 2822, and custom formats.\n\n2. **Formatting**: It provides flexible date formatting options, allowing you to display dates in any desired format.\n\n3. **Manipulation**: Easily add or subtract time units (years, months, weeks, days, hours, minutes, seconds) from dates.\n\n4. **Comparison**: Compare dates and determine their relative positions (before, after, same).\n\n5. **Localization**: Jiffy supports multiple languages and locales for date formatting.\n\n6. **Time Zones**: Work with different time zones effortlessly.\n\n7. **Relative Time**: Generate human-readable relative time strings (e.g., \"2 days ago\", \"in 3 hours\").\n\n8. **Immutability**: All operations return new Jiffy objects, ensuring immutability.\n\n## Why Choose Jiffy?\n\n1. **Simplicity**: Jiffy provides an intuitive API that's easy to learn and use.\n2. **Versatility**: It covers a wide range of date-time operations, reducing the need for multiple packages.\n3. **Performance**: Jiffy is designed to be lightweight and efficient.\n4. **Active Development**: The package is actively maintained and updated.\n\nIn the following sections, we'll explore how to integrate Jiffy into your Flutter projects and demonstrate its powerful features through practical examples.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:jiffy/jiffy.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Jiffy Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const JiffyDemoPage(),\n    );\n  }\n}\n\nclass JiffyDemoPage extends StatefulWidget {\n  const JiffyDemoPage({Key? key}) : super(key: key);\n\n  @override\n  _JiffyDemoPageState createState() => _JiffyDemoPageState();\n}\n\nclass _JiffyDemoPageState extends State<JiffyDemoPage> {\n  late Jiffy _currentDate;\n  String _formattedDate = '';\n  String _relativeTime = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _initializeJiffy();\n  }\n\n  // Step 1: Initialize Jiffy with the current date\n  void _initializeJiffy() {\n    _currentDate = Jiffy.now();\n    _updateDisplays();\n  }\n\n  // Step 2: Update the formatted date and relative time displays\n  void _updateDisplays() {\n    setState(() {\n      _formattedDate = _currentDate.format(pattern: \"MMMM do yyyy, h:mm:ss a\");\n      _relativeTime = _currentDate.fromNow();\n    });\n  }\n\n  // Step 3: Add days to the current date\n  void _addDays() {\n    setState(() {\n      _currentDate = _currentDate.add(days: 1);\n      _updateDisplays();\n    });\n  }\n\n  // Step 4: Subtract days from the current date\n  void _subtractDays() {\n    setState(() {\n      _currentDate = _currentDate.subtract(days: 1);\n      _updateDisplays();\n    });\n  }\n\n  // Step 5: Change the locale (language) for date formatting\n  Future<void> _changeLocale(String locale) async {\n    await Jiffy.locale(locale);\n    _updateDisplays();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Jiffy Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'Current Date:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            Text(\n              _formattedDate,\n              style: Theme.of(context).textTheme.subtitle1,\n            ),\n            const SizedBox(height: 20),\n            Text(\n              'Relative Time:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            Text(\n              _relativeTime,\n              style: Theme.of(context).textTheme.subtitle1,\n            ),\n            const SizedBox(height: 20),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(\n                  onPressed: _subtractDays,\n                  child: const Text('Subtract Day'),\n                ),\n                const SizedBox(width: 20),\n                ElevatedButton(\n                  onPressed: _addDays,\n                  child: const Text('Add Day'),\n                ),\n              ],\n            ),\n            const SizedBox(height: 20),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(\n                  onPressed: () => _changeLocale('en'),\n                  child: const Text('English'),\n                ),\n                const SizedBox(width: 20),\n                ElevatedButton(\n                  onPressed: () => _changeLocale('fr'),\n                  child: const Text('French'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes with the current date using Jiffy.\n// 2. The formatted date and relative time are displayed on the screen.\n// 3. Users can add or subtract days using the buttons, which updates the displays.\n// 4. Users can switch between English and French locales, changing the date format.\n// 5. The app demonstrates Jiffy's capabilities in parsing, formatting, \n//    manipulation, and localization of dates.\n\n// Key Jiffy features demonstrated:\n// - Parsing current date: Jiffy.now()\n// - Formatting dates: _currentDate.format(pattern: \"...\")\n// - Date manipulation: _currentDate.add(days: 1) and _currentDate.subtract(days: 1)\n// - Relative time: _currentDate.fromNow()\n// - Localization: Jiffy.locale(locale)\n\n// This example provides a practical demonstration of how Jiffy can be integrated\n// into a Flutter application to handle various date and time operations efficiently.\n```"
  },
  {
    "_createdAt": "2024-08-28T22:17:37Z",
    "tutorialIncluded": true,
    "_type": "package",
    "description": "# Understanding the Injectable Package in Flutter\n\n## What is Injectable?\n\nInjectable is a powerful dependency injection system for Dart and Flutter. It simplifies the process of managing dependencies in your application, making your code more modular, testable, and maintainable.\n\n## Key Features of Injectable\n\n1. **Compile-time DI**: Injectable generates dependency injection code at compile-time, reducing runtime overhead.\n\n2. **Easy Configuration**: Simple annotations make it easy to configure your dependencies.\n\n3. **Scoped Injection**: Support for different scopes like singleton, lazy singleton, and factory.\n\n4. **Environment-based Injection**: Easily switch implementations based on the current environment.\n\n5. **Asynchronous Factories**: Support for asynchronous dependency resolution.\n\n6. **Code Generation**: Automatic generation of boilerplate code for dependency injection.\n\n## Why Use Injectable?\n\n- **Improved Testability**: Easily swap dependencies in tests.\n- **Better Code Organization**: Clear separation of concerns and dependency management.\n- **Reduced Boilerplate**: Less manual dependency management code.\n- **Flexibility**: Easily change implementations without modifying dependent code.\n\nInjectable is an excellent choice for Flutter developers looking to implement a robust dependency injection system in their projects.",
    "shortDescription": "Injectable is a convenient code generator for get_it. Inspired by Angular DI, Guice DI and inject.dart.",
    "_id": "V06bsD4sX3T8NTHrBPanCW",
    "similarPackages": [
      {
        "_key": "d7lpwirq",
        "_ref": "Rx1Nho763d29lawKra1VXT",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "mw4zvjtx"
      }
    ],
    "name": "injectable",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference",
        "_key": "onluuvo7"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWqB",
        "_type": "reference",
        "_key": "w5f1kaos"
      }
    ],
    "_updatedAt": "2024-09-06T04:12:02Z",
    "pubPoint": 160,
    "tags": [
      "dependency-injection",
      "di",
      "inversion-of-control",
      "code-generation"
    ],
    "likesCount": 1228,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "lastUpdate": "2024-07-20T18:30:00.000Z",
    "tutorial": "# Injectable Package Tutorial\n\nThis tutorial will guide you through setting up and using the Injectable package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  injectable: ^2.1.0\n\ndev_dependencies:\n  injectable_generator: ^2.1.3\n  build_runner: ^2.3.3\n```\n\nRun `flutter pub get` to fetch the dependencies.\n\n## Step 2: Create Injectable Classes\n\nCreate a file `services.dart`:\n\n```dart\nimport 'package:injectable/injectable.dart';\n\n@injectable\nclass ApiService {\n  void fetchData() {\n    // API logic here\n  }\n}\n\n@injectable\nclass RealFlutter {\n  final ApiService _apiService;\n\n  RealFlutter(this._apiService);\n\n  void doSomething() {\n    _apiService.fetchData();\n  }\n}\n```\n\n## Step 3: Configure Injection\n\nCreate a file `injection.dart`:\n\n```dart\nimport 'package:get_it/get_it.dart';\nimport 'package:injectable/injectable.dart';\n\nimport 'injection.config.dart';\n\nfinal getIt = GetIt.instance;\n\n@InjectableInit(\n  initializerName: 'init', // default\n  preferRelativeImports: true, // default\n  asExtension: false, // default\n)\nvoid configureDependencies() => init(getIt);\n```\n\n## Step 4: Generate Injection Code\n\nRun the following command to generate the injection code:\n\n```\nflutter pub run build_runner build --delete-conflicting-outputs\n```\n\n## Step 5: Use Injected Dependencies\n\nIn your `main.dart` file:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'injection.dart';\n\nvoid main() {\n  configureDependencies();\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final realFlutter = getIt<RealFlutter>();\n    realFlutter.doSomething();\n    // Rest of your app\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nNo additional setup is required for Android.\n\n### iOS\n\nNo additional setup is required for iOS.\n\n### Web\n\nFor web projects, ensure you have the latest version of the `build_runner` package, as some older versions may have issues with web compilation.\n\n### Desktop (Windows, macOS, Linux)\n\nNo additional setup is required for desktop platforms.\n\nBy following these steps, you'll have successfully integrated the Injectable package into your Flutter project across all supported platforms.",
    "slug": {
      "current": "injectable",
      "_type": "slug"
    },
    "author": "codeness.ly",
    "_rev": "eaCZ7mIhmiYZX5KGqJmPsy",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:get_it/get_it.dart';\nimport 'package:injectable/injectable.dart';\n\n// Step 1: Import the generated injection file\nimport 'injection.config.dart';\n\n// Step 2: Create a GetIt instance\nfinal getIt = GetIt.instance;\n\n// Step 3: Configure the dependency injection\n@InjectableInit(\n  initializerName: 'init',\n  preferRelativeImports: true,\n  asExtension: false,\n)\nvoid configureDependencies() => init(getIt);\n\n// Step 4: Define injectable services\n@injectable\nclass ApiService {\n  Future<String> fetchData() async {\n    // Simulating API call\n    await Future.delayed(Duration(seconds: 2));\n    return 'Data from API';\n  }\n}\n\n@injectable\nclass DatabaseService {\n  Future<String> getData() async {\n    // Simulating database query\n    await Future.delayed(Duration(seconds: 1));\n    return 'Data from Database';\n  }\n}\n\n// Step 5: Define the main RealFlutter class\n@injectable\nclass RealFlutter {\n  final ApiService _apiService;\n  final DatabaseService _databaseService;\n\n  RealFlutter(this._apiService, this._databaseService);\n\n  Future<String> getCombinedData() async {\n    final apiData = await _apiService.fetchData();\n    final dbData = await _databaseService.getData();\n    return '$apiData\\n$dbData';\n  }\n}\n\n// Step 6: Create the main app\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  configureDependencies();\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Injectable Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: MyHomePage(title: 'Injectable Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  String _data = 'Press the button to fetch data';\n\n  // Step 7: Use the injected RealFlutter instance\n  final RealFlutter _realFlutter = getIt<RealFlutter>();\n\n  Future<void> _fetchData() async {\n    setState(() {\n      _data = 'Loading...';\n    });\n    final result = await _realFlutter.getCombinedData();\n    setState(() {\n      _data = result;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'Fetched Data:',\n            ),\n            Text(\n              _data,\n              style: Theme.of(context).textTheme.headlineSmall,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _fetchData,\n        tooltip: 'Fetch Data',\n        child: Icon(Icons.refresh),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts in the main() function, where we first ensure Flutter bindings are initialized.\n// 2. We call configureDependencies() to set up our dependency injection.\n// 3. The MyApp widget is created, which sets up the MaterialApp with our MyHomePage as the home widget.\n// 4. In MyHomePage, we use getIt to retrieve an instance of RealFlutter.\n// 5. When the user presses the FloatingActionButton, _fetchData() is called.\n// 6. _fetchData() uses the injected RealFlutter instance to call getCombinedData().\n// 7. getCombinedData() in RealFlutter uses the injected ApiService and DatabaseService to fetch data.\n// 8. The fetched data is then displayed on the screen.\n\n// This example demonstrates:\n// - How to set up and use Injectable in a Flutter app\n// - How to create and use injectable services (ApiService, DatabaseService)\n// - How to use dependency injection to compose more complex classes (RealFlutter)\n// - How to retrieve injected instances in your widgets\n// - Asynchronous operations with injected services\n```"
  },
  {
    "author": "begnis.dev",
    "subCategories": [
      {
        "_key": "50o0h7kl",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP",
        "_type": "reference"
      }
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-06-26T18:30:00.000Z",
    "name": "grouped_list",
    "_id": "V06bsD4sX3T8NTHrBPanSa",
    "pubPoint": 160,
    "shortDescription": "A Flutter ListView where the list items can be grouped into sections.",
    "tags": [
      "list",
      "listview",
      "grouping",
      "ui",
      "data-display"
    ],
    "likesCount": 1420,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:02Z",
    "slug": {
      "current": "grouped_list",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaR0s",
    "_type": "package",
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:grouped_list/grouped_list.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Grouped List Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: GroupedListDemo(),\n    );\n  }\n}\n\nclass GroupedListDemo extends StatefulWidget {\n  @override\n  _GroupedListDemoState createState() => _GroupedListDemoState();\n}\n\nclass _GroupedListDemoState extends State<GroupedListDemo> {\n  List _elements = [\n    {'name': 'John', 'group': 'Team A'},\n    {'name': 'Will', 'group': 'Team B'},\n    {'name': 'Beth', 'group': 'Team A'},\n    {'name': 'Miranda', 'group': 'Team B'},\n    {'name': 'Mike', 'group': 'Team C'},\n    {'name': 'Danny', 'group': 'Team C'},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Grouped List Example')),\n      body: GroupedListView<dynamic, String>(\n        elements: _elements,\n        groupBy: (element) => element['group'],\n        groupSeparatorBuilder: _buildGroupSeparator,\n        itemBuilder: _buildListItem,\n        order: GroupedListOrder.ASC,\n        useStickyGroupSeparators: true,\n        groupComparator: (value1, value2) => value2.compareTo(value1),\n        itemComparator: (item1, item2) =>\n            item1['name'].compareTo(item2['name']),\n        floatingHeader: true,\n        groupHeaderBuilder: _buildGroupHeader,\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addNewItem,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n\n  Widget _buildGroupSeparator(String groupByValue) {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Text(\n        groupByValue,\n        style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n\n  Widget _buildListItem(BuildContext context, dynamic element) {\n    return Card(\n      elevation: 4.0,\n      margin: EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),\n      child: ListTile(\n        contentPadding:\n            EdgeInsets.symmetric(horizontal: 20.0, vertical: 10.0),\n        leading: Icon(Icons.account_circle),\n        title: Text(element['name']),\n        trailing: Icon(Icons.arrow_forward),\n      ),\n    );\n  }\n\n  Widget _buildGroupHeader(dynamic element) {\n    return Container(\n      height: 50,\n      child: Align(\n        alignment: Alignment.center,\n        child: Container(\n          decoration: BoxDecoration(\n            color: Colors.blue[300],\n            borderRadius: BorderRadius.circular(10.0),\n          ),\n          padding: EdgeInsets.symmetric(horizontal: 10.0, vertical: 5.0),\n          child: Text(\n            '${element['group']} header',\n            textAlign: TextAlign.center,\n            style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),\n          ),\n        ),\n      ),\n    );\n  }\n\n  void _addNewItem() {\n    setState(() {\n      _elements.add({\n        'name': 'New Item ${_elements.length + 1}',\n        'group': 'Team ${String.fromCharCode(65 + (_elements.length % 3))}'\n      });\n    });\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home page is set to GroupedListDemo, a StatefulWidget.\n// 3. In the build method of _GroupedListDemoState:\n//    - A Scaffold is created with an AppBar and a GroupedListView.\n//    - The GroupedListView is configured with various properties:\n//      a. elements: The list of items to be displayed.\n//      b. groupBy: A function that determines how items are grouped.\n//      c. groupSeparatorBuilder: Builds the separator between groups.\n//      d. itemBuilder: Builds each list item.\n//      e. order: Sets the order of the groups.\n//      f. useStickyGroupSeparators: Keeps group separators at the top while scrolling.\n//      g. groupComparator and itemComparator: Define custom sorting for groups and items.\n//      h. floatingHeader: Enables a floating header for each group.\n//      i. groupHeaderBuilder: Builds a header for each group.\n// 4. The FloatingActionButton allows adding new items to the list.\n// 5. When a new item is added:\n//    - The _addNewItem method is called.\n//    - A new item is created with a name and assigned to a team (group).\n//    - setState is called to rebuild the widget with the updated list.\n// 6. The GroupedListView efficiently renders the items in their respective groups,\n//    applying all the custom styling and behavior defined in the builder methods.\n```",
    "packageImage": null,
    "tutorial": "# Grouped List Package: Tutorial\n\n## Getting Started\n\nTo begin using the `grouped_list` package in your Flutter project, follow these steps:\n\n1. Add the package to your `pubspec.yaml` file:\n\n   ```yaml\n   dependencies:\n     grouped_list: ^5.1.2\n   ```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n   ```dart\n   import 'package:grouped_list/grouped_list.dart';\n   ```\n\n## Basic Implementation\n\nHere's a simple example of how to use `GroupedListView`:\n\n```dart\nGroupedListView<dynamic, String>(\n  elements: _elements,\n  groupBy: (element) => element['group'],\n  groupSeparatorBuilder: (String groupByValue) => Text(groupByValue),\n  itemBuilder: (context, dynamic element) => Text(element['name']),\n  order: GroupedListOrder.ASC,\n)\n```\n\n## Customization Options\n\n### Group Separator\n\nCustomize the group separator using `groupSeparatorBuilder`:\n\n```dart\ngroupSeparatorBuilder: (String value) => Padding(\n  padding: const EdgeInsets.all(8.0),\n  child: Text(\n    value,\n    style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n  ),\n),\n```\n\n### Item Builder\n\nDesign your list items with `itemBuilder`:\n\n```dart\nitemBuilder: (c, element) {\n  return Card(\n    elevation: 8.0,\n    margin: EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),\n    child: ListTile(\n      contentPadding:\n          EdgeInsets.symmetric(horizontal: 20.0, vertical: 10.0),\n      leading: Icon(Icons.account_circle),\n      title: Text(element['name']),\n      trailing: Icon(Icons.arrow_forward),\n    ),\n  );\n},\n```\n\n### Sorting\n\nControl the order of groups and items:\n\n```dart\norder: GroupedListOrder.DESC,\ngroupComparator: (group1, group2) => group2.compareTo(group1),\nitemComparator: (item1, item2) =>\n    item1['name'].compareTo(item2['name']),\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, consider using `CupertinoScrollbar` for a native feel:\n\n```dart\nCupertinoScrollbar(\n  child: GroupedListView<dynamic, String>(\n    // ... other properties\n  ),\n)\n```\n\n### Android\n\nFor Android, you might want to use `Material` design elements:\n\n```dart\nMaterial(\n  child: GroupedListView<dynamic, String>(\n    // ... other properties\n  ),\n)\n```\n\n### Web\n\nFor web applications, focus on responsive design:\n\n```dart\nLayoutBuilder(\n  builder: (context, constraints) {\n    return GroupedListView<dynamic, String>(\n      // ... other properties\n      itemExtent: constraints.maxWidth > 600 ? 80 : 60,\n    );\n  },\n)\n```\n\nBy following this tutorial, you'll be able to implement and customize the `grouped_list` package in your Flutter applications across various platforms.",
    "description": "# Grouped List Package in Flutter: A Comprehensive Overview\n\n## Introduction\n\nThe `grouped_list` package is a powerful tool for Flutter developers looking to create organized and visually appealing lists with grouped elements. This package simplifies the process of rendering items in groups, making it an ideal choice for applications that require categorized data presentation.\n\n## Key Features\n\n1. **Effortless Grouping**: Easily group list items based on any criteria you define.\n2. **Customizable Group Headers**: Create distinct and stylish headers for each group.\n3. **Flexible Item Layouts**: Design list items to fit your specific needs.\n4. **Sorting Options**: Sort groups and items within groups according to your requirements.\n5. **Performance Optimization**: Utilizes Flutter's efficient list view for smooth scrolling and rendering.\n\n## When to Use Grouped List\n\nThe `grouped_list` package is particularly useful in scenarios such as:\n\n- Contact lists grouped by first letter\n- Event schedules grouped by date\n- Product catalogs grouped by category\n- Task lists grouped by priority or status\n\n## Benefits\n\n- **Improved User Experience**: Organized data presentation enhances navigation and information retrieval.\n- **Time-Saving**: Reduces development time by handling complex grouping logic.\n- **Maintainability**: Clean separation of grouping logic from UI code.\n\nIn the following sections, we'll dive deeper into how to implement and customize the `grouped_list` package in your Flutter applications.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:17:40Z"
  },
  {
    "lastUpdate": "2023-07-08T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:03Z",
    "likesCount": 1167,
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:43Z",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaR44",
    "tags": [
      "swiper",
      "carousel",
      "slider",
      "ui",
      "animation"
    ],
    "name": "card_swiper",
    "shortDescription": "swiper/carousel for flutter, with multiple layouts, infinite loop. Compatible with Android & iOS.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:card_swiper/card_swiper.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Card Swiper Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: CardSwiperDemo(),\n    );\n  }\n}\n\nclass CardSwiperDemo extends StatefulWidget {\n  @override\n  _CardSwiperDemoState createState() => _CardSwiperDemoState();\n}\n\nclass _CardSwiperDemoState extends State<CardSwiperDemo> {\n  // Step 1: Define a list of image URLs for our cards\n  final List<String> imageUrls = [\n    'https://via.placeholder.com/350x150?text=Card+1',\n    'https://via.placeholder.com/350x150?text=Card+2',\n    'https://via.placeholder.com/350x150?text=Card+3',\n    'https://via.placeholder.com/350x150?text=Card+4',\n    'https://via.placeholder.com/350x150?text=Card+5',\n  ];\n\n  // Step 2: Create a SwiperController to programmatically control the swiper\n  SwiperController _controller = SwiperController();\n\n  // Step 3: Define the current swiper layout\n  SwiperLayout _currentLayout = SwiperLayout.DEFAULT;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Card Swiper Demo'),\n      ),\n      body: Column(\n        children: <Widget>[\n          // Step 4: Create the Swiper widget\n          Expanded(\n            child: Swiper(\n              itemBuilder: (BuildContext context, int index) {\n                // Step 5: Build each card\n                return ClipRRect(\n                  borderRadius: BorderRadius.circular(15.0),\n                  child: Image.network(\n                    imageUrls[index],\n                    fit: BoxFit.fill,\n                  ),\n                );\n              },\n              itemCount: imageUrls.length,\n              pagination: SwiperPagination(\n                builder: DotSwiperPaginationBuilder(\n                  activeColor: Colors.red,\n                  color: Colors.grey,\n                ),\n              ),\n              control: SwiperControl(),\n              layout: _currentLayout,\n              itemWidth: 300.0,\n              itemHeight: 200.0,\n              autoplay: true,\n              autoplayDelay: 3000,\n              loop: true,\n              controller: _controller,\n              onTap: (index) => print('Tapped index: $index'),\n            ),\n          ),\n          // Step 6: Add buttons to demonstrate different layouts and controls\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: <Widget>[\n                ElevatedButton(\n                  child: Text('Default'),\n                  onPressed: () => setState(() => _currentLayout = SwiperLayout.DEFAULT),\n                ),\n                ElevatedButton(\n                  child: Text('Stack'),\n                  onPressed: () => setState(() => _currentLayout = SwiperLayout.STACK),\n                ),\n                ElevatedButton(\n                  child: Text('Tinder'),\n                  onPressed: () => setState(() => _currentLayout = SwiperLayout.TINDER),\n                ),\n              ],\n            ),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: <Widget>[\n                ElevatedButton(\n                  child: Text('Previous'),\n                  onPressed: () => _controller.previous(),\n                ),\n                ElevatedButton(\n                  child: Text('Next'),\n                  onPressed: () => _controller.next(),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home page is set to CardSwiperDemo, a stateful widget.\n// 3. In the state class _CardSwiperDemoState:\n//    - We define a list of image URLs for our cards.\n//    - We create a SwiperController to programmatically control the swiper.\n//    - We define a variable to keep track of the current swiper layout.\n// 4. In the build method:\n//    - We create a Scaffold with an AppBar and a Column in the body.\n//    - The main content is a Swiper widget, which displays our cards.\n//    - The Swiper is customized with various properties like pagination, control, layout, etc.\n//    - Below the Swiper, we add two rows of buttons:\n//      - The first row allows changing the swiper layout (Default, Stack, Tinder).\n//      - The second row allows manual navigation (Previous, Next).\n// 5. When a user interacts with the app:\n//    - They can swipe through cards manually or let them auto-play.\n//    - They can tap on a card (which will print the index to the console).\n//    - They can change the layout using the buttons, which triggers a setState and rebuilds the widget.\n//    - They can manually navigate using the Previous/Next buttons, which use the SwiperController.\n// \n// This example showcases the versatility of the card_swiper package, \n// demonstrating features like custom layouts, autoplay, loop, and programmatic control.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tutorial": "# Tutorial: Implementing Card Swiper in Flutter\n\nThis tutorial will guide you through the process of integrating the `card_swiper` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `card_swiper` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  card_swiper: ^2.0.4  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:card_swiper/card_swiper.dart';\n```\n\nCreate a basic Swiper widget:\n\n```dart\nSwiper(\n  itemBuilder: (BuildContext context, int index) {\n    return Image.network(\n      \"https://via.placeholder.com/350x150\",\n      fit: BoxFit.fill,\n    );\n  },\n  itemCount: 3,\n  pagination: SwiperPagination(),\n  control: SwiperControl(),\n)\n```\n\n## Step 3: Customization\n\nCustomize the Swiper with various properties:\n\n```dart\nSwiper(\n  itemBuilder: (BuildContext context, int index) {\n    return Image.network(\n      \"https://via.placeholder.com/350x150\",\n      fit: BoxFit.fill,\n    );\n  },\n  itemCount: 3,\n  pagination: SwiperPagination(),\n  control: SwiperControl(),\n  layout: SwiperLayout.STACK,\n  itemWidth: 300.0,\n  itemHeight: 400.0,\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure you have the following in your `Info.plist` file:\n\n```xml\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n```\n\nThis enables support for platform views, which may be necessary for certain Swiper functionalities.\n\n### Android\n\nFor Android, no specific configuration is required. However, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // ...\n    }\n}\n```\n\n## Advanced Usage\n\n### Custom Pagination\n\nCreate custom pagination indicators:\n\n```dart\nSwiper(\n  // ... other properties\n  pagination: SwiperPagination(\n    builder: DotSwiperPaginationBuilder(\n      color: Colors.grey,\n      activeColor: Colors.blue,\n      size: 8.0,\n      activeSize: 12.0,\n    ),\n  ),\n)\n```\n\n### Auto-play\n\nEnable auto-play functionality:\n\n```dart\nSwiper(\n  // ... other properties\n  autoplay: true,\n  autoplayDelay: 5000,\n)\n```\n\n### Infinite Loop\n\nCreate an infinite loop of cards:\n\n```dart\nSwiper(\n  // ... other properties\n  loop: true,\n)\n```\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize the Card Swiper package in your Flutter application. In the next section, we'll look at a comprehensive example that demonstrates all the features of this package.",
    "slug": {
      "current": "card_swiper",
      "_type": "slug"
    },
    "author": "",
    "_type": "package",
    "description": "# Card Swiper Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, creating engaging and interactive user interfaces is crucial. The `card_swiper` package for Flutter provides developers with a powerful tool to implement smooth, customizable card swiping animations in their applications. This blog post will delve into the features, usage, and implementation of the `card_swiper` package.\n\n## What is Card Swiper?\n\nCard Swiper is a Flutter package that enables developers to create swipeable card interfaces with ease. It offers a wide range of customization options and supports various swiping animations, making it an excellent choice for building interactive galleries, product showcases, or even dating app interfaces.\n\n## Key Features\n\n1. **Multiple Layouts**: Supports various layouts including stack, tinder, and custom layouts.\n2. **Customizable Animations**: Offers smooth, customizable animations for card transitions.\n3. **Pagination**: Built-in support for pagination with customizable indicators.\n4. **Auto-play**: Option to automatically swipe cards at defined intervals.\n5. **Infinite Loop**: Ability to create an infinite loop of cards.\n6. **Control API**: Provides methods to programmatically control the swiper.\n7. **Responsive Design**: Adapts to different screen sizes and orientations.\n\n## Why Use Card Swiper?\n\n- **Enhanced User Experience**: Swiping interactions are intuitive and engaging for users.\n- **Versatility**: Suitable for various use cases from image galleries to product catalogs.\n- **Performance**: Optimized for smooth performance, even with a large number of items.\n- **Easy Integration**: Simple to integrate into existing Flutter projects.\n\nIn the following sections, we'll dive into a tutorial on how to implement Card Swiper in your Flutter application and explore a comprehensive example showcasing its features.",
    "dependentPackages": [
      {
        "_key": "7l2h9197",
        "_ref": "uQRNMiDfrp20RZ8Id8CWf9",
        "_type": "reference"
      }
    ],
    "_id": "V06bsD4sX3T8NTHrBPanie",
    "pubPoint": 160,
    "similarPackages": [],
    "subCategories": [
      {
        "_key": "p4bxizh8",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP",
        "_type": "reference"
      }
    ]
  },
  {
    "pubPoint": 160,
    "author": "",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CfWv",
        "_type": "reference",
        "_key": "drqdmi08"
      }
    ],
    "tutorial": "# Flutter Barcode Scanner: Tutorial\n\n## Step 1: Installation\n\nAdd the `flutter_barcode_scanner` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_barcode_scanner: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_barcode_scanner/flutter_barcode_scanner.dart';\n```\n\n## Step 3: Platform-specific Setup\n\n### Android Setup\n\nAdd the following permissions to your `android/app/src/main/AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.CAMERA\" />\n```\n\n### iOS Setup\n\nAdd the following keys to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>NSCameraUsageDescription</key>\n<string>Camera permission is required for barcode scanning.</string>\n```\n\n## Step 4: Implementing Barcode Scanning\n\nHere's a basic implementation of barcode scanning using the `RealFlutter` class:\n\n```dart\nclass RealFlutter {\n  Future<void> scanBarcode() async {\n    String barcodeScanRes;\n    try {\n      barcodeScanRes = await FlutterBarcodeScanner.scanBarcode(\n        '#ff6666', // Color of the scan line\n        'Cancel', // Text for the cancel button\n        true, // Whether to show the flash icon\n        ScanMode.BARCODE, // The scan mode (can be BARCODE, QR)\n      );\n      print('Scanned barcode: $barcodeScanRes');\n    } on PlatformException {\n      barcodeScanRes = 'Failed to get platform version.';\n    }\n  }\n}\n```\n\n## Step 5: Customizing the Scanner\n\nYou can customize the scanner's appearance:\n\n```dart\nFlutterBarcodeScanner.scanBarcode(\n  '#ff6666', // Color of the scan line\n  'Go Back', // Custom text for the cancel button\n  true, // Show flash icon\n  ScanMode.QR, // Set to QR mode\n);\n```\n\n## Step 6: Continuous Scanning\n\nFor continuous scanning, use the `barcodeScanStream` method:\n\n```dart\nFlutterBarcodeScanner.getBarcodeStreamReceiver(\n  '#ff6666',\n  'Cancel',\n  true,\n  ScanMode.BARCODE,\n)?.listen((barcode) {\n  // Handle the scanned barcode\n  print(barcode);\n});\n```\n\nThis tutorial provides a basic foundation for integrating barcode scanning into your Flutter application using the `flutter_barcode_scanner` package. In the next section, we'll look at a more comprehensive example that demonstrates all the features of this package.",
    "_updatedAt": "2024-09-06T04:12:05Z",
    "slug": {
      "current": "flutter_barcode_scanner",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaR7G",
    "description": "# Flutter Barcode Scanner: A Comprehensive Guide\n\n## Introduction\n\nThe `flutter_barcode_scanner` package is a powerful tool for Flutter developers looking to implement barcode and QR code scanning functionality in their applications. This package provides a simple and efficient way to integrate scanning capabilities, supporting both Android and iOS platforms.\n\n## Key Features\n\n1. **Multiple Barcode Formats**: Supports various barcode formats including QR Code, Code 39, Code 93, Code 128, EAN-13, EAN-8, UPC-A, UPC-E, and more.\n\n2. **Customizable UI**: Offers options to customize the scanner overlay, including colors and scan line animations.\n\n3. **Continuous Scanning**: Enables continuous scanning mode for multiple barcode detection without closing the camera.\n\n4. **Flash Control**: Provides built-in flash control for low-light scanning scenarios.\n\n5. **Platform Compatibility**: Works seamlessly on both Android and iOS devices.\n\n## Why Choose flutter_barcode_scanner?\n\nThe `flutter_barcode_scanner` package stands out for its ease of use and robust feature set. It's particularly useful for applications that require inventory management, event ticketing, or any scenario where quick and accurate barcode or QR code scanning is essential.\n\nIn the following sections, we'll dive deeper into how to implement this package in your Flutter projects and explore its various features through practical examples.",
    "tags": [
      "barcode",
      "qr-code",
      "scanner",
      "camera",
      "image-processing"
    ],
    "_id": "V06bsD4sX3T8NTHrBPaovc",
    "likesCount": 1327,
    "packageImage": null,
    "_createdAt": "2024-08-28T22:18:04Z",
    "name": "flutter_barcode_scanner",
    "_type": "package",
    "shortDescription": "A plugin for barcode scanning support on Android and iOS. Supports barcodes, QR codes, etc.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_barcode_scanner/flutter_barcode_scanner.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Barcode Scanner Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String _scanResult = 'No scan result';\n  bool _isContinuousScanning = false;\n\n  // Step 1: Basic Barcode Scan\n  Future<void> scanBarcode() async {\n    String barcodeScanRes;\n    try {\n      barcodeScanRes = await FlutterBarcodeScanner.scanBarcode(\n        '#ff6666', // Color of the scan line\n        'Cancel', // Text for the cancel button\n        true, // Whether to show the flash icon\n        ScanMode.BARCODE, // The scan mode (can be BARCODE, QR)\n      );\n    } catch (e) {\n      barcodeScanRes = 'Failed to scan: $e';\n    }\n    if (!mounted) return;\n    setState(() {\n      _scanResult = barcodeScanRes;\n    });\n  }\n\n  // Step 2: QR Code Scan\n  Future<void> scanQR() async {\n    String qrScanRes;\n    try {\n      qrScanRes = await FlutterBarcodeScanner.scanBarcode(\n        '#ff6666',\n        'Cancel',\n        true,\n        ScanMode.QR,\n      );\n    } catch (e) {\n      qrScanRes = 'Failed to scan QR: $e';\n    }\n    if (!mounted) return;\n    setState(() {\n      _scanResult = qrScanRes;\n    });\n  }\n\n  // Step 3: Continuous Scanning\n  void startContinuousScanning() {\n    setState(() {\n      _isContinuousScanning = true;\n    });\n    FlutterBarcodeScanner.getBarcodeStreamReceiver(\n      '#ff6666',\n      'Cancel',\n      true,\n      ScanMode.BARCODE,\n    )?.listen((barcode) {\n      if (!_isContinuousScanning) return;\n      setState(() {\n        _scanResult = barcode;\n      });\n    });\n  }\n\n  void stopContinuousScanning() {\n    setState(() {\n      _isContinuousScanning = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Barcode Scanner')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Scan Result: $_scanResult', style: TextStyle(fontSize: 18)),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Scan Barcode'),\n              onPressed: scanBarcode,\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              child: Text('Scan QR Code'),\n              onPressed: scanQR,\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              child: Text(_isContinuousScanning ? 'Stop Continuous Scan' : 'Start Continuous Scan'),\n              onPressed: _isContinuousScanning ? stopContinuousScanning : startContinuousScanning,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with three buttons and a text showing the scan result.\n// 2. When \"Scan Barcode\" is pressed, it opens the camera for a single barcode scan.\n// 3. When \"Scan QR Code\" is pressed, it opens the camera specifically for QR code scanning.\n// 4. The \"Start/Stop Continuous Scan\" button toggles continuous scanning mode.\n// 5. In continuous mode, the app keeps scanning and updating the result without closing the camera.\n// 6. The scan result is always displayed at the top of the screen and updates after each scan.\n\n// Note: Remember to handle permissions properly in a production app. This example assumes\n// permissions are already granted for simplicity.\n```",
    "platforms": [
      "android",
      "ios"
    ],
    "tutorialIncluded": true,
    "similarPackages": [
      {
        "_key": "nw8qhblw",
        "_ref": "Rx1Nho763d29lawKra1aLX",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGrS",
        "_type": "reference",
        "_key": "5pmxbvwh"
      }
    ],
    "lastUpdate": "2021-04-18T18:30:00.000Z"
  },
  {
    "_rev": "ezMiwuUkJkbYMWycA6RboX",
    "_type": "package",
    "description": "# Pretty Dio Logger: Enhancing HTTP Logging in Flutter\n\n## Introduction\n\nIn the world of Flutter development, efficient debugging and logging of HTTP requests and responses are crucial for building robust applications. The `pretty_dio_logger` package offers a powerful solution to streamline this process, providing detailed and well-formatted logs for your Dio HTTP client.\n\n## What is pretty_dio_logger?\n\n`pretty_dio_logger` is a Dart package that serves as an interceptor for the popular Dio HTTP client. It enhances the debugging experience by providing beautifully formatted and colored logs of HTTP requests and responses directly in your console.\n\n## Key Features\n\n1. **Detailed Logging**: Captures and displays comprehensive information about requests and responses, including headers, body content, and query parameters.\n\n2. **Customizable Output**: Offers various options to tailor the log output to your specific needs, such as controlling the logging of request/response headers and bodies.\n\n3. **Color-coded Output**: Utilizes color-coding to improve readability and quickly distinguish between different components of the HTTP transaction.\n\n4. **Support for Large Payloads**: Handles large request and response bodies efficiently, with options to truncate or expand the logged content.\n\n5. **Error Logging**: Provides clear and informative logs for HTTP errors, making it easier to diagnose and fix issues.\n\n6. **Compact Mode**: Offers a compact logging mode for a more concise output when detailed information is not required.\n\n## Why Use pretty_dio_logger?\n\n1. **Improved Debugging**: The detailed logs make it easier to identify and resolve issues related to API interactions.\n\n2. **Time-saving**: Quickly inspect request and response data without the need for external tools or manual parsing.\n\n3. **Enhanced Readability**: The color-coded and well-formatted output improves the overall debugging experience.\n\n4. **Flexibility**: Customize the logging behavior to suit your specific development and debugging needs.\n\nIn the following sections, we'll explore how to integrate and use `pretty_dio_logger` in your Flutter projects, along with a practical example demonstrating its features.",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:dio/dio.dart';\nimport 'package:pretty_dio_logger/pretty_dio_logger.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pretty Dio Logger Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late Dio _dio;\n  String _responseText = '';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize Dio\n    _dio = Dio();\n\n    // Step 2: Add PrettyDioLogger interceptor\n    _dio.interceptors.add(PrettyDioLogger(\n      requestHeader: true,\n      requestBody: true,\n      responseBody: true,\n      responseHeader: false,\n      error: true,\n      compact: true,\n      maxWidth: 90,\n    ));\n  }\n\n  // Step 3: Create a method to make a GET request\n  Future<void> _makeGetRequest() async {\n    setState(() => _responseText = 'Loading...');\n    try {\n      final response = await _dio.get('https://jsonplaceholder.typicode.com/posts/1');\n      setState(() => _responseText = 'GET Response: ${response.data}');\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    }\n  }\n\n  // Step 4: Create a method to make a POST request\n  Future<void> _makePostRequest() async {\n    setState(() => _responseText = 'Loading...');\n    try {\n      final response = await _dio.post(\n        'https://jsonplaceholder.typicode.com/posts',\n        data: {'title': 'foo', 'body': 'bar', 'userId': 1},\n      );\n      setState(() => _responseText = 'POST Response: ${response.data}');\n    } catch (e) {\n      setState(() => _responseText = 'Error: $e');\n    }\n  }\n\n  // Step 5: Create a method to simulate an error\n  Future<void> _simulateError() async {\n    setState(() => _responseText = 'Loading...');\n    try {\n      await _dio.get('https://jsonplaceholder.typicode.com/invalid');\n    } catch (e) {\n      setState(() => _responseText = 'Error simulated successfully');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Pretty Dio Logger Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: _makeGetRequest,\n              child: Text('Make GET Request'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _makePostRequest,\n              child: Text('Make POST Request'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _simulateError,\n              child: Text('Simulate Error'),\n            ),\n            SizedBox(height: 20),\n            Text(_responseText),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes with a Dio instance and adds the PrettyDioLogger interceptor.\n// 2. The UI presents three buttons for different HTTP operations.\n// 3. When a button is pressed, the corresponding method is called:\n//    - _makeGetRequest(): Performs a GET request to fetch a post.\n//    - _makePostRequest(): Performs a POST request to create a new post.\n//    - _simulateError(): Attempts to access an invalid URL to trigger an error.\n// 4. The PrettyDioLogger intercepts each request and response, logging detailed information to the console.\n// 5. The app updates the UI with a simple representation of the response or error.\n// 6. Developers can observe the detailed logs in the console for each operation, including:\n//    - Request method, URL, headers, and body (if applicable)\n//    - Response status code, headers, and body\n//    - Detailed error information for failed requests\n// This setup allows developers to easily monitor and debug HTTP interactions within the app.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "f8awljfk"
      }
    ],
    "name": "pretty_dio_logger",
    "_id": "V06bsD4sX3T8NTHrBPapH2",
    "tutorial": "# Pretty Dio Logger: Integration Tutorial\n\nThis tutorial will guide you through the process of integrating the `pretty_dio_logger` package into your Flutter project. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `pretty_dio_logger` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  dio: ^5.0.0  # Make sure you have the latest version of dio\n  pretty_dio_logger: ^1.3.1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Setup\n\nImport the necessary packages in your Dart file:\n\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:pretty_dio_logger/pretty_dio_logger.dart';\n```\n\nCreate an instance of Dio and add the PrettyDioLogger interceptor:\n\n```dart\nclass RealFlutter {\n  late Dio _dio;\n\n  RealFlutter() {\n    _dio = Dio();\n    _dio.interceptors.add(PrettyDioLogger(\n      requestHeader: true,\n      requestBody: true,\n      responseBody: true,\n      responseHeader: false,\n      error: true,\n      compact: true,\n      maxWidth: 90,\n    ));\n  }\n\n  // Use _dio for your HTTP requests\n}\n```\n\n## Step 3: Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional configuration is required. The logs will appear in the Android Studio or VS Code console when running the app in debug mode.\n\n### iOS\n\nFor iOS, you need to ensure that OS_ACTIVITY_MODE is disabled in your Xcode scheme. Follow these steps:\n\n1. Open your project in Xcode.\n2. Go to Product > Scheme > Edit Scheme.\n3. Select the Run phase.\n4. Go to the Arguments tab.\n5. Add a new environment variable:\n   - Name: OS_ACTIVITY_MODE\n   - Value: disable\n\nThis will allow the logger's output to appear in the Xcode console.\n\n### Web\n\nFor web applications, the logs will appear in the browser's developer console. No additional configuration is needed.\n\n## Step 4: Customizing the Logger\n\nYou can customize the logger's behavior by adjusting its parameters:\n\n```dart\nPrettyDioLogger(\n  requestHeader: true,    // Log request headers\n  requestBody: true,      // Log request body\n  responseBody: true,     // Log response body\n  responseHeader: false,  // Don't log response headers\n  error: true,            // Log errors\n  compact: true,          // Use compact log format\n  maxWidth: 90,           // Set the maximum log width\n)\n```\n\nAdjust these parameters based on your debugging needs and preferences.\n\n## Step 5: Using the Logger\n\nOnce set up, the logger will automatically intercept and log all HTTP requests made through the Dio instance. You don't need to call any additional methods; just use Dio for your API calls as usual:\n\n```dart\nclass RealFlutter {\n  // ... previous setup code ...\n\n  Future<void> fetchData() async {\n    try {\n      final response = await _dio.get('https://api.example.com/data');\n      print('Data fetched successfully');\n    } catch (e) {\n      print('Error fetching data: $e');\n    }\n  }\n}\n```\n\nThe logger will output detailed, formatted logs for each request and response in your debug console.\n\nBy following these steps, you'll have successfully integrated `pretty_dio_logger` into your Flutter project, enhancing your ability to debug and monitor HTTP interactions across all platforms.",
    "pubPoint": 160,
    "author": "codeness.ly",
    "shortDescription": "Pretty Dio logger is a Dio interceptor that logs network calls in a pretty, easy to read format.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference",
        "_key": "sceftbrw"
      }
    ],
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:05Z",
    "tags": [
      "dio",
      "logging",
      "http",
      "network",
      "debugging"
    ],
    "likesCount": 615,
    "_createdAt": "2024-08-28T22:18:05Z",
    "lastUpdate": "2024-07-20T18:30:00.000Z",
    "slug": {
      "current": "pretty_dio_logger",
      "_type": "slug"
    }
  },
  {
    "author": "simform.com",
    "shortDescription": "A Flutter package to Showcase/Highlight widgets step by step.",
    "packageImage": null,
    "_id": "V06bsD4sX3T8NTHrBPapX6",
    "lastUpdate": "2024-05-30T18:30:00.000Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmQ64",
    "_type": "package",
    "description": "# ShowcaseView Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe ShowcaseView package is a powerful tool for Flutter developers who want to create engaging and interactive user onboarding experiences or highlight specific features within their applications. This package allows you to easily add showcase/walkthrough/instruction overlays to your Flutter app, drawing attention to particular UI elements and providing helpful explanations.\n\n### Key Features:\n\n1. **Customizable Overlays**: Create visually appealing overlays that highlight specific widgets in your app.\n2. **Flexible Positioning**: Position your showcase tooltips anywhere on the screen relative to the target widget.\n3. **Sequential Showcases**: Guide users through a series of features in a specific order.\n4. **Customizable Animations**: Add smooth animations to enhance the user experience.\n5. **Easy Integration**: Simple to implement with minimal changes to your existing codebase.\n6. **Cross-Platform Compatibility**: Works seamlessly on both iOS and Android platforms.\n\nThe ShowcaseView package is an excellent choice for developers looking to improve user engagement and feature discovery in their Flutter applications. In the following sections, we'll dive into a detailed tutorial on how to implement ShowcaseView and explore a comprehensive example demonstrating its features.",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "c92bgibs"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [],
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the ShowcaseView package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the ShowcaseView package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  showcaseview: ^2.0.0+1\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Basic Implementation\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:showcaseview/showcaseview.dart';\n```\n\n2. Wrap your main app widget with `ShowCaseWidget`:\n\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ShowCaseWidget(\n      builder: Builder(\n        builder: (context) => MaterialApp(\n          home: RealFlutter(),\n        ),\n      ),\n    );\n  }\n}\n```\n\n3. Create `GlobalKey`s for each widget you want to showcase:\n\n```dart\nfinal GlobalKey _one = GlobalKey();\nfinal GlobalKey _two = GlobalKey();\nfinal GlobalKey _three = GlobalKey();\n```\n\n4. Wrap the target widgets with `Showcase` widget:\n\n```dart\nShowcase(\n  key: _one,\n  title: 'Profile',\n  description: 'Tap to see user profile',\n  child: IconButton(\n    icon: Icon(Icons.account_circle),\n    onPressed: () {},\n  ),\n)\n```\n\n5. Start the showcase in your `initState` method:\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    ShowCaseWidget.of(context).startShowCase([_one, _two, _three]);\n  });\n}\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n\nFor iOS, ensure that you have set the minimum deployment target to iOS 9.0 or higher in your `Podfile`:\n\n```ruby\nplatform :ios, '9.0'\n```\n\n#### Android\n\nFor Android, no additional configuration is required. The package should work out of the box with the default settings.\n\n### Advanced Usage\n\n1. **Custom Shapes**: You can create custom shapes for your showcase by extending the `ShapeBorder` class and passing it to the `shapeBorder` parameter of the `Showcase` widget.\n\n2. **Overlay Color**: Customize the overlay color using the `overlayColor` parameter in the `Showcase` widget.\n\n3. **Animation Duration**: Adjust the animation duration with the `animationDuration` parameter in the `ShowCaseWidget`.\n\n4. **Showcase Order**: Control the order of showcases by passing an ordered list of keys to the `startShowCase` method.\n\nBy following these steps and exploring the advanced usage options, you can create engaging and informative showcases in your Flutter application using the ShowcaseView package.",
    "_updatedAt": "2024-09-06T04:12:06Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:showcaseview/showcaseview.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'ShowcaseView Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ShowCaseWidget(\n        builder: Builder(builder: (context) => RealFlutter()),\n      ),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Define GlobalKeys for each widget to be showcased\n  final GlobalKey _one = GlobalKey();\n  final GlobalKey _two = GlobalKey();\n  final GlobalKey _three = GlobalKey();\n  final GlobalKey _four = GlobalKey();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Start the showcase after the widget tree is built\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      ShowCaseWidget.of(context).startShowCase([_one, _two, _three, _four]);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('ShowcaseView Demo'),\n        // Step 3: Wrap the AppBar actions with Showcase widget\n        actions: [\n          Showcase(\n            key: _one,\n            title: 'Profile',\n            description: 'Tap to view your profile',\n            child: IconButton(\n              icon: Icon(Icons.account_circle),\n              onPressed: () {},\n            ),\n          ),\n        ],\n      ),\n      // Step 4: Wrap the body with Showcase widget\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Showcase(\n              key: _two,\n              title: 'Search',\n              description: 'Tap to search for items',\n              child: ElevatedButton.icon(\n                onPressed: () {},\n                icon: Icon(Icons.search),\n                label: Text('Search'),\n              ),\n            ),\n            SizedBox(height: 20),\n            Showcase(\n              key: _three,\n              title: 'Add to Cart',\n              description: 'Tap to add items to your cart',\n              child: ElevatedButton.icon(\n                onPressed: () {},\n                icon: Icon(Icons.shopping_cart),\n                label: Text('Add to Cart'),\n              ),\n            ),\n          ],\n        ),\n      ),\n      // Step 5: Wrap the FloatingActionButton with Showcase widget\n      floatingActionButton: Showcase(\n        key: _four,\n        title: 'Create',\n        description: 'Tap to create a new item',\n        child: FloatingActionButton(\n          onPressed: () {},\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow Explanation:\n// 1. The app starts and builds the widget tree.\n// 2. In the initState method, we schedule the showcase to start after the build is complete.\n// 3. The ShowCaseWidget wraps our entire app, allowing us to control the showcase from anywhere.\n// 4. We define four showcase points: profile icon, search button, add to cart button, and create button.\n// 5. When the showcase starts, it highlights each widget in the order specified in the startShowCase method.\n// 6. The user can tap through each showcase point to learn about different features of the app.\n// 7. After the last showcase point, the overlay disappears, and the user can interact with the app normally.\n\n// This example demonstrates how to use ShowcaseView to create an interactive onboarding experience\n// that guides users through the main features of your app. You can easily customize the appearance\n// and behavior of each showcase point to fit your app's design and requirements.\n```",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "tags": [
      "ui",
      "onboarding",
      "tutorial",
      "showcase",
      "feature-discovery"
    ],
    "likesCount": 2395,
    "_createdAt": "2024-08-28T22:18:07Z",
    "name": "showcaseview",
    "slug": {
      "current": "showcaseview",
      "_type": "slug"
    }
  },
  {
    "author": "",
    "lastUpdate": "2024-08-15T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:07Z",
    "slug": {
      "current": "vibration",
      "_type": "slug"
    },
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:vibration/vibration.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Vibration Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: VibrationDemo(),\n    );\n  }\n}\n\nclass VibrationDemo extends StatefulWidget {\n  @override\n  _VibrationDemoState createState() => _VibrationDemoState();\n}\n\nclass _VibrationDemoState extends State<VibrationDemo> {\n  bool _canVibrate = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _init();\n  }\n\n  // Step 1: Initialize and check for vibration support\n  Future<void> _init() async {\n    bool canVibrate = await Vibration.hasVibrator() ?? false;\n    setState(() {\n      _canVibrate = canVibrate;\n    });\n  }\n\n  // Step 2: Basic vibration function\n  void _basicVibration() {\n    if (_canVibrate) {\n      Vibration.vibrate();\n    }\n  }\n\n  // Step 3: Vibration with custom duration\n  void _durationVibration() {\n    if (_canVibrate) {\n      Vibration.vibrate(duration: 2000); // 2 seconds vibration\n    }\n  }\n\n  // Step 4: Custom vibration pattern\n  void _patternVibration() {\n    if (_canVibrate) {\n      Vibration.vibrate(pattern: [500, 1000, 500, 2000, 500]);\n    }\n  }\n\n  // Step 5: Cancel ongoing vibration\n  void _cancelVibration() {\n    Vibration.cancel();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Vibration Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              _canVibrate ? 'This device can vibrate' : 'This device cannot vibrate',\n              style: TextStyle(fontSize: 18),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _basicVibration,\n              child: Text('Basic Vibration'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _durationVibration,\n              child: Text('2 Second Vibration'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _patternVibration,\n              child: Text('Pattern Vibration'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _cancelVibration,\n              child: Text('Cancel Vibration'),\n              style: ElevatedButton.styleFrom(primary: Colors.red),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and sets VibrationDemo as the home widget.\n// 3. VibrationDemo is a StatefulWidget that creates a _VibrationDemoState.\n// 4. In the initState of _VibrationDemoState, we call _init() to check if the device supports vibration.\n// 5. The build method creates a Scaffold with an AppBar and a Column of buttons in the body.\n// 6. Each button triggers a different vibration function:\n//    - Basic Vibration: Triggers a short, default vibration.\n//    - 2 Second Vibration: Triggers a vibration that lasts for 2 seconds.\n//    - Pattern Vibration: Triggers a custom pattern of vibrations and pauses.\n//    - Cancel Vibration: Stops any ongoing vibration.\n// 7. The app checks if vibration is supported before executing any vibration command.\n// 8. Users can interact with the buttons to experience different types of vibrations on their device.\n\n// Note: Remember to add the necessary permissions in the AndroidManifest.xml for Android devices.\n// For iOS, no additional setup is required, but custom patterns will default to the standard vibration.\n```",
    "platforms": [
      "android",
      "ios"
    ],
    "name": "vibration",
    "tutorialIncluded": true,
    "_createdAt": "2024-08-28T22:18:08Z",
    "pubPoint": 160,
    "description": "# Flutter Vibration Package: Unleashing Haptic Feedback in Your App\n\n## Introduction\n\nIn the world of mobile app development, creating an engaging user experience goes beyond visual and auditory elements. Haptic feedback, the use of touch sensation and motion to communicate with users, has become an essential part of modern mobile interfaces. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful vibration package that allows developers to incorporate haptic feedback into their apps seamlessly.\n\n## What is the Vibration Package?\n\nThe vibration package for Flutter is a plugin that provides a simple way to vibrate the device on both Android and iOS platforms. It allows developers to trigger various vibration patterns, control the duration of vibrations, and even create custom vibration sequences. This package is particularly useful for enhancing user interactions, providing non-visual alerts, and creating immersive experiences in games and interactive applications.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works on both Android and iOS devices.\n2. **Simple API**: Easy to integrate and use within your Flutter projects.\n3. **Customizable vibration patterns**: Create single vibrations or complex sequences.\n4. **Duration control**: Specify the length of each vibration.\n5. **Vibration cancellation**: Ability to stop ongoing vibrations programmatically.\n\n## Use Cases\n\nThe vibration package can be utilized in various scenarios, including:\n\n- Providing tactile feedback for button presses\n- Enhancing gaming experiences with haptic responses\n- Creating silent alarms or notifications\n- Improving accessibility for users with visual impairments\n- Adding emphasis to important events or alerts in your app\n\nIn the following sections, we'll dive deeper into how to implement the vibration package in your Flutter project and explore its full potential through a comprehensive tutorial and example.",
    "shortDescription": "A plugin for handling Vibration API on iOS, Android, web and OpenHarmony.",
    "similarPackages": [],
    "tags": [
      "haptic-feedback",
      "vibration",
      "hardware",
      "user-experience"
    ],
    "likesCount": 725,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWZd",
        "_type": "reference",
        "_key": "5ceqfo16"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "nfmaoc23"
      }
    ],
    "tutorial": "# Flutter Vibration Package: Implementation Tutorial\n\n## Step 1: Add the Vibration Package to Your Project\n\nFirst, add the vibration package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  vibration: ^1.7.5\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the vibration package:\n\n```dart\nimport 'package:vibration/vibration.dart';\n```\n\n## Step 3: Check for Vibration Support\n\nBefore using vibration, it's good practice to check if the device supports it:\n\n```dart\nif (await Vibration.hasVibrator()) {\n  // Vibration supported\n} else {\n  // Vibration not supported\n}\n```\n\n## Step 4: Implementing Vibration Features\n\n### Basic Vibration\n\nTo trigger a simple vibration:\n\n```dart\nVibration.vibrate();\n```\n\n### Vibration with Duration\n\nTo vibrate for a specific duration (in milliseconds):\n\n```dart\nVibration.vibrate(duration: 1000); // Vibrate for 1 second\n```\n\n### Custom Vibration Pattern\n\nTo create a custom vibration pattern:\n\n```dart\nVibration.vibrate(pattern: [500, 1000, 500, 2000]);\n```\n\nThis pattern means:\n- Vibrate for 500ms\n- Pause for 1000ms\n- Vibrate for 500ms\n- Pause for 2000ms\n\n### Cancel Vibration\n\nTo stop an ongoing vibration:\n\n```dart\nVibration.cancel();\n```\n\n## Platform-Specific Considerations\n\n### Android\n\n- Requires `<uses-permission android:name=\"android.permission.VIBRATE\" />` in the AndroidManifest.xml file.\n- Custom vibration patterns are fully supported.\n\n### iOS\n\n- No additional permissions required.\n- Custom vibration patterns are not supported. iOS will use the default vibration regardless of the pattern specified.\n\n## Best Practices\n\n1. Always check for vibration support before using it.\n2. Use vibrations sparingly to avoid overwhelming the user.\n3. Provide an option for users to disable vibrations in your app settings.\n4. Be mindful of battery usage, especially with long or frequent vibrations.\n\nBy following this tutorial, you'll be able to integrate vibration functionality into your Flutter app effectively, enhancing user experience across both Android and iOS platforms.",
    "_rev": "AE3hjGWNkNE6aGQMMbaRDe",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfECi",
        "_type": "reference",
        "_key": "dp0y9qud"
      }
    ],
    "packageImage": null,
    "_id": "V06bsD4sX3T8NTHrBPapnA"
  },
  {
    "pubPoint": 160,
    "author": "fluttered.dev",
    "description": "# Map Launcher Package for Flutter: Seamless Integration with Native Map Apps\n\n## Introduction\n\nThe `map_launcher` package is a powerful tool for Flutter developers looking to integrate map functionality into their applications. This package allows you to launch various map applications installed on the user's device, providing a seamless experience for navigation and location-based services.\n\n## Key Features\n\n1. **Multiple Map Support**: Launch maps from various providers, including Google Maps, Apple Maps, Waze, and more.\n2. **Platform Flexibility**: Works on both iOS and Android platforms.\n3. **Custom Markers**: Add custom markers to the map with ease.\n4. **Route Planning**: Launch maps with pre-defined routes for navigation.\n5. **Coordinate Support**: Use latitude and longitude coordinates for precise location marking.\n\n## Why Use Map Launcher?\n\nThe `map_launcher` package offers several advantages:\n\n- **User Preference**: Allows users to choose their preferred map application.\n- **Native Experience**: Leverages the device's native map applications for optimal performance.\n- **Simplicity**: Easy to implement with just a few lines of code.\n- **Versatility**: Supports various use cases, from simple location display to complex route planning.\n\nIn the following sections, we'll dive deeper into how to implement this package in your Flutter project and explore its capabilities through a comprehensive example.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWSz",
        "_type": "reference",
        "_key": "40eyqa6w"
      }
    ],
    "platforms": [
      "android",
      "ios"
    ],
    "_createdAt": "2024-08-28T22:18:13Z",
    "name": "map_launcher",
    "shortDescription": "Map Launcher is a flutter plugin to find available maps installed on a device and launch them with a marker or show directions.",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1nZD",
        "_type": "reference",
        "_key": "3imrf6xy"
      }
    ],
    "likesCount": 827,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1K9L",
        "_type": "reference",
        "_key": "znjmcgnd"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVGj",
        "_type": "reference",
        "_key": "em0yt73w"
      }
    ],
    "tutorial": "# Map Launcher Package Tutorial\n\n## Installation\n\nTo get started with the `map_launcher` package, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  map_launcher: ^2.5.0+1\n```\n\nThen, run `flutter pub get` to install the package.\n\n## Basic Usage\n\nHere's a simple example of how to use the `map_launcher` package:\n\n```dart\nimport 'package:map_launcher/map_launcher.dart';\n\n// Check if maps are available\nfinal availableMaps = await MapLauncher.installedMaps;\n\n// Launch the first available map\nif (availableMaps.isNotEmpty) {\n  await availableMaps.first.showMarker(\n    coords: Coords(37.759392, -122.5107336),\n    title: \"Ocean Beach\",\n  );\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, you need to add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\n### iOS\n\nFor iOS, add the following keys to your `Info.plist` file:\n\n```xml\n<key>LSApplicationQueriesSchemes</key>\n<array>\n    <string>comgooglemaps</string>\n    <string>baidumap</string>\n    <string>iosamap</string>\n    <string>waze</string>\n    <string>yandexmaps</string>\n    <string>yandexnavi</string>\n    <string>citymapper</string>\n    <string>mapswithme</string>\n    <string>osmandmaps</string>\n    <string>dgis</string>\n    <string>qqmap</string>\n    <string>here-location</string>\n</array>\n```\n\n## Advanced Features\n\n### Showing a Marker\n\nTo show a marker on the map:\n\n```dart\nawait MapLauncher.showMarker(\n  mapType: MapType.google,\n  coords: Coords(37.759392, -122.5107336),\n  title: \"Ocean Beach\",\n  description: \"A beautiful beach in San Francisco\",\n);\n```\n\n### Launching Directions\n\nTo launch directions between two points:\n\n```dart\nawait MapLauncher.showDirections(\n  mapType: MapType.google,\n  destination: Coords(37.759392, -122.5107336),\n  origin: Coords(37.7749, -122.4194),\n  destinationTitle: \"Ocean Beach\",\n  originTitle: \"San Francisco City Hall\",\n);\n```\n\nBy following this tutorial, you'll be able to integrate the `map_launcher` package into your Flutter application and provide your users with a rich map experience.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:09Z",
    "_rev": "ezMiwuUkJkbYMWycA6Rbvj",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:map_launcher/map_launcher.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MapLauncherDemo(),\n    );\n  }\n}\n\nclass MapLauncherDemo extends StatefulWidget {\n  @override\n  _MapLauncherDemoState createState() => _MapLauncherDemoState();\n}\n\nclass _MapLauncherDemoState extends State<MapLauncherDemo> {\n  List<AvailableMap> availableMaps = [];\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Get available maps when the widget initializes\n    getAvailableMaps();\n  }\n\n  // Step 2: Function to get available maps\n  Future<void> getAvailableMaps() async {\n    availableMaps = await MapLauncher.installedMaps;\n    setState(() {});\n  }\n\n  // Step 3: Function to show a marker\n  Future<void> showMarker() async {\n    final coords = Coords(37.759392, -122.5107336);\n    final title = \"Ocean Beach\";\n    final description = \"A beautiful beach in San Francisco\";\n\n    final map = availableMaps.first;\n    await map.showMarker(\n      coords: coords,\n      title: title,\n      description: description,\n    );\n  }\n\n  // Step 4: Function to show directions\n  Future<void> showDirections() async {\n    final origin = Coords(37.7749, -122.4194);\n    final destination = Coords(37.759392, -122.5107336);\n    final originTitle = \"San Francisco City Hall\";\n    final destinationTitle = \"Ocean Beach\";\n\n    final map = availableMaps.first;\n    await map.showDirections(\n      origin: origin,\n      destination: destination,\n      originTitle: originTitle,\n      destinationTitle: destinationTitle,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Map Launcher Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 5: Display available maps\n            Text('Available Maps: ${availableMaps.length}'),\n            SizedBox(height: 20),\n            // Step 6: Button to show marker\n            ElevatedButton(\n              onPressed: showMarker,\n              child: Text('Show Marker'),\n            ),\n            SizedBox(height: 20),\n            // Step 7: Button to show directions\n            ElevatedButton(\n              onPressed: showDirections,\n              child: Text('Show Directions'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. MapLauncherDemo widget is created and its state is initialized.\n// 3. In initState, getAvailableMaps() is called to fetch installed map apps.\n// 4. The UI is built with two buttons: \"Show Marker\" and \"Show Directions\".\n// 5. When \"Show Marker\" is pressed, it calls showMarker() which launches\n//    the first available map app and displays a marker for Ocean Beach.\n// 6. When \"Show Directions\" is pressed, it calls showDirections() which\n//    launches the first available map app and shows directions from\n//    San Francisco City Hall to Ocean Beach.\n// 7. The app uses setState to update the UI when necessary, ensuring\n//    that the latest data is always displayed.\n```",
    "tags": [
      "maps",
      "navigation",
      "location",
      "launcher",
      "geo"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-2a783ab9b301e3fe3c0426867214ae86beaa0631-248x536-webp",
        "_type": "reference"
      }
    },
    "lastUpdate": "2024-08-24T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPaqDw",
    "slug": {
      "current": "map_launcher",
      "_type": "slug"
    }
  },
  {
    "platforms": [
      "android",
      "ios"
    ],
    "_createdAt": "2024-08-28T22:18:15Z",
    "name": "flutter_pdfview",
    "_id": "V06bsD4sX3T8NTHrBPaqU0",
    "_updatedAt": "2024-09-06T04:12:09Z",
    "slug": {
      "current": "flutter_pdfview",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmQCc",
    "shortDescription": "A Flutter plugin that provides a PDFView widget on Android and iOS.",
    "likesCount": 570,
    "lastUpdate": "2023-10-10T18:30:00.000Z",
    "_type": "package",
    "description": "# Flutter PDF View Package: A Comprehensive Guide\n\n## Introduction\n\nThe `flutter_pdfview` package is a powerful tool for Flutter developers who need to integrate PDF viewing capabilities into their applications. This package provides a seamless way to render and interact with PDF documents within your Flutter app, offering a native-like experience on both iOS and Android platforms.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works on both iOS and Android.\n2. **Customizable viewer**: Allows for tailoring the PDF viewing experience to your app's needs.\n3. **Page navigation**: Enables users to move between pages easily.\n4. **Zoom functionality**: Supports pinch-to-zoom for a better reading experience.\n5. **Page count**: Provides information about the total number of pages in the document.\n6. **Current page tracking**: Keeps track of the currently viewed page.\n7. **File source flexibility**: Supports loading PDFs from assets, file system, or network URLs.\n8. **Error handling**: Provides callbacks for error scenarios during PDF loading or rendering.\n\n## Why Choose flutter_pdfview?\n\nThe `flutter_pdfview` package stands out for its simplicity and efficiency. It leverages native PDF rendering capabilities on both platforms, ensuring optimal performance and a smooth user experience. Whether you're building a document reader, an e-book app, or any application that requires PDF viewing, this package offers a robust solution that can be easily integrated into your Flutter project.\n\nIn the following sections, we'll dive deeper into how to implement and utilize the `flutter_pdfview` package in your Flutter applications.",
    "similarPackages": [],
    "packageImage": null,
    "tutorial": "# Flutter PDF View Package: Tutorial\n\n## Setup\n\nTo get started with the `flutter_pdfview` package, follow these steps:\n\n1. Add the package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_pdfview: ^1.3.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\n```\n\n## Platform-Specific Configuration\n\n### Android\n\nFor Android, you need to set the minimum SDK version to 21 (Android 5.0) or higher. In your `android/app/build.gradle` file, update the `minSdkVersion`:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n    }\n}\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist` file to allow loading PDFs from the internet:\n\n```xml\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n```\n\n## Basic Usage\n\nHere's a basic example of how to use the `PDFView` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\n\nclass RealFlutter extends StatelessWidget {\n  final String pdfPath;\n\n  const RealFlutter({Key? key, required this.pdfPath}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('PDF View')),\n      body: PDFView(\n        filePath: pdfPath,\n        enableSwipe: true,\n        swipeHorizontal: true,\n        autoSpacing: false,\n        pageFling: false,\n        onRender: (_pages) {\n          // PDF is rendered\n        },\n        onError: (error) {\n          print(error.toString());\n        },\n        onPageError: (page, error) {\n          print('$page: ${error.toString()}');\n        },\n        onViewCreated: (PDFViewController pdfViewController) {\n          // PDF view is created\n        },\n        onPageChanged: (int? page, int? total) {\n          print('page change: $page/$total');\n        },\n      ),\n    );\n  }\n}\n```\n\nThis example demonstrates how to create a basic PDF viewer using the `PDFView` widget. The `filePath` parameter specifies the location of the PDF file, which can be a local file path or an asset path.\n\nIn the next section, we'll explore a more comprehensive example that showcases all the features of the `flutter_pdfview` package.",
    "tutorialIncluded": true,
    "author": "",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGp5",
        "_type": "reference",
        "_key": "oic3i1ax"
      }
    ],
    "example": "```\nimport 'dart:async';\nimport 'dart:io';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter PDF View Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String remotePDFpath = \"\";\n  String localPDFpath = \"\";\n  bool isLoading = true;\n  int? pages = 0;\n  int? currentPage = 0;\n  bool isReady = false;\n  String errorMessage = '';\n  PDFViewController? controller;\n\n  @override\n  void initState() {\n    super.initState();\n    loadPDF();\n  }\n\n  // Step 1: Load PDF from a remote URL\n  Future<void> loadPDF() async {\n    setState(() {\n      isLoading = true;\n    });\n\n    String url = \"https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf\";\n    final response = await http.get(Uri.parse(url));\n\n    if (response.statusCode == 200) {\n      // Step 2: Get temporary directory to store the PDF\n      final dir = await getTemporaryDirectory();\n      final filePath = '${dir.path}/sample.pdf';\n      final file = File(filePath);\n\n      // Step 3: Write the PDF data to the file\n      await file.writeAsBytes(response.bodyBytes);\n\n      setState(() {\n        remotePDFpath = url;\n        localPDFpath = filePath;\n        isLoading = false;\n      });\n    } else {\n      setState(() {\n        errorMessage = \"Failed to load PDF: ${response.statusCode}\";\n        isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(\"Flutter PDF View Demo\")),\n      body: isLoading\n          ? Center(child: CircularProgressIndicator())\n          : errorMessage.isNotEmpty\n              ? Center(child: Text(errorMessage))\n              : Column(\n                  children: <Widget>[\n                    // Step 4: Display PDF information\n                    Expanded(\n                      flex: 1,\n                      child: Text(\"Remote PDF: $remotePDFpath\\nLocal PDF: $localPDFpath\"),\n                    ),\n                    // Step 5: PDF View widget\n                    Expanded(\n                      flex: 9,\n                      child: PDFView(\n                        filePath: localPDFpath,\n                        enableSwipe: true,\n                        swipeHorizontal: true,\n                        autoSpacing: false,\n                        pageFling: true,\n                        pageSnap: true,\n                        defaultPage: currentPage!,\n                        fitPolicy: FitPolicy.BOTH,\n                        preventLinkNavigation: false,\n                        onRender: (_pages) {\n                          setState(() {\n                            pages = _pages;\n                            isReady = true;\n                          });\n                        },\n                        onError: (error) {\n                          setState(() {\n                            errorMessage = error.toString();\n                          });\n                          print(error.toString());\n                        },\n                        onPageError: (page, error) {\n                          setState(() {\n                            errorMessage = '$page: ${error.toString()}';\n                          });\n                          print('$page: ${error.toString()}');\n                        },\n                        onViewCreated: (PDFViewController pdfViewController) {\n                          controller = pdfViewController;\n                        },\n                        onLinkHandler: (String? uri) {\n                          print('Link tapped: $uri');\n                        },\n                        onPageChanged: (int? page, int? total) {\n                          print('page change: $page/$total');\n                          setState(() {\n                            currentPage = page;\n                          });\n                        },\n                      ),\n                    ),\n                    // Step 6: Navigation controls\n                    Expanded(\n                      flex: 1,\n                      child: Row(\n                        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n                        children: <Widget>[\n                          IconButton(\n                            icon: Icon(Icons.first_page),\n                            onPressed: () {\n                              controller?.setPage(0);\n                            },\n                          ),\n                          IconButton(\n                            icon: Icon(Icons.arrow_back),\n                            onPressed: () {\n                              controller?.previousPage();\n                            },\n                          ),\n                          Text(\"${currentPage! + 1}/$pages\"),\n                          IconButton(\n                            icon: Icon(Icons.arrow_forward),\n                            onPressed: () {\n                              controller?.nextPage();\n                            },\n                          ),\n                          IconButton(\n                            icon: Icon(Icons.last_page),\n                            onPressed: () {\n                              controller?.setPage(pages! - 1);\n                            },\n                          ),\n                        ],\n                      ),\n                    ),\n                  ],\n                ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and enters the loading state.\n// 2. loadPDF() is called in initState(), which downloads a sample PDF from a remote URL.\n// 3. The PDF is saved to a temporary file on the device.\n// 4. Once the PDF is loaded, the UI updates to display the PDF viewer.\n// 5. The PDFView widget renders the PDF and provides interactive features like swiping and zooming.\n// 6. Navigation controls allow the user to move between pages.\n// 7. Error handling is implemented to catch and display any issues during PDF loading or rendering.\n// 8. The app maintains state for the current page, total pages, and loading status.\n\n// Key Features Demonstrated:\n// - Loading a PDF from a remote URL\n// - Saving and loading a PDF from local storage\n// - Displaying PDF content with PDFView\n// - Implementing swipe navigation and zoom\n// - Tracking current page and total pages\n// - Providing manual navigation controls\n// - Error handling for various scenarios\n// - Responsive layout adapting to different screen sizes\n```",
    "tags": [
      "pdf",
      "viewer",
      "document",
      "rendering"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbBNs",
        "_type": "reference",
        "_key": "jqtau0zv"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPadBM",
        "_type": "reference",
        "_key": "fz02tfbo"
      }
    ]
  },
  {
    "name": "skeletonizer",
    "tutorial": "# Implementing Skeletonizer in Your Flutter Project\n\nThis tutorial will guide you through the process of adding the Skeletonizer package to your Flutter project and using its features effectively.\n\n## Step 1: Add Dependencies\n\nFirst, add the Skeletonizer package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  skeletonizer: ^latest_version\n```\n\nReplace `latest_version` with the current version of the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the Skeletonizer package:\n\n```dart\nimport 'package:skeletonizer/skeletonizer.dart';\n```\n\n## Step 3: Wrap Your Widget\n\nTo create a skeleton loading effect, wrap your widget with the `Skeletonizer` widget:\n\n```dart\nSkeletonizer(\n  enabled: isLoading,\n  child: YourWidget(),\n)\n```\n\nThe `enabled` parameter controls when the skeleton effect is shown. Set it to `true` when your data is loading.\n\n## Step 4: Customize the Skeleton\n\nSkeletonizer offers various customization options:\n\n```dart\nSkeletonizer(\n  enabled: isLoading,\n  effect: ShimmerEffect(), // or other effects\n  ignorePointers: true,\n  containersColor: Colors.grey[300],\n  textBorderRadius: BorderRadius.circular(8),\n  child: YourWidget(),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, you might want to adjust the skeleton colors to match the native iOS design language:\n\n```dart\nSkeletonizer(\n  enabled: isLoading,\n  containersColor: CupertinoColors.systemGrey5,\n  // Other properties...\n  child: YourWidget(),\n)\n```\n\n### Android\n\nFor Android, consider using Material Design color schemes:\n\n```dart\nSkeletonizer(\n  enabled: isLoading,\n  containersColor: Theme.of(context).colorScheme.surfaceVariant,\n  // Other properties...\n  child: YourWidget(),\n)\n```\n\n## Advanced Usage\n\n### Custom Effects\n\nYou can create custom skeleton effects by extending the `SkeletonEffect` class:\n\n```dart\nclass MyCustomEffect extends SkeletonEffect {\n  @override\n  Widget build(BuildContext context, Widget child) {\n    // Implement your custom effect here\n  }\n}\n\n// Usage\nSkeletonizer(\n  enabled: isLoading,\n  effect: MyCustomEffect(),\n  child: YourWidget(),\n)\n```\n\n### Ignoring Specific Widgets\n\nTo prevent certain widgets from being \"skeletonized\", wrap them with `IgnoreSkeletonizer`:\n\n```dart\nSkeletonizer(\n  enabled: isLoading,\n  child: Column(\n    children: [\n      SkeletonizedWidget(),\n      IgnoreSkeletonizer(\n        child: NonSkeletonizedWidget(),\n      ),\n    ],\n  ),\n)\n```\n\nBy following these steps and exploring the customization options, you can effectively implement Skeletonizer in your Flutter project, enhancing the user experience during loading states.",
    "_updatedAt": "2024-09-06T04:12:11Z",
    "pubPoint": 160,
    "author": "codeness.ly",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "o2hzenr9"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-d9e4006c036a457fce228e9037d169933581a399-360x321-webp",
        "_type": "reference"
      }
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaRK2",
    "description": "# Skeletonizer Package for Flutter: Enhancing User Experience with Animated Loading Skeletons\n\n## Introduction\n\nIn the world of mobile app development, user experience is paramount. One of the key aspects of a smooth user experience is providing visual feedback during loading states. This is where the Skeletonizer package for Flutter comes into play. Skeletonizer allows developers to easily implement animated loading skeletons, creating a more engaging and polished look for their applications.\n\n## What is Skeletonizer?\n\nSkeletonizer is a powerful Flutter package that enables developers to add animated loading skeletons to their widgets with minimal effort. These skeletons provide a visual placeholder for content that is still loading, giving users a sense of the app's structure and improving perceived performance.\n\n## Key Features\n\n1. **Easy Integration**: Wrap your existing widgets with Skeletonizer to instantly create loading skeletons.\n2. **Customizable Animations**: Choose from various animation effects or create your own custom animations.\n3. **Flexible Configuration**: Adjust colors, shapes, and durations to match your app's design language.\n4. **Performance Optimized**: Designed to work efficiently, even with complex widget trees.\n5. **Cross-Platform Compatibility**: Works seamlessly on both iOS and Android platforms.\n\n## Why Use Skeletonizer?\n\n- **Improved User Experience**: By providing visual feedback during loading states, users are less likely to perceive delays negatively.\n- **Design Consistency**: Maintain your app's look and feel even during loading phases.\n- **Reduced Perceived Load Time**: Skeletons give the impression of faster load times, enhancing user satisfaction.\n- **Easy to Implement**: With its simple API, you can add sophisticated loading effects without complex code.\n\nIn the following sections, we'll dive into a tutorial on how to implement Skeletonizer in your Flutter project and showcase a complete example demonstrating its features.",
    "tags": [
      "skeleton",
      "shimmer-loading",
      "skeleton-loader",
      "loading",
      "ui",
      "placeholder"
    ],
    "slug": {
      "current": "skeletonizer",
      "_type": "slug"
    },
    "_id": "V06bsD4sX3T8NTHrBParQu",
    "_type": "package",
    "shortDescription": "Converts already built widgets into skeleton loaders with no extra effort.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "1xitm05x",
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cakt",
        "_type": "reference",
        "_key": "3i11aqyw"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:skeletonizer/skeletonizer.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Skeletonizer Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Simulate a network delay\n    Future.delayed(const Duration(seconds: 3), () {\n      setState(() {\n        _isLoading = false;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Skeletonizer Demo'),\n      ),\n      body: Skeletonizer(\n        // Step 2: Enable skeletonizer based on loading state\n        enabled: _isLoading,\n        // Step 3: Customize the skeleton effect\n        effect: const ShimmerEffect(),\n        ignorePointers: true,\n        containersColor: Colors.grey[300],\n        textBorderRadius: BorderRadius.circular(8),\n        child: ListView(\n          padding: const EdgeInsets.all(16),\n          children: [\n            // Step 4: Create a card with skeleton-friendly content\n            Card(\n              child: Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    const Text(\n                      'Welcome to Skeletonizer Demo',\n                      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n                    ),\n                    const SizedBox(height: 16),\n                    const Text(\n                      'This is a long paragraph of text that will be skeletonized when loading. '\n                      'It demonstrates how Skeletonizer handles multi-line text elements.',\n                      style: TextStyle(fontSize: 16),\n                    ),\n                    const SizedBox(height: 16),\n                    // Step 5: Add an image placeholder\n                    Container(\n                      height: 200,\n                      color: Colors.grey[200],\n                      child: const Center(\n                        child: Icon(Icons.image, size: 64, color: Colors.grey),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n            const SizedBox(height: 16),\n            // Step 6: Add a list of items\n            ...List.generate(\n              5,\n              (index) => ListTile(\n                leading: const CircleAvatar(\n                  child: Icon(Icons.person),\n                ),\n                title: Text('Item ${index + 1}'),\n                subtitle: Text('Description for item ${index + 1}'),\n                trailing: const Icon(Icons.arrow_forward_ios),\n              ),\n            ),\n            const SizedBox(height: 16),\n            // Step 7: Add a button that's ignored by Skeletonizer\n            IgnoreSkeletonizer(\n              child: ElevatedButton(\n                onPressed: () {\n                  setState(() {\n                    _isLoading = !_isLoading;\n                  });\n                },\n                child: Text(_isLoading ? 'Load Content' : 'Show Skeleton'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with _isLoading set to true, simulating a data loading state.\n// 2. Skeletonizer is enabled, creating skeleton effects for all child widgets.\n// 3. After a 3-second delay (simulating network request), _isLoading is set to false.\n// 4. When _isLoading becomes false, Skeletonizer is disabled, revealing the actual content.\n// 5. The IgnoreSkeletonizer widget ensures the button remains interactive even during loading.\n// 6. Pressing the button toggles between loaded and skeleton states for demonstration.\n\n// Key Points:\n// - Skeletonizer wraps the entire ListView, affecting all child widgets.\n// - Various widgets (Text, Container, ListTile) demonstrate how Skeletonizer handles different elements.\n// - The IgnoreSkeletonizer widget shows how to exclude specific widgets from the skeleton effect.\n// - The loading simulation demonstrates how to integrate Skeletonizer with real-world data fetching scenarios.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "37in8uvo"
      },
      {
        "_key": "zm3k27td",
        "_ref": "uQRNMiDfrp20RZ8Id8CUlT",
        "_type": "reference"
      }
    ],
    "likesCount": 1113,
    "_createdAt": "2024-08-28T22:18:19Z",
    "lastUpdate": "2024-07-30T18:30:00.000Z",
    "tutorialIncluded": true
  },
  {
    "author": "dart.dev",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 794,
    "lastUpdate": "2023-05-22T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPas2O",
    "description": "# Flutter Logging Package: A Comprehensive Guide\n\n## Introduction\n\nLogging is an essential part of any application development process. It helps developers track the flow of their application, debug issues, and monitor performance. In the Flutter ecosystem, the `logging` package provides a flexible and powerful solution for implementing logging in your applications.\n\n## What is the Logging Package?\n\nThe `logging` package is a Dart library that provides a straightforward way to add logging functionality to your Flutter applications. It offers various features such as:\n\n1. Multiple log levels (FINEST, FINER, FINE, CONFIG, INFO, WARNING, SEVERE, SHOUT)\n2. Hierarchical logger names\n3. Custom log handlers\n4. Easy integration with existing Flutter projects\n\n## Why Use the Logging Package?\n\nUsing the logging package in your Flutter application offers several benefits:\n\n1. **Debugging**: Easily trace the execution flow of your application and identify issues.\n2. **Performance Monitoring**: Log performance-critical sections to optimize your app.\n3. **Error Tracking**: Capture and analyze errors and exceptions in detail.\n4. **Flexibility**: Customize log output and integrate with various logging backends.\n5. **Cross-platform Compatibility**: Works seamlessly on all platforms supported by Flutter.\n\nIn the following sections, we'll dive deeper into how to implement and use the logging package in your Flutter applications.",
    "tutorial": "# Flutter Logging Package: Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the logging package in a Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the logging package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  logging: ^1.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the logging package in your Dart file:\n\n```dart\nimport 'package:logging/logging.dart';\n```\n\nSet up a logger in your `RealFlutter` class:\n\n```dart\nclass RealFlutter {\n  static final Logger _logger = Logger('RealFlutter');\n\n  static void initializeLogging() {\n    Logger.root.level = Level.ALL; // Set the root logger level\n    Logger.root.onRecord.listen((record) {\n      print('${record.level.name}: ${record.time}: ${record.message}');\n    });\n  }\n}\n```\n\n## Step 3: Using the Logger\n\nNow you can use the logger throughout your application:\n\n```dart\nRealFlutter._logger.info('This is an info message');\nRealFlutter._logger.warning('This is a warning message');\nRealFlutter._logger.severe('This is a severe error message');\n```\n\n## Step 4: Platform-Specific Considerations\n\n### Android\n\nFor Android, you can use the `android_logger` package to integrate with the native Android logging system:\n\n1. Add the `android_logger` package to your `pubspec.yaml`:\n\n```yaml\ndependencies:\n  android_logger: ^1.0.0\n```\n\n2. Modify your logging setup:\n\n```dart\nimport 'package:android_logger/android_logger.dart';\n\nclass RealFlutter {\n  static final Logger _logger = Logger('RealFlutter');\n\n  static void initializeLogging() {\n    if (Platform.isAndroid) {\n      AndroidLogger.initializeLogging();\n      Logger.root.onRecord.listen((record) {\n        AndroidLogger.log(\n          record.level.androidLogPriority,\n          record.loggerName,\n          record.message,\n        );\n      });\n    } else {\n      // Default logging for other platforms\n      Logger.root.onRecord.listen((record) {\n        print('${record.level.name}: ${record.time}: ${record.message}');\n      });\n    }\n  }\n}\n```\n\n### iOS\n\nFor iOS, you can use the `ios_log` package to integrate with the native iOS logging system:\n\n1. Add the `ios_log` package to your `pubspec.yaml`:\n\n```yaml\ndependencies:\n  ios_log: ^0.2.0\n```\n\n2. Modify your logging setup:\n\n```dart\nimport 'package:ios_log/ios_log.dart';\n\nclass RealFlutter {\n  static final Logger _logger = Logger('RealFlutter');\n\n  static void initializeLogging() {\n    if (Platform.isIOS) {\n      Logger.root.onRecord.listen((record) {\n        IOSLog.log(\n          record.message,\n          name: record.loggerName,\n          logType: record.level.iOSLogType,\n        );\n      });\n    } else {\n      // Default logging for other platforms\n      Logger.root.onRecord.listen((record) {\n        print('${record.level.name}: ${record.time}: ${record.message}');\n      });\n    }\n  }\n}\n```\n\nBy following these steps, you'll have a robust logging system in place for your Flutter application, with platform-specific integrations for enhanced debugging capabilities.",
    "_updatedAt": "2024-09-06T04:12:13Z",
    "slug": {
      "current": "logging",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1YHn",
        "_type": "reference",
        "_key": "n8lwk0gh"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:logging/logging.dart';\nimport 'dart:io' show Platform;\n\n// Step 1: Import platform-specific packages (if needed)\n// import 'package:android_logger/android_logger.dart';\n// import 'package:ios_log/ios_log.dart';\n\nvoid main() {\n  // Step 2: Initialize logging\n  RealFlutter.initializeLogging();\n  \n  // Step 3: Run the app\n  runApp(MyApp());\n}\n\nclass RealFlutter {\n  // Step 4: Create a logger instance\n  static final Logger _logger = Logger('RealFlutter');\n\n  // Step 5: Initialize logging with platform-specific considerations\n  static void initializeLogging() {\n    Logger.root.level = Level.ALL; // Set the root logger level to capture all log levels\n\n    if (Platform.isAndroid) {\n      // Android-specific logging setup\n      // AndroidLogger.initializeLogging();\n      Logger.root.onRecord.listen((record) {\n        print('Android: ${record.level.name}: ${record.time}: ${record.message}');\n        // AndroidLogger.log(record.level.androidLogPriority, record.loggerName, record.message);\n      });\n    } else if (Platform.isIOS) {\n      // iOS-specific logging setup\n      Logger.root.onRecord.listen((record) {\n        print('iOS: ${record.level.name}: ${record.time}: ${record.message}');\n        // IOSLog.log(record.message, name: record.loggerName, logType: record.level.iOSLogType);\n      });\n    } else {\n      // Default logging for other platforms\n      Logger.root.onRecord.listen((record) {\n        print('${record.level.name}: ${record.time}: ${record.message}');\n      });\n    }\n  }\n\n  // Step 6: Create methods to demonstrate different log levels\n  static void logInfo(String message) => _logger.info(message);\n  static void logWarning(String message) => _logger.warning(message);\n  static void logSevere(String message) => _logger.severe(message);\n  static void logFine(String message) => _logger.fine(message);\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: LoggingDemo(),\n    );\n  }\n}\n\nclass LoggingDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Logging Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Log Info'),\n              onPressed: () {\n                // Step 7: Use the logger to log an info message\n                RealFlutter.logInfo('This is an info message');\n              },\n            ),\n            ElevatedButton(\n              child: Text('Log Warning'),\n              onPressed: () {\n                // Step 8: Use the logger to log a warning message\n                RealFlutter.logWarning('This is a warning message');\n              },\n            ),\n            ElevatedButton(\n              child: Text('Log Severe'),\n              onPressed: () {\n                // Step 9: Use the logger to log a severe message\n                RealFlutter.logSevere('This is a severe error message');\n              },\n            ),\n            ElevatedButton(\n              child: Text('Log Fine'),\n              onPressed: () {\n                // Step 10: Use the logger to log a fine message\n                RealFlutter.logFine('This is a fine message for detailed tracing');\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The main() function is called when the app starts.\n// 2. RealFlutter.initializeLogging() is called to set up the logging system.\n//    - This sets the root logger level and configures platform-specific logging if needed.\n// 3. The MyApp widget is created and run, which in turn creates the LoggingDemo widget.\n// 4. The LoggingDemo widget displays a screen with four buttons, each corresponding to a different log level.\n// 5. When a button is pressed, it calls the corresponding logging method in the RealFlutter class.\n// 6. The RealFlutter class uses its _logger instance to log the message.\n// 7. The logged message is then processed by the onRecord listener set up in initializeLogging().\n// 8. Depending on the platform, the message is either printed to the console or sent to the platform-specific logging system.\n\n// This example demonstrates:\n// - Setting up a central logging class (RealFlutter)\n// - Initializing logging with platform-specific considerations\n// - Using different log levels (info, warning, severe, fine)\n// - Integrating logging into a Flutter UI\n// - Structuring the application to easily log from anywhere by calling RealFlutter's static methods\n```",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:18:24Z",
    "tutorialIncluded": true,
    "_rev": "eaCZ7mIhmiYZX5KGqJmQJA",
    "shortDescription": "Provides APIs for debugging and error logging, similar to loggers in other languages, such as the Closure JS Logger and java.util.logging.Logger.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGWu",
        "_type": "reference",
        "_key": "hwclcydc"
      }
    ],
    "tags": [
      "log",
      "logger",
      "debugging",
      "error-tracking"
    ],
    "dependentPackages": [
      {
        "_key": "iolrlwm2",
        "_ref": "Rx1Nho763d29lawKra1wGZ",
        "_type": "reference"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPapH2",
        "_type": "reference",
        "_key": "8d26afaf"
      }
    ],
    "name": "logging"
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:sliver_tools/sliver_tools.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sliver Tools Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const SliverToolsDemo(),\n    );\n  }\n}\n\nclass SliverToolsDemo extends StatelessWidget {\n  const SliverToolsDemo({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Sliver Tools Demo')),\n      body: CustomScrollView(\n        slivers: [\n          // Step 1: Using SliverStack\n          SliverStack(\n            children: [\n              // Background\n              SliverPositioned.fill(\n                child: Container(\n                  decoration: const BoxDecoration(\n                    gradient: LinearGradient(\n                      begin: Alignment.topCenter,\n                      end: Alignment.bottomCenter,\n                      colors: [Colors.blue, Colors.lightBlueAccent],\n                    ),\n                  ),\n                ),\n              ),\n              // Foreground content\n              SliverList(\n                delegate: SliverChildBuilderDelegate(\n                  (context, index) => ListTile(\n                    title: Text('Stacked Item $index', style: TextStyle(color: Colors.white)),\n                  ),\n                  childCount: 5,\n                ),\n              ),\n            ],\n          ),\n\n          // Step 2: Using SliverClip\n          SliverClip(\n            clipper: _WaveClipper(),\n            child: SliverToBoxAdapter(\n              child: Container(\n                height: 200,\n                color: Colors.orange,\n                child: const Center(child: Text('Clipped Section')),\n              ),\n            ),\n          ),\n\n          // Step 3: Using SliverCrossAxisConstrained\n          SliverCrossAxisConstrained(\n            maxCrossAxisExtent: 300,\n            child: SliverList(\n              delegate: SliverChildBuilderDelegate(\n                (context, index) => ListTile(title: Text('Constrained Item $index')),\n                childCount: 5,\n              ),\n            ),\n          ),\n\n          // Step 4: Using SliverAnimatedPaintExtent\n          SliverAnimatedPaintExtent(\n            duration: const Duration(seconds: 1),\n            child: SliverToBoxAdapter(\n              child: Container(\n                height: 100,\n                color: Colors.green,\n                child: const Center(child: Text('Animated Extent')),\n              ),\n            ),\n          ),\n\n          // Step 5: Using MultiSliver\n          MultiSliver(\n            children: [\n              const SliverToBoxAdapter(\n                child: Padding(\n                  padding: EdgeInsets.all(16.0),\n                  child: Text('MultiSliver Section', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),\n                ),\n              ),\n              SliverGrid(\n                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n                  crossAxisCount: 2,\n                  mainAxisSpacing: 10,\n                  crossAxisSpacing: 10,\n                  childAspectRatio: 1.5,\n                ),\n                delegate: SliverChildBuilderDelegate(\n                  (context, index) => Container(\n                    color: Colors.primaries[index % Colors.primaries.length],\n                    child: Center(child: Text('Grid Item $index')),\n                  ),\n                  childCount: 6,\n                ),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Custom clipper for the SliverClip example\nclass _WaveClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    final path = Path();\n    path.lineTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width * 0.25, size.height * 0.85,\n        size.width * 0.5, size.height * 0.75);\n    path.quadraticBezierTo(size.width * 0.75, size.height * 0.65,\n        size.width, size.height * 0.75);\n    path.lineTo(size.width, 0);\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}\n\n// Application flow explanation:\n/*\n1. The app starts by creating a CustomScrollView, which allows us to use slivers.\n2. SliverStack is used to create a gradient background with a list of items on top.\n3. SliverClip demonstrates custom clipping of a sliver with a wave-like shape.\n4. SliverCrossAxisConstrained limits the width of its child sliver.\n5. SliverAnimatedPaintExtent shows how to animate the extent of a sliver.\n6. MultiSliver combines multiple slivers, including a text header and a grid.\n\nThe flow of the application is top-down, with each sliver component demonstrating\na different feature of the sliver_tools package. Users can scroll through the\nentire content, experiencing the various sliver effects and layouts.\n\nThis example showcases the versatility and power of the sliver_tools package,\nallowing developers to create complex, performant scrollable layouts with ease.\n*/\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:18:25Z",
    "lastUpdate": "2023-07-16T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPasIS",
    "tutorialIncluded": true,
    "slug": {
      "current": "sliver_tools",
      "_type": "slug"
    },
    "description": "# Sliver Tools Package for Flutter: Enhancing Your Scrollable Experiences\n\n## Introduction\n\nIn the world of Flutter development, creating smooth and efficient scrollable experiences is crucial for building engaging user interfaces. The `sliver_tools` package is a powerful addition to your toolkit, offering a set of utilities and widgets that extend the capabilities of Flutter's built-in slivers.\n\n## What are Slivers?\n\nBefore diving into the `sliver_tools` package, let's quickly recap what slivers are in Flutter. Slivers are special-purpose widgets optimized for scrollable areas. They provide fine-grained control over the scrolling behavior and layout of scrollable widgets, allowing for more complex and performant scrolling experiences.\n\n## Enter Sliver Tools\n\nThe `sliver_tools` package, developed by Matan Lurey, introduces several new sliver widgets and utilities that complement Flutter's existing sliver ecosystem. These tools allow developers to create more advanced scrollable layouts with ease.\n\n## Key Features\n\n1. **SliverStack**: Allows stacking of multiple slivers, similar to how the Stack widget works for regular widgets.\n2. **SliverClip**: Provides clipping functionality for slivers, enabling custom shapes and animations.\n3. **SliverCrossAxisConstrained**: Constrains the cross-axis size of child slivers.\n4. **SliverAnimatedPaintExtent**: Animates the paint extent of a sliver.\n5. **MultiSliver**: Combines multiple slivers into a single sliver.\n\n## Benefits of Using Sliver Tools\n\n- **Enhanced Flexibility**: Create more complex scrollable layouts that were previously challenging or impossible.\n- **Improved Performance**: Optimize your scrollable widgets for better performance, especially in long lists or grids.\n- **Code Reusability**: Encapsulate common sliver patterns into reusable components.\n- **Animations**: Easily add animations to your scrollable interfaces.\n\n## Conclusion\n\nThe `sliver_tools` package is an invaluable asset for Flutter developers looking to push the boundaries of what's possible with scrollable interfaces. In the following sections, we'll explore how to use these tools in practice and showcase a comprehensive example demonstrating their power and flexibility.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1tZn",
        "_type": "reference",
        "_key": "z2i0vzdc"
      }
    ],
    "dependentPackages": [],
    "packageImage": null,
    "name": "sliver_tools",
    "tutorial": "# Tutorial: Getting Started with Sliver Tools\n\nIn this tutorial, we'll walk through the process of integrating and using the `sliver_tools` package in your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nFirst, add the `sliver_tools` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  sliver_tools: ^0.2.12\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Importing the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:sliver_tools/sliver_tools.dart';\n```\n\n## Step 3: Using SliverStack\n\nLet's start with a simple example using `SliverStack`:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverStack(\n          children: <Widget>[\n            SliverPositioned.fill(\n              child: Container(color: Colors.blue),\n            ),\n            SliverList(\n              delegate: SliverChildBuilderDelegate(\n                (BuildContext context, int index) {\n                  return ListTile(title: Text('Item $index'));\n                },\n                childCount: 20,\n              ),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n```\n\nThis example creates a stacked layout with a blue background and a list of items on top.\n\n## Step 4: Implementing SliverClip\n\nNow, let's use `SliverClip` to create a custom-shaped scrollable area:\n\n```dart\nSliverClip(\n  clipper: MyCustomClipper(),\n  child: SliverList(\n    delegate: SliverChildBuilderDelegate(\n      (BuildContext context, int index) {\n        return ListTile(title: Text('Clipped Item $index'));\n      },\n      childCount: 10,\n    ),\n  ),\n)\n```\n\nYou'll need to implement `MyCustomClipper` to define the clipping shape.\n\n## Step 5: Using MultiSliver\n\n`MultiSliver` is useful for grouping multiple slivers:\n\n```dart\nMultiSliver(\n  children: <Widget>[\n    SliverToBoxAdapter(\n      child: Container(\n        height: 100,\n        color: Colors.red,\n        child: Center(child: Text('Header')),\n      ),\n    ),\n    SliverList(\n      delegate: SliverChildBuilderDelegate(\n        (BuildContext context, int index) {\n          return ListTile(title: Text('Item $index'));\n        },\n        childCount: 5,\n      ),\n    ),\n    SliverToBoxAdapter(\n      child: Container(\n        height: 100,\n        color: Colors.green,\n        child: Center(child: Text('Footer')),\n      ),\n    ),\n  ],\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure smooth scrolling physics by using `BouncingScrollPhysics`:\n\n```dart\nCustomScrollView(\n  physics: BouncingScrollPhysics(),\n  // ... other properties\n)\n```\n\n### Android\n- Consider using `ClampingScrollPhysics` for a more Android-native feel:\n\n```dart\nCustomScrollView(\n  physics: ClampingScrollPhysics(),\n  // ... other properties\n)\n```\n\n### Web\n- Be mindful of browser scroll behavior. You may want to use `ScrollConfiguration` to customize the scrollbar appearance:\n\n```dart\nScrollConfiguration(\n  behavior: ScrollConfiguration.of(context).copyWith(scrollbars: false),\n  child: CustomScrollView(\n    // ... your slivers\n  ),\n)\n```\n\n## Conclusion\n\nThis tutorial covers the basics of using the `sliver_tools` package in your Flutter projects. Experiment with these widgets to create unique and performant scrollable experiences across different platforms. In the next section, we'll look at a comprehensive example that combines multiple features of the package.",
    "shortDescription": "A set of useful sliver tools that are missing from the flutter framework",
    "_type": "package",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "czljt3xa",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP"
      }
    ],
    "_updatedAt": "2024-09-06T04:12:13Z",
    "author": "pietervanloon.com",
    "_rev": "eaCZ7mIhmiYZX5KGqJmQPi",
    "tags": [
      "sliver",
      "scrolling",
      "ui",
      "custom-scroll-view"
    ],
    "likesCount": 1257,
    "pubPoint": 160
  },
  {
    "pubPoint": 160,
    "tags": [
      "animation",
      "ui",
      "effects",
      "celebration"
    ],
    "lastUpdate": "2022-05-12T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPasYW",
    "_type": "package",
    "likesCount": 1273,
    "name": "confetti",
    "tutorial": "# Tutorial: Implementing Confetti in Your Flutter App\n\nThis tutorial will guide you through the process of adding the Confetti package to your Flutter project and using its features effectively.\n\n## Step 1: Add the Dependency\n\nFirst, add the confetti package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  confetti: ^0.7.0  # Use the latest version available\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the confetti package:\n\n```dart\nimport 'package:confetti/confetti.dart';\n```\n\n## Step 3: Create a ConfettiController\n\nThe `ConfettiController` manages the state of the confetti animation. Create it in your `RealFlutter` class:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late ConfettiController _confettiController;\n\n  @override\n  void initState() {\n    super.initState();\n    _confettiController = ConfettiController(duration: const Duration(seconds: 5));\n  }\n\n  @override\n  void dispose() {\n    _confettiController.dispose();\n    super.dispose();\n  }\n\n  // ... rest of the class\n}\n```\n\n## Step 4: Add the ConfettiWidget\n\nPlace the `ConfettiWidget` in your build method:\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Stack(\n    children: [\n      // Your other widgets\n      Align(\n        alignment: Alignment.topCenter,\n        child: ConfettiWidget(\n          confettiController: _confettiController,\n          blastDirection: pi / 2, // Straight up\n          emissionFrequency: 0.05,\n          numberOfParticles: 20,\n          gravity: 0.1,\n        ),\n      ),\n      // Button to trigger confetti\n      ElevatedButton(\n        onPressed: () {\n          _confettiController.play();\n        },\n        child: Text('Celebrate!'),\n      ),\n    ],\n  );\n}\n```\n\n## Step 5: Customize the Confetti\n\nYou can customize various aspects of the confetti:\n\n```dart\nConfettiWidget(\n  confettiController: _confettiController,\n  colors: const [Colors.red, Colors.blue, Colors.yellow], // Custom colors\n  shouldLoop: true, // Set to true for continuous animation\n  blastDirectionality: BlastDirectionality.explosive, // Explode in all directions\n  emissionFrequency: 0.1,\n  numberOfParticles: 50,\n  maxBlastForce: 5,\n  minBlastForce: 2,\n  particleDrag: 0.05,\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional setup is required. The package works out of the box.\n\n### iOS\n\nFor iOS, you need to set the minimum deployment target to iOS 11.0 or higher in your `Podfile`:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n### Web\n\nThe Confetti package is compatible with Flutter web applications. However, be mindful of performance on lower-end devices when using extensive particle animations.\n\nBy following these steps, you'll have a fully functional confetti animation in your Flutter app. Experiment with different settings to achieve the perfect celebratory effect for your users!",
    "tutorialIncluded": true,
    "slug": {
      "current": "confetti",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmQWG",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAQu",
        "_type": "reference",
        "_key": "eowi6604"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:confetti/confetti.dart';\nimport 'dart:math';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize controllers for different confetti effects\n  late ConfettiController _controllerCenter;\n  late ConfettiController _controllerTopCenter;\n  late ConfettiController _controllerBottomCenter;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Set up the controllers with different durations\n    _controllerCenter = ConfettiController(duration: const Duration(seconds: 1));\n    _controllerTopCenter = ConfettiController(duration: const Duration(seconds: 5));\n    _controllerBottomCenter = ConfettiController(duration: const Duration(seconds: 10));\n  }\n\n  @override\n  void dispose() {\n    // Step 3: Dispose of the controllers when the widget is removed\n    _controllerCenter.dispose();\n    _controllerTopCenter.dispose();\n    _controllerBottomCenter.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Confetti Demo')),\n      body: Stack(\n        children: <Widget>[\n          // Step 4: Add different ConfettiWidgets to the stack\n          Align(\n            alignment: Alignment.center,\n            child: ConfettiWidget(\n              confettiController: _controllerCenter,\n              blastDirectionality: BlastDirectionality.explosive,\n              particleDrag: 0.05,\n              emissionFrequency: 0.05,\n              numberOfParticles: 50,\n              gravity: 0.05,\n              shouldLoop: false,\n              colors: const [Colors.green, Colors.blue, Colors.pink],\n            ),\n          ),\n          Align(\n            alignment: Alignment.topCenter,\n            child: ConfettiWidget(\n              confettiController: _controllerTopCenter,\n              blastDirection: pi / 2,\n              maxBlastForce: 5,\n              minBlastForce: 2,\n              emissionFrequency: 0.05,\n              numberOfParticles: 50,\n              gravity: 1,\n            ),\n          ),\n          Align(\n            alignment: Alignment.bottomCenter,\n            child: ConfettiWidget(\n              confettiController: _controllerBottomCenter,\n              blastDirection: -pi / 2,\n              emissionFrequency: 0.01,\n              numberOfParticles: 20,\n              maxBlastForce: 100,\n              minBlastForce: 80,\n              gravity: 0.3,\n            ),\n          ),\n          // Step 5: Create a column of buttons to trigger different effects\n          Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                ElevatedButton(\n                  onPressed: () {\n                    _controllerCenter.play();\n                  },\n                  child: Text(' Celebration Explosion!'),\n                ),\n                ElevatedButton(\n                  onPressed: () {\n                    _controllerTopCenter.play();\n                  },\n                  child: Text(' Confetti Rainfall'),\n                ),\n                ElevatedButton(\n                  onPressed: () {\n                    _controllerBottomCenter.play();\n                  },\n                  child: Text(' Confetti Fountain'),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes three ConfettiControllers in initState.\n// 2. The build method creates a Scaffold with an AppBar and a Stack as the body.\n// 3. Three ConfettiWidgets are added to the Stack, each with different configurations:\n//    - Center: Creates an explosive effect\n//    - Top: Creates a rainfall effect\n//    - Bottom: Creates a fountain effect\n// 4. A Column of ElevatedButtons is centered on the screen.\n// 5. When a button is pressed, it triggers the corresponding ConfettiController:\n//    - 'Celebration Explosion' plays the center controller\n//    - 'Confetti Rainfall' plays the top controller\n//    - 'Confetti Fountain' plays the bottom controller\n// 6. The confetti animation plays based on the configuration of each ConfettiWidget.\n// 7. The controllers are disposed of when the widget is removed to prevent memory leaks.\n\n// This example demonstrates various ways to use the Confetti package,\n// allowing users to trigger different confetti effects and customize\n// the behavior of each effect independently.\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1VMp",
        "_type": "reference",
        "_key": "m84wnftc"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference",
        "_key": "lyshapf3"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:18:27Z",
    "author": "funwith.app",
    "description": "# Flutter Confetti Package: Add Sparkle to Your App\n\nThe Flutter Confetti package is a delightful addition to any Flutter developer's toolkit. It allows you to easily add animated confetti to your application, creating a festive and engaging user experience. Whether you're celebrating a user's achievement, marking a special occasion, or simply wanting to add some flair to your UI, the Confetti package has got you covered.\n\n## Key Features\n\n1. **Customizable Particles**: Control the size, shape, and color of your confetti particles.\n2. **Flexible Emission**: Adjust the emission frequency and duration to suit your needs.\n3. **Direction Control**: Choose the direction in which confetti falls or explodes.\n4. **Performance Optimized**: Designed to be lightweight and efficient, even on mobile devices.\n5. **Easy Integration**: Simple to add to any Flutter project with minimal setup required.\n\n## Use Cases\n\n- Celebrate user achievements or milestones\n- Enhance game interfaces with victory animations\n- Create engaging onboarding experiences\n- Add visual interest to marketing or promotional screens\n\nThe Confetti package is an excellent way to add a touch of excitement and interactivity to your Flutter applications. In the following sections, we'll dive into how to implement and customize this package in your projects.",
    "shortDescription": "Blast colorful confetti all over the screen. Celebrate in app achievements with style. Control the velocity, angle, gravity and amount of confetti.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "57aiy8j2",
        "_ref": "uQRNMiDfrp20RZ8Id8CaUL"
      },
      {
        "_type": "reference",
        "_key": "vuxaxx6l",
        "_ref": "Rx1Nho763d29lawKra1ZND"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_updatedAt": "2024-09-06T04:12:15Z"
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:mime/mime.dart';\nimport 'dart:io';\nimport 'package:file_picker/file_picker.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'MIME Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const MimeDemo(),\n    );\n  }\n}\n\nclass MimeDemo extends StatefulWidget {\n  const MimeDemo({Key? key}) : super(key: key);\n\n  @override\n  _MimeDemoState createState() => _MimeDemoState();\n}\n\nclass _MimeDemoState extends State<MimeDemo> {\n  String? _filePath;\n  String? _mimeType;\n  String? _fileExtension;\n\n  // Step 1: Method to pick a file\n  Future<void> _pickFile() async {\n    FilePickerResult? result = await FilePicker.platform.pickFiles();\n    \n    if (result != null) {\n      setState(() {\n        _filePath = result.files.single.path;\n        _mimeType = null;\n        _fileExtension = null;\n      });\n    }\n  }\n\n  // Step 2: Method to detect MIME type\n  void _detectMimeType() {\n    if (_filePath != null) {\n      setState(() {\n        _mimeType = lookupMimeType(_filePath!);\n      });\n    }\n  }\n\n  // Step 3: Method to get file extension from MIME type\n  void _getFileExtension() {\n    if (_mimeType != null) {\n      setState(() {\n        _fileExtension = extensionFromMime(_mimeType!);\n      });\n    }\n  }\n\n  // Step 4: Method to perform content analysis\n  Future<void> _performContentAnalysis() async {\n    if (_filePath != null) {\n      File file = File(_filePath!);\n      List<int> bytes = await file.readAsBytes();\n      bytes = bytes.take(defaultMagicNumbersMaxLength).toList();\n      \n      setState(() {\n        _mimeType = lookupMimeType('', headerBytes: bytes);\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MIME Package Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            ElevatedButton(\n              onPressed: _pickFile,\n              child: const Text('Pick a File'),\n            ),\n            const SizedBox(height: 20),\n            Text('File Path: ${_filePath ?? \"No file selected\"}'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _detectMimeType,\n              child: const Text('Detect MIME Type'),\n            ),\n            Text('MIME Type: ${_mimeType ?? \"Not detected\"}'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _getFileExtension,\n              child: const Text('Get File Extension'),\n            ),\n            Text('File Extension: ${_fileExtension ?? \"Not determined\"}'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _performContentAnalysis,\n              child: const Text('Perform Content Analysis'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a UI with buttons for different MIME package operations.\n// 2. User picks a file using the file picker.\n// 3. The file path is displayed.\n// 4. User can then:\n//    a. Detect the MIME type based on the file extension.\n//    b. Get the file extension from the detected MIME type.\n//    c. Perform content analysis for more accurate MIME type detection.\n// 5. Results are displayed after each operation.\n// \n// Note: This example demonstrates basic usage of the MIME package.\n// In a production app, you'd want to add error handling and possibly\n// use asynchronous operations more extensively.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:18:31Z",
    "tutorial": "# MIME Package in Flutter: A Comprehensive Tutorial\n\n## Getting Started\n\nTo begin using the MIME package in your Flutter project, follow these steps:\n\n1. Add the MIME package to your `pubspec.yaml` file:\n   ```yaml\n   dependencies:\n     mime: ^1.0.0\n   ```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import the package in your Dart file:\n   ```dart\n   import 'package:mime/mime.dart';\n   ```\n\n## Basic Usage\n\n### Detecting MIME Types\n\nTo detect the MIME type of a file:\n\n```dart\nString filePath = 'path/to/your/file.jpg';\nString? mimeType = lookupMimeType(filePath);\nprint('MIME Type: $mimeType'); // Output: MIME Type: image/jpeg\n```\n\n### Getting File Extension from MIME Type\n\nTo get the file extension for a given MIME type:\n\n```dart\nString mimeType = 'text/plain';\nString? fileExtension = extensionFromMime(mimeType);\nprint('File Extension: $fileExtension'); // Output: File Extension: txt\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, you might need to request storage permissions to access files. Add the following to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n### iOS\n\nFor iOS, you generally don't need additional permissions for basic file operations. However, if you're accessing user files, you might need to add appropriate usage descriptions in your `Info.plist`:\n\n```xml\n<key>NSDocumentsFolderUsageDescription</key>\n<string>This app needs access to the documents folder to analyze file types.</string>\n```\n\n## Advanced Usage\n\n### Custom MIME Type Definitions\n\nYou can add custom MIME type definitions:\n\n```dart\naddMimeType('customtype', 'application/x-custom');\n```\n\n### Content Analysis\n\nFor more accurate MIME type detection, especially when file extensions are missing or unreliable, you can use content analysis:\n\n```dart\nimport 'dart:io';\n\nFile file = File('path/to/unknown/file');\nList<int> bytes = file.readAsBytesSync().take(defaultMagicNumbersMaxLength).toList();\nString? mimeType = lookupMimeType('', headerBytes: bytes);\nprint('Detected MIME Type: $mimeType');\n```\n\nThis tutorial covers the basics of using the MIME package in Flutter. In the next section, we'll see a complete example that demonstrates these concepts in action.",
    "slug": {
      "current": "mime",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "tools.dart.dev",
    "_type": "package",
    "lastUpdate": "2024-08-25T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:16Z",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1sm7",
        "_type": "reference",
        "_key": "il53lw53"
      }
    ],
    "subCategories": [
      {
        "_key": "j4kk91co",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGar",
        "_type": "reference"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "43xvuqoq"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1LSx",
        "_type": "reference",
        "_key": "nyhbybz9"
      }
    ],
    "tags": [
      "magic-numbers",
      "mime",
      "mimetype",
      "multipart-form",
      "file-type"
    ],
    "packageImage": null,
    "name": "mime",
    "likesCount": 464,
    "_id": "V06bsD4sX3T8NTHrBPat4e",
    "_rev": "AE3hjGWNkNE6aGQMMbaRYP",
    "description": "# Understanding the MIME Package in Flutter\n\n## Introduction\n\nThe MIME package in Flutter is a powerful tool for handling Multipurpose Internet Mail Extensions (MIME) types. It provides a set of utilities for working with MIME types, which are essential for identifying file formats and content types in various applications, especially those dealing with file uploads, downloads, and content handling.\n\n## Key Features of the MIME Package\n\n1. **MIME Type Detection**: The package can detect MIME types based on file extensions or content analysis.\n2. **File Extension Mapping**: It provides a comprehensive mapping between file extensions and their corresponding MIME types.\n3. **Custom MIME Type Handling**: Developers can add or override MIME type definitions for specific use cases.\n4. **Content-Type Header Generation**: Useful for setting appropriate headers in HTTP requests and responses.\n\n## Why Use the MIME Package?\n\n- **Improved File Handling**: Accurately identify and handle different file types in your Flutter applications.\n- **Enhanced User Experience**: Provide appropriate actions or previews based on file types.\n- **Security**: Validate file types to ensure only allowed formats are processed or uploaded.\n- **Cross-Platform Compatibility**: Works seamlessly across different platforms supported by Flutter.\n\nIn the following sections, we'll dive deeper into how to use the MIME package in your Flutter projects, including a step-by-step tutorial and a comprehensive example demonstrating its features.",
    "shortDescription": "Utilities for handling media (MIME) types, including determining a type from a file extension and file contents."
  },
  {
    "description": "# Drift Package for Flutter: Powerful Local Database Solution\n\n## Introduction\n\nThe drift package is a powerful and type-safe persistence library for Flutter applications. It provides a robust solution for local database management, offering a high-level abstraction over SQLite. Drift, formerly known as Moor, allows developers to define database schemas using Dart code and generates type-safe APIs for database operations.\n\n## Key Features\n\n1. **Type-safe queries**: Drift generates Dart code that ensures type safety for your database operations, reducing runtime errors.\n\n2. **Reactive streams**: It provides reactive streams for database changes, allowing your UI to update automatically when data changes.\n\n3. **Migrations**: Drift supports database migrations, making it easy to evolve your schema as your app grows.\n\n4. **Custom SQL queries**: While providing a high-level API, drift also allows you to write custom SQL queries when needed.\n\n5. **Transactions**: It supports database transactions for maintaining data integrity.\n\n6. **Null safety**: Drift is fully compatible with Dart's null safety feature.\n\n7. **Platform support**: Works on all platforms supported by Flutter, including Android, iOS, web, and desktop.\n\n## When to Use Drift\n\nDrift is an excellent choice when:\n\n- You need a local database solution for your Flutter app.\n- You want type-safe database operations.\n- Your app requires complex queries or data relationships.\n- You need to handle large amounts of structured data locally.\n\nIn the following sections, we'll dive into a tutorial on how to set up and use drift in your Flutter application, followed by a comprehensive example demonstrating its features.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGH6",
        "_type": "reference",
        "_key": "pt00tcob"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1673,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "ao6jdrn5",
        "_ref": "Rx1Nho763d29lawKra1L7f"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPah4K",
        "_type": "reference",
        "_key": "zu9d4zq4"
      }
    ],
    "_createdAt": "2024-08-28T22:18:36Z",
    "name": "drift",
    "_rev": "ezMiwuUkJkbYMWycA6RcyT",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "2ijtjrbh",
        "_ref": "uQRNMiDfrp20RZ8Id8CX1D"
      },
      {
        "_type": "reference",
        "_key": "aji3xfa5",
        "_ref": "uQRNMiDfrp20RZ8Id8Cew9"
      }
    ],
    "lastUpdate": "2024-08-15T18:30:00.000Z",
    "slug": {
      "current": "drift",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_id": "V06bsD4sX3T8NTHrBPatKi",
    "tutorial": "# Drift Package for Flutter: Tutorial\n\nThis tutorial will guide you through setting up and using the drift package in your Flutter application. We'll cover installation, database setup, and basic operations.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  drift: ^2.8.0\n  sqlite3_flutter_libs: ^0.5.0\n  path_provider: ^2.0.0\n  path: ^1.8.0\n\ndev_dependencies:\n  drift_dev: ^2.8.0\n  build_runner: ^2.4.0\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Define Your Database Schema\n\nCreate a new file `database.dart` and define your database schema:\n\n```dart\nimport 'dart:io';\nimport 'package:drift/drift.dart';\nimport 'package:drift/native.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart' as p;\n\npart 'database.g.dart';\n\nclass Tasks extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 1, max: 50)();\n  TextColumn get content => text().named('body')();\n  IntColumn get category => integer().nullable()();\n  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();\n}\n\n@DriftDatabase(tables: [Tasks])\nclass RealFlutter extends _$RealFlutter {\n  RealFlutter() : super(_openConnection());\n\n  @override\n  int get schemaVersion => 1;\n}\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final dbFolder = await getApplicationDocumentsDirectory();\n    final file = File(p.join(dbFolder.path, 'db.sqlite'));\n    return NativeDatabase(file);\n  });\n}\n```\n\n## Step 3: Generate the Code\n\nRun the following command to generate the necessary Dart code:\n\n```\nflutter pub run build_runner build\n```\n\nThis will create a `database.g.dart` file with generated code for your database operations.\n\n## Step 4: Use the Database in Your App\n\nNow you can use the database in your Flutter app. Here's a basic example:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'database.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  final db = RealFlutter();\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Drift Demo')),\n        body: FutureBuilder<List<Task>>(\n          future: db.select(db.tasks).get(),\n          builder: (context, snapshot) {\n            if (snapshot.hasData) {\n              return ListView.builder(\n                itemCount: snapshot.data!.length,\n                itemBuilder: (context, index) {\n                  final task = snapshot.data![index];\n                  return ListTile(\n                    title: Text(task.title),\n                    subtitle: Text(task.content),\n                  );\n                },\n              );\n            } else {\n              return Center(child: CircularProgressIndicator());\n            }\n          },\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: Icon(Icons.add),\n          onPressed: () async {\n            await db.into(db.tasks).insert(\n                  TasksCompanion.insert(\n                    title: 'New Task',\n                    content: 'Task Content',\n                  ),\n                );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nNo additional setup is required for Android.\n\n### iOS\n\nAdd the following to your `ios/Podfile`:\n\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '9.0'\n    end\n  end\nend\n```\n\n### Web\n\nFor web support, you need to use `drift/web.dart` instead of `drift/native.dart`. Modify your database connection as follows:\n\n```dart\nimport 'package:drift/web.dart';\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final db = await WebDatabase.withStorage(await DriftWebStorage.indexedDb('db'));\n    return db;\n  });\n}\n```\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, you need to use `drift/ffi.dart` instead of `drift/native.dart`. Modify your imports and database connection as follows:\n\n```dart\nimport 'package:drift/ffi.dart';\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final dbFolder = await getApplicationDocumentsDirectory();\n    final file = File(p.join(dbFolder.path, 'db.sqlite'));\n    return NativeDatabase(file);\n  });\n}\n```\n\nThis setup covers the basics of using drift in your Flutter application across different platforms. In the next section, we'll look at a more comprehensive example demonstrating various features of the drift package.",
    "tutorialIncluded": true,
    "packageImage": null,
    "_type": "package",
    "shortDescription": "Drift is a reactive library to store relational data in Dart and Flutter applications.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:drift/drift.dart' as drift;\nimport 'database.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Drift Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize the database\n  late RealFlutterDatabase database;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Create an instance of the database\n    database = RealFlutterDatabase();\n  }\n\n  @override\n  void dispose() {\n    // Step 3: Close the database when the widget is disposed\n    database.close();\n    super.dispose();\n  }\n\n  // Step 4: Method to add a new task\n  Future<void> _addTask() async {\n    await database.into(database.tasks).insert(\n          TasksCompanion.insert(\n            title: 'New Task',\n            content: 'This is a new task',\n            category: drift.Value(1),\n          ),\n        );\n  }\n\n  // Step 5: Method to update a task\n  Future<void> _updateTask(Task task) async {\n    await database.update(database.tasks).replace(task);\n  }\n\n  // Step 6: Method to delete a task\n  Future<void> _deleteTask(Task task) async {\n    await database.delete(database.tasks).delete(task);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Drift Demo')),\n      // Step 7: Use StreamBuilder to reactively display tasks\n      body: StreamBuilder<List<Task>>(\n        stream: database.watchAllTasks(),\n        builder: (context, snapshot) {\n          if (snapshot.hasData) {\n            return ListView.builder(\n              itemCount: snapshot.data!.length,\n              itemBuilder: (context, index) {\n                final task = snapshot.data![index];\n                return ListTile(\n                  title: Text(task.title),\n                  subtitle: Text(task.content),\n                  trailing: Row(\n                    mainAxisSize: MainAxisSize.min,\n                    children: [\n                      // Step 8: Update task button\n                      IconButton(\n                        icon: Icon(Icons.edit),\n                        onPressed: () async {\n                          final updatedTask = task.copyWith(\n                            title: '${task.title} (Updated)',\n                          );\n                          await _updateTask(updatedTask);\n                        },\n                      ),\n                      // Step 9: Delete task button\n                      IconButton(\n                        icon: Icon(Icons.delete),\n                        onPressed: () async {\n                          await _deleteTask(task);\n                        },\n                      ),\n                    ],\n                  ),\n                );\n              },\n            );\n          } else if (snapshot.hasError) {\n            return Center(child: Text('Error: ${snapshot.error}'));\n          } else {\n            return Center(child: CircularProgressIndicator());\n          }\n        },\n      ),\n      // Step 10: Add new task button\n      floatingActionButton: FloatingActionButton(\n        child: Icon(Icons.add),\n        onPressed: _addTask,\n      ),\n    );\n  }\n}\n\n// Here's an explanation of the application flow:\n\n// 1. The app starts by initializing the RealFlutterDatabase in the initState method.\n// 2. The build method sets up a StreamBuilder that listens to changes in the tasks table.\n// 3. When the app loads, it displays all existing tasks in a ListView.\n// 4. The FloatingActionButton allows users to add new tasks. When pressed, it calls _addTask method.\n// 5. Each task in the list has two action buttons:\n//    - Edit: Updates the task title by appending \" (Updated)\" to it.\n//    - Delete: Removes the task from the database.\n// 6. Any changes (add, update, delete) trigger the StreamBuilder to rebuild with the updated data.\n// 7. The database is closed when the widget is disposed to free up resources.\n\n// This example demonstrates key features of drift:\n// - Reactive streams for real-time UI updates\n// - CRUD operations (Create, Read, Update, Delete)\n// - Use of transactions for data integrity\n// - Type-safe queries and operations\n\n// Note: For a complete implementation, you would typically split this into multiple files\n// (e.g., separate database.dart, task_list.dart, task_form.dart) for better organization.\n```",
    "tags": [
      "drift",
      "database",
      "sql",
      "orm",
      "persistence"
    ],
    "_updatedAt": "2024-09-06T04:12:17Z",
    "author": "simonbinder.eu"
  },
  {
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using the shelf package in a Flutter project. We'll cover both the basics and some advanced features, including platform-specific considerations.\n\n### Step 1: Add Dependencies\n\nFirst, add the shelf package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  shelf: ^1.4.0\n  shelf_router: ^1.1.3\n```\n\nRun `flutter pub get` to fetch the dependencies.\n\n### Step 2: Create a Basic Server\n\nCreate a new file called `server.dart` and add the following code:\n\n```dart\nimport 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart' as io;\n\nvoid main() async {\n  final handler = const shelf.Pipeline()\n      .addMiddleware(shelf.logRequests())\n      .addHandler(_echoRequest);\n\n  final server = await io.serve(handler, 'localhost', 8080);\n  print('Serving at http://${server.address.host}:${server.port}');\n}\n\nshelf.Response _echoRequest(shelf.Request request) {\n  return shelf.Response.ok('Request for \"${request.url}\"');\n}\n```\n\nThis creates a basic server that responds to all requests with an echo of the requested URL.\n\n### Step 3: Add Routing\n\nTo handle different routes, we'll use the `shelf_router` package. Update your `server.dart` file:\n\n```dart\nimport 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart' as io;\nimport 'package:shelf_router/shelf_router.dart';\n\nvoid main() async {\n  final app = Router();\n\n  app.get('/', (request) {\n    return shelf.Response.ok('Welcome to RealFlutter Server!');\n  });\n\n  app.get('/hello/<name>', (request, String name) {\n    return shelf.Response.ok('Hello, $name!');\n  });\n\n  final handler = const shelf.Pipeline()\n      .addMiddleware(shelf.logRequests())\n      .addHandler(app);\n\n  final server = await io.serve(handler, 'localhost', 8080);\n  print('Serving at http://${server.address.host}:${server.port}');\n}\n```\n\n### Step 4: Handle POST Requests\n\nLet's add a route to handle POST requests:\n\n```dart\napp.post('/api/data', (request) async {\n  final payload = await request.readAsString();\n  // Process the payload\n  return shelf.Response.ok('Received data: $payload');\n});\n```\n\n### Step 5: Platform-Specific Considerations\n\n#### Android\n\nFor Android, you need to add the INTERNET permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n#### iOS\n\nFor iOS, you need to configure App Transport Security (ATS) in your `Info.plist` file:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsLocalNetworking</key>\n    <true/>\n</dict>\n```\n\n#### Web\n\nFor web applications, ensure that your server is set up to handle CORS (Cross-Origin Resource Sharing) if your Flutter web app is hosted on a different domain:\n\n```dart\nimport 'package:shelf_cors_headers/shelf_cors_headers.dart';\n\n// In your main function\nfinal handler = const shelf.Pipeline()\n    .addMiddleware(corsHeaders())\n    .addMiddleware(shelf.logRequests())\n    .addHandler(app);\n```\n\nDon't forget to add the `shelf_cors_headers` package to your `pubspec.yaml` file.\n\nBy following these steps, you've created a basic server using the shelf package in Flutter, with routing and platform-specific considerations. In the next section, we'll look at a more comprehensive example that demonstrates additional features of the package.",
    "tutorialIncluded": true,
    "slug": {
      "current": "shelf",
      "_type": "slug"
    },
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "c9k69266"
      },
      {
        "_type": "reference",
        "_key": "j14555r4",
        "_ref": "V06bsD4sX3T8NTHrBPapH2"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-06-20T18:30:00.000Z",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "n6ly6py4",
        "_ref": "Rx1Nho763d29lawKra1LSx"
      }
    ],
    "subCategories": [
      {
        "_key": "c4m43dxk",
        "_ref": "4gmBGwifQuSypgRenUbW2r",
        "_type": "reference"
      }
    ],
    "tags": [
      "server",
      "shelf",
      "backend",
      "http-server",
      "web-server"
    ],
    "pubPoint": 160,
    "author": "tools.dart.dev",
    "description": "# Shelf Package in Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe shelf package is a powerful tool in the Flutter ecosystem that provides a composable way to create web server applications. It offers a set of utilities for handling HTTP requests and responses, making it an excellent choice for building robust backend services for your Flutter applications.\n\nKey features of the shelf package include:\n\n1. **Composability**: Shelf allows you to build complex server logic by composing simple functions, known as middlewares.\n\n2. **Flexibility**: It supports various HTTP methods and provides fine-grained control over request handling and response generation.\n\n3. **Extensibility**: The package can be easily extended with additional functionalities through middlewares and handlers.\n\n4. **Performance**: Shelf is designed to be lightweight and efficient, making it suitable for both small and large-scale applications.\n\n5. **Testing**: The package includes utilities for testing your server logic, ensuring reliability and maintainability.\n\nIn the following sections, we'll dive deeper into how to use the shelf package in your Flutter projects, providing a tutorial and a comprehensive example to demonstrate its capabilities.",
    "likesCount": 874,
    "_createdAt": "2024-08-28T22:18:42Z",
    "name": "shelf",
    "_id": "V06bsD4sX3T8NTHrBPb2EG",
    "shortDescription": "A model for web server middleware that encourages composition and easy reuse.",
    "example": "```\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart' as io;\nimport 'package:shelf_router/shelf_router.dart';\nimport 'dart:convert';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String serverStatus = 'Server not started';\n  String serverResponse = '';\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('RealFlutter Shelf Demo')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text(serverStatus),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: startServer,\n                child: Text('Start Server'),\n              ),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: testServerEndpoints,\n                child: Text('Test Server Endpoints'),\n              ),\n              SizedBox(height: 20),\n              Text(serverResponse),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Start the server\n  void startServer() async {\n    final app = Router();\n\n    // Step 2: Define routes\n    app.get('/', (request) {\n      return shelf.Response.ok('Welcome to RealFlutter Server!');\n    });\n\n    app.get('/hello/<name>', (request, String name) {\n      return shelf.Response.ok('Hello, $name!');\n    });\n\n    app.post('/api/data', (request) async {\n      final payload = await request.readAsString();\n      return shelf.Response.ok('Received data: $payload');\n    });\n\n    // Step 3: Add middleware for logging\n    final handler = const shelf.Pipeline()\n        .addMiddleware(shelf.logRequests())\n        .addHandler(app);\n\n    // Step 4: Start the server\n    final server = await io.serve(handler, 'localhost', 8080);\n    setState(() {\n      serverStatus = 'Server running on ${server.address.host}:${server.port}';\n    });\n  }\n\n  // Step 5: Test server endpoints\n  void testServerEndpoints() async {\n    setState(() {\n      serverResponse = 'Testing endpoints...';\n    });\n\n    // Test GET request\n    var response = await get('http://localhost:8080/');\n    var getResponse = 'GET /: ${response.body}\\n';\n\n    // Test GET request with parameter\n    response = await get('http://localhost:8080/hello/RealFlutter');\n    getResponse += 'GET /hello/RealFlutter: ${response.body}\\n';\n\n    // Test POST request\n    response = await post(\n      'http://localhost:8080/api/data',\n      body: json.encode({'message': 'Hello from RealFlutter!'}),\n    );\n    var postResponse = 'POST /api/data: ${response.body}';\n\n    setState(() {\n      serverResponse = getResponse + postResponse;\n    });\n  }\n}\n\n// Helper functions to simulate HTTP requests\nFuture<Response> get(String url) async {\n  // In a real app, use a proper HTTP client like http package\n  return Response('Simulated GET response', 200);\n}\n\nFuture<Response> post(String url, {dynamic body}) async {\n  // In a real app, use a proper HTTP client like http package\n  return Response('Simulated POST response', 200);\n}\n\nclass Response {\n  final String body;\n  final int statusCode;\n\n  Response(this.body, this.statusCode);\n}\n\n// Application flow:\n// 1. The app starts and displays a button to start the server.\n// 2. When the \"Start Server\" button is pressed, the startServer() function is called:\n//    - It creates a Router instance and defines routes for '/', '/hello/<name>', and '/api/data'.\n//    - It sets up middleware for request logging.\n//    - It starts the server on localhost:8080.\n// 3. The server status is updated on the UI.\n// 4. When the \"Test Server Endpoints\" button is pressed, the testServerEndpoints() function is called:\n//    - It simulates GET and POST requests to the server endpoints.\n//    - The responses are collected and displayed on the UI.\n// \n// Note: In a real-world scenario, you would use a proper HTTP client to make actual network requests,\n// and you might want to handle errors and edge cases more robustly. This example is simplified for\n// demonstration purposes.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmQg5",
    "_type": "package",
    "_updatedAt": "2024-09-06T04:12:19Z"
  },
  {
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfH24",
        "_type": "reference",
        "_key": "3grmkjlx"
      }
    ],
    "_createdAt": "2024-08-28T22:18:43Z",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "rmp16uft"
      },
      {
        "_key": "ftieplgp",
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:20Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaRlB",
    "shortDescription": "Flutter integration for Supabase. This package makes it simple for developers to build secure and scalable products.",
    "description": "# Supabase Flutter Package: Empowering Real-Time Applications\n\n## Introduction\n\nThe `supabase_flutter` package is a powerful tool for Flutter developers looking to integrate real-time database functionality into their applications. This package serves as a Flutter client for Supabase, an open-source alternative to Firebase, providing a suite of tools for building scalable and responsive applications.\n\n## Key Features\n\n1. **Real-time subscriptions**: Keep your app's data up-to-date with instant updates from the server.\n2. **Authentication**: Easily implement secure user authentication and management.\n3. **Database operations**: Perform CRUD operations on your Supabase database with a simple, intuitive API.\n4. **Storage**: Manage file uploads and downloads with Supabase's storage solution.\n5. **Functions**: Execute server-side functions for complex operations.\n\n## Why Choose Supabase Flutter?\n\n- **Open-source**: Full control over your data and infrastructure.\n- **PostgreSQL-based**: Leverage the power and flexibility of PostgreSQL.\n- **Easy integration**: Seamlessly works with existing Flutter projects.\n- **Scalability**: Built to handle applications of any size.\n\nIn the following sections, we'll dive into a tutorial on setting up Supabase Flutter and explore a comprehensive example showcasing its features.",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "supabase",
      "backend",
      "database",
      "authentication",
      "realtime"
    ],
    "name": "supabase_flutter",
    "_id": "V06bsD4sX3T8NTHrBPb2UK",
    "tutorial": "# Supabase Flutter Package: Tutorial\n\nThis tutorial will guide you through setting up and using the `supabase_flutter` package in your Flutter application.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  supabase_flutter: ^1.10.14\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Initialize Supabase\n\nIn your `main.dart` file, initialize Supabase before running your app:\n\n```dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Supabase.initialize(\n    url: 'YOUR_SUPABASE_URL',\n    anonKey: 'YOUR_SUPABASE_ANON_KEY',\n  );\n\n  runApp(const MyApp());\n}\n```\n\nReplace `YOUR_SUPABASE_URL` and `YOUR_SUPABASE_ANON_KEY` with your actual Supabase project details.\n\n## Step 3: Platform-specific setup\n\n### Android\n\nAdd the following to your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        ...\n        minSdkVersion 21\n    }\n}\n```\n\n### iOS\n\nUpdate your `ios/Runner/Info.plist` file:\n\n```xml\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>io.supabase.flutterquickstart</string>\n        </array>\n    </dict>\n</array>\n```\n\nReplace `io.supabase.flutterquickstart` with your custom URL scheme.\n\n### Web\n\nFor web support, add the following script to your `web/index.html` file:\n\n```html\n<head>\n  ...\n  <script src=\"https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2\"></script>\n</head>\n```\n\n## Step 4: Basic Usage\n\nHere's a quick example of how to use Supabase Flutter for authentication and database operations:\n\n```dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nfinal supabase = Supabase.instance.client;\n\n// Sign up a new user\nFuture<void> signUp(String email, String password) async {\n  final response = await supabase.auth.signUp(email: email, password: password);\n  final user = response.user;\n  final session = response.session;\n}\n\n// Sign in an existing user\nFuture<void> signIn(String email, String password) async {\n  final response = await supabase.auth.signInWithPassword(email: email, password: password);\n  final user = response.user;\n  final session = response.session;\n}\n\n// Fetch data from a table\nFuture<void> fetchData() async {\n  final response = await supabase\n    .from('your_table')\n    .select()\n    .execute();\n  final data = response.data;\n}\n\n// Insert data into a table\nFuture<void> insertData(Map<String, dynamic> data) async {\n  await supabase\n    .from('your_table')\n    .insert(data)\n    .execute();\n}\n```\n\nThis tutorial covers the basics of setting up and using Supabase Flutter. In the next section, we'll explore a more comprehensive example that demonstrates various features of the package.",
    "author": "supabase.io",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\n// Step 1: Initialize Supabase\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Supabase.initialize(\n    url: 'YOUR_SUPABASE_URL',\n    anonKey: 'YOUR_SUPABASE_ANON_KEY',\n  );\n\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Supabase Flutter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _messageController = TextEditingController();\n\n  List<Map<String, dynamic>> _messages = [];\n\n  // Step 2: Get Supabase client instance\n  final supabase = Supabase.instance.client;\n\n  @override\n  void initState() {\n    super.initState();\n    _subscribeToMessages();\n  }\n\n  // Step 3: Implement sign up functionality\n  Future<void> _signUp() async {\n    try {\n      final response = await supabase.auth.signUp(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n      if (response.user != null) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Sign up successful!')),\n        );\n      }\n    } catch (error) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: $error')),\n      );\n    }\n  }\n\n  // Step 4: Implement sign in functionality\n  Future<void> _signIn() async {\n    try {\n      final response = await supabase.auth.signInWithPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n      if (response.user != null) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Sign in successful!')),\n        );\n      }\n    } catch (error) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: $error')),\n      );\n    }\n  }\n\n  // Step 5: Implement message sending functionality\n  Future<void> _sendMessage() async {\n    try {\n      await supabase.from('messages').insert({\n        'content': _messageController.text,\n        'user_id': supabase.auth.currentUser!.id,\n      });\n      _messageController.clear();\n    } catch (error) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: $error')),\n      );\n    }\n  }\n\n  // Step 6: Implement real-time subscription to messages\n  void _subscribeToMessages() {\n    supabase\n        .from('messages')\n        .stream(primaryKey: ['id'])\n        .order('created_at')\n        .listen((List<Map<String, dynamic>> data) {\n      setState(() {\n        _messages = data;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Supabase Flutter Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            TextField(\n              controller: _emailController,\n              decoration: const InputDecoration(labelText: 'Email'),\n            ),\n            TextField(\n              controller: _passwordController,\n              decoration: const InputDecoration(labelText: 'Password'),\n              obscureText: true,\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(onPressed: _signUp, child: const Text('Sign Up')),\n            ElevatedButton(onPressed: _signIn, child: const Text('Sign In')),\n            const SizedBox(height: 16),\n            Expanded(\n              child: ListView.builder(\n                itemCount: _messages.length,\n                itemBuilder: (context, index) {\n                  final message = _messages[index];\n                  return ListTile(\n                    title: Text(message['content']),\n                    subtitle: Text('User ID: ${message['user_id']}'),\n                  );\n                },\n              ),\n            ),\n            TextField(\n              controller: _messageController,\n              decoration: const InputDecoration(labelText: 'New Message'),\n            ),\n            ElevatedButton(\n              onPressed: _sendMessage,\n              child: const Text('Send Message'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes Supabase in the main() function.\n// 2. The RealFlutter class sets up the MaterialApp and defines the home page.\n// 3. The HomePage is a StatefulWidget that manages the state of the application.\n// 4. In the _HomePageState:\n//    - We set up controllers for email, password, and message input.\n//    - We get the Supabase client instance.\n//    - In initState(), we subscribe to real-time updates from the 'messages' table.\n// 5. The _signUp() method handles user registration using Supabase authentication.\n// 6. The _signIn() method handles user login using Supabase authentication.\n// 7. The _sendMessage() method inserts a new message into the 'messages' table.\n// 8. The _subscribeToMessages() method sets up a real-time listener for changes in the 'messages' table.\n// 9. The build() method creates the UI, including:\n//    - Input fields for email and password\n//    - Buttons for sign up and sign in\n//    - A list view displaying messages from the 'messages' table\n//    - An input field and button for sending new messages\n// 10. When a user signs up or signs in, the app displays a success message or an error if something goes wrong.\n// 11. When a user sends a message, it's immediately inserted into the database.\n// 12. Due to the real-time subscription, any new messages or changes to existing messages are instantly reflected in the UI.\n\n// This example demonstrates authentication, real-time database operations, and state management using Supabase Flutter.\n```",
    "likesCount": 597,
    "tutorialIncluded": true,
    "slug": {
      "current": "supabase_flutter",
      "_type": "slug"
    },
    "pubPoint": 160,
    "similarPackages": []
  },
  {
    "name": "formz",
    "_id": "V06bsD4sX3T8NTHrBPb2kO",
    "author": "verygood.ventures",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "m86ovxvn",
        "_ref": "uQRNMiDfrp20RZ8Id8CaDn"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "e9cf06qn",
        "_ref": "t8DYBEKn49O4mjbyRAfCdI"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "lastUpdate": "2024-02-20T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:21Z",
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaRoN",
    "tags": [
      "form",
      "validation",
      "input",
      "state-management"
    ],
    "_createdAt": "2024-08-28T22:18:44Z",
    "description": "# Understanding the Formz Package in Flutter\n\nFormz is a powerful package in the Flutter ecosystem that simplifies form validation and management. It provides a structured approach to handling form inputs, validations, and submissions, making it easier for developers to create robust and user-friendly forms in their applications.\n\n## Key Features of Formz\n\n1. **Input Abstraction**: Formz introduces the concept of `FormzInput`, an abstract class that represents a single form input. This abstraction allows for easy management of input states and validations.\n\n2. **Form Management**: The package offers a `FormzMixin` that can be used with your form's state class to track the overall form status and validity.\n\n3. **Validation**: Formz provides a simple way to define custom validations for each input field. These validations can be as simple or complex as needed.\n\n4. **Status Tracking**: The package automatically tracks the status of each input and the overall form, making it easy to update UI elements based on the form's state.\n\n5. **Submission Handling**: Formz includes utilities to manage form submission, including tracking submission status and handling submission attempts.\n\n## Benefits of Using Formz\n\n- **Consistency**: Formz enforces a consistent structure for managing forms across your application.\n- **Separation of Concerns**: The package encourages separating input logic from UI code, leading to cleaner and more maintainable code.\n- **Scalability**: As your forms grow in complexity, Formz scales well, allowing you to manage multiple inputs and their interdependencies efficiently.\n- **Improved User Experience**: With built-in status tracking, you can provide real-time feedback to users as they interact with your forms.\n\nIn the following sections, we'll dive deeper into how to implement Formz in your Flutter applications and explore its features through practical examples.",
    "shortDescription": "A unified form representation in Dart which aims to simplify form representation and validation in a generic way.",
    "slug": {
      "current": "formz",
      "_type": "slug"
    },
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:formz/formz.dart';\n\n// Step 1: Define custom form inputs\nenum NameValidationError { empty, tooShort }\nclass Name extends FormzInput<String, NameValidationError> {\n  const Name.pure() : super.pure('');\n  const Name.dirty([String value = '']) : super.dirty(value);\n\n  @override\n  NameValidationError? validator(String value) {\n    if (value.isEmpty) return NameValidationError.empty;\n    return value.length < 2 ? NameValidationError.tooShort : null;\n  }\n}\n\nenum EmailValidationError { empty, invalid }\nclass Email extends FormzInput<String, EmailValidationError> {\n  const Email.pure() : super.pure('');\n  const Email.dirty([String value = '']) : super.dirty(value);\n\n  static final RegExp _emailRegExp = RegExp(\n    r'^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$',\n  );\n\n  @override\n  EmailValidationError? validator(String value) {\n    if (value.isEmpty) return EmailValidationError.empty;\n    return _emailRegExp.hasMatch(value) ? null : EmailValidationError.invalid;\n  }\n}\n\nenum PasswordValidationError { empty, tooShort, noUppercase, noNumber }\nclass Password extends FormzInput<String, PasswordValidationError> {\n  const Password.pure() : super.pure('');\n  const Password.dirty([String value = '']) : super.dirty(value);\n\n  @override\n  PasswordValidationError? validator(String value) {\n    if (value.isEmpty) return PasswordValidationError.empty;\n    if (value.length < 8) return PasswordValidationError.tooShort;\n    if (!value.contains(RegExp(r'[A-Z]'))) return PasswordValidationError.noUppercase;\n    if (!value.contains(RegExp(r'[0-9]'))) return PasswordValidationError.noNumber;\n    return null;\n  }\n}\n\n// Step 2: Create a form state class\nclass RealFlutterFormState with FormzMixin {\n  RealFlutterFormState({\n    this.name = const Name.pure(),\n    this.email = const Email.pure(),\n    this.password = const Password.pure(),\n    this.status = FormzSubmissionStatus.initial,\n  });\n\n  final Name name;\n  final Email email;\n  final Password password;\n  final FormzSubmissionStatus status;\n\n  @override\n  List<FormzInput> get inputs => [name, email, password];\n\n  RealFlutterFormState copyWith({\n    Name? name,\n    Email? email,\n    Password? password,\n    FormzSubmissionStatus? status,\n  }) {\n    return RealFlutterFormState(\n      name: name ?? this.name,\n      email: email ?? this.email,\n      password: password ?? this.password,\n      status: status ?? this.status,\n    );\n  }\n}\n\n// Step 3: Create the main application widget\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final _formKey = GlobalKey<FormState>();\n  late RealFlutterFormState _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _state = RealFlutterFormState();\n  }\n\n  // Step 4: Implement input change handlers\n  void _onNameChanged(String value) {\n    final name = Name.dirty(value);\n    setState(() {\n      _state = _state.copyWith(name: name);\n    });\n  }\n\n  void _onEmailChanged(String value) {\n    final email = Email.dirty(value);\n    setState(() {\n      _state = _state.copyWith(email: email);\n    });\n  }\n\n  void _onPasswordChanged(String value) {\n    final password = Password.dirty(value);\n    setState(() {\n      _state = _state.copyWith(password: password);\n    });\n  }\n\n  // Step 5: Implement form submission\n  Future<void> _onSubmit() async {\n    if (!_state.valid) return;\n\n    setState(() {\n      _state = _state.copyWith(status: FormzSubmissionStatus.inProgress);\n    });\n\n    // Simulate API call\n    await Future.delayed(Duration(seconds: 2));\n\n    // Simulate success (you could add error handling here)\n    setState(() {\n      _state = _state.copyWith(status: FormzSubmissionStatus.success);\n    });\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Form submitted successfully!')),\n    );\n  }\n\n  // Step 6: Helper method to get error message\n  String? _getErrorText(FormzInput input) {\n    if (input.isPure) return null;\n    if (input is Name) {\n      switch (input.error) {\n        case NameValidationError.empty:\n          return 'Name cannot be empty';\n        case NameValidationError.tooShort:\n          return 'Name must be at least 2 characters long';\n        default:\n          return null;\n      }\n    } else if (input is Email) {\n      switch (input.error) {\n        case EmailValidationError.empty:\n          return 'Email cannot be empty';\n        case EmailValidationError.invalid:\n          return 'Please enter a valid email address';\n        default:\n          return null;\n      }\n    } else if (input is Password) {\n      switch (input.error) {\n        case PasswordValidationError.empty:\n          return 'Password cannot be empty';\n        case PasswordValidationError.tooShort:\n          return 'Password must be at least 8 characters long';\n        case PasswordValidationError.noUppercase:\n          return 'Password must contain at least one uppercase letter';\n        case PasswordValidationError.noNumber:\n          return 'Password must contain at least one number';\n        default:\n          return null;\n      }\n    }\n    return null;\n  }\n\n  // Step 7: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Advanced Form')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Form(\n          key: _formKey,\n          child: Column(\n            children: [\n              TextFormField(\n                decoration: InputDecoration(\n                  labelText: 'Name',\n                  errorText: _getErrorText(_state.name),\n                ),\n                onChanged: _onNameChanged,\n              ),\n              TextFormField(\n                decoration: InputDecoration(\n                  labelText: 'Email',\n                  errorText: _getErrorText(_state.email),\n                ),\n                onChanged: _onEmailChanged,\n              ),\n              TextFormField(\n                decoration: InputDecoration(\n                  labelText: 'Password',\n                  errorText: _getErrorText(_state.password),\n                ),\n                obscureText: true,\n                onChanged: _onPasswordChanged,\n              ),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: _state.valid ? _onSubmit : null,\n                child: _state.status.isInProgress\n                    ? CircularProgressIndicator()\n                    : Text('Submit'),\n              ),\n              if (_state.status.isSuccess)\n                Padding(\n                  padding: const EdgeInsets.only(top: 10),\n                  child: Text(\n                    'Form submitted successfully!',\n                    style: TextStyle(color: Colors.green),\n                  ),\n                ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 8: Run the application\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\n// Application Flow:\n// 1. The application starts by creating an instance of RealFlutter widget.\n// 2. RealFlutterState is initialized with default form state (all inputs pure).\n// 3. The build method creates a form with three input fields (name, email, password).\n// 4. As the user types, onChanged callbacks update the form state:\n//    - _onNameChanged updates the name input\n//    - _onEmailChanged updates the email input\n//    - _onPasswordChanged updates the password input\n// 5. Each input change triggers a re-render, updating validation states.\n// 6. The _getErrorText method provides specific error messages for each input type.\n// 7. The submit button is enabled only when all inputs are valid (using _state.valid).\n// 8. On submission:\n//    - If the form is valid, submission status is set to inProgress\n//    - A 2-second delay simulates an API call\n//    - After the delay, status is set to success and a success message is shown\n// 9. The UI updates in real-time based on input validity and submission status.\n// 10. Error messages are displayed immediately under each input field as the user types.\n\n// Key Features Demonstrated:\n// - Custom form inputs with multiple error types\n// - Real-time validation and error display\n// - Form submission state management\n// - Conditional UI rendering based on form state\n// - Separation of form logic from UI\n// - Use of FormzMixin for overall form validity tracking\n```",
    "likesCount": 770,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "sj3n66db"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "9781z4u4"
      }
    ],
    "tutorial": "# Formz Tutorial: Implementing Form Validation in Flutter\n\nThis tutorial will guide you through the process of implementing form validation using the Formz package in Flutter. We'll create a simple login form to demonstrate the key concepts.\n\n## Step 1: Add Dependencies\n\nFirst, add the Formz package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  formz: ^0.6.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Define Form Inputs\n\nCreate a new file `login_form_inputs.dart` and define your form inputs:\n\n```dart\nimport 'package:formz/formz.dart';\n\nenum EmailValidationError { invalid }\n\nclass Email extends FormzInput<String, EmailValidationError> {\n  const Email.pure() : super.pure('');\n  const Email.dirty([String value = '']) : super.dirty(value);\n\n  static final RegExp _emailRegExp = RegExp(\n    r'^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$',\n  );\n\n  @override\n  EmailValidationError? validator(String value) {\n    return _emailRegExp.hasMatch(value) ? null : EmailValidationError.invalid;\n  }\n}\n\nenum PasswordValidationError { invalid }\n\nclass Password extends FormzInput<String, PasswordValidationError> {\n  const Password.pure() : super.pure('');\n  const Password.dirty([String value = '']) : super.dirty(value);\n\n  @override\n  PasswordValidationError? validator(String value) {\n    return value.length >= 8 ? null : PasswordValidationError.invalid;\n  }\n}\n```\n\n## Step 3: Create Form State\n\nCreate a new file `login_form_state.dart`:\n\n```dart\nimport 'package:formz/formz.dart';\nimport 'login_form_inputs.dart';\n\nclass LoginFormState with FormzMixin {\n  LoginFormState({\n    this.email = const Email.pure(),\n    this.password = const Password.pure(),\n    this.status = FormzSubmissionStatus.initial,\n  });\n\n  final Email email;\n  final Password password;\n  final FormzSubmissionStatus status;\n\n  @override\n  List<FormzInput> get inputs => [email, password];\n\n  LoginFormState copyWith({\n    Email? email,\n    Password? password,\n    FormzSubmissionStatus? status,\n  }) {\n    return LoginFormState(\n      email: email ?? this.email,\n      password: password ?? this.password,\n      status: status ?? this.status,\n    );\n  }\n}\n```\n\n## Step 4: Implement the Form UI\n\nCreate a new file `login_form.dart`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:formz/formz.dart';\nimport 'login_form_state.dart';\nimport 'login_form_inputs.dart';\n\nclass LoginForm extends StatefulWidget {\n  @override\n  _LoginFormState createState() => _LoginFormState();\n}\n\nclass _LoginFormState extends State<LoginForm> {\n  final _formKey = GlobalKey<FormState>();\n  late LoginFormState _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _state = LoginFormState();\n  }\n\n  void _onEmailChanged(String value) {\n    final email = Email.dirty(value);\n    setState(() {\n      _state = _state.copyWith(email: email);\n    });\n  }\n\n  void _onPasswordChanged(String value) {\n    final password = Password.dirty(value);\n    setState(() {\n      _state = _state.copyWith(password: password);\n    });\n  }\n\n  void _onSubmit() {\n    if (_formKey.currentState!.validate()) {\n      // Perform login logic here\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: _formKey,\n      child: Column(\n        children: [\n          TextFormField(\n            decoration: InputDecoration(labelText: 'Email'),\n            onChanged: _onEmailChanged,\n            validator: (_) => _state.email.error?.toString(),\n          ),\n          TextFormField(\n            decoration: InputDecoration(labelText: 'Password'),\n            obscureText: true,\n            onChanged: _onPasswordChanged,\n            validator: (_) => _state.password.error?.toString(),\n          ),\n          ElevatedButton(\n            onPressed: _state.status.isValidated ? _onSubmit : null,\n            child: Text('Login'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- For iOS, you may want to wrap your form fields in a `CupertinoFormSection` for a more native look:\n\n```dart\nCupertinoFormSection(\n  header: Text('Login'),\n  children: [\n    CupertinoTextFormFieldRow(\n      placeholder: 'Email',\n      onChanged: _onEmailChanged,\n      validator: (_) => _state.email.error?.toString(),\n    ),\n    CupertinoTextFormFieldRow(\n      placeholder: 'Password',\n      obscureText: true,\n      onChanged: _onPasswordChanged,\n      validator: (_) => _state.password.error?.toString(),\n    ),\n  ],\n)\n```\n\n### Android\n- For Android, consider using `OutlinedButton` instead of `ElevatedButton` for a more Material Design 3 look:\n\n```dart\nOutlinedButton(\n  onPressed: _state.status.isValidated ? _onSubmit : null,\n  child: Text('Login'),\n)\n```\n\n### Web\n- For web applications, you might want to add keyboard navigation support:\n\n```dart\nFocus(\n  onKey: (node, event) {\n    if (event.isKeyPressed(LogicalKeyboardKey.enter)) {\n      _onSubmit();\n      return KeyEventResult.handled;\n    }\n    return KeyEventResult.ignored;\n  },\n  child: // Your form widgets\n)\n```\n\nBy following these steps and considerations, you'll have a fully functional login form using the Formz package, with platform-specific optimizations for a better user experience across different devices."
  },
  {
    "slug": {
      "current": "youtube_player_iframe",
      "_type": "slug"
    },
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-08-12T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPb3Ls",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfCJo",
        "_type": "reference",
        "_key": "n2iz6b55"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:youtube_player_iframe/youtube_player_iframe.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'YouTube Player IFrame Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const YouTubePlayerDemo(),\n    );\n  }\n}\n\nclass YouTubePlayerDemo extends StatefulWidget {\n  const YouTubePlayerDemo({Key? key}) : super(key: key);\n\n  @override\n  _YouTubePlayerDemoState createState() => _YouTubePlayerDemoState();\n}\n\nclass _YouTubePlayerDemoState extends State<YouTubePlayerDemo> with WidgetsBindingObserver {\n  // Step 1: Initialize the YoutubePlayerController\n  late YoutubePlayerController _controller;\n\n  // Step 2: Define a list of video IDs\n  final List<String> _videoIds = [\n    'dQw4w9WgXcQ',\n    'iLnmTe5Q2Qw',\n    '_WoCV4c6XOE',\n  ];\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Step 3: Initialize the controller with the first video ID\n    _controller = YoutubePlayerController(\n      initialVideoId: _videoIds.first,\n      params: const YoutubePlayerParams(\n        autoPlay: false,\n        mute: false,\n        showControls: true,\n        showFullscreenButton: true,\n      ),\n    );\n\n    // Step 4: Add the widget as an observer for app lifecycle changes\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    // Step 5: Remove the observer and close the controller\n    WidgetsBinding.instance.removeObserver(this);\n    _controller.close();\n    super.dispose();\n  }\n\n  // Step 6: Implement app lifecycle management\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    switch (state) {\n      case AppLifecycleState.resumed:\n        _controller.play();\n        break;\n      case AppLifecycleState.inactive:\n      case AppLifecycleState.paused:\n      case AppLifecycleState.detached:\n        _controller.pause();\n        break;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('YouTube Player IFrame Demo'),\n      ),\n      body: SingleChildScrollView(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 7: Add the YoutubePlayerIFrame widget\n            YoutubePlayerIFrame(\n              controller: _controller,\n              aspectRatio: 16 / 9,\n            ),\n            const SizedBox(height: 20),\n            // Step 8: Add playback controls\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                IconButton(\n                  icon: const Icon(Icons.play_arrow),\n                  onPressed: () => _controller.play(),\n                ),\n                IconButton(\n                  icon: const Icon(Icons.pause),\n                  onPressed: () => _controller.pause(),\n                ),\n                IconButton(\n                  icon: const Icon(Icons.stop),\n                  onPressed: () => _controller.stopVideo(),\n                ),\n              ],\n            ),\n            const SizedBox(height: 20),\n            // Step 9: Add a video selection feature\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Text(\n                'Select a video:',\n                style: Theme.of(context).textTheme.headline6,\n              ),\n            ),\n            ListView.builder(\n              shrinkWrap: true,\n              itemCount: _videoIds.length,\n              itemBuilder: (context, index) {\n                return ListTile(\n                  title: Text('Video ${index + 1}'),\n                  onTap: () {\n                    _controller.loadVideoById(videoId: _videoIds[index]);\n                  },\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the YoutubePlayerController with the first video ID.\n// 2. The main screen displays the YouTube player, playback controls, and a list of selectable videos.\n// 3. Users can interact with the player using the on-screen controls or the custom buttons below the player.\n// 4. Tapping on a video in the list loads that video into the player.\n// 5. The app responds to lifecycle changes, pausing the video when the app is inactive and resuming when it's active again.\n// \n// Key Features Demonstrated:\n// - Basic video playback\n// - Custom playback controls\n// - Video selection from a list\n// - Proper lifecycle management\n// \n// This example provides a solid foundation for integrating YouTube videos into a Flutter app,\n// showcasing the core functionality of the youtube_player_iframe package.\n```",
    "tags": [
      "youtube",
      "video-player",
      "iframe",
      "media"
    ],
    "tutorialIncluded": true,
    "description": "# YouTube Player IFrame Package for Flutter: A Comprehensive Guide\n\n## Part 1: Description\n\nThe `youtube_player_iframe` package is a powerful and flexible solution for integrating YouTube video playback into your Flutter applications. This package provides a seamless way to embed YouTube videos with full control over playback, styling, and functionality.\n\n### Key Features:\n\n1. **Iframe API Support**: Utilizes YouTube's IFrame Player API for robust video playback.\n2. **Customizable UI**: Offers extensive options for customizing the player's appearance.\n3. **Autoplay and Mute Control**: Easily manage autoplay and mute settings.\n4. **Playlist Support**: Seamlessly play entire YouTube playlists.\n5. **Thumbnail Display**: Show video thumbnails before playback begins.\n6. **Fullscreen Mode**: Enable fullscreen viewing for an immersive experience.\n7. **Closed Captions**: Support for closed captions and subtitles.\n8. **Quality Control**: Adjust video quality settings as needed.\n9. **Error Handling**: Robust error handling for a smooth user experience.\n10. **Cross-Platform**: Works on both Android and iOS platforms.\n\n### Why Choose youtube_player_iframe?\n\n- **Performance**: Lightweight and optimized for smooth playback.\n- **Flexibility**: Extensive API for fine-grained control over the player.\n- **Compliance**: Adheres to YouTube's terms of service and API policies.\n- **Community Support**: Active development and community contributions.\n\nIn the following sections, we'll dive into a detailed tutorial on how to implement this package in your Flutter project and explore a comprehensive example showcasing its features.",
    "shortDescription": "Flutter port of the official YouTube iFrame player API. Supports web & mobile platforms.",
    "likesCount": 544,
    "tutorial": "# YouTube Player IFrame Package for Flutter: A Comprehensive Guide\n\n## Part 2: Tutorial\n\nIn this section, we'll walk through the process of implementing the `youtube_player_iframe` package in your Flutter project. We'll cover installation, basic setup, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  youtube_player_iframe: ^4.0.4\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:youtube_player_iframe/youtube_player_iframe.dart';\n```\n\n### Step 3: Create a YouTube Player Controller\n\nInitialize the `YoutubePlayerController`:\n\n```dart\nfinal _controller = YoutubePlayerController(\n  initialVideoId: 'dQw4w9WgXcQ',\n  params: const YoutubePlayerParams(\n    autoPlay: true,\n    mute: false,\n    showControls: true,\n    showFullscreenButton: true,\n  ),\n);\n```\n\n### Step 4: Implement the YouTube Player Widget\n\nUse the `YoutubePlayerIFrame` widget in your build method:\n\n```dart\nYoutubePlayerIFrame(\n  controller: _controller,\n  aspectRatio: 16 / 9,\n)\n```\n\n### Step 5: Handle Lifecycle\n\nImplement `WidgetsBindingObserver` to manage the player's lifecycle:\n\n```dart\nclass _MyHomePageState extends State<MyHomePage> with WidgetsBindingObserver {\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    _controller.close();\n    super.dispose();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    switch (state) {\n      case AppLifecycleState.resumed:\n        _controller.play();\n        break;\n      case AppLifecycleState.inactive:\n      case AppLifecycleState.paused:\n      case AppLifecycleState.detached:\n        _controller.pause();\n        break;\n    }\n  }\n}\n```\n\n### Platform-Specific Considerations\n\n#### Android\n\n1. Update your `AndroidManifest.xml`:\n\n```xml\n<manifest ...>\n  <application ...>\n    ...\n    android:usesCleartextTraffic=\"true\"\n    ...\n  </application>\n</manifest>\n```\n\n2. Ensure your `minSdkVersion` is at least 17 in `android/app/build.gradle`:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 17\n        ...\n    }\n}\n```\n\n#### iOS\n\nUpdate your `Info.plist` file:\n\n```xml\n<key>io.flutter.embedded_views_preview</key>\n<string>YES</string>\n```\n\nWith these steps completed, you're ready to start using the YouTube Player IFrame package in your Flutter application!",
    "_createdAt": "2024-08-28T22:18:47Z",
    "name": "youtube_player_iframe",
    "_updatedAt": "2024-09-06T04:12:22Z",
    "author": "sarbagyastha.com.np",
    "_rev": "AE3hjGWNkNE6aGQMMbaRrZ",
    "similarPackages": [
      {
        "_key": "rcasfpsp",
        "_ref": "V06bsD4sX3T8NTHrBPagYC",
        "_type": "reference"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_type": "reference",
        "_ref": "image-91bd8bb6031d16c8b3e95aa4cf64bbad8a241e58-800x600-webp"
      }
    }
  },
  {
    "_updatedAt": "2024-09-06T04:12:23Z",
    "slug": {
      "current": "calendar_date_picker2",
      "_type": "slug"
    },
    "_type": "package",
    "shortDescription": "A lightweight and customizable calendar picker based on Flutter CalendarDatePicker, with support for single date picker, range picker and multi picker.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "V06bsD4sX3T8NTHrBPb42i",
    "pubPoint": 160,
    "description": "# Calendar Date Picker 2: A Flexible Date Selection Widget for Flutter\n\n## Introduction\n\nThe `calendar_date_picker2` package is a powerful and customizable date selection widget for Flutter applications. It provides developers with a range of options for implementing date pickers, from single date selection to multi-date and date range picking. This package is an enhanced version of Flutter's built-in `showDatePicker`, offering more flexibility and features.\n\n## Key Features\n\n1. **Multiple Selection Modes**: \n   - Single Date\n   - Multi Date\n   - Date Range\n\n2. **Customizable UI**: \n   - Theming options for colors, text styles, and more\n   - Support for custom day builder to create unique date cells\n\n3. **Flexible Configuration**: \n   - Control over selectable date range\n   - Option to show or hide specific UI elements\n\n4. **Localization Support**: \n   - Easy integration with Flutter's localization system\n\n5. **Responsive Design**: \n   - Adapts well to different screen sizes and orientations\n\n## When to Use\n\nConsider using `calendar_date_picker2` in your Flutter project when you need:\n\n- A more feature-rich alternative to the default `showDatePicker`\n- To allow users to select multiple dates or date ranges\n- To implement a custom-styled calendar view\n- To integrate a calendar picker within your app's UI, rather than as a dialog\n\n## Getting Started\n\nTo use this package, add `calendar_date_picker2` as a dependency in your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  calendar_date_picker2: ^0.5.3\n```\n\nThen, import it in your Dart code:\n\n```dart\nimport 'package:calendar_date_picker2/calendar_date_picker2.dart';\n```\n\nWith these steps, you're ready to implement a flexible and powerful date picker in your Flutter application.",
    "subCategories": [
      {
        "_key": "1a0h7rd4",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFuy",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:18:49Z",
    "likesCount": 467,
    "tutorial": "# Calendar Date Picker 2: Implementation Tutorial\n\nThis tutorial will guide you through implementing the `calendar_date_picker2` package in your Flutter application, including platform-specific considerations.\n\n## Basic Implementation\n\n### Step 1: Import the Package\n\nFirst, import the package in your Dart file:\n\n```dart\nimport 'package:calendar_date_picker2/calendar_date_picker2.dart';\n```\n\n### Step 2: Create a Calendar Date Picker\n\nHere's a basic implementation of the calendar date picker:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CalendarDatePicker2(\n      config: CalendarDatePicker2Config(),\n      onValueChanged: (dates) => print('Selected dates: $dates'),\n    );\n  }\n}\n```\n\nThis creates a simple date picker with default configurations.\n\n## Advanced Configuration\n\n### Customizing Appearance\n\nYou can customize the appearance of the calendar using `CalendarDatePicker2Config`:\n\n```dart\nCalendarDatePicker2Config(\n  calendarType: CalendarDatePicker2Type.range,\n  selectedDayHighlightColor: Colors.blue,\n  weekdayLabels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  weekdayLabelTextStyle: const TextStyle(\n    color: Colors.black87,\n    fontWeight: FontWeight.bold,\n  ),\n  firstDayOfWeek: 1, // Monday\n  controlsHeight: 50,\n  controlsTextStyle: const TextStyle(\n    color: Colors.black,\n    fontSize: 15,\n    fontWeight: FontWeight.bold,\n  ),\n  dayTextStyle: const TextStyle(\n    color: Colors.black,\n    fontWeight: FontWeight.bold,\n  ),\n  disabledDayTextStyle: const TextStyle(\n    color: Colors.grey,\n  ),\n  selectableDayPredicate: (day) => !day.difference(DateTime.now().subtract(const Duration(days: 3))).isNegative,\n)\n```\n\n### Handling Selected Dates\n\nTo handle the selected dates, use the `onValueChanged` callback:\n\n```dart\nonValueChanged: (dates) {\n  setState(() {\n    _selectedDates = dates;\n  });\n},\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, you might want to adjust the appearance to match the native iOS look and feel:\n\n```dart\nCalendarDatePicker2Config(\n  controlsHeight: 50,\n  controlsTextStyle: const TextStyle(\n    color: CupertinoColors.activeBlue,\n    fontSize: 15,\n    fontWeight: FontWeight.bold,\n  ),\n  dayTextStyle: const TextStyle(\n    color: CupertinoColors.black,\n    fontWeight: FontWeight.bold,\n  ),\n  disabledDayTextStyle: const TextStyle(\n    color: CupertinoColors.inactiveGray,\n  ),\n)\n```\n\n### Android\n\nFor Android, you might prefer Material Design styles:\n\n```dart\nCalendarDatePicker2Config(\n  selectedDayHighlightColor: Colors.blue,\n  weekdayLabelTextStyle: const TextStyle(\n    color: Colors.black87,\n    fontWeight: FontWeight.bold,\n  ),\n  controlsTextStyle: const TextStyle(\n    color: Colors.black,\n    fontSize: 15,\n    fontWeight: FontWeight.bold,\n  ),\n)\n```\n\n### Web\n\nFor web applications, consider using a more compact layout:\n\n```dart\nCalendarDatePicker2Config(\n  calendarType: CalendarDatePicker2Type.range,\n  controlsHeight: 40,\n  controlsTextStyle: const TextStyle(\n    color: Colors.blue,\n    fontSize: 14,\n  ),\n  dayTextStyle: const TextStyle(\n    color: Colors.black87,\n    fontSize: 12,\n  ),\n)\n```\n\nBy following these guidelines, you can create a calendar date picker that looks and feels native on each platform while maintaining consistency across your application.",
    "tutorialIncluded": true,
    "author": "",
    "_rev": "ezMiwuUkJkbYMWycA6RdGS",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1XCN",
        "_type": "reference",
        "_key": "4lwvg4hv"
      }
    ],
    "tags": [
      "calendar",
      "date-picker",
      "ui",
      "widget"
    ],
    "name": "calendar_date_picker2",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:calendar_date_picker2/calendar_date_picker2.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Calendar Date Picker 2 Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: CalendarDemo(),\n    );\n  }\n}\n\nclass CalendarDemo extends StatefulWidget {\n  @override\n  _CalendarDemoState createState() => _CalendarDemoState();\n}\n\nclass _CalendarDemoState extends State<CalendarDemo> {\n  // Step 1: Initialize variables\n  List<DateTime?> _singleDatePickerValueWithDefaultValue = [\n    DateTime.now(),\n  ];\n  List<DateTime?> _multiDatePickerValueWithDefaultValue = [\n    DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day),\n    DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day + 5),\n  ];\n  List<DateTime?> _rangeDatePickerValueWithDefaultValue = [\n    DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day - 1),\n    DateTime(DateTime.now().year, DateTime.now().month, DateTime.now().day + 1),\n  ];\n\n  // Step 2: Define configurations\n  final config = CalendarDatePicker2Config(\n    calendarType: CalendarDatePicker2Type.single,\n    selectedDayHighlightColor: Colors.blue,\n    weekdayLabels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    weekdayLabelTextStyle: const TextStyle(\n      color: Colors.black87,\n      fontWeight: FontWeight.bold,\n    ),\n    firstDayOfWeek: 1,\n    controlsHeight: 50,\n    controlsTextStyle: const TextStyle(\n      color: Colors.black,\n      fontSize: 15,\n      fontWeight: FontWeight.bold,\n    ),\n    dayTextStyle: const TextStyle(\n      color: Colors.black,\n      fontWeight: FontWeight.bold,\n    ),\n    disabledDayTextStyle: const TextStyle(\n      color: Colors.grey,\n    ),\n    selectableDayPredicate: (day) => !day\n        .difference(DateTime.now().subtract(const Duration(days: 3)))\n        .isNegative,\n  );\n\n  // Step 3: Create helper methods\n  String _getValueText(\n    CalendarDatePicker2Type datePickerType,\n    List<DateTime?> values,\n  ) {\n    values =\n        values.map((e) => e != null ? DateUtils.dateOnly(e) : null).toList();\n    var valueText = (values.isNotEmpty ? values[0] : null)\n        .toString()\n        .replaceAll('00:00:00.000', '');\n\n    if (datePickerType == CalendarDatePicker2Type.multi) {\n      valueText = values.isNotEmpty\n          ? values\n              .map((v) => v.toString().replaceAll('00:00:00.000', ''))\n              .join(', ')\n          : 'null';\n    } else if (datePickerType == CalendarDatePicker2Type.range) {\n      if (values.isNotEmpty) {\n        final startDate = values[0].toString().replaceAll('00:00:00.000', '');\n        final endDate = values.length > 1\n            ? values[1].toString().replaceAll('00:00:00.000', '')\n            : 'null';\n        valueText = '$startDate to $endDate';\n      } else {\n        return 'null';\n      }\n    }\n\n    return valueText;\n  }\n\n  // Step 4: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Calendar Date Picker 2 Demo'),\n      ),\n      body: Center(\n        child: SizedBox(\n          width: 375,\n          child: ListView(\n            children: <Widget>[\n              // Step 5: Single Date Picker\n              Text('Single Date Picker (with default value)'),\n              CalendarDatePicker2(\n                config: config,\n                value: _singleDatePickerValueWithDefaultValue,\n                onValueChanged: (dates) =>\n                    setState(() => _singleDatePickerValueWithDefaultValue = dates),\n              ),\n              Text('Selected: ${_getValueText(\n                config.calendarType,\n                _singleDatePickerValueWithDefaultValue,\n              )}'),\n              const SizedBox(height: 24),\n\n              // Step 6: Multi Date Picker\n              Text('Multi Date Picker (with default value)'),\n              CalendarDatePicker2(\n                config: config.copyWith(\n                  calendarType: CalendarDatePicker2Type.multi,\n                ),\n                value: _multiDatePickerValueWithDefaultValue,\n                onValueChanged: (dates) =>\n                    setState(() => _multiDatePickerValueWithDefaultValue = dates),\n              ),\n              Text('Selected: ${_getValueText(\n                CalendarDatePicker2Type.multi,\n                _multiDatePickerValueWithDefaultValue,\n              )}'),\n              const SizedBox(height: 24),\n\n              // Step 7: Range Date Picker\n              Text('Range Date Picker (with default value)'),\n              CalendarDatePicker2(\n                config: config.copyWith(\n                  calendarType: CalendarDatePicker2Type.range,\n                ),\n                value: _rangeDatePickerValueWithDefaultValue,\n                onValueChanged: (dates) =>\n                    setState(() => _rangeDatePickerValueWithDefaultValue = dates),\n              ),\n              Text('Selected: ${_getValueText(\n                CalendarDatePicker2Type.range,\n                _rangeDatePickerValueWithDefaultValue,\n              )}'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the main() function, which runs the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and defines the theme.\n// 3. The home page is set to CalendarDemo, which is a StatefulWidget.\n// 4. In the _CalendarDemoState:\n//    - Variables are initialized for single, multi, and range date selections.\n//    - A configuration object is created with various styling and behavior options.\n//    - The build method creates a Scaffold with an AppBar and a ListView in the body.\n//    - Three CalendarDatePicker2 widgets are created for single, multi, and range selections.\n//    - Each picker has its own configuration, value, and onValueChanged callback.\n//    - The selected dates are displayed below each picker using the _getValueText helper method.\n// 5. As the user interacts with the date pickers:\n//    - The onValueChanged callbacks update the state with the new selected dates.\n//    - setState is called, which triggers a rebuild of the widget tree.\n//    - The updated dates are reflected in the UI.\n\n// This example demonstrates all major features of the calendar_date_picker2 package:\n// - Single, multi, and range date selection modes\n// - Custom styling and configuration\n// - Handling and displaying selected dates\n// - Updating the UI based on user interactions\n```",
    "dependentPackages": [],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-e5fae809224a02f512bad809c94758eb89a18cb3-626x786-webp",
        "_type": "reference"
      }
    },
    "lastUpdate": "2024-06-23T18:30:00.000Z"
  },
  {
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Ceqd",
        "_type": "reference",
        "_key": "25vq0yw8"
      }
    ],
    "shortDescription": "Utilities for working with English words. Counts syllables, generates well-sounding word combinations, and provides access to the top 5000 English words by usage.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXJF",
        "_type": "reference",
        "_key": "x9eebow1"
      }
    ],
    "tags": [
      "words",
      "language",
      "random",
      "generator"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CZDH",
        "_type": "reference",
        "_key": "3il7a4n8"
      }
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "author": "filiph.net",
    "_rev": "AE3hjGWNkNE6aGQMMbaRzY",
    "_updatedAt": "2024-09-06T04:12:24Z",
    "slug": {
      "current": "english_words",
      "_type": "slug"
    },
    "likesCount": 541,
    "_createdAt": "2024-08-28T22:18:51Z",
    "lastUpdate": "2021-03-23T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPb4Im",
    "tutorial": "# Tutorial: Implementing the English Words Package in Flutter\n\nThis tutorial will guide you through the process of integrating and using the `english_words` package in your Flutter project.\n\n## Step 1: Adding the Package\n\nFirst, add the `english_words` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  english_words: ^4.0.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Importing the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:english_words/english_words.dart';\n```\n\n## Step 3: Using Basic Features\n\n### Generating Random Words\n\nTo generate a random word:\n\n```dart\nfinal word = WordPair.random();\nprint(word.asString); // Outputs a random word pair as a string\n```\n\n### Creating Word Pairs\n\nTo create a specific word pair:\n\n```dart\nfinal pair = WordPair('hello', 'world');\nprint(pair.first); // Outputs 'hello'\nprint(pair.second); // Outputs 'world'\n```\n\n### Generating Multiple Random Words\n\nTo generate a list of random words:\n\n```dart\nfinal wordList = generateWordPairs().take(5).toList();\nwordList.forEach((pair) => print(pair.asString));\n```\n\n## Step 4: Advanced Usage\n\n### Filtering Words\n\nTo filter words based on specific criteria:\n\n```dart\nfinal filteredWords = generateWordPairs()\n    .where((pair) => pair.first.length > 5 && pair.second.startsWith('a'))\n    .take(10)\n    .toList();\n```\n\n### Custom Syllables\n\nTo create word pairs with specific syllable counts:\n\n```dart\nfinal customPair = WordPair.random(maxSyllables: 2);\nprint(customPair.asString);\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nWhen using the `english_words` package in iOS, ensure that you have the latest version of Xcode installed and your iOS deployment target is set to iOS 9.0 or later in your project settings.\n\n### Android\n\nFor Android, make sure your `minSdkVersion` is set to 16 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### Web\n\nThe `english_words` package is fully compatible with Flutter web applications. No additional configuration is required.\n\nBy following this tutorial, you should now have a solid understanding of how to implement and use the `english_words` package in your Flutter projects across different platforms.",
    "pubPoint": 160,
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "english_words",
    "description": "# English Words Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nThe `english_words` package is a powerful and versatile tool for Flutter developers who need to work with English words in their applications. This package provides a comprehensive list of English words and offers various utilities to manipulate and use these words effectively.\n\n## Key Features\n\n1. **Extensive Word List**: The package includes a vast collection of English words, covering a wide range of vocabulary.\n\n2. **Random Word Generation**: Easily generate random English words for various purposes, such as placeholder text or user-generated content.\n\n3. **Word Pairs**: Create and manipulate word pairs, which can be useful for generating unique identifiers or creative naming schemes.\n\n4. **Customization**: Filter words based on specific criteria, such as length or starting letter.\n\n5. **Efficient Performance**: The package is designed to be lightweight and efficient, ensuring minimal impact on your app's performance.\n\n## Use Cases\n\n- Generating placeholder text for UI prototypes\n- Creating unique usernames or identifiers\n- Building word-based games or educational apps\n- Enhancing natural language processing features\n\nIn the following sections, we'll dive deeper into how to implement and utilize the `english_words` package in your Flutter projects.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'English Words Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const EnglishWordsDemo(),\n    );\n  }\n}\n\nclass EnglishWordsDemo extends StatefulWidget {\n  const EnglishWordsDemo({Key? key}) : super(key: key);\n\n  @override\n  _EnglishWordsDemoState createState() => _EnglishWordsDemoState();\n}\n\nclass _EnglishWordsDemoState extends State<EnglishWordsDemo> {\n  // Step 1: Initialize variables\n  late WordPair _randomWord;\n  late List<WordPair> _wordList;\n  late List<WordPair> _filteredWords;\n  late WordPair _customSyllableWord;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Initialize word-related variables\n    _randomWord = WordPair.random();\n    _wordList = generateWordPairs().take(5).toList();\n    _filteredWords = generateWordPairs()\n        .where((pair) => pair.first.length > 5 && pair.second.startsWith('a'))\n        .take(5)\n        .toList();\n    _customSyllableWord = WordPair.random(maxSyllables: 2);\n  }\n\n  // Step 3: Create a method to refresh all word-related variables\n  void _refreshWords() {\n    setState(() {\n      _randomWord = WordPair.random();\n      _wordList = generateWordPairs().take(5).toList();\n      _filteredWords = generateWordPairs()\n          .where((pair) => pair.first.length > 5 && pair.second.startsWith('a'))\n          .take(5)\n          .toList();\n      _customSyllableWord = WordPair.random(maxSyllables: 2);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 4: Build the UI\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('English Words Demo'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 5: Display random word\n            Text('Random Word: ${_randomWord.asString}',\n                style: Theme.of(context).textTheme.headline6),\n            const SizedBox(height: 20),\n\n            // Step 6: Display word list\n            Text('Word List:', style: Theme.of(context).textTheme.headline6),\n            Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: _wordList\n                  .map((pair) => Text(pair.asString))\n                  .toList(),\n            ),\n            const SizedBox(height: 20),\n\n            // Step 7: Display filtered words\n            Text('Filtered Words:',\n                style: Theme.of(context).textTheme.headline6),\n            Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: _filteredWords\n                  .map((pair) => Text(pair.asString))\n                  .toList(),\n            ),\n            const SizedBox(height: 20),\n\n            // Step 8: Display custom syllable word\n            Text('Custom Syllable Word: ${_customSyllableWord.asString}',\n                style: Theme.of(context).textTheme.headline6),\n          ],\n        ),\n      ),\n      // Step 9: Add a refresh button\n      floatingActionButton: FloatingActionButton(\n        onPressed: _refreshWords,\n        tooltip: 'Refresh Words',\n        child: const Icon(Icons.refresh),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp and defines the theme.\n// 3. The home page is set to EnglishWordsDemo, which is a StatefulWidget.\n// 4. In the _EnglishWordsDemoState:\n//    a. initState() initializes all word-related variables.\n//    b. build() creates the UI, displaying all the word examples.\n//    c. _refreshWords() updates all word variables when called.\n// 5. The UI displays:\n//    - A random word pair\n//    - A list of 5 random word pairs\n//    - A list of 5 filtered word pairs (first word > 5 letters, second word starts with 'a')\n//    - A random word pair with max 2 syllables\n// 6. The floating action button allows the user to refresh all displayed words.\n\n// This example demonstrates various features of the english_words package:\n// - Generating random word pairs\n// - Creating lists of word pairs\n// - Filtering word pairs based on specific criteria\n// - Creating word pairs with custom syllable counts\n```"
  },
  {
    "tags": [
      "network",
      "information",
      "utils",
      "connectivity",
      "ip-address"
    ],
    "pubPoint": 160,
    "likesCount": 626,
    "tutorial": "# Network Info Plus Package Tutorial\n\n## Getting Started\n\nTo use the `network_info_plus` package in your Flutter project, follow these steps:\n\n1. Add the dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  network_info_plus: ^5.0.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:network_info_plus/network_info_plus.dart';\n```\n\n## Basic Usage\n\nHere's a simple example of how to use the `network_info_plus` package:\n\n```dart\nimport 'package:network_info_plus/network_info_plus.dart';\n\nfinal info = NetworkInfo();\n\n// Get Wi-Fi details\nString? wifiName = await info.getWifiName(); // \"MyWiFiNetwork\"\nString? wifiBSSID = await info.getWifiBSSID(); // \"01:23:45:67:89:AB\"\nString? wifiIP = await info.getWifiIP(); // \"192.168.1.43\"\n\n// Get Cellular IP\nString? mobileIP = await info.getWifiIP(); // \"10.0.2.15\"\n```\n\n## Platform-Specific Details\n\n### Android\n\n- Requires `ACCESS_WIFI_STATE` and `ACCESS_NETWORK_STATE` permissions.\n- Add the following to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n### iOS\n\n- Requires \"Access WiFi Information\" capability.\n- Add the following to your `Info.plist`:\n\n```xml\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>Your location is required for WiFi information.</string>\n```\n\n### macOS\n\n- Requires \"Access WiFi Information\" capability.\n- Add the following to your `Info.plist`:\n\n```xml\n<key>com.apple.security.network.wifi-info</key>\n<true/>\n```\n\n### Windows\n\n- No additional setup required.\n\n### Linux\n\n- Requires `libnm` (NetworkManager) library.\n- Install using: `sudo apt-get install libnm-dev`\n\nBy following these platform-specific instructions, you can ensure that the `network_info_plus` package works correctly across all supported platforms.",
    "tutorialIncluded": true,
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:network_info_plus/network_info_plus.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Network Info Plus Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const NetworkInfoScreen(),\n    );\n  }\n}\n\nclass NetworkInfoScreen extends StatefulWidget {\n  const NetworkInfoScreen({Key? key}) : super(key: key);\n\n  @override\n  _NetworkInfoScreenState createState() => _NetworkInfoScreenState();\n}\n\nclass _NetworkInfoScreenState extends State<NetworkInfoScreen> {\n  final NetworkInfo _networkInfo = NetworkInfo();\n  String _connectionStatus = 'Unknown';\n  String _wifiName = 'Unknown';\n  String _wifiBSSID = 'Unknown';\n  String _wifiIP = 'Unknown';\n  String _mobileIP = 'Unknown';\n\n  @override\n  void initState() {\n    super.initState();\n    _initNetworkInfo();\n  }\n\n  // Step 1: Initialize and fetch network information\n  Future<void> _initNetworkInfo() async {\n    String connectionStatus;\n    try {\n      connectionStatus = await _networkInfo.getWifiName() ?? 'Unknown';\n    } catch (e) {\n      connectionStatus = 'Failed to get network status';\n    }\n\n    // Step 2: Update the state with fetched information\n    setState(() {\n      _connectionStatus = connectionStatus;\n    });\n\n    // Step 3: Fetch additional network details\n    _getMoreNetworkDetails();\n  }\n\n  // Step 4: Fetch more detailed network information\n  Future<void> _getMoreNetworkDetails() async {\n    try {\n      String? wifiName = await _networkInfo.getWifiName();\n      String? wifiBSSID = await _networkInfo.getWifiBSSID();\n      String? wifiIP = await _networkInfo.getWifiIP();\n      String? mobileIP = await _networkInfo.getWifiIP();\n\n      // Step 5: Update the state with additional information\n      setState(() {\n        _wifiName = wifiName ?? 'Unknown';\n        _wifiBSSID = wifiBSSID ?? 'Unknown';\n        _wifiIP = wifiIP ?? 'Unknown';\n        _mobileIP = mobileIP ?? 'Unknown';\n      });\n    } catch (e) {\n      print('Failed to get network details: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Network Info Plus Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Connection Status: $_connectionStatus'),\n            Text('WiFi Name: $_wifiName'),\n            Text('WiFi BSSID: $_wifiBSSID'),\n            Text('WiFi IP: $_wifiIP'),\n            Text('Mobile IP: $_mobileIP'),\n            ElevatedButton(\n              onPressed: _getMoreNetworkDetails,\n              child: const Text('Refresh Network Info'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutter.\n// 2. RealFlutter sets up the MaterialApp and sets NetworkInfoScreen as the home screen.\n// 3. NetworkInfoScreen is created, and its state is initialized.\n// 4. In initState, _initNetworkInfo is called to fetch initial network information.\n// 5. _initNetworkInfo tries to get the WiFi name and updates the _connectionStatus.\n// 6. After updating the connection status, _getMoreNetworkDetails is called to fetch additional information.\n// 7. _getMoreNetworkDetails retrieves WiFi name, BSSID, WiFi IP, and mobile IP.\n// 8. The state is updated with all the fetched information.\n// 9. The build method creates the UI, displaying all the network information.\n// 10. A 'Refresh Network Info' button allows the user to manually update the information by calling _getMoreNetworkDetails again.\n\n// Note: Error handling is implemented to prevent app crashes if any network information is unavailable.\n// The app uses setState to update the UI whenever new information is fetched, ensuring real-time updates.\n```",
    "shortDescription": "Flutter plugin for discovering information (e.g. WiFi details) of the network.",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CW83",
        "_type": "reference",
        "_key": "61x6e1nf"
      }
    ],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference",
        "_key": "eur062zq"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaluC",
        "_type": "reference",
        "_key": "7ojg136f"
      }
    ],
    "slug": {
      "current": "network_info_plus",
      "_type": "slug"
    },
    "author": "fluttercommunity.dev",
    "_type": "package",
    "description": "# Network Info Plus Package for Flutter\n\n## Description\n\nThe `network_info_plus` package is a powerful Flutter plugin that provides detailed information about the device's network connectivity. It's an essential tool for developers who need to access network-related data in their Flutter applications.\n\n### Key Features\n\n1. **Network Type Detection**: Easily determine whether the device is connected via Wi-Fi, cellular data, or ethernet.\n\n2. **IP Address Retrieval**: Obtain the device's IP address for both IPv4 and IPv6 protocols.\n\n3. **Wi-Fi Details**: Access specific information about the connected Wi-Fi network, including SSID and BSSID.\n\n4. **Cross-Platform Compatibility**: Works seamlessly on multiple platforms, including iOS, Android, macOS, Windows, and Linux.\n\n5. **Asynchronous API**: Utilizes Dart's asynchronous programming model for efficient and non-blocking operations.\n\n### Why Use Network Info Plus?\n\n- **Enhanced User Experience**: Tailor your app's behavior based on the network status, ensuring a smooth experience across different connection types.\n- **Debugging Aid**: Quickly diagnose network-related issues during development and testing phases.\n- **Security Features**: Implement network-specific security measures by identifying the connection type.\n- **Offline Functionality**: Develop robust offline-first applications by detecting network availability.\n\nBy leveraging the `network_info_plus` package, developers can create more intelligent and network-aware Flutter applications, providing users with a seamless experience across various network conditions.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:18:52Z",
    "lastUpdate": "2024-08-14T18:30:00.000Z",
    "name": "network_info_plus",
    "_rev": "eaCZ7mIhmiYZX5KGqJmQmd",
    "_updatedAt": "2024-09-06T04:12:25Z",
    "_id": "V06bsD4sX3T8NTHrBPb4Yq"
  },
  {
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "flutter_chat_ui",
    "_updatedAt": "2024-09-06T04:12:25Z",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:18:54Z",
    "slug": {
      "current": "flutter_chat_ui",
      "_type": "slug"
    },
    "likesCount": 1280,
    "dependentPackages": [],
    "author": "flyer.chat",
    "_rev": "eaCZ7mIhmiYZX5KGqJmQtB",
    "description": "# Flutter Chat UI Package: A Comprehensive Guide\n\n## 1. Description\n\nThe `flutter_chat_ui` package is a powerful and customizable solution for implementing chat interfaces in Flutter applications. It provides a set of pre-built widgets and utilities that make it easy to create beautiful and functional chat UIs with minimal effort.\n\n### Key Features:\n\n1. **Pre-built Chat Widgets**: The package includes ready-to-use widgets like `ChatList`, `Message`, and `InputToolbar`, which can be easily integrated into your app.\n\n2. **Customizable Themes**: Easily customize the look and feel of your chat interface with built-in theme support.\n\n3. **Support for Various Message Types**: Handle text, image, file, and custom message types out of the box.\n\n4. **Bubble Customization**: Customize message bubbles with different colors, shapes, and styles for sender and receiver.\n\n5. **Avatar Support**: Display user avatars with options for circular or square shapes.\n\n6. **Typing Indicators**: Show typing indicators when users are composing messages.\n\n7. **Message Status**: Display message status (sent, delivered, read) with customizable icons.\n\n8. **Date Headers**: Automatically group messages by date with customizable date headers.\n\n9. **Link Preview**: Generate link previews for URLs shared in messages.\n\n10. **Localization**: Easy integration with Flutter's localization system for multi-language support.\n\nThe `flutter_chat_ui` package is designed to be flexible and extensible, allowing developers to create chat interfaces that match their app's design language while saving time on implementation details.\n\nIn the following sections, we'll dive into a tutorial on how to use this package and provide a comprehensive example demonstrating its features.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP",
        "_type": "reference",
        "_key": "5j99l4xd"
      }
    ],
    "example": "```\nimport 'dart:convert';\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_chat_types/flutter_chat_types.dart' as types;\nimport 'package:flutter_chat_ui/flutter_chat_ui.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:uuid/uuid.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Chat UI Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const ChatPage(),\n    );\n  }\n}\n\nclass ChatPage extends StatefulWidget {\n  const ChatPage({Key? key}) : super(key: key);\n\n  @override\n  _ChatPageState createState() => _ChatPageState();\n}\n\nclass _ChatPageState extends State<ChatPage> {\n  // Step 1: Initialize variables\n  final List<types.Message> _messages = [];\n  final _user = const types.User(id: '82091008-a484-4a89-ae75-a22bf8d6f3ac');\n  final _otherUser = const types.User(id: 'other_user');\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Load initial messages\n    _loadMessages();\n  }\n\n  void _loadMessages() {\n    // Step 3: Add some dummy messages\n    final messages = [\n      types.TextMessage(\n        author: _otherUser,\n        createdAt: DateTime.now().millisecondsSinceEpoch,\n        id: const Uuid().v4(),\n        text: 'Hello! Welcome to our chat app!',\n      ),\n      types.TextMessage(\n        author: _user,\n        createdAt: DateTime.now().millisecondsSinceEpoch,\n        id: const Uuid().v4(),\n        text: 'Hi there! Thanks for having me.',\n      ),\n    ];\n\n    setState(() {\n      _messages.insertAll(0, messages);\n    });\n  }\n\n  // Step 4: Handle sending text messages\n  void _handleSendPressed(types.PartialText message) {\n    final textMessage = types.TextMessage(\n      author: _user,\n      createdAt: DateTime.now().millisecondsSinceEpoch,\n      id: const Uuid().v4(),\n      text: message.text,\n    );\n\n    _addMessage(textMessage);\n  }\n\n  // Step 5: Handle sending image messages\n  void _handleImageSelection() async {\n    final result = await ImagePicker().pickImage(\n      imageQuality: 70,\n      maxWidth: 1440,\n      source: ImageSource.gallery,\n    );\n\n    if (result != null) {\n      final bytes = await result.readAsBytes();\n      final image = await decodeImageFromList(bytes);\n\n      final message = types.ImageMessage(\n        author: _user,\n        createdAt: DateTime.now().millisecondsSinceEpoch,\n        height: image.height.toDouble(),\n        id: const Uuid().v4(),\n        name: result.name,\n        size: bytes.length,\n        uri: result.path,\n        width: image.width.toDouble(),\n      );\n\n      _addMessage(message);\n    }\n  }\n\n  // Step 6: Add message to the list\n  void _addMessage(types.Message message) {\n    setState(() {\n      _messages.insert(0, message);\n    });\n  }\n\n  // Step 7: Handle message tap\n  void _handleMessageTap(BuildContext context, types.Message message) {\n    if (message is types.ImageMessage) {\n      Navigator.of(context).push(\n        MaterialPageRoute<void>(\n          builder: (context) => Scaffold(\n            appBar: AppBar(title: const Text('Image')),\n            body: Center(\n              child: Image.network(message.uri),\n            ),\n          ),\n        ),\n      );\n    }\n  }\n\n  // Step 8: Simulate receiving a message\n  void _simulateReceivedMessage() {\n    final message = types.TextMessage(\n      author: _otherUser,\n      createdAt: DateTime.now().millisecondsSinceEpoch,\n      id: const Uuid().v4(),\n      text: 'This is a simulated received message!',\n    );\n\n    _addMessage(message);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Chat UI Demo'),\n        actions: [\n          // Step 9: Add a button to simulate receiving a message\n          IconButton(\n            icon: const Icon(Icons.message),\n            onPressed: _simulateReceivedMessage,\n          ),\n        ],\n      ),\n      body: Chat(\n        messages: _messages,\n        onSendPressed: _handleSendPressed,\n        onMessageTap: _handleMessageTap,\n        user: _user,\n        // Step 10: Customize the chat theme\n        theme: DefaultChatTheme(\n          backgroundColor: Colors.grey[100]!,\n          primaryColor: Colors.blue,\n          secondaryColor: Colors.white,\n          userAvatarNameColors: [Colors.blue, Colors.green, Colors.red],\n        ),\n        // Step 11: Add custom actions to the input bar\n        customBottomWidget: Container(\n          color: Colors.white,\n          child: Row(\n            children: [\n              IconButton(\n                icon: const Icon(Icons.image),\n                onPressed: _handleImageSelection,\n              ),\n              Expanded(\n                child: Input(\n                  onSendPressed: _handleSendPressed,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application flow:\n// 1. The app starts and displays the ChatPage.\n// 2. Initial dummy messages are loaded in the initState method.\n// 3. Users can send text messages using the input field at the bottom.\n// 4. Users can send image messages by tapping the image icon.\n// 5. When a message is sent or received, it's added to the _messages list.\n// 6. The Chat widget displays all messages in the _messages list.\n// 7. Users can tap on image messages to view them in full screen.\n// 8. The \"message\" icon in the app bar simulates receiving a message.\n// 9. The chat UI is customized using the DefaultChatTheme.\n// 10. The input bar is customized to include an image selection button.\n\n// This example demonstrates the core features of the flutter_chat_ui package,\n// including sending and receiving messages, handling different message types,\n// customizing the UI, and adding custom input options.\n```",
    "tags": [
      "chat",
      "ui",
      "messaging",
      "communication"
    ],
    "_id": "V06bsD4sX3T8NTHrBPb4ou",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "Actively maintained, community-driven chat UI implementation with an optional Firebase BaaS.",
    "similarPackages": [],
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `flutter_chat_ui` package into your Flutter project and creating a basic chat interface.\n\n### Step 1: Add Dependencies\n\nFirst, add the `flutter_chat_ui` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_chat_ui: ^1.6.0\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the necessary classes:\n\n```dart\nimport 'package:flutter_chat_ui/flutter_chat_ui.dart';\nimport 'package:flutter_chat_types/flutter_chat_types.dart' as types;\n```\n\n### Step 3: Create a Chat Screen\n\nCreate a new stateful widget for your chat screen:\n\n```dart\nclass ChatScreen extends StatefulWidget {\n  const ChatScreen({Key? key}) : super(key: key);\n\n  @override\n  _ChatScreenState createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  List<types.Message> _messages = [];\n  final _user = const types.User(id: '82091008-a484-4a89-ae75-a22bf8d6f3ac');\n\n  @override\n  void initState() {\n    super.initState();\n    _loadMessages();\n  }\n\n  void _loadMessages() {\n    // Load messages from a data source (e.g., API, database)\n    // For this example, we'll add some dummy messages\n    final messages = [\n      types.TextMessage(\n        author: _user,\n        createdAt: DateTime.now().millisecondsSinceEpoch,\n        id: '1',\n        text: 'Hello!',\n      ),\n      types.TextMessage(\n        author: const types.User(id: 'other_user'),\n        createdAt: DateTime.now().millisecondsSinceEpoch,\n        id: '2',\n        text: 'Hi there!',\n      ),\n    ];\n\n    setState(() {\n      _messages = messages;\n    });\n  }\n\n  void _handleSendPressed(types.PartialText message) {\n    final textMessage = types.TextMessage(\n      author: _user,\n      createdAt: DateTime.now().millisecondsSinceEpoch,\n      id: DateTime.now().toString(),\n      text: message.text,\n    );\n\n    setState(() {\n      _messages.insert(0, textMessage);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Chat'),\n      ),\n      body: Chat(\n        messages: _messages,\n        onSendPressed: _handleSendPressed,\n        user: _user,\n      ),\n    );\n  }\n}\n```\n\n### Step 4: Customize the Chat UI (Optional)\n\nYou can customize the appearance of the chat interface by providing a `theme` parameter to the `Chat` widget:\n\n```dart\nChat(\n  messages: _messages,\n  onSendPressed: _handleSendPressed,\n  user: _user,\n  theme: DefaultChatTheme(\n    backgroundColor: Colors.grey[200],\n    messageBorderRadius: 8,\n    primaryColor: Colors.blue,\n    secondaryColor: Colors.white,\n    sentMessageBodyTextStyle: const TextStyle(\n      color: Colors.white,\n      fontSize: 16,\n    ),\n    receivedMessageBodyTextStyle: const TextStyle(\n      color: Colors.black,\n      fontSize: 16,\n    ),\n  ),\n)\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n\n1. For iOS, ensure that you have the required permissions in your `Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for sharing images in chat.</string>\n<key>NSCameraUsageDescription</key>\n<string>This app requires access to the camera for taking photos to share in chat.</string>\n```\n\n2. If you're using image picking functionality, add the following to your `Podfile`:\n\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= [\n        '$(inherited)',\n        'PERMISSION_PHOTOS=1',\n      ]\n    end\n  end\nend\n```\n\n#### Android\n\n1. For Android, add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.CAMERA\" />\n```\n\n2. If targeting Android 13 (API level 33) or higher, also add:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" />\n```\n\n3. For file picking functionality, add the following to your `android/app/build.gradle`:\n\n```gradle\nandroid {\n    defaultConfig {\n        ...\n        minSdkVersion 21\n    }\n}\n```\n\nBy following these steps and considering the platform-specific requirements, you'll have a basic chat interface up and running with the `flutter_chat_ui` package."
  },
  {
    "_id": "V06bsD4sX3T8NTHrBPb5QO",
    "tutorial": "# Tutorial: Using flutter_widget_from_html_core in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the `flutter_widget_from_html_core` package into your Flutter application. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_widget_from_html_core: ^0.10.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:flutter_widget_from_html_core/flutter_widget_from_html_core.dart';\n```\n\nTo render HTML content, use the `HtmlWidget` class:\n\n```dart\nHtmlWidget(\n  '<p>Hello, <b>World!</b></p>',\n)\n```\n\n## Step 3: Customization\n\nYou can customize the rendering by providing a `textStyle` or `customStylesBuilder`:\n\n```dart\nHtmlWidget(\n  '<p>Custom styled text</p>',\n  textStyle: TextStyle(fontSize: 18, color: Colors.blue),\n  customStylesBuilder: (element) {\n    if (element.classes.contains('custom-class')) {\n      return {'color': 'red', 'font-weight': 'bold'};\n    }\n    return null;\n  },\n)\n```\n\n## Step 4: Handling Links\n\nTo handle link taps, use the `onTapUrl` callback:\n\n```dart\nHtmlWidget(\n  '<a href=\"https://flutter.dev\">Flutter Website</a>',\n  onTapUrl: (url) async {\n    // Handle URL tap\n    print('Tapped URL: $url');\n    return true; // Return true to prevent default behavior\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure you have the necessary permissions set in your `Info.plist` file if you plan to load external resources:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSAllowsArbitraryLoads</key>\n  <true/>\n</dict>\n```\n\n### Android\n\nFor Android, add internet permission to your `AndroidManifest.xml` file if you're loading external resources:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n### Web\n\nFor web applications, no additional configuration is required. However, be mindful of potential CORS issues when loading external resources.\n\nBy following this tutorial, you should now have a good understanding of how to use the `flutter_widget_from_html_core` package in your Flutter applications across different platforms.",
    "pubPoint": 160,
    "author": "daohoangson.com",
    "shortDescription": "Flutter package to render html as widgets that focuses on correctness and extensibility.",
    "tags": [
      "widget",
      "html",
      "css",
      "fwfh",
      "rendering"
    ],
    "_createdAt": "2024-08-28T22:18:57Z",
    "name": "flutter_widget_from_html_core",
    "_type": "package",
    "dependentPackages": [
      {
        "_key": "jps5flpu",
        "_ref": "Rx1Nho763d29lawKra1VCB",
        "_type": "reference"
      }
    ],
    "packageImage": {
      "asset": {
        "_ref": "image-e98bb84bf06dd1765a14c602313062e84001f7c7-524x1080-webp",
        "_type": "reference"
      },
      "_type": "image"
    },
    "lastUpdate": "2024-08-21T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:27Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmR6H",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfHVI",
        "_type": "reference",
        "_key": "i6ioovzs"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_widget_from_html_core/flutter_widget_from_html_core.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'flutter_widget_from_html_core Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HtmlRenderingDemo(),\n    );\n  }\n}\n\nclass HtmlRenderingDemo extends StatelessWidget {\n  const HtmlRenderingDemo({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('HTML Rendering Demo'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 1: Basic HTML Rendering\n            const Text('Basic HTML Rendering:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            HtmlWidget(\n              '<p>This is a <b>bold</b> and <i>italic</i> text.</p>',\n            ),\n            const SizedBox(height: 20),\n\n            // Step 2: Styling with CSS\n            const Text('Styling with CSS:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            HtmlWidget(\n              '<p style=\"color: red; font-size: 20px;\">This text is red and larger.</p>',\n            ),\n            const SizedBox(height: 20),\n\n            // Step 3: Custom Styling\n            const Text('Custom Styling:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            HtmlWidget(\n              '<p class=\"custom-class\">This text has custom styling.</p>',\n              customStylesBuilder: (element) {\n                if (element.classes.contains('custom-class')) {\n                  return {'color': 'green', 'font-weight': 'bold'};\n                }\n                return null;\n              },\n            ),\n            const SizedBox(height: 20),\n\n            // Step 4: Handling Links\n            const Text('Handling Links:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            HtmlWidget(\n              '<a href=\"https://flutter.dev\">Visit Flutter Website</a>',\n              onTapUrl: (url) async {\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('You tapped: $url')),\n                );\n                return true;\n              },\n            ),\n            const SizedBox(height: 20),\n\n            // Step 5: Complex HTML Structure\n            const Text('Complex HTML Structure:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            HtmlWidget(\n              '''\n              <h1>Welcome to Flutter</h1>\n              <p>Flutter is Google's UI toolkit for building beautiful, natively compiled applications for <span style=\"color: blue;\">mobile</span>, <span style=\"color: green;\">web</span>, and <span style=\"color: red;\">desktop</span> from a single codebase.</p>\n              <ul>\n                <li>Fast Development</li>\n                <li>Expressive and Flexible UI</li>\n                <li>Native Performance</li>\n              </ul>\n              ''',\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home page is set to HtmlRenderingDemo, a stateless widget.\n// 3. HtmlRenderingDemo builds a Scaffold with an AppBar and a SingleChildScrollView body.\n// 4. Inside the body, we demonstrate various features of flutter_widget_from_html_core:\n//    - Basic HTML rendering\n//    - Styling with inline CSS\n//    - Custom styling using customStylesBuilder\n//    - Handling link taps with onTapUrl\n//    - Rendering complex HTML structures\n// 5. Each feature is separated by a title and a SizedBox for spacing.\n// 6. The SingleChildScrollView allows the content to be scrollable if it exceeds the screen height.\n// 7. When a link is tapped, a SnackBar is shown with the URL, demonstrating the onTapUrl functionality.\n\n// This example showcases the versatility of the flutter_widget_from_html_core package,\n// allowing developers to easily render and customize HTML content within their Flutter applications.\n```",
    "tutorialIncluded": true,
    "slug": {
      "current": "flutter_widget_from_html_core",
      "_type": "slug"
    },
    "description": "# flutter_widget_from_html_core: Rendering HTML in Flutter\n\nThe `flutter_widget_from_html_core` package is a powerful tool for Flutter developers who need to render HTML content within their applications. This lightweight package provides a simple yet effective way to convert HTML strings into Flutter widgets, making it easier to display rich text content in your apps.\n\n## Key Features\n\n1. **HTML Parsing**: The package can parse a wide range of HTML tags and attributes, converting them into corresponding Flutter widgets.\n\n2. **Customization**: Developers can customize the rendering process by providing custom style sheets or overriding default widget builders.\n\n3. **Performance**: The core package is designed to be lightweight and efficient, ensuring smooth performance even with complex HTML content.\n\n4. **Extensibility**: While the core package covers basic HTML rendering, it can be extended with additional packages for more advanced features like tables or iframes.\n\n5. **Cross-platform Support**: The package works seamlessly across different platforms supported by Flutter, including iOS, Android, and web.\n\nBy leveraging this package, Flutter developers can easily incorporate HTML content into their applications, making it an invaluable tool for scenarios such as displaying rich text content, rendering dynamic information from APIs, or creating text-heavy interfaces with minimal effort.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1fNn",
        "_type": "reference",
        "_key": "597vtx6u"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 442
  },
  {
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_cached_pdfview/flutter_cached_pdfview.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Cached PDFView Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Define variables\n  String _pdfUrl = 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf';\n  bool _isNightMode = false;\n  PDFViewController? _pdfViewController;\n  int _currentPage = 0;\n  int _totalPages = 0;\n\n  // Step 2: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter PDF Viewer'),\n        actions: [\n          // Step 3: Add night mode toggle\n          IconButton(\n            icon: Icon(_isNightMode ? Icons.wb_sunny : Icons.nightlight_round),\n            onPressed: () {\n              setState(() {\n                _isNightMode = !_isNightMode;\n              });\n            },\n          ),\n        ],\n      ),\n      body: Column(\n        children: [\n          // Step 4: Add PDF viewer\n          Expanded(\n            child: PDF(\n              enableSwipe: true,\n              swipeHorizontal: true,\n              autoSpacing: false,\n              pageFling: false,\n              nightMode: _isNightMode,\n              onViewCreated: (PDFViewController pdfViewController) {\n                _pdfViewController = pdfViewController;\n              },\n              onPageChanged: (int? page, int? total) {\n                setState(() {\n                  _currentPage = page! + 1;\n                  _totalPages = total!;\n                });\n              },\n              onError: (error) {\n                print('Error: $error');\n              },\n              onPageError: (page, error) {\n                print('Error on page $page: $error');\n              },\n            ).fromUrl(\n              _pdfUrl,\n              placeholder: (double progress) => Center(child: Text('$progress %')),\n              errorWidget: (dynamic error) => Center(child: Text(error.toString())),\n            ),\n          ),\n          // Step 5: Add navigation controls\n          Padding(\n            padding: EdgeInsets.all(16.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  child: Text('Previous'),\n                  onPressed: () {\n                    _pdfViewController?.previousPage(\n                      curve: Curves.ease,\n                      duration: Duration(milliseconds: 100),\n                    );\n                  },\n                ),\n                Text('Page $_currentPage of $_totalPages'),\n                ElevatedButton(\n                  child: Text('Next'),\n                  onPressed: () {\n                    _pdfViewController?.nextPage(\n                      curve: Curves.ease,\n                      duration: Duration(milliseconds: 100),\n                    );\n                  },\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 6: Explanation of the application flow\n\n/*\nApplication Flow:\n\n1. The app starts by running the MyApp widget, which sets up the MaterialApp and defines the theme.\n\n2. The home page is set to the RealFlutter widget, which is a StatefulWidget.\n\n3. In the RealFlutter state:\n   - We define variables for the PDF URL, night mode state, PDF view controller, and page tracking.\n   - The build method creates a Scaffold with an AppBar and a body containing the PDF viewer and navigation controls.\n\n4. The PDF viewer is created using the PDF widget from the flutter_cached_pdfview package:\n   - It's configured with various options like enableSwipe, swipeHorizontal, etc.\n   - The onViewCreated callback stores the PDFViewController for later use.\n   - The onPageChanged callback updates the current page and total pages state.\n   - Error handling is implemented with onError and onPageError callbacks.\n\n5. The PDF is loaded from a URL using the fromUrl method, with placeholder and error widgets defined.\n\n6. Navigation controls are added below the PDF viewer:\n   - \"Previous\" and \"Next\" buttons use the PDFViewController to change pages.\n   - The current page and total pages are displayed between the buttons.\n\n7. A night mode toggle is added to the AppBar, which updates the _isNightMode state and refreshes the PDF viewer.\n\nThis example demonstrates key features of the flutter_cached_pdfview package, including:\n- Loading a PDF from a URL\n- Implementing swipe navigation\n- Adding custom controls for page navigation\n- Displaying loading progress and handling errors\n- Implementing a night mode feature\n- Tracking and displaying page information\n\nUsers can navigate through the PDF using swipe gestures or the provided buttons, toggle night mode, and see their current position in the document.\n*/\n```",
    "platforms": [
      "android",
      "ios"
    ],
    "_createdAt": "2024-08-28T22:19:39Z",
    "tutorial": "## 2. Tutorial\n\nIn this section, we'll walk through the process of integrating the `flutter_cached_pdfview` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_cached_pdfview: ^0.4.2\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_cached_pdfview/flutter_cached_pdfview.dart';\n```\n\n### Step 3: Basic Usage\n\nHere's a simple example of how to use the PDF viewer:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_cached_pdfview/flutter_cached_pdfview.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('PDF Viewer')),\n      body: PDF().fromUrl(\n        'https://example.com/sample.pdf',\n        placeholder: (progress) => Center(child: Text('$progress %')),\n        errorWidget: (error) => Center(child: Text(error.toString())),\n      ),\n    );\n  }\n}\n```\n\n### Step 4: Platform-Specific Configuration\n\n#### Android\n\nAdd the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n\n#### iOS\n\nNo additional configuration is required for iOS.\n\n### Step 5: Advanced Features\n\n1. **Loading from Assets**:\n   ```dart\n   PDF().fromAsset('assets/sample.pdf')\n   ```\n\n2. **Password Protection**:\n   ```dart\n   PDF().fromUrl(\n     'https://example.com/protected.pdf',\n     password: 'your_password',\n   )\n   ```\n\n3. **Customizing Controls**:\n   ```dart\n   PDF(\n     enableSwipe: true,\n     swipeHorizontal: true,\n     autoSpacing: false,\n     pageFling: false,\n     nightMode: false,\n   ).fromUrl('https://example.com/sample.pdf')\n   ```\n\n4. **Callbacks**:\n   ```dart\n   PDF().fromUrl(\n     'https://example.com/sample.pdf',\n     onViewCreated: (PDFViewController pdfViewController) {\n       // Controller created\n     },\n     onPageChanged: (int page, int total) {\n       // Page changed\n     },\n     onError: (error) {\n       // Error occurred\n     },\n     onPageError: (page, error) {\n       // Error occurred for a specific page\n     },\n   )\n   ```\n\nBy following this tutorial, you should now have a good understanding of how to implement and use the `flutter_cached_pdfview` package in your Flutter application. In the next section, we'll look at a more comprehensive example that demonstrates all the features of this package.",
    "_rev": "eaCZ7mIhmiYZX5KGqJmRCp",
    "shortDescription": "A package to show Native PDF View for iOS and Android, support Open from a different resource like Path, Asset or Url and Cache it.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGp5",
        "_type": "reference",
        "_key": "ftzhbxwl"
      }
    ],
    "likesCount": 454,
    "lastUpdate": "2023-07-01T18:30:00.000Z",
    "name": "flutter_cached_pdfview",
    "tutorialIncluded": true,
    "slug": {
      "current": "flutter_cached_pdfview",
      "_type": "slug"
    },
    "author": "bnsaed.com",
    "description": "# Flutter Cached PDFView: A Comprehensive Guide\n\n## 1. Description\n\nThe `flutter_cached_pdfview` package is a powerful tool for Flutter developers who need to implement PDF viewing functionality in their applications. This package offers a seamless way to render PDF documents with built-in caching capabilities, ensuring efficient performance and a smooth user experience.\n\n### Key Features:\n\n1. **Caching**: The package automatically caches PDF files, reducing load times for frequently accessed documents.\n\n2. **Customizable Controls**: Developers can easily customize the PDF viewer's interface, including zoom controls, page navigation, and more.\n\n3. **Cross-Platform Compatibility**: Works on both Android and iOS platforms, providing a consistent experience across devices.\n\n4. **Network and Asset Support**: Load PDFs from network URLs or local assets with equal ease.\n\n5. **Page Preloading**: Enhances performance by preloading adjacent pages for smoother scrolling.\n\n6. **Night Mode**: Supports a night mode feature for comfortable reading in low-light conditions.\n\n7. **Password Protection**: Handles password-protected PDF files seamlessly.\n\n8. **Callbacks**: Provides various callbacks for tracking loading progress, errors, and page changes.\n\nThe `flutter_cached_pdfview` package simplifies the process of integrating PDF viewing capabilities into Flutter applications, making it an invaluable tool for developers working on document-centric apps, e-readers, or any project that requires PDF rendering.\n\nIn the following sections, we'll dive deeper into how to implement this package in your Flutter project and explore its various features through practical examples.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaqU0",
        "_type": "reference",
        "_key": "f99nu2h2"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "5pkpuora"
      },
      {
        "_type": "reference",
        "_key": "y27dx6m1",
        "_ref": "Rx1Nho763d29lawKra1adH"
      }
    ],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:12:28Z",
    "pubPoint": 160,
    "tags": [
      "pdf",
      "cache",
      "viewer",
      "document"
    ],
    "_id": "V06bsD4sX3T8NTHrBPbBNs"
  },
  {
    "description": "# Understanding the `restart_app` Package in Flutter\n\n## Introduction\n\nIn the world of Flutter development, there are times when you need to restart your application programmatically. Whether it's to apply new configurations, reset the app state, or recover from a critical error, the ability to restart an app can be crucial. This is where the `restart_app` package comes into play.\n\n## What is `restart_app`?\n\nThe `restart_app` package is a lightweight Flutter plugin that provides a simple and efficient way to restart your Flutter application programmatically. It works across multiple platforms, including Android, iOS, and web.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works on Android, iOS, and web platforms.\n2. **Simple API**: Offers an easy-to-use API with just a few methods.\n3. **Customizable**: Allows you to set custom splash screens during the restart process.\n4. **Performance**: Designed to restart your app quickly and efficiently.\n\n## When to Use `restart_app`\n\nThe `restart_app` package can be particularly useful in scenarios such as:\n\n- Applying theme changes that require a full app restart\n- Implementing a \"force update\" feature in your app\n- Recovering from critical errors that require a fresh start\n- Resetting the entire app state after a user logs out\n\n## Getting Started\n\nTo use the `restart_app` package in your Flutter project, you need to add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  restart_app: ^latest_version\n```\n\nReplace `latest_version` with the current version of the package.\n\nAfter adding the dependency, run:\n\n```\nflutter pub get\n```\n\nNow you're ready to use `restart_app` in your Flutter application!\n\nIn the next section, we'll dive into a tutorial on how to implement and use the `restart_app` package in your Flutter projects.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "9nevkcrp"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:restart_app/restart_app.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Restart App Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  // Step 1: Create a method for basic restart\n  void _restartApp() {\n    Restart.restartApp();\n  }\n\n  // Step 2: Create a method for delayed restart\n  Future<void> _delayedRestart() async {\n    // Simulating some operation before restart\n    await Future.delayed(const Duration(seconds: 2));\n    Restart.restartApp();\n  }\n\n  // Step 3: Create a method for restart with custom splash screen\n  void _restartWithCustomSplash() {\n    Restart.restartApp(customSplashScreen: const CustomSplashScreen());\n  }\n\n  // Step 4: Create a method to demonstrate error handling\n  void _restartWithErrorHandling() {\n    try {\n      Restart.restartApp();\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error restarting app: $e')),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Restart App Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            const SizedBox(height: 20),\n            // Step 5: Add buttons to demonstrate different restart methods\n            ElevatedButton(\n              onPressed: _restartApp,\n              child: const Text('Basic Restart'),\n            ),\n            ElevatedButton(\n              onPressed: _delayedRestart,\n              child: const Text('Delayed Restart'),\n            ),\n            ElevatedButton(\n              onPressed: _restartWithCustomSplash,\n              child: const Text('Restart with Custom Splash'),\n            ),\n            ElevatedButton(\n              onPressed: _restartWithErrorHandling,\n              child: const Text('Restart with Error Handling'),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Step 6: Create a custom splash screen widget\nclass CustomSplashScreen extends StatelessWidget {\n  const CustomSplashScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.blue,\n      child: const Center(\n        child: Text(\n          'Restarting...',\n          style: TextStyle(color: Colors.white, fontSize: 24),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a counter and several buttons.\n// 2. Users can increment the counter using the floating action button.\n// 3. The \"Basic Restart\" button immediately restarts the app using Restart.restartApp().\n// 4. The \"Delayed Restart\" button waits for 2 seconds before restarting, simulating some pre-restart operation.\n// 5. The \"Restart with Custom Splash\" button restarts the app and displays a custom splash screen during the process.\n// 6. The \"Restart with Error Handling\" button demonstrates how to handle potential errors during the restart process.\n// 7. After each restart, the app will reset to its initial state (counter back to 0).\n\n// Note: The actual restart behavior may vary slightly depending on the platform (Android, iOS, or web).\n// Always test thoroughly on all target platforms to ensure consistent behavior.\n```",
    "packageImage": null,
    "lastUpdate": "2023-05-28T18:30:00.000Z",
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "likesCount": 372,
    "_id": "V06bsD4sX3T8NTHrBPbBzM",
    "tutorial": "# Tutorial: Implementing `restart_app` in Your Flutter Project\n\nIn this tutorial, we'll walk through the process of implementing the `restart_app` package in a Flutter application. We'll cover basic usage as well as platform-specific details.\n\n## Basic Usage\n\n1. First, import the package in your Dart file:\n\n```dart\nimport 'package:restart_app/restart_app.dart';\n```\n\n2. To restart the app, simply call the `Restart.restartApp()` method:\n\n```dart\nElevatedButton(\n  onPressed: () {\n    Restart.restartApp();\n  },\n  child: Text('Restart App'),\n)\n```\n\nThis will immediately restart your application.\n\n## Platform-Specific Details\n\n### Android\n\nOn Android, the `restart_app` package uses the `PackageManager` to restart the app. No additional configuration is needed.\n\n### iOS\n\nFor iOS, the package uses `UIApplication.shared.suspend()` followed by exit(0) to restart the app. This approach ensures a smooth restart experience on iOS devices.\n\n### Web\n\nOn web platforms, the package uses `window.location.reload()` to refresh the page, effectively restarting the web app.\n\n## Advanced Usage\n\n### Custom Splash Screen\n\nYou can set a custom splash screen to be displayed during the restart process:\n\n```dart\nRestart.restartApp(customSplashScreen: MyCustomSplashScreen());\n```\n\nWhere `MyCustomSplashScreen` is a widget you've created to serve as a splash screen.\n\n### Delayed Restart\n\nIf you need to perform some operations before restarting, you can use a delayed restart:\n\n```dart\nFuture<void> delayedRestart() async {\n  // Perform some operations\n  await Future.delayed(Duration(seconds: 2));\n  Restart.restartApp();\n}\n```\n\n### Error Handling\n\nWhile `restart_app` is designed to work seamlessly, it's always a good practice to handle potential errors:\n\n```dart\ntry {\n  Restart.restartApp();\n} catch (e) {\n  print('Error restarting app: $e');\n  // Handle the error (e.g., show an error message to the user)\n}\n```\n\n## Best Practices\n\n1. **Use sparingly**: Restarting the app should not be a frequent operation. Use it only when necessary.\n2. **Inform the user**: Always inform the user before restarting the app, especially if it's not initiated by them.\n3. **Save important data**: Ensure all important data is saved before restarting the app.\n4. **Test thoroughly**: Test the restart functionality on all targeted platforms to ensure consistent behavior.\n\nBy following this tutorial, you should now have a good understanding of how to implement and use the `restart_app` package in your Flutter projects. In the next section, we'll look at a complete example that demonstrates all the features of this package.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:29Z",
    "slug": {
      "current": "restart_app",
      "_type": "slug"
    },
    "author": "gabrimatic.info",
    "_rev": "eaCZ7mIhmiYZX5KGqJmRJN",
    "shortDescription": "A Flutter plugin that helps you to restart the whole Flutter app with a single function call by using native APIs.",
    "similarPackages": [],
    "tags": [
      "app-restart",
      "lifecycle",
      "utility"
    ],
    "name": "restart_app",
    "_type": "package",
    "dependentPackages": [
      {
        "_key": "tikem6wf",
        "_ref": "Rx1Nho763d29lawKra1WL9",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:19:49Z"
  },
  {
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFqE",
        "_type": "reference",
        "_key": "pibcff93"
      }
    ],
    "_id": "V06bsD4sX3T8NTHrBPbJ9o",
    "_rev": "eaCZ7mIhmiYZX5KGqJmRPv",
    "author": "theaxen.com",
    "similarPackages": [
      {
        "_key": "f0ioej4p",
        "_ref": "Rx1Nho763d29lawKra1wRD",
        "_type": "reference"
      }
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "slug": {
      "current": "circular_countdown_timer",
      "_type": "slug"
    },
    "pubPoint": 160,
    "shortDescription": "Make an animated circular countdown using Circular Countdown Timer.",
    "tags": [
      "timer",
      "countdown",
      "circular",
      "ui",
      "animation"
    ],
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:20:09Z",
    "name": "circular_countdown_timer",
    "tutorial": "# Circular Countdown Timer Tutorial\n\nThis tutorial will guide you through the process of implementing the `circular_countdown_timer` package in your Flutter application.\n\n## Step 1: Import the Package\n\nFirst, import the package in your Dart file:\n\n```dart\nimport 'package:circular_countdown_timer/circular_countdown_timer.dart';\n```\n\n## Step 2: Create a CountDownController\n\nThe `CountDownController` allows you to control the timer programmatically:\n\n```dart\nfinal CountDownController _controller = CountDownController();\n```\n\n## Step 3: Implement the CircularCountDownTimer Widget\n\nHere's a basic implementation of the `CircularCountDownTimer`:\n\n```dart\nCircularCountDownTimer(\n  duration: 60,\n  initialDuration: 0,\n  controller: _controller,\n  width: MediaQuery.of(context).size.width / 2,\n  height: MediaQuery.of(context).size.height / 2,\n  ringColor: Colors.grey[300]!,\n  ringGradient: null,\n  fillColor: Colors.purpleAccent[100]!,\n  fillGradient: null,\n  backgroundColor: Colors.purple[500],\n  backgroundGradient: null,\n  strokeWidth: 20.0,\n  strokeCap: StrokeCap.round,\n  textStyle: TextStyle(\n    fontSize: 33.0,\n    color: Colors.white,\n    fontWeight: FontWeight.bold,\n  ),\n  textFormat: CountdownTextFormat.S,\n  isReverse: false,\n  isReverseAnimation: false,\n  isTimerTextShown: true,\n  autoStart: false,\n  onStart: () {\n    debugPrint('Countdown Started');\n  },\n  onComplete: () {\n    debugPrint('Countdown Ended');\n  },\n  onChange: (String timeStamp) {\n    debugPrint('Countdown Changed $timeStamp');\n  },\n  timeFormatterFunction: (defaultFormatterFunction, duration) {\n    if (duration.inSeconds == 0) {\n      return \"Start\";\n    } else {\n      return Function.apply(defaultFormatterFunction, [duration]);\n    }\n  },\n)\n```\n\n## Step 4: Control the Timer\n\nUse the `CountDownController` to control the timer:\n\n```dart\n// Start the timer\n_controller.start();\n\n// Pause the timer\n_controller.pause();\n\n// Resume the timer\n_controller.resume();\n\n// Restart the timer\n_controller.restart(duration: 60);\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure that you have set the minimum deployment target to iOS 9.0 or higher in your `Podfile`:\n\n```ruby\nplatform :ios, '9.0'\n```\n\n### Android\n\nFor Android, make sure your `compileSdkVersion` is set to 29 or higher in your `app/build.gradle` file:\n\n```gradle\nandroid {\n    compileSdkVersion 29\n    // ...\n}\n```\n\n## Customization Tips\n\n1. **Color Schemes**: Use `ringColor`, `fillColor`, and `backgroundColor` to match your app's theme.\n2. **Gradients**: Implement `ringGradient`, `fillGradient`, and `backgroundGradient` for more dynamic visuals.\n3. **Text Formatting**: Customize `textStyle` and `textFormat` to display time in your preferred format.\n4. **Animation**: Adjust `isReverse` and `isReverseAnimation` for different countdown behaviors.\n\nBy following this tutorial, you'll be able to integrate and customize the Circular Countdown Timer in your Flutter application effectively.",
    "_updatedAt": "2024-09-06T04:12:30Z",
    "description": "# Circular Countdown Timer Package for Flutter\n\n## Introduction\n\nThe `circular_countdown_timer` package is a powerful and customizable Flutter widget that provides a visually appealing circular countdown timer. This package is perfect for developers looking to add an interactive and engaging timer to their Flutter applications.\n\n## Features\n\n1. **Customizable Appearance**: Easily adjust colors, stroke width, and text styles to match your app's design.\n2. **Flexible Duration**: Set any duration for the countdown, from seconds to hours.\n3. **Reverse Countdown**: Option to count down from the set duration to zero or count up from zero to the set duration.\n4. **Pause and Resume**: Built-in functionality to pause and resume the timer as needed.\n5. **Restart Capability**: Easily restart the timer from the beginning.\n6. **Completion Callback**: Execute custom actions when the timer completes.\n7. **On-Tap Action**: Define custom behavior when the timer is tapped.\n\n## Why Use Circular Countdown Timer?\n\n1. **Enhanced User Experience**: The visual representation of time passing can make waiting more engaging for users.\n2. **Versatility**: Suitable for various applications, from cooking apps to workout timers and more.\n3. **Easy Integration**: Simple to implement with minimal setup required.\n4. **Cross-Platform Compatibility**: Works seamlessly on both iOS and Android platforms.\n\n## Getting Started\n\nTo use the `circular_countdown_timer` package in your Flutter project, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  circular_countdown_timer: ^latest_version\n```\n\nReplace `latest_version` with the current version of the package.\n\nAfter adding the dependency, run:\n\n```\nflutter pub get\n```\n\nNow you're ready to import and use the package in your Flutter application!",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:circular_countdown_timer/circular_countdown_timer.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Circular Countdown Timer Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: MyHomePage(title: 'Circular Countdown Timer'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  // Step 1: Initialize the CountDownController\n  CountDownController _controller = CountDownController();\n\n  // Step 2: Set initial values\n  int _duration = 60;\n  bool _isReverse = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(widget.title)),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 3: Implement CircularCountDownTimer\n            CircularCountDownTimer(\n              duration: _duration,\n              initialDuration: 0,\n              controller: _controller,\n              width: MediaQuery.of(context).size.width / 2,\n              height: MediaQuery.of(context).size.height / 2,\n              ringColor: Colors.grey[300]!,\n              fillColor: Colors.blue[100]!,\n              backgroundColor: Colors.blue[500],\n              strokeWidth: 20.0,\n              strokeCap: StrokeCap.round,\n              textStyle: TextStyle(\n                fontSize: 33.0,\n                color: Colors.white,\n                fontWeight: FontWeight.bold,\n              ),\n              textFormat: CountdownTextFormat.S,\n              isReverse: _isReverse,\n              isReverseAnimation: false,\n              isTimerTextShown: true,\n              autoStart: false,\n              onStart: () {\n                debugPrint('Countdown Started');\n              },\n              onComplete: () {\n                debugPrint('Countdown Ended');\n              },\n              onChange: (String timeStamp) {\n                debugPrint('Countdown Changed $timeStamp');\n              },\n            ),\n            SizedBox(height: 20),\n            // Step 4: Add control buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                _button(title: \"Start\", onPressed: () => _controller.start()),\n                SizedBox(width: 10),\n                _button(title: \"Pause\", onPressed: () => _controller.pause()),\n                SizedBox(width: 10),\n                _button(title: \"Resume\", onPressed: () => _controller.resume()),\n                SizedBox(width: 10),\n                _button(\n                    title: \"Restart\",\n                    onPressed: () => _controller.restart(duration: _duration)),\n              ],\n            ),\n            SizedBox(height: 20),\n            // Step 5: Add customization options\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text(\"Duration: $_duration\"),\n                Slider(\n                  value: _duration.toDouble(),\n                  min: 10,\n                  max: 120,\n                  onChanged: (value) {\n                    setState(() {\n                      _duration = value.toInt();\n                    });\n                  },\n                ),\n              ],\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text(\"Reverse: \"),\n                Switch(\n                  value: _isReverse,\n                  onChanged: (value) {\n                    setState(() {\n                      _isReverse = value;\n                    });\n                  },\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Helper method to create buttons\n  Widget _button({required String title, VoidCallback? onPressed}) {\n    return ElevatedButton(\n      child: Text(title),\n      onPressed: onPressed,\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a circular countdown timer in the center.\n// 2. Below the timer, there are control buttons (Start, Pause, Resume, Restart).\n// 3. The user can adjust the duration using a slider (10 to 120 seconds).\n// 4. The user can toggle between forward and reverse countdown using a switch.\n// 5. When the user presses Start, the timer begins counting down (or up if reverse is true).\n// 6. The user can Pause, Resume, or Restart the timer at any time.\n// 7. When the timer completes, it triggers the onComplete callback (which currently just prints a debug message).\n// 8. The app demonstrates key features of the circular_countdown_timer package:\n//    - Visual countdown/up timer\n//    - Customizable appearance (colors, size, stroke width)\n//    - Controllable via buttons\n//    - Adjustable duration\n//    - Reverse countdown option\n//    - Callbacks for start, complete, and onChange events\n\n// This example provides a comprehensive demonstration of the circular_countdown_timer package,\n// allowing users to interact with and customize the timer in various ways.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 563,
    "lastUpdate": "2024-07-26T18:30:00.000Z",
    "_type": "package"
  },
  {
    "shortDescription": "Ionicons is a completely open-source icon set with 1k3+ icons crafted for web, iOS, Android, and desktop apps. They have both Material Design and iOS versions.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7pY",
        "_type": "reference",
        "_key": "epz21jqq"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "ss91rkn5",
        "_ref": "4gmBGwifQuSypgRenUbVh5"
      }
    ],
    "_createdAt": "2024-08-28T22:20:19Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmRWT",
    "description": "# Ionicons in Flutter: Enhancing Your App's UI\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, creating visually appealing and intuitive user interfaces is crucial. One of the key elements in achieving this is the effective use of icons. Enter Ionicons - a comprehensive, open-source icon set that has gained popularity among developers for its clean design and versatility.\n\n## What are Ionicons?\n\nIonicons is a premium icon font for mobile, web, and desktop apps. Originally designed for Ionic Framework, these icons have found their way into various development ecosystems, including Flutter. With over 1,300 meticulously crafted icons, Ionicons offers a wide range of options for developers to enhance their app's visual appeal and user experience.\n\n## Why Use Ionicons in Flutter?\n\n1. **Comprehensive Set**: With over 1,300 icons, you're likely to find the perfect icon for almost any use case.\n2. **Customizable**: Ionicons can be easily customized in terms of size, color, and other properties.\n3. **Lightweight**: Using icon fonts like Ionicons can be more performant than using individual image files.\n4. **Consistency**: Ionicons provides a consistent look and feel across different platforms and devices.\n5. **Regular Updates**: The Ionicons library is regularly updated with new icons and improvements.\n\n## Getting Started\n\nTo use Ionicons in your Flutter project, you'll need to add the `flutter_ionicons` package to your `pubspec.yaml` file. This package is a Flutter-specific implementation of Ionicons, making it easy to integrate these beautiful icons into your app.\n\nIn the next section, we'll dive into a detailed tutorial on how to set up and use Ionicons in your Flutter project.",
    "tags": [
      "icons",
      "ui",
      "ionicons",
      "vector-icons"
    ],
    "dependentPackages": [],
    "lastUpdate": "2023-01-18T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPbNIq",
    "tutorial": "# Ionicons in Flutter: A Comprehensive Tutorial\n\n## Setting Up\n\nTo get started with Ionicons in your Flutter project, follow these steps:\n\n1. Open your project's `pubspec.yaml` file.\n2. Add the following dependency under the `dependencies` section:\n\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     flutter_ionicons: ^0.2.2  # Use the latest version available\n   ```\n\n3. Run `flutter pub get` in your terminal to fetch the package.\n\n## Using Ionicons\n\nNow that you have the package installed, you can start using Ionicons in your Flutter app. Here's how:\n\n1. Import the package in your Dart file:\n\n   ```dart\n   import 'package:flutter_ionicons/flutter_ionicons.dart';\n   ```\n\n2. Use the `Icon` widget with `Ionicons` class:\n\n   ```dart\n   Icon(Ionicons.heart)\n   ```\n\n## Customizing Icons\n\nIonicons can be easily customized. Here are some properties you can modify:\n\n- **Size**: \n  ```dart\n  Icon(Ionicons.heart, size: 30.0)\n  ```\n\n- **Color**: \n  ```dart\n  Icon(Ionicons.heart, color: Colors.red)\n  ```\n\n- **Semantics Label** (for accessibility):\n  ```dart\n  Icon(Ionicons.heart, semanticLabel: 'Favorite')\n  ```\n\n## Platform-Specific Icons\n\nIonicons provides platform-specific variations for many icons. To use these, you can utilize Flutter's `Platform` class:\n\n```dart\nimport 'dart:io' show Platform;\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ionicons/flutter_ionicons.dart';\n\nIcon getPlatformIcon() {\n  if (Platform.isIOS) {\n    return Icon(Ionicons.heart_ios);\n  } else if (Platform.isAndroid) {\n    return Icon(Ionicons.heart_md);\n  } else {\n    return Icon(Ionicons.heart); // Default icon\n  }\n}\n```\n\nThis approach allows you to maintain a native look and feel across different platforms.\n\nIn the next section, we'll look at a complete example that demonstrates various features of the Ionicons package in Flutter.",
    "slug": {
      "_type": "slug",
      "current": "ionicons"
    },
    "author": "ez-connect.net",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ionicons/flutter_ionicons.dart';\nimport 'dart:io' show Platform;\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Ionicons Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: IoniconsDemoPage(),\n    );\n  }\n}\n\nclass IoniconsDemoPage extends StatefulWidget {\n  @override\n  _IoniconsDemoPageState createState() => _IoniconsDemoPageState();\n}\n\nclass _IoniconsDemoPageState extends State<IoniconsDemoPage> {\n  // Step 1: Initialize variables\n  double _iconSize = 24.0;\n  Color _iconColor = Colors.blue;\n  bool _isFavorite = false;\n\n  // Step 2: Create a method to get platform-specific icons\n  IconData getPlatformIcon(IconData iosIcon, IconData androidIcon) {\n    return Platform.isIOS ? iosIcon : androidIcon;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Build the UI\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Ionicons Demo'),\n        // Step 4: Use a platform-specific icon in the AppBar\n        leading: Icon(getPlatformIcon(Ionicons.menu_ios, Ionicons.menu_md)),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 5: Display a basic icon\n            Icon(Ionicons.heart, size: _iconSize, color: _iconColor),\n            SizedBox(height: 20),\n            \n            // Step 6: Display a customizable icon\n            IconButton(\n              icon: Icon(\n                _isFavorite ? Ionicons.heart : Ionicons.heart_outline,\n                size: _iconSize,\n                color: _isFavorite ? Colors.red : _iconColor,\n              ),\n              onPressed: () {\n                setState(() {\n                  _isFavorite = !_isFavorite;\n                });\n              },\n            ),\n            SizedBox(height: 20),\n            \n            // Step 7: Add sliders to customize icon size and color\n            Slider(\n              value: _iconSize,\n              min: 16.0,\n              max: 72.0,\n              onChanged: (value) {\n                setState(() {\n                  _iconSize = value;\n                });\n              },\n            ),\n            \n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: <Widget>[\n                ElevatedButton(\n                  child: Text('Blue'),\n                  onPressed: () {\n                    setState(() {\n                      _iconColor = Colors.blue;\n                    });\n                  },\n                ),\n                ElevatedButton(\n                  child: Text('Green'),\n                  onPressed: () {\n                    setState(() {\n                      _iconColor = Colors.green;\n                    });\n                  },\n                ),\n                ElevatedButton(\n                  child: Text('Red'),\n                  onPressed: () {\n                    setState(() {\n                      _iconColor = Colors.red;\n                    });\n                  },\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home page is set to IoniconsDemoPage, a StatefulWidget.\n// 3. In the State class, we initialize variables for icon size, color, and favorite status.\n// 4. The build method creates the UI:\n//    - AppBar uses a platform-specific menu icon.\n//    - The body contains:\n//      a. A basic Ionicon heart.\n//      b. A customizable heart icon that toggles between filled and outline on tap.\n//      c. A slider to adjust icon size.\n//      d. Buttons to change icon color.\n// 5. The setState method is used to update the UI whenever the user interacts with the controls.\n// 6. The getPlatformIcon method ensures that the correct icon variant is used based on the platform.\n\n// This example demonstrates:\n// - Basic usage of Ionicons\n// - Platform-specific icons\n// - Icon customization (size and color)\n// - Interactive icon state changes\n// - Integration with Flutter widgets and user interactions\n```",
    "name": "ionicons",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:12:31Z",
    "_type": "package",
    "likesCount": 478
  },
  {
    "description": "# Audio Waveforms Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `audio_waveforms` package is a powerful tool for Flutter developers looking to incorporate audio visualization and manipulation into their applications. This package provides a seamless way to display audio waveforms, record audio, and play audio files with customizable waveform displays.\n\n### Key Features:\n\n1. **Real-time Waveform Generation**: Visualize audio input in real-time, perfect for recording applications.\n2. **Customizable Waveform Display**: Adjust colors, width, spacing, and other visual properties of the waveform.\n3. **Audio Playback**: Play audio files with a synchronized waveform display.\n4. **Audio Recording**: Record audio directly within your Flutter application.\n5. **Seek Functionality**: Allow users to seek through audio files by interacting with the waveform.\n6. **Platform Support**: Works on both Android and iOS platforms.\n\n### Why Use Audio Waveforms?\n\nThe `audio_waveforms` package is ideal for developers working on:\n\n- Music production apps\n- Voice recording applications\n- Podcast players\n- Audio editing tools\n- Any app requiring visual representation of audio\n\nBy integrating this package, you can enhance user experience and provide intuitive audio interaction in your Flutter applications.",
    "similarPackages": [],
    "likesCount": 629,
    "_id": "V06bsD4sX3T8NTHrBPbPCe",
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `audio_waveforms` package into your Flutter project and demonstrate its basic usage.\n\n### Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  audio_waveforms: ^1.0.0  # Replace with the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:audio_waveforms/audio_waveforms.dart';\n```\n\n### Step 3: Initialize the PlayerController\n\nCreate a `PlayerController` to manage audio playback:\n\n```dart\nlate PlayerController _playerController;\n\n@override\nvoid initState() {\n  super.initState();\n  _playerController = PlayerController();\n}\n```\n\n### Step 4: Create a Waveform\n\nUse the `AudioWaveforms` widget to display the waveform:\n\n```dart\nAudioWaveforms(\n  size: Size(MediaQuery.of(context).size.width, 200.0),\n  recorderController: _playerController,\n)\n```\n\n### Step 5: Implement Audio Playback\n\nTo play an audio file:\n\n```dart\nawait _playerController.preparePlayer(\n  path: 'path/to/your/audio/file.mp3',\n  shouldExtractWaveform: true,\n);\n_playerController.startPlayer();\n```\n\n### Step 6: Implement Recording (Optional)\n\nTo record audio, you'll need a `RecorderController`:\n\n```dart\nlate RecorderController _recorderController;\n\n@override\nvoid initState() {\n  super.initState();\n  _recorderController = RecorderController()\n    ..androidEncoder = AndroidEncoder.aac\n    ..androidOutputFormat = AndroidOutputFormat.mpeg4\n    ..iosEncoder = IosEncoder.kAudioFormatMPEG4AAC\n    ..sampleRate = 44100;\n}\n```\n\nStart recording:\n\n```dart\nawait _recorderController.record();\n```\n\n### Platform-Specific Details\n\n#### Android\n\nAdd the following permissions to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n#### iOS\n\nAdd the following keys to your `Info.plist`:\n\n```xml\n<key>NSMicrophoneUsageDescription</key>\n<string>This app needs access to microphone for audio recording.</string>\n```\n\nRemember to handle permissions in your app logic for both platforms.",
    "author": "simform.com",
    "platforms": [
      "android",
      "ios"
    ],
    "tags": [
      "audio",
      "waveform",
      "visualization",
      "sound"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "80noq2rm"
      },
      {
        "_type": "reference",
        "_key": "qlj0zuza",
        "_ref": "uQRNMiDfrp20RZ8Id8CWZd"
      }
    ],
    "slug": {
      "current": "audio_waveforms",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "A Flutter package that allow you to generate waveform while recording audio or from audio file.",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:46Z",
    "name": "audio_waveforms",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaS2k",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbW9O",
        "_type": "reference",
        "_key": "hqhj22r9"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:audio_waveforms/audio_waveforms.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: AudioWaveformsDemo(),\n    );\n  }\n}\n\nclass AudioWaveformsDemo extends StatefulWidget {\n  @override\n  _AudioWaveformsDemoState createState() => _AudioWaveformsDemoState();\n}\n\nclass _AudioWaveformsDemoState extends State<AudioWaveformsDemo> {\n  late PlayerController _playerController;\n  late RecorderController _recorderController;\n  String? _recordedAudioPath;\n  bool _isRecording = false;\n  bool _isPlaying = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _initControllers();\n  }\n\n  // Step 1: Initialize controllers\n  void _initControllers() {\n    _playerController = PlayerController();\n    _recorderController = RecorderController()\n      ..androidEncoder = AndroidEncoder.aac\n      ..androidOutputFormat = AndroidOutputFormat.mpeg4\n      ..iosEncoder = IosEncoder.kAudioFormatMPEG4AAC\n      ..sampleRate = 44100;\n  }\n\n  // Step 2: Start recording\n  Future<void> _startRecording() async {\n    final directory = await getApplicationDocumentsDirectory();\n    _recordedAudioPath = '${directory.path}/recorded_audio.m4a';\n    await _recorderController.record(path: _recordedAudioPath);\n    setState(() => _isRecording = true);\n  }\n\n  // Step 3: Stop recording\n  Future<void> _stopRecording() async {\n    await _recorderController.stop();\n    setState(() => _isRecording = false);\n  }\n\n  // Step 4: Play recorded audio\n  Future<void> _playAudio() async {\n    if (_recordedAudioPath != null) {\n      await _playerController.preparePlayer(\n        path: _recordedAudioPath!,\n        shouldExtractWaveform: true,\n      );\n      _playerController.startPlayer();\n      setState(() => _isPlaying = true);\n    }\n  }\n\n  // Step 5: Stop playing audio\n  void _stopAudio() {\n    _playerController.stopPlayer();\n    setState(() => _isPlaying = false);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Audio Waveforms Demo')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          // Step 6: Display recording waveform\n          AudioWaveforms(\n            size: Size(MediaQuery.of(context).size.width, 200.0),\n            recorderController: _recorderController,\n            waveStyle: WaveStyle(\n              waveColor: Colors.blue,\n              extendWaveform: true,\n              showMiddleLine: false,\n            ),\n          ),\n          SizedBox(height: 20),\n          // Step 7: Display playback waveform\n          if (_recordedAudioPath != null)\n            AudioFileWaveforms(\n              size: Size(MediaQuery.of(context).size.width, 100.0),\n              playerController: _playerController,\n              enableSeekGesture: true,\n              waveformType: WaveformType.fitWidth,\n            ),\n          SizedBox(height: 20),\n          // Step 8: Control buttons\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: [\n              ElevatedButton(\n                onPressed: _isRecording ? _stopRecording : _startRecording,\n                child: Text(_isRecording ? 'Stop Recording' : 'Start Recording'),\n              ),\n              ElevatedButton(\n                onPressed: _recordedAudioPath != null\n                    ? (_isPlaying ? _stopAudio : _playAudio)\n                    : null,\n                child: Text(_isPlaying ? 'Stop Playing' : 'Play Recording'),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _playerController.dispose();\n    _recorderController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app initializes with two main components: a recording waveform and a playback waveform.\n// 2. User can start recording by pressing the \"Start Recording\" button.\n// 3. While recording, the top waveform displays the real-time audio input.\n// 4. User stops recording by pressing the \"Stop Recording\" button.\n// 5. The recorded audio file path is saved.\n// 6. User can play the recorded audio by pressing the \"Play Recording\" button.\n// 7. During playback, the bottom waveform shows the audio file's waveform and current playback position.\n// 8. User can seek through the audio by interacting with the playback waveform.\n// 9. The cycle can be repeated for new recordings.\n\n// Note: This example assumes you've handled permissions for audio recording on both Android and iOS platforms.\n```",
    "lastUpdate": "2024-03-04T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:32Z"
  },
  {
    "description": "# File Selector Package in Flutter: A Comprehensive Guide\n\nThe `file_selector` package is a powerful tool in the Flutter ecosystem that provides a platform-agnostic way to select files and directories. It's particularly useful for developers who need to implement file picking functionality across multiple platforms, including mobile (iOS and Android), desktop (Windows, macOS, and Linux), and web.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Works seamlessly across mobile, desktop, and web platforms.\n2. **Multiple file selection**: Allows users to select one or more files.\n3. **Directory selection**: Enables users to choose entire directories.\n4. **File type filtering**: Provides the ability to filter files based on their types or extensions.\n5. **Custom UI integration**: Can be easily integrated with custom UI components.\n\n## Why Use File Selector?\n\nThe `file_selector` package offers several advantages:\n\n- **Consistency**: Provides a unified API across different platforms, simplifying development.\n- **Flexibility**: Supports various file operations, from single file selection to multiple directory picks.\n- **Easy integration**: Seamlessly integrates with Flutter's widget system and existing projects.\n- **Customization**: Allows developers to tailor the file selection experience to their app's needs.\n\nIn the following sections, we'll dive deeper into how to use the `file_selector` package in your Flutter projects, including a step-by-step tutorial and a comprehensive example demonstrating its features.",
    "_createdAt": "2024-08-28T22:20:47Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:file_selector/file_selector.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'File Selector Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const FileSelectorDemo(),\n    );\n  }\n}\n\nclass FileSelectorDemo extends StatefulWidget {\n  const FileSelectorDemo({Key? key}) : super(key: key);\n\n  @override\n  _FileSelectorDemoState createState() => _FileSelectorDemoState();\n}\n\nclass _FileSelectorDemoState extends State<FileSelectorDemo> {\n  String _selectedFilePath = 'No file selected';\n  List<String> _selectedFilePaths = [];\n  String _selectedDirectoryPath = 'No directory selected';\n\n  // Step 1: Implement single file selection\n  Future<void> _pickSingleFile() async {\n    final XFile? file = await openFile();\n    if (file != null) {\n      setState(() {\n        _selectedFilePath = file.path;\n      });\n    }\n  }\n\n  // Step 2: Implement multiple file selection\n  Future<void> _pickMultipleFiles() async {\n    final List<XFile> files = await openFiles();\n    setState(() {\n      _selectedFilePaths = files.map((file) => file.path).toList();\n    });\n  }\n\n  // Step 3: Implement directory selection\n  Future<void> _pickDirectory() async {\n    final String? directoryPath = await getDirectoryPath();\n    if (directoryPath != null) {\n      setState(() {\n        _selectedDirectoryPath = directoryPath;\n      });\n    }\n  }\n\n  // Step 4: Implement file type filtering (e.g., for images)\n  Future<void> _pickImageFile() async {\n    final XTypeGroup imageTypeGroup = XTypeGroup(\n      label: 'images',\n      extensions: ['jpg', 'png', 'gif'],\n    );\n    final XFile? file = await openFile(acceptedTypeGroups: [imageTypeGroup]);\n    if (file != null) {\n      setState(() {\n        _selectedFilePath = file.path;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('File Selector Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: _pickSingleFile,\n              child: const Text('Pick Single File'),\n            ),\n            Text('Selected file: $_selectedFilePath'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _pickMultipleFiles,\n              child: const Text('Pick Multiple Files'),\n            ),\n            Text('Selected files: ${_selectedFilePaths.join(\", \")}'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _pickDirectory,\n              child: const Text('Pick Directory'),\n            ),\n            Text('Selected directory: $_selectedDirectoryPath'),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _pickImageFile,\n              child: const Text('Pick Image File'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons and text areas.\n// 2. When \"Pick Single File\" is pressed, it opens a file picker dialog.\n//    After selection, it updates the UI with the selected file path.\n// 3. \"Pick Multiple Files\" allows selecting multiple files and displays their paths.\n// 4. \"Pick Directory\" opens a directory picker and shows the selected directory path.\n// 5. \"Pick Image File\" opens a file picker with image type filtering.\n// 6. The UI updates after each selection to reflect the user's choices.\n\n// This example demonstrates:\n// - Single and multiple file selection\n// - Directory selection\n// - File type filtering (for images)\n// - Updating the UI based on user selections\n// - Basic error handling (null checks on selected files/directories)\n\n// Note: Platform-specific configurations (as mentioned in the tutorial) \n// should be applied for this example to work across different platforms.\n```",
    "slug": {
      "current": "file_selector",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmRd1",
    "shortDescription": "Flutter plugin for opening and saving files, or selecting directories, using native file selection UI.",
    "subCategories": [
      {
        "_key": "jsy4q2wh",
        "_ref": "4gmBGwifQuSypgRenUbWg3",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "files",
      "file-selection",
      "file-selector",
      "picker",
      "io",
      "document",
      "storage",
      "filesystem"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "kjsud77n"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7E4",
        "_type": "reference",
        "_key": "4jml8nxc"
      }
    ],
    "lastUpdate": "2024-01-31T18:30:00.000Z",
    "name": "file_selector",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "author": "flutter.dev",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1LIJ",
        "_type": "reference",
        "_key": "c53avggd"
      }
    ],
    "likesCount": 351,
    "packageImage": null,
    "_id": "V06bsD4sX3T8NTHrBPbPY4",
    "tutorial": "# File Selector Package Tutorial\n\nThis tutorial will guide you through setting up and using the `file_selector` package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  file_selector: ^1.0.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:file_selector/file_selector.dart';\n```\n\n## Step 3: Implement File Selection\n\nHere's a basic example of how to select a single file:\n\n```dart\nFuture<void> _pickFile() async {\n  final XFile? file = await openFile();\n  if (file != null) {\n    print('Selected file: ${file.path}');\n  }\n}\n```\n\n## Step 4: Platform-Specific Configuration\n\n### Android\n\nNo additional configuration is needed for Android.\n\n### iOS\n\nAdd the following keys to your `Info.plist` file:\n\n```xml\n<key>NSDocumentsFolderUsageDescription</key>\n<string>This app requires access to the documents folder</string>\n```\n\n### macOS\n\nAdd the following keys to your `Info.plist` file:\n\n```xml\n<key>com.apple.security.files.user-selected.read-only</key>\n<true/>\n```\n\n### Windows and Linux\n\nNo additional configuration is needed for Windows and Linux.\n\n### Web\n\nFor web support, add the following script to your `web/index.html` file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/file-selector@0.8.2/dist/file-selector.min.js\"></script>\n```\n\n## Step 5: Advanced Usage\n\n### Multiple File Selection\n\n```dart\nFuture<void> _pickMultipleFiles() async {\n  final List<XFile> files = await openFiles();\n  for (final file in files) {\n    print('Selected file: ${file.path}');\n  }\n}\n```\n\n### Directory Selection\n\n```dart\nFuture<void> _pickDirectory() async {\n  final String? directoryPath = await getDirectoryPath();\n  if (directoryPath != null) {\n    print('Selected directory: $directoryPath');\n  }\n}\n```\n\n### File Type Filtering\n\n```dart\nFuture<void> _pickImageFile() async {\n  final XTypeGroup typeGroup = XTypeGroup(\n    label: 'images',\n    extensions: ['jpg', 'png', 'gif'],\n  );\n  final XFile? file = await openFile(acceptedTypeGroups: [typeGroup]);\n  if (file != null) {\n    print('Selected image: ${file.path}');\n  }\n}\n```\n\nBy following these steps and examples, you'll be able to implement file and directory selection functionality in your Flutter app using the `file_selector` package.",
    "_updatedAt": "2024-09-06T04:12:33Z"
  },
  {
    "author": "splashbyte.dev",
    "shortDescription": "Fully customizable, draggable and animated switch with multiple choices and smooth loading animation. It has prebuilt constructors for rolling and size animations.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "_id": "V06bsD4sX3T8NTHrBPbQvk",
    "tutorial": "# Animated Toggle Switch Tutorial\n\nIn this tutorial, we'll walk through creating a basic animated toggle switch and then explore some advanced features.\n\n## Basic Implementation\n\nFirst, let's create a simple toggle switch with three options:\n\n```dart\nAnimatedToggleSwitch<int>.rolling(\n  current: _currentIndex,\n  values: const [0, 1, 2],\n  onChanged: (i) => setState(() => _currentIndex = i),\n  iconBuilder: iconBuilder,\n)\n```\n\nHere, `_currentIndex` is a state variable that holds the currently selected index.\n\nThe `iconBuilder` function could be defined as:\n\n```dart\nWidget iconBuilder(int value, Size size) {\n  IconData data = Icons.access_time_rounded;\n  if (value == 1) data = Icons.check_circle_rounded;\n  if (value == 2) data = Icons.cancel_rounded;\n  return Icon(data, size: size.shortestSide);\n}\n```\n\n## Advanced Features\n\n### Custom Styling\n\nYou can customize the appearance of the switch:\n\n```dart\nAnimatedToggleSwitch<int>.rolling(\n  current: _currentIndex,\n  values: const [0, 1, 2],\n  onChanged: (i) => setState(() => _currentIndex = i),\n  iconBuilder: iconBuilder,\n  borderColor: Colors.transparent,\n  borderWidth: 4.0,\n  indicatorColor: Colors.blue,\n  innerColor: Colors.white,\n  height: 55,\n  dif: 15,\n)\n```\n\n### Multiple Selection\n\nFor multiple selection, use `AnimatedToggleSwitch.multipleSelection`:\n\n```dart\nAnimatedToggleSwitch<int>.multipleSelection(\n  current: _selectedIndexes,\n  values: const [0, 1, 2],\n  onChanged: (i) => setState(() => _selectedIndexes = i),\n  iconBuilder: iconBuilder,\n)\n```\n\n### Custom Animations\n\nYou can create custom animations using the `customSizeBuilder` and `foregroundIndicatorBuilder` parameters:\n\n```dart\nAnimatedToggleSwitch<int>.rolling(\n  // ... other parameters ...\n  customSizeBuilder: (context, i, width) => Size(width / 3, 50),\n  foregroundIndicatorBuilder: (context, i) {\n    return SizedBox.fromSize(\n      size: Size.square(40),\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          color: Colors.white,\n          shape: BoxShape.circle,\n          boxShadow: [\n            BoxShadow(\n              color: Colors.black26,\n              spreadRadius: 1,\n              blurRadius: 2,\n              offset: Offset(0, 1),\n            )\n          ],\n        ),\n      ),\n    );\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, you might want to use a more iOS-style toggle switch. You can achieve this by customizing the `borderRadius` and using a Cupertino-style icon set:\n\n```dart\nAnimatedToggleSwitch<int>.rolling(\n  // ... other parameters ...\n  borderRadius: BorderRadius.circular(20.0),\n  iconBuilder: (value, size) {\n    IconData data = CupertinoIcons.clock;\n    if (value == 1) data = CupertinoIcons.check_mark_circled;\n    if (value == 2) data = CupertinoIcons.xmark_circle;\n    return Icon(data, size: size.shortestSide);\n  },\n)\n```\n\n### Android\n\nFor Android, you might want to use Material Design icons and follow Material Design guidelines:\n\n```dart\nAnimatedToggleSwitch<int>.rolling(\n  // ... other parameters ...\n  borderRadius: BorderRadius.circular(8.0),\n  iconBuilder: (value, size) {\n    IconData data = Icons.access_time;\n    if (value == 1) data = Icons.check_circle;\n    if (value == 2) data = Icons.cancel;\n    return Icon(data, size: size.shortestSide);\n  },\n)\n```\n\nBy following these platform-specific guidelines, you can ensure that your toggle switch feels native on each platform while still maintaining the animated functionality provided by the package.",
    "_updatedAt": "2024-09-06T04:12:34Z",
    "tags": [
      "ui",
      "switch",
      "toggle",
      "widget",
      "animation",
      "customization",
      "interactive",
      "user-interface"
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmRmq",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:animated_toggle_switch/animated_toggle_switch.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Animated Toggle Switch Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: AnimatedToggleSwitchDemo(),\n    );\n  }\n}\n\nclass AnimatedToggleSwitchDemo extends StatefulWidget {\n  @override\n  _AnimatedToggleSwitchDemoState createState() => _AnimatedToggleSwitchDemoState();\n}\n\nclass _AnimatedToggleSwitchDemoState extends State<AnimatedToggleSwitchDemo> {\n  // Step 1: Initialize state variables\n  int _currentIndex = 0;\n  List<int> _selectedIndexes = [];\n\n  // Step 2: Define icon builder function\n  Widget iconBuilder(int value, Size size) {\n    IconData data = Icons.access_time_rounded;\n    if (value == 1) data = Icons.check_circle_rounded;\n    if (value == 2) data = Icons.cancel_rounded;\n    return Icon(data, size: size.shortestSide);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Animated Toggle Switch Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 3: Basic toggle switch\n            AnimatedToggleSwitch<int>.rolling(\n              current: _currentIndex,\n              values: const [0, 1, 2],\n              onChanged: (i) => setState(() => _currentIndex = i),\n              iconBuilder: iconBuilder,\n            ),\n            SizedBox(height: 20),\n\n            // Step 4: Customized toggle switch\n            AnimatedToggleSwitch<int>.rolling(\n              current: _currentIndex,\n              values: const [0, 1, 2],\n              onChanged: (i) => setState(() => _currentIndex = i),\n              iconBuilder: iconBuilder,\n              borderColor: Colors.transparent,\n              borderWidth: 4.0,\n              indicatorColor: Colors.blue,\n              innerColor: Colors.white,\n              height: 55,\n              dif: 15,\n            ),\n            SizedBox(height: 20),\n\n            // Step 5: Multiple selection toggle switch\n            AnimatedToggleSwitch<int>.multipleSelection(\n              current: _selectedIndexes,\n              values: const [0, 1, 2],\n              onChanged: (i) => setState(() => _selectedIndexes = i),\n              iconBuilder: iconBuilder,\n            ),\n            SizedBox(height: 20),\n\n            // Step 6: Custom animated toggle switch\n            AnimatedToggleSwitch<int>.rolling(\n              current: _currentIndex,\n              values: const [0, 1, 2],\n              onChanged: (i) => setState(() => _currentIndex = i),\n              iconBuilder: iconBuilder,\n              customSizeBuilder: (context, i, width) => Size(width / 3, 50),\n              foregroundIndicatorBuilder: (context, i) {\n                return SizedBox.fromSize(\n                  size: Size.square(40),\n                  child: DecoratedBox(\n                    decoration: BoxDecoration(\n                      color: Colors.white,\n                      shape: BoxShape.circle,\n                      boxShadow: [\n                        BoxShadow(\n                          color: Colors.black26,\n                          spreadRadius: 1,\n                          blurRadius: 2,\n                          offset: Offset(0, 1),\n                        )\n                      ],\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays four different types of animated toggle switches.\n// 2. The first switch is a basic implementation with three options.\n// 3. The second switch is customized with specific colors and dimensions.\n// 4. The third switch allows multiple selections.\n// 5. The fourth switch demonstrates custom animations and styling.\n// 6. When a user interacts with any switch, the corresponding state variable \n//    (_currentIndex or _selectedIndexes) is updated, triggering a rebuild of the widget.\n// 7. The iconBuilder function determines which icon to display based on the current value.\n// 8. Each switch is responsive to user input and provides visual feedback through animations.\n\n// Note: This example showcases various features of the animated_toggle_switch package.\n// In a real application, you would typically use these switches in different parts of your UI\n// rather than all on one screen. The multiple types shown here are for demonstration purposes.\n```",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-55f5b74b3729022bcc37cabacfe1ea91e55930dc-320x320-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:20:54Z",
    "name": "animated_toggle_switch",
    "tutorialIncluded": true,
    "slug": {
      "current": "animated_toggle_switch",
      "_type": "slug"
    },
    "pubPoint": 160,
    "description": "# Animated Toggle Switch in Flutter: A Comprehensive Guide\n\n## Introduction\n\nThe `animated_toggle_switch` package is a powerful and flexible Flutter widget that allows developers to create beautifully animated toggle switches. This package offers a wide range of customization options, making it suitable for various use cases and design requirements.\n\n## Key Features\n\n1. **Multiple Selection Modes**: Supports single and multiple selections.\n2. **Customizable Animations**: Offers various built-in animations and allows for custom animations.\n3. **Flexible Styling**: Easily customize colors, shapes, and sizes to match your app's design.\n4. **Icon and Text Support**: Use icons or text as toggle options.\n5. **Accessibility**: Implements accessibility features for better usability.\n\n## When to Use\n\nThe `animated_toggle_switch` package is ideal for:\n\n- Creating interactive user interface elements\n- Implementing settings or preference toggles\n- Designing quiz or survey applications\n- Building custom radio or checkbox alternatives\n\n## Getting Started\n\nTo use this package, add `animated_toggle_switch` as a dependency in your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  animated_toggle_switch: ^0.8.0\n```\n\nThen, import it in your Dart code:\n\n```dart\nimport 'package:animated_toggle_switch/animated_toggle_switch.dart';\n```\n\nWith these simple steps, you're ready to create engaging and interactive toggle switches in your Flutter application!",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CcB9",
        "_type": "reference",
        "_key": "iduf9xlq"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "rvkk6tzd"
      }
    ],
    "likesCount": 653
  },
  {
    "_type": "package",
    "shortDescription": "A server and browser based MQTT client for Dart supporting normal, secure sockets and websockets.",
    "subCategories": [
      {
        "_key": "pu5pmxvq",
        "_ref": "t8DYBEKn49O4mjbyRAfHom",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-415dc24a6aef383f5d13e96dfef478dcb0091bbf-1460x1251-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:21:05Z",
    "tutorial": "# MQTT Flutter Client: A Comprehensive Guide\n\n## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using the `mqtt_client` package in a Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the `mqtt_client` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  mqtt_client: ^9.8.1\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the package\n\nIn your Dart file, import the necessary classes:\n\n```dart\nimport 'package:mqtt_client/mqtt_client.dart';\nimport 'package:mqtt_client/mqtt_server_client.dart';\n```\n\n### Step 3: Create an MQTT client\n\nCreate an instance of `MqttServerClient`:\n\n```dart\nfinal client = MqttServerClient('broker.hivemq.com', 'flutter_client');\n```\n\n### Step 4: Set up client options\n\nConfigure the client options:\n\n```dart\nclient.port = 1883;\nclient.keepAlivePeriod = 60;\nclient.onDisconnected = onDisconnected;\nclient.onConnected = onConnected;\nclient.onSubscribed = onSubscribed;\n```\n\n### Step 5: Connect to the broker\n\nEstablish a connection to the MQTT broker:\n\n```dart\ntry {\n  await client.connect();\n} catch (e) {\n  print('Exception: $e');\n  client.disconnect();\n}\n```\n\n### Step 6: Subscribe to topics\n\nSubscribe to MQTT topics:\n\n```dart\nconst topic = 'test/topic';\nclient.subscribe(topic, MqttQos.atMostOnce);\n```\n\n### Step 7: Publish messages\n\nPublish messages to a topic:\n\n```dart\nfinal builder = MqttClientPayloadBuilder();\nbuilder.addString('Hello MQTT!');\nclient.publishMessage(topic, MqttQos.exactlyOnce, builder.payload!);\n```\n\n### Step 8: Handle incoming messages\n\nSet up a listener for incoming messages:\n\n```dart\nclient.updates!.listen((List<MqttReceivedMessage<MqttMessage>> c) {\n  final MqttPublishMessage message = c[0].payload as MqttPublishMessage;\n  final payload =\n      MqttPublishPayload.bytesToStringAsString(message.payload.message);\n  print('Received message: $payload from topic: ${c[0].topic}');\n});\n```\n\n### Platform-specific considerations\n\n#### Android\n\nFor Android, add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n#### iOS\n\nFor iOS, add the following to your `Info.plist` file:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n#### Web\n\nFor web applications, ensure that your MQTT broker supports WebSocket connections. You may need to use a different port (typically 8080 or 8081 for WebSocket, 8883 for secure WebSocket).\n\nIn the next section, we'll provide a complete example that demonstrates all the features of the `mqtt_client` package in a fully functional Flutter application.",
    "author": "darticulate.com",
    "slug": {
      "current": "mqtt_client",
      "_type": "slug"
    },
    "_updatedAt": "2024-09-06T04:12:35Z",
    "description": "# MQTT Flutter Client: A Comprehensive Guide\n\n## 1. Description\n\nThe MQTT (Message Queuing Telemetry Transport) protocol is a lightweight, publish-subscribe network protocol that transports messages between devices. It's designed for low-bandwidth, high-latency, or unreliable networks, making it ideal for Internet of Things (IoT) applications and mobile devices.\n\nThe `mqtt_client` package for Flutter provides a robust implementation of the MQTT protocol, allowing developers to easily integrate MQTT functionality into their Flutter applications. This package supports both MQTT 3.1.1 and MQTT 5.0 protocols, offering a wide range of features including:\n\n- QoS (Quality of Service) levels 0, 1, and 2\n- SSL/TLS secure connections\n- Will messages\n- Keep alive and ping functionality\n- Topic wildcards\n- Persistent sessions\n- Auto reconnect\n- Offline buffering\n- Custom message persistence\n\nWith the `mqtt_client` package, you can build real-time, event-driven applications that can communicate efficiently with IoT devices, backend services, or other mobile clients. Whether you're developing a smart home app, a real-time chat application, or an industrial monitoring system, the MQTT Flutter client provides the tools you need to implement reliable, scalable messaging.\n\nIn the following sections, we'll dive into a tutorial on how to use the `mqtt_client` package and provide a comprehensive example demonstrating its features.",
    "dependentPackages": [],
    "pubPoint": 160,
    "tags": [
      "iot",
      "chat",
      "mqtt",
      "data",
      "messaging",
      "network",
      "protocol",
      "real-time",
      "pub-sub"
    ],
    "likesCount": 444,
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "name": "mqtt_client",
    "tutorialIncluded": true,
    "example": "```\nimport 'dart:async';\nimport 'dart:io';\nimport 'package:flutter/material.dart';\nimport 'package:mqtt_client/mqtt_client.dart';\nimport 'package:mqtt_client/mqtt_server_client.dart';\n\nvoid main() {\n  runApp(const MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late MqttServerClient client;\n  final TextEditingController _messageController = TextEditingController();\n  final List<String> _messages = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _setupMqttClient();\n  }\n\n  // Step 1: Set up MQTT client\n  Future<void> _setupMqttClient() async {\n    client = MqttServerClient('broker.hivemq.com', 'flutter_client');\n    client.port = 1883;\n    client.keepAlivePeriod = 60;\n    client.onDisconnected = _onDisconnected;\n    client.onConnected = _onConnected;\n    client.onSubscribed = _onSubscribed;\n\n    // Step 2: Set up client credentials if needed\n    // client.logging(on: true);\n    // client.setProtocolV311();\n    // client.websocketProtocols = ['mqtt'];\n\n    // Step 3: Connect to MQTT broker\n    try {\n      await client.connect();\n    } catch (e) {\n      print('Exception: $e');\n      client.disconnect();\n    }\n\n    // Step 4: Subscribe to topics\n    const topic = 'flutter/mqtt_example';\n    client.subscribe(topic, MqttQos.atMostOnce);\n\n    // Step 5: Set up message listener\n    client.updates!.listen((List<MqttReceivedMessage<MqttMessage>> c) {\n      final MqttPublishMessage message = c[0].payload as MqttPublishMessage;\n      final payload =\n          MqttPublishPayload.bytesToStringAsString(message.payload.message);\n      \n      setState(() {\n        _messages.add('Received: $payload');\n      });\n    });\n  }\n\n  // Step 6: Implement connection callbacks\n  void _onConnected() {\n    print('Connected to MQTT broker');\n  }\n\n  void _onDisconnected() {\n    print('Disconnected from MQTT broker');\n  }\n\n  void _onSubscribed(String topic) {\n    print('Subscribed to topic: $topic');\n  }\n\n  // Step 7: Implement publish functionality\n  void _publishMessage(String message) {\n    const topic = 'flutter/mqtt_example';\n    final builder = MqttClientPayloadBuilder();\n    builder.addString(message);\n    client.publishMessage(topic, MqttQos.exactlyOnce, builder.payload!);\n    setState(() {\n      _messages.add('Sent: $message');\n    });\n  }\n\n  @override\n  void dispose() {\n    client.disconnect();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MQTT Flutter Example')),\n      body: Column(\n        children: [\n          Expanded(\n            child: ListView.builder(\n              itemCount: _messages.length,\n              itemBuilder: (context, index) {\n                return ListTile(title: Text(_messages[index]));\n              },\n            ),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Row(\n              children: [\n                Expanded(\n                  child: TextField(\n                    controller: _messageController,\n                    decoration: const InputDecoration(\n                      hintText: 'Enter message',\n                    ),\n                  ),\n                ),\n                ElevatedButton(\n                  onPressed: () {\n                    if (_messageController.text.isNotEmpty) {\n                      _publishMessage(_messageController.text);\n                      _messageController.clear();\n                    }\n                  },\n                  child: const Text('Send'),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes and sets up the MQTT client in the initState method.\n// 2. It connects to the MQTT broker (broker.hivemq.com) and subscribes to the 'flutter/mqtt_example' topic.\n// 3. The app listens for incoming messages on the subscribed topic and displays them in a ListView.\n// 4. Users can enter messages in the TextField and send them by pressing the 'Send' button.\n// 5. Sent messages are published to the same topic and also displayed in the ListView.\n// 6. The app handles connection, disconnection, and subscription callbacks for better error handling and user feedback.\n// 7. When the app is closed, it properly disconnects from the MQTT broker in the dispose method.\n\n// This example demonstrates:\n// - Connecting to an MQTT broker\n// - Subscribing to a topic\n// - Publishing messages\n// - Receiving and displaying messages\n// - Basic error handling\n// - Proper resource management (disconnecting when the app is closed)\n```",
    "similarPackages": [],
    "_id": "V06bsD4sX3T8NTHrBPbSE4",
    "_rev": "eaCZ7mIhmiYZX5KGqJmRtO"
  },
  {
    "_id": "V06bsD4sX3T8NTHrBPbUDE",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmRzw",
    "shortDescription": "Currency Text Input Formatter for Flutter. Use it easy and simple for your flutter app.",
    "tags": [
      "input-formatter",
      "currency",
      "text-input",
      "form",
      "validation",
      "formatting"
    ],
    "likesCount": 252,
    "name": "currency_text_input_formatter",
    "description": "# Currency Text Input Formatter: Simplifying Currency Input in Flutter\n\nIn the world of mobile app development, handling currency input can be a tricky task. Formatting currency values correctly while allowing users to input them easily is crucial for a smooth user experience. This is where the `currency_text_input_formatter` package for Flutter comes to the rescue.\n\n## What is Currency Text Input Formatter?\n\n`currency_text_input_formatter` is a powerful Flutter package that provides a simple and efficient way to format currency input in real-time. It automatically adds thousands separators, decimal points, and currency symbols as the user types, ensuring that the input always follows the correct currency format.\n\n## Key Features\n\n1. **Real-time Formatting**: As users type, the input is instantly formatted to match the desired currency format.\n2. **Customizable**: Supports various currency symbols, decimal and thousand separators, and allows for custom formatting.\n3. **Locale Support**: Can adapt to different locales for region-specific currency formatting.\n4. **Negative Values**: Handles negative currency values with proper formatting.\n5. **Easy Integration**: Seamlessly integrates with Flutter's `TextFormField` and other text input widgets.\n\nBy using the `currency_text_input_formatter` package, developers can significantly improve the user experience in apps that deal with financial transactions, budgeting, or any scenario where currency input is required.\n\nIn the following sections, we'll dive into a tutorial on how to use this package and provide a comprehensive example demonstrating its features.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:currency_text_input_formatter/currency_text_input_formatter.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Currency Formatter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: CurrencyFormatterDemo(),\n    );\n  }\n}\n\nclass CurrencyFormatterDemo extends StatefulWidget {\n  @override\n  _CurrencyFormatterDemoState createState() => _CurrencyFormatterDemoState();\n}\n\nclass _CurrencyFormatterDemoState extends State<CurrencyFormatterDemo> {\n  // Step 1: Initialize controllers for each text field\n  final TextEditingController _usdController = TextEditingController();\n  final TextEditingController _eurController = TextEditingController();\n  final TextEditingController _customController = TextEditingController();\n\n  // Step 2: Initialize formatters with different configurations\n  final _usdFormatter = CurrencyTextInputFormatter(\n    locale: 'en_US',\n    symbol: '\\$',\n  );\n  final _eurFormatter = CurrencyTextInputFormatter(\n    locale: 'de_DE',\n    symbol: '',\n    decimalDigits: 2,\n  );\n  final _customFormatter = CurrencyTextInputFormatter(\n    locale: 'en_IN',\n    symbol: '',\n    decimalDigits: 0,\n    customPattern: ' #,##,###',\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Currency Formatter Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 3: Create text fields with different formatters\n            _buildCurrencyTextField(\n              'USD Input',\n              _usdController,\n              _usdFormatter,\n            ),\n            SizedBox(height: 20),\n            _buildCurrencyTextField(\n              'EUR Input',\n              _eurController,\n              _eurFormatter,\n            ),\n            SizedBox(height: 20),\n            _buildCurrencyTextField(\n              'Custom INR Input',\n              _customController,\n              _customFormatter,\n            ),\n            SizedBox(height: 40),\n            // Step 4: Add a button to display formatted values\n            ElevatedButton(\n              child: Text('Show Formatted Values'),\n              onPressed: _showFormattedValues,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 5: Helper method to build consistent text fields\n  Widget _buildCurrencyTextField(\n    String label,\n    TextEditingController controller,\n    CurrencyTextInputFormatter formatter,\n  ) {\n    return TextField(\n      decoration: InputDecoration(\n        labelText: label,\n        border: OutlineInputBorder(),\n      ),\n      controller: controller,\n      keyboardType: TextInputType.number,\n      inputFormatters: [formatter],\n    );\n  }\n\n  // Step 6: Method to display formatted values\n  void _showFormattedValues() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text('Formatted Values'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('USD: ${_usdController.text}'),\n            Text('EUR: ${_eurController.text}'),\n            Text('INR: ${_customController.text}'),\n          ],\n        ),\n        actions: [\n          TextButton(\n            child: Text('OK'),\n            onPressed: () => Navigator.of(context).pop(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays three text fields, each with a different currency formatter.\n// 2. As the user types into each field, the input is automatically formatted according to the specific currency rules.\n// 3. The USD field uses standard US dollar formatting.\n// 4. The EUR field uses Euro formatting with German locale settings.\n// 5. The INR field uses a custom Indian Rupee formatting without decimal places.\n// 6. When the user clicks the \"Show Formatted Values\" button, an alert dialog appears displaying the current formatted values from all three fields.\n// 7. This demo showcases how the CurrencyTextInputFormatter can be used with different configurations to handle various currency input scenarios in a single app.\n```",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:21:21Z",
    "_updatedAt": "2024-09-06T04:12:36Z",
    "similarPackages": [],
    "subCategories": [
      {
        "_key": "k1jr3v9g",
        "_ref": "t8DYBEKn49O4mjbyRAfIMs",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-05-07T18:30:00.000Z",
    "tutorial": "# Tutorial: Implementing Currency Text Input Formatter in Flutter\n\nIn this tutorial, we'll walk through the process of implementing the `currency_text_input_formatter` package in a Flutter application. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nFirst, add the `currency_text_input_formatter` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  currency_text_input_formatter: ^2.1.5\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:currency_text_input_formatter/currency_text_input_formatter.dart';\n```\n\n## Step 3: Basic Usage\n\nTo use the `CurrencyTextInputFormatter`, you need to add it to the `inputFormatters` property of a `TextFormField` or `TextField`:\n\n```dart\nTextFormField(\n  inputFormatters: [\n    CurrencyTextInputFormatter(\n      locale: 'en_US',\n      symbol: '\\$',\n    )\n  ],\n  keyboardType: TextInputType.number,\n)\n```\n\n## Step 4: Customization\n\nYou can customize the formatter with various options:\n\n```dart\nCurrencyTextInputFormatter(\n  locale: 'de_DE',\n  symbol: '',\n  decimalDigits: 2,\n  turnOffGrouping: false,\n  customPattern: '#,##0.00',\n)\n```\n\n## Step 5: Handling Input\n\nTo get the numeric value from the formatted input:\n\n```dart\nfinal formatter = CurrencyTextInputFormatter();\nString formattedValue = formatter.format('1234.56');\ndouble numericValue = formatter.getUnformattedValue();\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure that you've set up your iOS project correctly in Xcode.\n- If you're using custom fonts, make sure they're properly included in your `Info.plist` file.\n\n### Android\n- Check that your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher.\n- If you encounter any issues with number formatting, ensure that your device's locale settings are correct.\n\n### Web\n- The package works seamlessly on the web platform without any additional configuration.\n- Ensure that you're using a recent version of Flutter that supports web development.\n\nBy following these steps, you'll have successfully implemented the `currency_text_input_formatter` in your Flutter application, providing a smooth currency input experience for your users across all platforms.",
    "tutorialIncluded": true,
    "author": "",
    "_type": "package",
    "dependentPackages": [],
    "slug": {
      "current": "currency_text_input_formatter",
      "_type": "slug"
    }
  },
  {
    "name": "shared_preferences",
    "_id": "uQRNMiDfrp20RZ8Id8CTzf",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "lastUpdate": "2024-08-14T18:30:00.000Z",
    "likesCount": 9449,
    "_updatedAt": "2024-09-06T04:12:37Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmS6U",
    "shortDescription": "Flutter plugin for reading and writing simple key-value pairs. Wraps NSUserDefaults on iOS and SharedPreferences on Android.",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "w5l1qqde",
        "_ref": "Rx1Nho763d29lawKra1L7f"
      }
    ],
    "slug": {
      "current": "shared_preferences",
      "_type": "slug"
    },
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "persistence",
      "shared-preferences",
      "storage",
      "key-value",
      "local-storage",
      "data-persistence"
    ],
    "_type": "package",
    "description": "# Using the Latest `shared_preferences` Package in Flutter\n\nThe `shared_preferences` package is a popular solution for storing simple key-value pairs in Flutter applications. It allows you to save and retrieve data efficiently and is commonly used for storing user preferences, settings, and application state.\n\n## Key Features\n\n- **Data Types Supported**: You can store `String`, `int`, `double`, `bool`, and `List<String>`.\n- **Platform Compatibility**: Works across Android, iOS, web, Linux, macOS, and Windows.\n\n## New APIs in Version 2.3.0\n\nStarting with version 2.3.0, the `shared_preferences` package introduced three APIs:\n\n- **SharedPreferences**: The legacy API, which will be deprecated in the future.\n- **SharedPreferencesAsync**: This API does not use a local cache and ensures that all calls are asynchronous, providing the latest data.\n- **SharedPreferencesWithCache**: This API uses a local cache for synchronous calls after the initial setup.\n\nIt is recommended to use either `SharedPreferencesAsync` or `SharedPreferencesWithCache` for new projects to avoid issues with data consistency across isolates and engine instances.\n\n_Do not store user sensitive data using this_",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "6xnhjte5",
        "_ref": "V06bsD4sX3T8NTHrBPaMLA"
      }
    ],
    "subCategories": [
      {
        "_key": "8fm9jk1z",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGEj",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Shared Preferences Example',\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  String _username = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _loadUsername();\n  }\n\n  Future<void> _loadUsername() async {\n    final prefs = await SharedPreferences.getInstance();\n    setState(() {\n      _username = prefs.getString('username') ?? '';\n    });\n  }\n\n  Future<void> _saveUsername(String username) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString('username', username);\n    _loadUsername();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Shared Preferences Example'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Username: $_username'),\n            TextField(\n              onSubmitted: _saveUsername,\n              decoration: InputDecoration(labelText: 'Enter Username'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```",
    "_createdAt": "2024-08-28T22:15:21Z",
    "loafer": "raju loafer",
    "author": "flutter.dev",
    "tutorial": "# Tutorial: Using `shared_preferences` in Flutter\n\n## Getting Started\n\n1. **Add the Dependency**\n\n   To use the `shared_preferences` package, add it to your `pubspec.yaml` file:\n\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     shared_preferences: ^2.3.2\n   ```\n\n   After updating your `pubspec.yaml`, run the following command to install the package:\n\n   ```bash\n   flutter pub get\n   ```\n\t \n\t or simply type:\n   ```dart\n   flutter pub add shared_preferences\n   ```\n\n2. **Import the Package**\n\n   In your Dart file, import the package:\n\n   ```dart\n   import 'package:shared_preferences/shared_preferences.dart';\n   ```\n\n## Saving Data\n\nTo save data using `shared_preferences`, follow these steps:\n\n1. **Get an Instance of SharedPreferences**:\n\n   ```dart\n   final prefs = await SharedPreferences.getInstance();\n   ```\n\n2. **Save Data**:\n\n   You can save various data types using the appropriate setter methods:\n\n   ```dart\n   await prefs.setString('username', 'JohnDoe');\n   await prefs.setInt('age', 30);\n   await prefs.setDouble('height', 5.9);\n   await prefs.setBool('isLoggedIn', true);\n   await prefs.setStringList('hobbies', ['Reading', 'Traveling']);\n   ```\n\n## Reading Data\n\nTo read data from SharedPreferences, use the corresponding getter methods:\n\n```dart\nString? username = prefs.getString('username');\nint? age = prefs.getInt('age');\ndouble? height = prefs.getDouble('height');\nbool? isLoggedIn = prefs.getBool('isLoggedIn');\nList<String>? hobbies = prefs.getStringList('hobbies');\n```\n\nIf the key does not exist, these methods will return `null`. You can provide a default value if needed:\n\n```dart\nString username = prefs.getString('username') ?? 'Guest';\n```\n\n## Removing Data\n\nTo remove a specific key-value pair:\n\n```dart\nawait prefs.remove('username');\n```\n\nTo clear all data:\n\n```dart\nawait prefs.clear();\n```"
  },
  {
    "shortDescription": "Flutter plugin for selecting images from the Android and iOS image library, and taking new pictures with the camera.",
    "similarPackages": [],
    "example": "```\n// You need to install video_player as well along with image_picker to play this whole main file\n// flutter pub add video_player image_picker\nimport 'dart:async';\nimport 'dart:io';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:mime/mime.dart';\nimport 'package:video_player/video_player.dart';\n\nvoid main() {\n  runApp(const MediaPickerApp());\n}\n\nclass MediaPickerApp extends StatelessWidget {\n  const MediaPickerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      title: 'Media Picker Demo',\n      home: MediaPickerHomePage(title: 'Media Picker Example'),\n    );\n  }\n}\n\nclass MediaPickerHomePage extends StatefulWidget {\n  const MediaPickerHomePage({super.key, this.title});\n\n  final String? title;\n\n  @override\n  State<MediaPickerHomePage> createState() => _MediaPickerHomePageState();\n}\n\nclass _MediaPickerHomePageState extends State<MediaPickerHomePage> {\n  // Step 1: Initialize variables\n  List<XFile>? _selectedMediaFiles;\n  dynamic _pickError;\n  bool _isVideo = false;\n  VideoPlayerController? _videoController;\n  VideoPlayerController? _toBeDisposedController;\n  String? _retrieveError;\n\n  final ImagePicker _imagePicker = ImagePicker();\n  final TextEditingController _maxWidthController = TextEditingController();\n  final TextEditingController _maxHeightController = TextEditingController();\n  final TextEditingController _qualityController = TextEditingController();\n  final TextEditingController _limitController = TextEditingController();\n\n  // Step 2: Dispose video controller when not needed\n  @override\n  void deactivate() {\n    _videoController?.setVolume(0.0);\n    _videoController?.pause();\n    super.deactivate();\n  }\n\n  @override\n  void dispose() {\n    _disposeVideoController();\n    _maxWidthController.dispose();\n    _maxHeightController.dispose();\n    _qualityController.dispose();\n    _limitController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _disposeVideoController() async {\n    if (_toBeDisposedController != null) {\n      await _toBeDisposedController!.dispose();\n    }\n    _toBeDisposedController = _videoController;\n    _videoController = null;\n  }\n\n  // Step 3: Handle video playback\n  Future<void> _playVideo(XFile? file) async {\n    if (file != null && mounted) {\n      await _disposeVideoController();\n      late VideoPlayerController controller;\n\n      if (kIsWeb) {\n        controller = VideoPlayerController.networkUrl(Uri.parse(file.path));\n      } else {\n        controller = VideoPlayerController.file(File(file.path));\n      }\n\n      _videoController = controller;\n\n      const double volume = kIsWeb ? 0.0 : 1.0;\n      await controller.setVolume(volume);\n      await controller.initialize();\n      await controller.setLooping(true);\n      await controller.play();\n      setState(() {});\n    }\n  }\n\n  // Step 4: Handle image and video picking\n  Future<void> _pickMedia(ImageSource source,\n      {required BuildContext context,\n        bool isMultiImage = false,\n        bool isMedia = false}) async {\n    if (_videoController != null) {\n      await _videoController!.setVolume(0.0);\n    }\n\n    if (context.mounted) {\n      if (_isVideo) {\n        final XFile? videoFile =\n        await _imagePicker.pickVideo(source: source, maxDuration: const Duration(seconds: 10));\n        await _playVideo(videoFile);\n      } else if (isMultiImage) {\n        await _showMediaOptionsDialog(context, true, (double? maxWidth, double? maxHeight,\n            int? quality, int? limit) async {\n          try {\n            final List<XFile> pickedFiles = isMedia\n                ? await _imagePicker.pickMultipleMedia(\n              maxWidth: maxWidth,\n              maxHeight: maxHeight,\n              imageQuality: quality,\n              limit: limit,\n            )\n                : await _imagePicker.pickMultiImage(\n              maxWidth: maxWidth,\n              maxHeight: maxHeight,\n              imageQuality: quality,\n              limit: limit,\n            );\n            setState(() {\n              _selectedMediaFiles = pickedFiles;\n            });\n          } catch (e) {\n            setState(() {\n              _pickError = e;\n            });\n          }\n        });\n      } else if (isMedia) {\n        await _showMediaOptionsDialog(context, false, (double? maxWidth, double? maxHeight,\n            int? quality, int? limit) async {\n          try {\n            final List<XFile> pickedFiles = <XFile>[];\n            final XFile? media = await _imagePicker.pickMedia(\n              maxWidth: maxWidth,\n              maxHeight: maxHeight,\n              imageQuality: quality,\n            );\n            if (media != null) {\n              pickedFiles.add(media);\n              setState(() {\n                _selectedMediaFiles = pickedFiles;\n              });\n            }\n          } catch (e) {\n            setState(() {\n              _pickError = e;\n            });\n          }\n        });\n      } else {\n        await _showMediaOptionsDialog(context, false, (double? maxWidth, double? maxHeight,\n            int? quality, int? limit) async {\n          try {\n            final XFile? pickedImage = await _imagePicker.pickImage(\n              source: source,\n              maxWidth: maxWidth,\n              maxHeight: maxHeight,\n              imageQuality: quality,\n            );\n            setState(() {\n              _selectedMediaFiles = pickedImage == null ? null : [pickedImage];\n            });\n          } catch (e) {\n            setState(() {\n              _pickError = e;\n            });\n          }\n        });\n      }\n    }\n  }\n\n  // Step 5: Retrieve lost data (important for Android)\n  Future<void> _retrieveLostData() async {\n    final LostDataResponse response = await _imagePicker.retrieveLostData();\n    if (response.isEmpty) {\n      return;\n    }\n    if (response.file != null) {\n      if (response.type == RetrieveType.video) {\n        _isVideo = true;\n        await _playVideo(response.file);\n      } else {\n        _isVideo = false;\n        setState(() {\n          _selectedMediaFiles = response.files ?? [response.file!];\n        });\n      }\n    } else {\n      _retrieveError = response.exception!.code;\n    }\n  }\n\n  // Step 6: Build the UI for the app\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title!),\n      ),\n      body: Center(\n        child: !kIsWeb && defaultTargetPlatform == TargetPlatform.android\n            ? FutureBuilder<void>(\n          future: _retrieveLostData(),\n          builder: (BuildContext context, AsyncSnapshot<void> snapshot) {\n            switch (snapshot.connectionState) {\n              case ConnectionState.none:\n              case ConnectionState.waiting:\n                return const Text(\n                  'You have not yet picked an image.',\n                  textAlign: TextAlign.center,\n                );\n              case ConnectionState.done:\n                return _previewMedia();\n              case ConnectionState.active:\n                if (snapshot.hasError) {\n                  return Text(\n                    'Pick image/video error: ${snapshot.error}}',\n                    textAlign: TextAlign.center,\n                  );\n                } else {\n                  return const Text(\n                    'You have not yet picked an image.',\n                    textAlign: TextAlign.center,\n                  );\n                }\n            }\n          },\n        )\n            : _previewMedia(),\n      ),\n      floatingActionButton: _buildFloatingActionButtons(context),\n    );\n  }\n\n  // Step 7: Build floating action buttons for media selection\n  Widget _buildFloatingActionButtons(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.end,\n      children: <Widget>[\n        FloatingActionButton(\n          onPressed: () {\n            _isVideo = false;\n            _pickMedia(ImageSource.gallery, context: context);\n          },\n          heroTag: 'pickImage',\n          tooltip: 'Pick Image from gallery',\n          child: const Icon(Icons.photo),\n        ),\n        FloatingActionButton(\n          onPressed: () {\n            _isVideo = false;\n            _pickMedia(\n              ImageSource.gallery,\n              context: context,\n              isMultiImage: true,\n              isMedia: true,\n            );\n          },\n          heroTag: 'pickMultipleMedia',\n          tooltip: 'Pick Multiple Media from gallery',\n          child: const Icon(Icons.photo_library),\n        ),\n        FloatingActionButton(\n          onPressed: () {\n            _isVideo = false;\n            _pickMedia(\n              ImageSource.gallery,\n              context: context,\n              isMedia: true,\n            );\n          },\n          heroTag: 'pickSingleMedia',\n          tooltip: 'Pick Single Media from gallery',\n          child: const Icon(Icons.photo_library),\n        ),\n        FloatingActionButton(\n          onPressed: () {\n            _isVideo = false;\n            _pickMedia(\n              ImageSource.gallery,\n              context: context,\n              isMultiImage: true,\n            );\n          },\n          heroTag: 'pickMultipleImages',\n          tooltip: 'Pick Multiple Images from gallery',\n          child: const Icon(Icons.photo_library),\n        ),\n        if (_imagePicker.supportsImageSource(ImageSource.camera))\n          FloatingActionButton(\n            onPressed: () {\n              _isVideo = false;\n              _pickMedia(ImageSource.camera, context: context);\n            },\n            heroTag: 'capturePhoto',\n            tooltip: 'Take a Photo',\n            child: const Icon(Icons.camera_alt),\n          ),\n        FloatingActionButton(\n          backgroundColor: Colors.red,\n          onPressed: () {\n            _isVideo = true;\n            _pickMedia(ImageSource.gallery, context: context);\n          },\n          heroTag: 'pickVideo',\n          tooltip: 'Pick Video from gallery',\n          child: const Icon(Icons.video_library),\n        ),\n        if (_imagePicker.supportsImageSource(ImageSource.camera))\n          FloatingActionButton(\n            backgroundColor: Colors.red,\n            onPressed: () {\n              _isVideo = true;\n              _pickMedia(ImageSource.camera, context: context);\n            },\n            heroTag: 'captureVideo',\n            tooltip: 'Take a Video',\n            child: const Icon(Icons.videocam),\n          ),\n      ],\n    );\n  }\n\n  // Step 8: Display preview of selected media\n  Widget _previewMedia() {\n    if (_isVideo) {\n      return _previewVideo();\n    } else {\n      return _previewImages();\n    }\n  }\n\n  Widget _previewVideo() {\n    final Text? errorWidget = _getRetrieveErrorWidget();\n    if (errorWidget != null) {\n      return errorWidget;\n    }\n    if (_videoController == null) {\n      return const Text(\n        'You have not yet picked a video',\n        textAlign: TextAlign.center,\n      );\n    }\n    return Padding(\n      padding: const EdgeInsets.all(10.0),\n      child: AspectRatioVideo(_videoController),\n    );\n  }\n\n  Widget _previewImages() {\n    final Text? errorWidget = _getRetrieveErrorWidget();\n    if (errorWidget != null) {\n      return errorWidget;\n    }\n    if (_selectedMediaFiles != null) {\n      return Semantics(\n        label: 'media_picker_example_picked_images',\n        child: ListView.builder(\n          key: UniqueKey(),\n          itemBuilder: (BuildContext context, int index) {\n            final String? mime = lookupMimeType(_selectedMediaFiles![index].path);\n            return Semantics(\n              label: 'media_picker_example_picked_image',\n              child: kIsWeb\n                  ? Image.network(_selectedMediaFiles![index].path)\n                  : (mime == null || mime.startsWith('image/')\n                  ? Image.file(\n                File(_selectedMediaFiles![index].path),\n                errorBuilder: (BuildContext context, Object error,\n                    StackTrace? stackTrace) {\n                  return const Center(\n                      child: Text('This image type is not supported'));\n                },\n              )\n                  : _buildInlineVideoPlayer(index)),\n            );\n          },\n          itemCount: _selectedMediaFiles!.length,\n        ),\n      );\n    } else if (_pickError != null) {\n      return Text(\n        'Pick image error: $_pickError',\n        textAlign: TextAlign.center,\n      );\n    } else {\n      return const Text(\n        'You have not yet picked an image.',\n        textAlign: TextAlign.center,\n      );\n    }\n  }\n\n  Widget _buildInlineVideoPlayer(int index) {\n    final VideoPlayerController controller =\n    VideoPlayerController.file(File(_selectedMediaFiles![index].path));\n    const double volume = kIsWeb ? 0.0 : 1.0;\n    controller.setVolume(volume);\n    controller.initialize();\n    controller.setLooping(true);\n    controller.play();\n    return Center(child: AspectRatioVideo(controller));\n  }\n\n  Text? _getRetrieveErrorWidget() {\n    if (_retrieveError != null) {\n      final Text result = Text(_retrieveError!);\n      _retrieveError = null;\n      return result;\n    }\n    return null;\n  }\n\n  // Step 9: Display dialog for picking media with optional parameters\n  Future<void> _showMediaOptionsDialog(BuildContext context, bool isMulti,\n      OnPickImageCallback onPick) async {\n    return showDialog(\n        context: context,\n        builder: (BuildContext context) {\n          return AlertDialog(\n            title: const Text('Add optional parameters'),\n            content: Column(\n              mainAxisSize: MainAxisSize.min,\n              children: <Widget>[\n                TextField(\n                  controller: _maxWidthController,\n                  keyboardType:\n                  const TextInputType.numberWithOptions(decimal: true),\n                  decoration: const InputDecoration(\n                      hintText: 'Enter maxWidth if desired'),\n                ),\n                TextField(\n                  controller: _maxHeightController,\n                  keyboardType:\n                  const TextInputType.numberWithOptions(decimal: true),\n                  decoration: const InputDecoration(\n                      hintText: 'Enter maxHeight if desired'),\n                ),\n                TextField(\n                  controller: _qualityController,\n                  keyboardType: TextInputType.number,\n                  decoration: const InputDecoration(\n                      hintText: 'Enter quality if desired'),\n                ),\n                if (isMulti)\n                  TextField(\n                    controller: _limitController,\n                    keyboardType: TextInputType.number,\n                    decoration: const InputDecoration(\n                        hintText: 'Enter limit if desired'),\n                  ),\n              ],\n            ),\n            actions: <Widget>[\n              TextButton(\n                child: const Text('CANCEL'),\n                onPressed: () {\n                  Navigator.of(context).pop();\n                },\n              ),\n              TextButton(\n                  child: const Text('PICK'),\n                  onPressed: () {\n                    final double? width = _maxWidthController.text.isNotEmpty\n                        ? double.parse(_maxWidthController.text)\n                        : null;\n                    final double? height = _maxHeightController.text.isNotEmpty\n                        ? double.parse(_maxHeightController.text)\n                        : null;\n                    final int? quality = _qualityController.text.isNotEmpty\n                        ? int.parse(_qualityController.text)\n                        : null;\n                    final int? limit = _limitController.text.isNotEmpty\n                        ? int.parse(_limitController.text)\n                        : null;\n                    onPick(width, height, quality, limit);\n                    Navigator.of(context).pop();\n                  }),\n            ],\n          );\n        });\n  }\n}\n\ntypedef OnPickImageCallback = void Function(\n    double? maxWidth, double? maxHeight, int? quality, int? limit);\n\nclass AspectRatioVideo extends StatefulWidget {\n  const AspectRatioVideo(this.controller, {super.key});\n\n  final VideoPlayerController? controller;\n\n  @override\n  AspectRatioVideoState createState() => AspectRatioVideoState();\n}\n\nclass AspectRatioVideoState extends State<AspectRatioVideo> {\n  VideoPlayerController? get controller => widget.controller;\n  bool initialized = false;\n\n  void _onVideoControllerUpdate() {\n    if (!mounted) {\n      return;\n    }\n    if (initialized != controller!.value.isInitialized) {\n      initialized = controller!.value.isInitialized;\n      setState(() {});\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    controller!.addListener(_onVideoControllerUpdate);\n  }\n\n  @override\n  void dispose() {\n    controller!.removeListener(_onVideoControllerUpdate);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (initialized) {\n      return Center(\n        child: AspectRatio(\n          aspectRatio: controller!.value.aspectRatio,\n          child: VideoPlayer(controller!),\n        ),\n      );\n    } else {\n      return Container();\n    }\n  }\n}\n\n// Flow of the Application:\n// Initialization:\n//\n// The application starts by initializing the MediaPickerApp, which contains the MediaPickerHomePage widget.\n// Inside MediaPickerHomePage, the necessary controllers and variables are initialized for handling media picking and video playback.\n// Picking Media:\n//\n// Users can select an image or video from the gallery or capture one using the camera by clicking on the floating action buttons.\n// The _pickMedia method is triggered, which checks if a video or image needs to be picked and whether it's a single or multiple selection.\n// If a video is selected, it is played using a VideoPlayerController. For images, they are displayed in a list view.\n// Video Playback:\n//\n// If a video is selected, _playVideo is called to initialize and play the video using the VideoPlayerController.\n// If an image is selected, it is added to the _selectedMediaFiles list and displayed on the screen.\n// Displaying Media:\n//\n// The _previewMedia method checks if the selected file is a video or image and displays it accordingly.\n// For videos, an AspectRatioVideo widget is used to display the video with the correct aspect ratio.\n// Handling Errors and Lost Data:\n//\n// The application handles potential errors and lost data (important for Android) using _retrieveLostData.\n// Any errors during picking are displayed to the user.\n// Custom Dialog for Picking Options:\n//\n// Users can input custom parameters (like width, height, quality) for media selection through a dialog box triggered by _showMediaOptionsDialog.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-05-30T18:30:00.000Z",
    "tutorial": "# Image Picker Tutorial: Implementation Guide\n\nIn this tutorial, we'll walk through the process of integrating the `image_picker` package into your Flutter application. We'll cover setup, platform-specific configurations, and basic usage.\n\n## Step 1: Add Dependencies\n\nAdd the `image_picker` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  image_picker: ^1.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Platform-specific Configuration\n\n### iOS Configuration\n\n1. Open your project's `ios/Runner/Info.plist` file.\n2. Add the following keys:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for image selection.</string>\n<key>NSCameraUsageDescription</key>\n<string>This app requires access to the camera for taking photos.</string>\n<key>NSMicrophoneUsageDescription</key>\n<string>This app requires microphone access for video recording.</string>\n```\n\n### Android Configuration\n\nFor Android, no additional configuration is required for basic functionality. However, to handle MainActivity destruction:\n\n1. Implement `retrieveLostData()` method in your Flutter app.\n2. Call this method when your app starts or resumes.\n\n## Step 3: Basic Implementation\n\nHere's a basic example of how to use `image_picker` in your Flutter app:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final ImagePicker _picker = ImagePicker();\n  XFile? _image;\n\n  Future<void> _pickImage() async {\n    final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery);\n    setState(() {\n      if (pickedFile != null) {\n        _image = pickedFile;\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Image Picker Example')),\n      body: Center(\n        child: _image == null\n            ? Text('No image selected.')\n            : Image.file(File(_image!.path)),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _pickImage,\n        tooltip: 'Pick Image',\n        child: Icon(Icons.add_a_photo),\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Handling Lost Data (Android)\n\nTo handle lost data due to MainActivity destruction on Android:\n\n```dart\nFuture<void> _retrieveLostData() async {\n  final LostDataResponse response = await _picker.retrieveLostData();\n  if (response.isEmpty) {\n    return;\n  }\n  if (response.file != null) {\n    setState(() {\n      _image = response.file;\n    });\n  } else {\n    print(response.exception!.code);\n  }\n}\n```\n\nCall this method in your `initState()` or when your app resumes.\n\n## Conclusion\n\nThis tutorial covers the basics of implementing `image_picker` in your Flutter application. Remember to handle permissions properly and test thoroughly on both Android and iOS devices. In the next section, we'll explore a more comprehensive example that demonstrates all the features of the `image_picker` package.",
    "pubPoint": 160,
    "_type": "package",
    "_updatedAt": "2024-09-06T04:12:38Z",
    "likesCount": 6913,
    "_createdAt": "2024-08-28T22:15:22Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaSAj",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGKG",
        "_type": "reference",
        "_key": "csom0cji"
      }
    ],
    "slug": {
      "current": "image_picker",
      "_type": "slug"
    },
    "tags": [
      "camera",
      "image-picker",
      "files",
      "file-selection",
      "gallery",
      "photo",
      "media"
    ],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPa7E4",
        "_type": "reference",
        "_key": "qvxcf8tl"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ffX",
        "_type": "reference",
        "_key": "qxqg66t3"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-dce0c420e2da8446845d9a7a2224809e9629171c-110x252-png",
        "_type": "reference"
      }
    },
    "name": "image_picker",
    "_id": "uQRNMiDfrp20RZ8Id8CU5B",
    "tutorialIncluded": true,
    "author": "flutter.dev",
    "description": "# Image Picker in Flutter: A Comprehensive Overview\n\nFlutter's `image_picker` package is a powerful tool for iOS and Android developers looking to integrate image and video selection capabilities into their applications. This versatile plugin allows users to pick images from the device's gallery or capture new photos and videos using the camera.\n\n## Key Features\n\n1. **Multi-platform Support**: Compatible with Android (SDK 21+), iOS (12+), Linux, macOS (10.14+), Web, and Windows (10+).\n2. **Multiple Source Options**: Pick media from both gallery and camera.\n3. **Diverse Media Types**: Support for images and videos.\n4. **Single and Multiple Selection**: Pick one or multiple files at once.\n5. **Full Metadata Access**: Retrieve comprehensive metadata for picked media.\n\n## Why Use Image Picker?\n\nThe `image_picker` package simplifies the process of integrating media selection into your Flutter apps. Instead of dealing with platform-specific code, you can use a unified API across different operating systems. This not only speeds up development but also ensures consistency in user experience across platforms.\n\n## Latest Developments\n\nAs of the latest version, the package has introduced several improvements:\n\n- Use of PHPicker on iOS 14+ for enhanced performance and privacy.\n- Support for Android's new Photo Picker on Android 13 and above.\n- It is no longer required to add android:requestLegacyExternalStorage=\"true\" as an attribute to the <application> tag in AndroidManifest.xml, as image_picker has been updated to make use of scoped storage.\n- Desktop platform support (Windows, macOS, and Linux) through integration with the `file_selector` plugin.\n\n### Points to remember\n\t\n- As a result of implementing PHPicker it becomes impossible to pick HEIC images on the iOS simulator in iOS 14+ (Use real devices for testing on iOS or test with non-HEIC images)\n- Under high memory pressure it can kill the app\n- When the Android system is under high memory pressure, it may kill the `MainActivity` of an application using the `image_picker` plugin. On Android, `image_picker` utilizes the default `Intent.ACTION_GET_CONTENT` or `MediaStore.ACTION_IMAGE_CAPTURE` intents. This causes the source application to move to the background while the intent is being processed, making it susceptible to being cleared if the system needs to free up memory. Once the intent completes, Android restarts the application, but the original data is not returned to the initial call. To recover this lost data, use the `ImagePicker.retrieveLostData()` method.\n\n## Conclusion\n\nWhether you're building a social media app, a photo editing tool, or any application that requires media input from users, the `image_picker` package is an excellent choice. Its robust feature set and cross-platform compatibility make it a go-to solution for Flutter developers worldwide.\n\nIn the next sections, we'll dive into a tutorial on how to implement `image_picker` in your Flutter project and explore a comprehensive example showcasing its features.",
    "gallery": [
      {
        "_type": "image",
        "_key": "3981667df216",
        "asset": {
          "_ref": "image-a5a1ba4b64088f841740cfa65e877991830a0de7-444x386-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "89b8b75120d5",
        "asset": {
          "_ref": "image-82703452295822a9b0024b6bc22c920f43783d4a-454x474-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "a5b74cc00de8",
        "asset": {
          "_type": "reference",
          "_ref": "image-ff94887543a7ba3ff88d640380d7ad85bc411b5c-452x398-png"
        }
      }
    ]
  },
  {
    "pubPoint": 160,
    "author": "dash-overflow.net",
    "likesCount": 10153,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "klmjf3la"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1VXT",
        "_type": "reference",
        "_key": "ukpnxuig"
      }
    ],
    "name": "provider",
    "gallery": [
      {
        "_key": "f16cb62ee83a",
        "asset": {
          "_type": "reference",
          "_ref": "image-f1b3459e48a76d230947538ea77256d71f36eed2-476x974-png"
        },
        "_type": "image"
      },
      {
        "_type": "image",
        "_key": "ce89e913a944",
        "asset": {
          "_ref": "image-9290335edc5e59ae807337e4311482feaced9cf9-206x66-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "2d5a3dab5910",
        "asset": {
          "_type": "reference",
          "_ref": "image-afdff7a70ba9a7117f417da2c239761a22f02d7d-498x974-png"
        }
      }
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmSD2",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1pcx",
        "_type": "reference",
        "_key": "lphkn76c"
      }
    ],
    "subCategories": [
      {
        "_key": "uokoxn8u",
        "_ref": "t8DYBEKn49O4mjbyRAfBIU",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// Step 1: Define the Task model\nclass Task {\n  String name;\n  bool isCompleted;\n\n  Task({required this.name, this.isCompleted = false});\n\n  // Toggle the completion status of the task\n  void toggleCompleted() {\n    isCompleted = !isCompleted;\n  }\n}\n\n// Step 2: Define the TaskListProvider model to manage the list of tasks\nclass TaskListProvider with ChangeNotifier {\n  List<Task> _tasks = [];\n\n  List<Task> get tasks => _tasks;\n\n  // Add a new task\n  void addTask(String taskName) {\n    _tasks.add(Task(name: taskName));\n    notifyListeners(); // Notify listeners about the change\n  }\n\n  // Remove a task\n  void removeTask(Task task) {\n    _tasks.remove(task);\n    notifyListeners(); // Notify listeners about the change\n  }\n\n  // Toggle the completion status of a task\n  void toggleTaskCompletion(Task task) {\n    task.toggleCompleted();\n    notifyListeners(); // Notify listeners about the change\n  }\n}\n\n// Step 3: Main function to set up the application with providers\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (context) => TaskListProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\n// Step 4: Define the MyApp widget as the root of the application\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Provider Task List Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: TaskListScreen(),\n    );\n  }\n}\n\n// Step 5: Define the TaskListScreen widget to display the list of tasks\nclass TaskListScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Task List'),\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: Consumer<TaskListProvider>(\n              builder: (context, taskListProvider, child) {\n                return ListView.builder(\n                  itemCount: taskListProvider.tasks.length,\n                  itemBuilder: (context, index) {\n                    final task = taskListProvider.tasks[index];\n                    return TaskTile(task: task);\n                  },\n                );\n              },\n            ),\n          ),\n          TaskInputField(), // Input field to add new tasks\n        ],\n      ),\n    );\n  }\n}\n\n// Step 6: Define the TaskTile widget to display each task\nclass TaskTile extends StatelessWidget {\n  final Task task;\n\n  TaskTile({required this.task});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      title: Text(\n        task.name,\n        style: TextStyle(\n          decoration: task.isCompleted ? TextDecoration.lineThrough : null,\n        ),\n      ),\n      leading: Checkbox(\n        value: task.isCompleted,\n        onChanged: (value) {\n          context.read<TaskListProvider>().toggleTaskCompletion(task);\n        },\n      ),\n      trailing: IconButton(\n        icon: Icon(Icons.delete),\n        onPressed: () {\n          context.read<TaskListProvider>().removeTask(task);\n        },\n      ),\n    );\n  }\n}\n\n// Step 7: Define the TaskInputField widget to add new tasks\nclass TaskInputField extends StatefulWidget {\n  @override\n  _TaskInputFieldState createState() => _TaskInputFieldState();\n}\n\nclass _TaskInputFieldState extends State<TaskInputField> {\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Row(\n        children: [\n          Expanded(\n            child: TextField(\n              controller: _controller,\n              decoration: InputDecoration(\n                labelText: 'Add a task',\n                border: OutlineInputBorder(),\n              ),\n            ),\n          ),\n          IconButton(\n            icon: Icon(Icons.add),\n            onPressed: () {\n              if (_controller.text.isNotEmpty) {\n                context.read<TaskListProvider>().addTask(_controller.text);\n                _controller.clear();\n              }\n            },\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}\n\n// Explanation and Application Flow:\n// Task Model:\n//\n// Task represents a single task with a name and a completion status.\n// The toggleCompleted() method changes the completion status of a task.\n// TaskListProvider Model:\n//\n// Manages a list of tasks using the _tasks list.\n// Provides methods to add, remove, and toggle the completion status of tasks.\n// Notifies listeners whenever the list of tasks changes.\n// Main Function:\n//\n// Initializes the app with MultiProvider to provide TaskListProvider to the entire widget tree.\n// MyApp serves as the root widget and sets up the TaskListScreen as the home screen.\n// TaskListScreen Widget:\n//\n// Displays the list of tasks using a ListView.builder.\n// Uses a Consumer<TaskListProvider> to listen for changes in the task list and rebuild the list view when tasks are added, removed, or updated.\n// TaskTile Widget:\n//\n// Displays individual tasks with a checkbox to toggle their completion status and a delete button to remove them.\n// Uses context.read<TaskListProvider>() to interact with the task list without rebuilding the widget when the state changes.\n// TaskInputField Widget:\n//\n// Provides a text input field for adding new tasks.\n// When the user submits a task, it's added to the task list, and the text field is cleared.\n// Key Concepts:\n// Provider Pattern: Used to manage the state of the task list across the app.\n// ChangeNotifier: The TaskListProvider extends ChangeNotifier to notify listeners when the task list changes.\n// Consumer: Used in TaskListScreen to rebuild the list of tasks when the task list updates.\n// TextField with Controller: Allows users to input new tasks and handle text input.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CUlT",
    "tutorial": "# Provider Package Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the Provider package in a Flutter application. We'll create a simple counter app to demonstrate the basic concepts.\n\n## Step 1: Add Dependencies\n\nFirst, add the provider package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  provider: ^6.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Create a Model\n\nCreate a file named `counter_model.dart`:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n## Step 3: Provide the Model\n\nIn your `main.dart` file, wrap your app with a `ChangeNotifierProvider`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'counter_model.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: RealFlutter(),\n    ),\n  );\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: CounterPage(),\n    );\n  }\n}\n```\n\n## Step 4: Consume the Model\n\nCreate a `CounterPage` widget that consumes the model:\n\n```dart\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Provider Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('You have pushed the button this many times:'),\n            Consumer<CounterModel>(\n              builder: (context, counter, child) => Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headline4,\n              ),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Provider.of<CounterModel>(context, listen: false).increment(),\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### iOS\n\nFor iOS, update your `ios/Podfile` to target iOS 9.0 or higher:\n\n```ruby\nplatform :ios, '9.0'\n```\n\n### Web\n\nFor web support, no additional configuration is needed. However, ensure you have enabled web support in your Flutter project:\n\n```\nflutter config --enable-web\n```\n\nThis tutorial provides a basic implementation of the Provider package. In the next section, we'll see a more comprehensive example that demonstrates additional features of Provider.",
    "description": "# Understanding the Provider Package in Flutter\n\n## What is Provider?\n\nProvider is a state management solution for Flutter applications. It's a wrapper around InheritedWidget, making it easier to use and more reusable. The provider package is recommended by the Flutter team and is widely used in the Flutter community.\n\n## Key Features of Provider\n\n1. **Simplicity**: Provider simplifies the process of passing data down the widget tree without manually passing it through constructors.\n\n2. **Performance**: It's optimized for performance, ensuring that only the widgets that depend on the changed state are rebuilt.\n\n3. **Testability**: Provider makes it easier to test your application by allowing you to mock and provide different implementations of your data models.\n\n4. **Flexibility**: It supports various use cases, from simple state management to complex application architectures.\n\n5. **Integration**: Provider works well with other Flutter packages and can be easily integrated into existing projects.\n\n## When to Use Provider\n\nProvider is particularly useful in the following scenarios:\n\n- When you need to share data between widgets that are far apart in the widget tree.\n- For managing application-wide state or theme.\n- When implementing dependency injection in your Flutter app.\n- For separating business logic from UI components.\n\nIn the next sections, we'll dive into a tutorial on how to use Provider and see a practical example of its implementation in a Flutter application.",
    "shortDescription": "A wrapper around InheritedWidget to make them easier to use and more reusable.",
    "tags": [
      "state-management",
      "dependency-injection",
      "widget-communication",
      "reactive"
    ],
    "lastUpdate": "2024-02-27T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:39Z",
    "slug": {
      "current": "provider",
      "_type": "slug"
    },
    "packageImage": {
      "asset": {
        "_ref": "image-553cf41ee737d68d58e3c9ba5dc9bab8c8ae6af1-534x964-png",
        "_type": "reference"
      },
      "_type": "image"
    },
    "_createdAt": "2024-08-28T22:15:24Z",
    "tutorialIncluded": true
  },
  {
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-484b568a3c7999997d64d0b678ab8c9b8aded519-270x480-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:15:41Z",
    "lastUpdate": "2024-07-06T18:30:00.000Z",
    "name": "flutter_native_splash",
    "_id": "uQRNMiDfrp20RZ8Id8CUqz",
    "_updatedAt": "2024-09-06T04:12:40Z",
    "dependentPackages": [],
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_native_splash/flutter_native_splash.dart';\n\n// Step 1: Define our main function\nvoid main() {\n  // Step 2: Ensure Flutter is initialized and preserve the splash screen\n  WidgetsBinding widgetsBinding = WidgetsFlutterBinding.ensureInitialized();\n  FlutterNativeSplash.preserve(widgetsBinding: widgetsBinding);\n\n  // Step 3: Run the app\n  runApp(const RealFlutter());\n}\n\n// Step 4: Define our main app widget\nclass RealFlutter extends StatefulWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 5: Simulate an initialization process\n    _initializeApp();\n  }\n\n  // Step 6: Simulated initialization process\n  Future<void> _initializeApp() async {\n    // Simulating some initialization work\n    await Future.delayed(const Duration(seconds: 3));\n    setState(() {\n      _isLoading = false;\n    });\n    // Step 7: Remove the splash screen when initialization is complete\n    FlutterNativeSplash.remove();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('RealFlutter Native Splash Demo'),\n        ),\n        body: Center(\n          child: _isLoading\n              ? const CircularProgressIndicator()\n              : const Text('Welcome to RealFlutter!'),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The main() function is called when the app starts.\n// 2. We initialize Flutter and preserve the native splash screen.\n// 3. The RealFlutter widget is created and its state is initialized.\n// 4. In the initState() method, we start the _initializeApp() process.\n// 5. While _initializeApp() is running, the app shows a loading indicator.\n// 6. After the initialization delay, we update the state and remove the splash screen.\n// 7. The app then displays the \"Welcome to RealFlutter!\" message.\n\n// Note: This example demonstrates how to use flutter_native_splash to show a splash screen\n// during app initialization. In a real app, you would replace the simulated delay with\n// actual initialization tasks like loading data or setting up services.\n```",
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "tutorial": "# Flutter Native Splash Tutorial\n\nThis tutorial will guide you through the process of implementing the flutter_native_splash package in your Flutter project. We'll cover installation, configuration, and platform-specific details.\n\n## Step 1: Add the package to your pubspec.yaml\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_native_splash: ^2.3.1\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Create a configuration file\n\nCreate a new file named `flutter_native_splash.yaml` in the root of your project:\n\n```yaml\nflutter_native_splash:\n  color: \"#42a5f5\"\n  image: assets/splash.png\n  branding: assets/branding.png\n  color_dark: \"#042a49\"\n  image_dark: assets/splash_dark.png\n  branding_dark: assets/branding_dark.png\n\n  android_12:\n    image: assets/splash_android12.png\n    icon_background_color: \"#111111\"\n    image_dark: assets/splash_android12_dark.png\n    icon_background_color_dark: \"#eeeeee\"\n\n  web: false\n```\n\n## Step 3: Add splash screen assets\n\nPlace your splash screen images in the `assets` folder:\n- `splash.png`: Main splash image\n- `splash_dark.png`: Dark mode splash image\n- `branding.png`: Branding image (optional)\n- `branding_dark.png`: Dark mode branding image (optional)\n- `splash_android12.png`: Android 12+ splash image\n- `splash_android12_dark.png`: Android 12+ dark mode splash image\n\n## Step 4: Generate splash screen files\n\nRun the following command to generate the necessary files:\n\n```\nflutter pub run flutter_native_splash:create\n```\n\n## Step 5: Platform-specific configurations\n\n### Android\n\nFor Android 12 and above, update your `android/app/src/main/res/values-v31/styles.xml`:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <style name=\"LaunchTheme\" parent=\"@android:style/Theme.Light.NoTitleBar\">\n        <item name=\"android:windowSplashScreenBackground\">@color/splash_background</item>\n        <item name=\"android:windowSplashScreenAnimatedIcon\">@drawable/android12splash</item>\n    </style>\n</resources>\n```\n\n### iOS\n\nFor iOS, update your `ios/Runner/Info.plist`:\n\n```xml\n<key>UILaunchStoryboardName</key>\n<string>LaunchScreen</string>\n```\n\n## Step 6: Customize the splash screen behavior\n\nIn your `main.dart` file, you can control when to remove the splash screen:\n\n```dart\nimport 'package:flutter_native_splash/flutter_native_splash.dart';\n\nvoid main() {\n  WidgetsBinding widgetsBinding = WidgetsFlutterBinding.ensureInitialized();\n  FlutterNativeSplash.preserve(widgetsBinding: widgetsBinding);\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    FlutterNativeSplash.remove();\n    return MaterialApp(\n      // Your app configuration\n    );\n  }\n}\n```\n\nBy following these steps, you'll have successfully implemented a native splash screen in your Flutter application using the flutter_native_splash package.",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RdRF",
    "description": "# Flutter Native Splash: Enhancing Your App's First Impression\n\nIn the world of mobile app development, first impressions matter. The flutter_native_splash package for Flutter provides an elegant solution to create captivating splash screens for your applications. This powerful tool allows developers to seamlessly integrate custom splash screens across multiple platforms, ensuring a consistent and professional look from the moment your app launches.\n\n## What is flutter_native_splash?\n\nflutter_native_splash is a Flutter package that simplifies the process of adding native splash screens to your Flutter applications. It supports both Android and iOS platforms, allowing you to create a unified launch experience across devices.\n\n## Key Features:\n\n1. **Cross-platform compatibility**: Works seamlessly on both Android and iOS.\n2. **Customizable**: Easily configure background colors, images, and animations.\n3. **Dark mode support**: Create separate splash screens for light and dark modes.\n4. **Branding options**: Add your logo or any custom image to the splash screen.\n5. **Performance optimized**: Ensures quick app startup without compromising user experience.\n\n## Why Use flutter_native_splash?\n\n1. **Professional appearance**: A well-designed splash screen adds a polished look to your app.\n2. **Improved user experience**: Provides visual feedback during app initialization.\n3. **Brand reinforcement**: Showcase your app's logo or branding from the start.\n4. **Easy implementation**: Simplifies the process of adding native splash screens.\n\nIn the following sections, we'll dive into a tutorial on how to implement flutter_native_splash in your Flutter project and explore a complete example showcasing its features.",
    "shortDescription": "Customize Flutter's default white native splash screen with background color and splash image. Supports dark mode, full screen, and more.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "79vgj15i"
      }
    ],
    "tutorialIncluded": true,
    "gallery": [
      {
        "_type": "image",
        "_key": "3b25472cdd42",
        "asset": {
          "_ref": "image-f57556d238ef38ebfe0c64e614acd7b6bbc5441c-1092x976-png",
          "_type": "reference"
        }
      }
    ],
    "slug": {
      "current": "flutter_native_splash",
      "_type": "slug"
    },
    "author": "jonhanson.net",
    "tags": [
      "splash-screen",
      "native",
      "branding",
      "launch-screen",
      "app-startup"
    ],
    "likesCount": 8156,
    "_type": "package"
  },
  {
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-514a0380beed76fca84b5daa7a865472b116f291-225x225-png",
        "_type": "reference"
      }
    },
    "gallery": [
      {
        "_key": "ae87864b19cf",
        "asset": {
          "_ref": "image-8c3659e3464365c8cb21cf2a0c122736ab3edb93-682x292-png",
          "_type": "reference"
        },
        "_type": "image"
      },
      {
        "_key": "9dfe659c6490",
        "asset": {
          "_ref": "image-ea1b83e943cc2e2fb78d0b07170f481d552a0370-588x1274-png",
          "_type": "reference"
        },
        "_type": "image"
      }
    ],
    "slug": {
      "_type": "slug",
      "current": "google_maps_flutter"
    },
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1K9L",
        "_type": "reference",
        "_key": "9vgwcftv"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWvh",
        "_type": "reference",
        "_key": "tn6kq5no"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CVGj",
    "tutorial": "# Google Maps Flutter Tutorial\n\nThis tutorial will guide you through setting up and using the `google_maps_flutter` package in your Flutter application.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  google_maps_flutter: ^2.2.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Platform-Specific Setup\n\n### Android Setup\n\n1. In `android/app/src/main/AndroidManifest.xml`, add the following permission:\n\n```xml\n<manifest ...>\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n    ...\n</manifest>\n```\n\n2. In the same file, add your API key inside the `<application>` tag:\n\n```xml\n<application ...>\n    <meta-data android:name=\"com.google.android.geo.API_KEY\"\n               android:value=\"YOUR_API_KEY_HERE\"/>\n</application>\n```\n\n3. In `android/app/build.gradle`, ensure your `minSdkVersion` is at least 20:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 20\n    }\n}\n```\n\n### iOS Setup\n\n1. In `ios/Runner/AppDelegate.swift`, import the Google Maps package and add the API key:\n\n```swift\nimport UIKit\nimport Flutter\nimport GoogleMaps\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    GMSServices.provideAPIKey(\"YOUR_API_KEY_HERE\")\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}\n```\n\n2. In `ios/Runner/Info.plist`, add the following to enable location services:\n\n```xml\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>This app needs access to location when open.</string>\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to display a Google Map in your Flutter app:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\n\nclass MapScreen extends StatefulWidget {\n  @override\n  _MapScreenState createState() => _MapScreenState();\n}\n\nclass _MapScreenState extends State<MapScreen> {\n  GoogleMapController? mapController;\n\n  final LatLng _center = const LatLng(45.521563, -122.677433);\n\n  void _onMapCreated(GoogleMapController controller) {\n    mapController = controller;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Google Maps Demo'),\n      ),\n      body: GoogleMap(\n        onMapCreated: _onMapCreated,\n        initialCameraPosition: CameraPosition(\n          target: _center,\n          zoom: 11.0,\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis code creates a basic map centered on Portland, Oregon. You can customize the initial location by changing the `_center` coordinates.\n\n## Next Steps\n\nWith this setup, you're ready to explore more advanced features of the `google_maps_flutter` package, such as adding markers, drawing polylines, and handling user interactions with the map.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1a3n",
        "_type": "reference",
        "_key": "flb946la"
      }
    ],
    "shortDescription": "A Flutter plugin for integrating Google Maps in iOS and Android applications.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWSz",
        "_type": "reference",
        "_key": "9imcy9pb"
      }
    ],
    "tags": [
      "google-maps",
      "google-maps-flutter",
      "map",
      "location",
      "geolocation",
      "navigation"
    ],
    "likesCount": 4147,
    "_createdAt": "2024-08-28T22:15:44Z",
    "lastUpdate": "2024-08-06T18:30:00.000Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaSFW",
    "description": "# Google Maps Flutter Package: Bringing Interactive Maps to Your Flutter App\n\nThe `google_maps_flutter` package is a powerful tool for integrating Google Maps into your Flutter applications. It provides a native Google Maps widget for both iOS and Android platforms, allowing developers to create rich, interactive map experiences within their Flutter apps.\n\n## Key Features\n\n1. **Map Display**: Render Google Maps with various map types (normal, satellite, terrain, hybrid).\n2. **Markers**: Add custom markers to highlight specific locations on the map.\n3. **Polylines**: Draw lines connecting multiple points on the map.\n4. **Polygons**: Create shapes to highlight areas on the map.\n5. **Camera Controls**: Programmatically control the map's view, zoom level, and position.\n6. **User Location**: Access and display the user's current location (with proper permissions).\n7. **Custom Map Styling**: Customize the appearance of the map using JSON-based styling options.\n8. **Gesture Handling**: Interact with the map using touch gestures like pinch-to-zoom and pan.\n\n## Why Use Google Maps Flutter?\n\n- **Native Performance**: The package uses native Google Maps SDK under the hood, ensuring smooth performance.\n- **Cross-Platform**: Works seamlessly on both iOS and Android with a single codebase.\n- **Rich Ecosystem**: Benefit from Google's vast mapping data and services.\n- **Customization**: Offers extensive options to tailor the map to your app's needs.\n- **Regular Updates**: Maintained by the Flutter team, ensuring compatibility with the latest Flutter versions.\n\nBy leveraging the `google_maps_flutter` package, developers can create sophisticated location-based features in their Flutter apps, from simple map displays to complex geospatial analytics tools.",
    "name": "google_maps_flutter",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Google Maps Flutter Demo',\n      home: MapScreen(),\n    );\n  }\n}\n\nclass MapScreen extends StatefulWidget {\n  @override\n  _MapScreenState createState() => _MapScreenState();\n}\n\nclass _MapScreenState extends State<MapScreen> {\n  GoogleMapController? mapController;\n  \n  // Step 1: Define initial map position\n  final LatLng _center = const LatLng(45.521563, -122.677433);\n  \n  // Step 2: Define a set to hold markers\n  final Set<Marker> _markers = {};\n  \n  // Step 3: Define a set to hold polylines\n  final Set<Polyline> _polylines = {};\n  \n  // Step 4: Define a set to hold polygons\n  final Set<Polygon> _polygons = {};\n\n  void _onMapCreated(GoogleMapController controller) {\n    mapController = controller;\n    \n    // Step 5: Add a marker\n    setState(() {\n      _markers.add(\n        Marker(\n          markerId: MarkerId('center'),\n          position: _center,\n          infoWindow: InfoWindow(title: 'Portland', snippet: 'The City of Roses'),\n        ),\n      );\n    });\n  }\n\n  // Step 6: Method to add a polyline\n  void _addPolyline() {\n    setState(() {\n      _polylines.add(\n        Polyline(\n          polylineId: PolylineId('route1'),\n          visible: true,\n          points: [\n            LatLng(45.521563, -122.677433),\n            LatLng(45.525563, -122.680433),\n            LatLng(45.528563, -122.675433),\n          ],\n          color: Colors.blue,\n        ),\n      );\n    });\n  }\n\n  // Step 7: Method to add a polygon\n  void _addPolygon() {\n    setState(() {\n      _polygons.add(\n        Polygon(\n          polygonId: PolygonId('area1'),\n          points: [\n            LatLng(45.521563, -122.677433),\n            LatLng(45.525563, -122.680433),\n            LatLng(45.528563, -122.675433),\n          ],\n          strokeColor: Colors.red,\n          fillColor: Colors.red.withOpacity(0.3),\n        ),\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Google Maps Flutter Demo'),\n      ),\n      body: GoogleMap(\n        onMapCreated: _onMapCreated,\n        initialCameraPosition: CameraPosition(\n          target: _center,\n          zoom: 11.0,\n        ),\n        markers: _markers,\n        polylines: _polylines,\n        polygons: _polygons,\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: <Widget>[\n          FloatingActionButton(\n            onPressed: _addPolyline,\n            tooltip: 'Add Polyline',\n            child: Icon(Icons.timeline),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            onPressed: _addPolygon,\n            tooltip: 'Add Polygon',\n            child: Icon(Icons.shape_line),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutter, which sets up the MaterialApp.\n// 2. The home screen is set to MapScreen, a StatefulWidget that manages the Google Map.\n// 3. In _MapScreenState, we define the initial map center, and sets for markers, polylines, and polygons.\n// 4. The build method creates a Scaffold with a GoogleMap widget as its body.\n// 5. When the map is created, _onMapCreated is called, which sets the mapController and adds a marker at the center.\n// 6. Two FloatingActionButtons are added to demonstrate adding a polyline and a polygon.\n// 7. When the user taps the \"Add Polyline\" button, _addPolyline is called, creating a blue line on the map.\n// 8. When the user taps the \"Add Polygon\" button, _addPolygon is called, creating a red polygon on the map.\n// 9. The setState calls in these methods trigger a rebuild of the widget, updating the map with the new elements.\n\n// This example demonstrates basic map setup, marker placement, and dynamic addition of polylines and polygons,\n// showcasing key features of the google_maps_flutter package.\n```",
    "_updatedAt": "2024-09-06T04:12:41Z",
    "author": "flutter.dev",
    "_type": "package"
  },
  {
    "likesCount": 5979,
    "slug": {
      "current": "fl_chart",
      "_type": "slug"
    },
    "author": "flchart.dev",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "fl_chart",
    "_id": "uQRNMiDfrp20RZ8Id8CVMF",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:42Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmSJa",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:fl_chart/fl_chart.dart';\nimport 'dart:math';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 1: Set up the MaterialApp with a theme and the RealFlutter widget as the home.\n    return MaterialApp(\n      title: 'FL Chart Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 2: Maintain the current index of the selected chart type\n  int _currentIndex = 0;\n\n  // Step 3: Create a list of chart samples to display based on the selected index\n  final List<Widget> _charts = [\n    LineChartSample(),\n    BarChartSample(),\n    PieChartSample(),\n    ScatterChartSample(),\n    RadarChartSample(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 4: Build the Scaffold with an AppBar, the selected chart, and a BottomNavigationBar\n    return Scaffold(\n      appBar: AppBar(title: Text('FL Chart Examples')),\n      body: _charts[_currentIndex],\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: _currentIndex,\n        onTap: (index) => setState(() => _currentIndex = index),\n        items: [\n          BottomNavigationBarItem(icon: Icon(Icons.show_chart), label: 'Line'),\n          BottomNavigationBarItem(icon: Icon(Icons.bar_chart), label: 'Bar'),\n          BottomNavigationBarItem(icon: Icon(Icons.pie_chart), label: 'Pie'),\n          BottomNavigationBarItem(icon: Icon(Icons.scatter_plot), label: 'Scatter'),\n          BottomNavigationBarItem(icon: Icon(Icons.radar), label: 'Radar'),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 5: Create a Line Chart Sample widget using FL Chart\nclass LineChartSample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: LineChart(\n        LineChartData(\n          lineBarsData: [\n            LineChartBarData(\n              spots: List.generate(\n                  7, (index) => FlSpot(index.toDouble(), Random().nextInt(6).toDouble())),\n              isCurved: true,\n              color: Colors.blue,\n              barWidth: 4,\n              dotData: FlDotData(show: false),\n            ),\n          ],\n          titlesData: FlTitlesData(\n            bottomTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n            leftTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n          ),\n          gridData: FlGridData(show: true),\n          borderData: FlBorderData(show: true),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 6: Create a Bar Chart Sample widget using FL Chart\nclass BarChartSample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: BarChart(\n        BarChartData(\n          barGroups: List.generate(\n            7,\n                (index) => BarChartGroupData(\n              x: index,\n              barRods: [BarChartRodData(fromY: Random().nextInt(10).toDouble(), toY: 100)],\n            ),\n          ),\n          titlesData: FlTitlesData(\n            bottomTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n            leftTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n          ),\n          borderData: FlBorderData(show: false),\n          gridData: FlGridData(show: false),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 7: Create a Pie Chart Sample widget using FL Chart\nclass PieChartSample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: PieChart(\n        PieChartData(\n          sections: List.generate(\n            4,\n                (index) => PieChartSectionData(\n              color: Colors.primaries[index],\n              value: Random().nextInt(50).toDouble(),\n              title: 'Section ${index + 1}',\n              radius: 100,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 8: Create a Scatter Chart Sample widget using FL Chart\nclass ScatterChartSample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: ScatterChart(\n        ScatterChartData(\n          scatterSpots: List.generate(\n            20,\n                (index) => ScatterSpot(\n              Random().nextDouble() * 10,\n              Random().nextDouble() * 10,\n              show: true,\n            ),\n          ),\n          titlesData: FlTitlesData(\n            bottomTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n            leftTitles: AxisTitles(\n              sideTitles: SideTitles(showTitles: true),\n            ),\n          ),\n          borderData: FlBorderData(show: true),\n          gridData: FlGridData(show: true),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 9: Create a Radar Chart Sample widget using FL Chart\nclass RadarChartSample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: RadarChart(\n        RadarChartData(\n          radarShape: RadarShape.circle,\n          dataSets: [\n            RadarDataSet(\n              dataEntries: List.generate(\n                5,\n                    (index) => RadarEntry(value: Random().nextDouble() * 10),\n              ),\n              fillColor: Colors.blue.withOpacity(0.2),\n              borderColor: Colors.blue,\n            ),\n          ],\n          radarBorderData: BorderSide(color: Colors.black12, width: 1),\n          titlePositionPercentageOffset: 0.2,\n          titleTextStyle: TextStyle(color: Colors.black, fontSize: 14),\n            getTitle: (index, angle) {\n              const titles = ['A', 'B', 'C', 'D', 'E'];\n              if (index >= 0 && index < titles.length) {\n                return RadarChartTitle(\n                  text: titles[index],\n                  angle: angle,\n                );\n              }\n              return RadarChartTitle(text: '', angle: angle);\n            }\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the MyApp widget, which sets up the MaterialApp and theme.\n// 2. RealFlutter is the main stateful widget that manages the current chart view.\n// 3. A BottomNavigationBar allows the user to switch between different chart types.\n// 4. Each chart type (Line, Bar, Pie, Scatter, Radar) is implemented as a separate stateless widget.\n// 5. The charts use random data for demonstration purposes.\n// 6. Users can interact with the charts (e.g., zoom, pan) depending on the chart type.\n// 7. The app demonstrates the versatility of the fl_chart package by showcasing various chart types and customization options.\n```",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWt7",
        "_type": "reference",
        "_key": "p41x8dcg"
      }
    ],
    "dependentPackages": [],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-c2e2d598da77860831e2180157cc3d691636b85e-1024x1024-webp",
        "_type": "reference"
      }
    },
    "gallery": [
      {
        "_type": "image",
        "_key": "3a6be474b7b6",
        "asset": {
          "_ref": "image-4c722645066c0345a1e6ae28f4fcae6b108bc617-540x1082-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "e444879135c7",
        "asset": {
          "_ref": "image-3df86ce18f4d4d973942c29a7746f1b09b6f94c5-560x1108-png",
          "_type": "reference"
        }
      },
      {
        "_type": "image",
        "_key": "c3aa0fc54827",
        "asset": {
          "_ref": "image-c7b319bfdfdb8632b50a15e039feb1159c237c8b-564x1092-png",
          "_type": "reference"
        }
      }
    ],
    "description": "# FL Chart: A Powerful Charting Library for Flutter\n\nFL Chart is a highly customizable and feature-rich charting library for Flutter applications. It provides a wide range of chart types and options, making it an excellent choice for developers who need to visualize data in their Flutter apps.\n\n## Key Features\n\n1. **Multiple Chart Types**: FL Chart supports various chart types, including:\n   - Line charts\n   - Bar charts\n   - Pie charts\n   - Scatter charts\n   - Radar charts\n\n2. **Customization**: The library offers extensive customization options, allowing developers to adjust colors, styles, labels, and animations to match their app's design.\n\n3. **Interactive Charts**: FL Chart supports touch interactions, enabling users to explore data points, zoom, and pan the charts.\n\n4. **Responsive Design**: Charts automatically adjust to different screen sizes and orientations, ensuring a consistent look across devices.\n\n5. **Animations**: Smooth animations are available for data changes and initial chart rendering, enhancing the user experience.\n\n6. **Performance**: FL Chart is designed with performance in mind, efficiently rendering charts even with large datasets.\n\n## When to Use FL Chart\n\nFL Chart is ideal for Flutter applications that require:\n\n- Data visualization for analytics dashboards\n- Financial applications with stock or currency charts\n- Fitness apps displaying workout or health data trends\n- Weather apps showing temperature or precipitation patterns\n- Any app that needs to present numerical data in a visually appealing manner\n\nBy leveraging FL Chart, developers can create engaging and informative data visualizations that enhance the overall user experience of their Flutter applications.",
    "similarPackages": [],
    "shortDescription": "A highly customizable Flutter chart library that supports Line Chart, Bar Chart, Pie Chart, Scatter Chart, and Radar Chart.",
    "tags": [
      "chart",
      "charts",
      "visualization",
      "graph",
      "diagram",
      "data-visualization",
      "statistics"
    ],
    "_createdAt": "2024-08-28T22:15:48Z",
    "lastUpdate": "2024-08-25T18:30:00.000Z",
    "tutorial": "# FL Chart Tutorial: Getting Started\n\nThis tutorial will guide you through the process of integrating FL Chart into your Flutter application and creating a basic line chart.\n\n## Step 1: Add Dependencies\n\nFirst, add the FL Chart package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  fl_chart: ^0.55.0  # Use the latest version\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the FL Chart package:\n\n```dart\nimport 'package:fl_chart/fl_chart.dart';\n```\n\n## Step 3: Create a Basic Line Chart\n\nLet's create a simple line chart to demonstrate the basics of FL Chart:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('FL Chart Example')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: LineChart(\n          LineChartData(\n            lineBarsData: [\n              LineChartBarData(\n                spots: [\n                  FlSpot(0, 3),\n                  FlSpot(1, 1),\n                  FlSpot(2, 4),\n                  FlSpot(3, 2),\n                  FlSpot(4, 5),\n                ],\n                isCurved: true,\n                color: Colors.blue,\n                barWidth: 4,\n                dotData: FlDotData(show: false),\n              ),\n            ],\n            titlesData: FlTitlesData(\n              bottomTitles: SideTitles(showTitles: true),\n              leftTitles: SideTitles(showTitles: true),\n            ),\n            gridData: FlGridData(show: true),\n            borderData: FlBorderData(show: true),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis code creates a basic line chart with a single line and some customization options.\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, no additional configuration is needed. FL Chart works out of the box.\n\n### Android\nFor Android, ensure that your `android/app/build.gradle` file has a `minSdkVersion` of at least 16:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // ... other configurations\n    }\n}\n```\n\n### Web\nFL Chart is compatible with Flutter web applications. However, for optimal performance, consider using the `CanvasKit` renderer:\n\n1. In your `web/index.html` file, add the following script tag:\n\n```html\n<script src=\"https://unpkg.com/canvaskit-wasm@0.33.0/bin/canvaskit.js\"></script>\n```\n\n2. When running or building your web app, use the `--web-renderer canvaskit` flag:\n\n```\nflutter run -d chrome --web-renderer canvaskit\n```\n\nor\n\n```\nflutter build web --web-renderer canvaskit\n```\n\nBy following these steps, you'll have a basic line chart set up in your Flutter application using FL Chart. Experiment with different chart types and customization options to create the perfect visualization for your data.",
    "pubPoint": 160,
    "_type": "package"
  },
  {
    "author": "fluttercommunity.dev",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfERK",
        "_type": "reference",
        "_key": "no35l9d9"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:43Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmSQ8",
    "shortDescription": "Flutter plugin for sharing content via the platform share UI, using the ACTION_SEND intent on Android and UIActivityViewController on iOS.",
    "likesCount": 3299,
    "lastUpdate": "2024-08-14T18:30:00.000Z",
    "slug": {
      "current": "share_plus",
      "_type": "slug"
    },
    "_type": "package",
    "description": "# Share Plus Package for Flutter: Seamless Content Sharing Across Platforms\n\nThe `share_plus` package is a powerful and versatile tool for Flutter developers looking to implement sharing functionality in their applications. This package provides a simple and efficient way to share content across various platforms, including iOS, Android, Web, and desktop environments.\n\n## Key Features\n\n1. **Cross-platform compatibility**: Share Plus works seamlessly across multiple platforms, ensuring a consistent sharing experience for users regardless of their device.\n\n2. **Multiple content types**: The package supports sharing various types of content, including text, files, and URLs.\n\n3. **Customizable share sheet**: On supported platforms, you can customize the appearance and behavior of the share sheet to match your app's design.\n\n4. **Asynchronous API**: Share Plus uses Future-based methods, allowing for smooth integration with Flutter's asynchronous programming model.\n\n5. **Platform-specific features**: The package takes advantage of platform-specific sharing capabilities, ensuring optimal performance on each supported platform.\n\nBy leveraging the Share Plus package, developers can easily implement robust sharing functionality in their Flutter applications, enhancing user engagement and improving the overall app experience.",
    "example": "```\n// This example depends on `path_provider` as well so add both of them before testing this out\n\nimport 'package:flutter/material.dart';\nimport 'package:share_plus/share_plus.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Share Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: SharePlusDemo(),\n    );\n  }\n}\n\nclass SharePlusDemo extends StatefulWidget {\n  @override\n  _SharePlusDemoState createState() => _SharePlusDemoState();\n}\n\nclass _SharePlusDemoState extends State<SharePlusDemo> {\n  // Step 1: Initialize variables\n  String _shareResult = 'Not shared yet';\n  String _text = 'Hello from Share Plus!';\n  String _subject = 'Share Plus Subject';\n  List<String> _imagePaths = [];\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Create sample images when the widget initializes\n    _createSampleImages();\n  }\n\n  // Step 3: Create sample images\n  Future<void> _createSampleImages() async {\n    final directory = await getTemporaryDirectory();\n    final imagePath1 = '${directory.path}/sample_image1.png';\n    final imagePath2 = '${directory.path}/sample_image2.png';\n\n    // Create two sample images (you would replace this with actual image creation/saving logic)\n    await File(imagePath1).writeAsString('Sample image 1 content');\n    await File(imagePath2).writeAsString('Sample image 2 content');\n\n    setState(() {\n      _imagePaths = [imagePath1, imagePath2];\n    });\n  }\n\n  // Step 4: Share text\n  void _shareText() async {\n    final result = await Share.share(_text, subject: _subject);\n    _updateShareResult(result);\n  }\n\n  // Step 5: Share files\n  void _shareFiles() async {\n    final result = await Share.shareXFiles(\n      _imagePaths.map((path) => XFile(path)).toList(),\n      text: 'Check out these images!',\n      subject: 'Image Share',\n    );\n    _updateShareResult(result);\n  }\n\n  // Step 6: Share URL\n  void _shareUrl() async {\n    final result = await Share.share(\n      'https://flutter.dev',\n      subject: 'Check out Flutter!',\n    );\n    _updateShareResult(result);\n  }\n\n  // Step 7: Update share result\n  void _updateShareResult(ShareResult result) {\n    setState(() {\n      _shareResult = 'Shared: ${result.status}';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Share Plus Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: _shareText,\n              child: Text('Share Text'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _shareFiles,\n              child: Text('Share Files'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _shareUrl,\n              child: Text('Share URL'),\n            ),\n            SizedBox(height: 20),\n            Text(_shareResult),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. The SharePlusDemo widget is created as the home screen.\n// 3. In the initState method, sample images are created (simulated in this example).\n// 4. The UI displays three buttons for different sharing options.\n// 5. When a button is pressed, the corresponding share method is called:\n//    - _shareText(): Shares a predefined text message.\n//    - _shareFiles(): Shares the sample images created earlier.\n//    - _shareUrl(): Shares a URL to the Flutter website.\n// 6. After sharing, the _updateShareResult method updates the UI with the share status.\n// 7. The user can perform multiple share actions, and the result is updated each time.\n\n// Note: For a fully functional app, you would need to replace the sample image\n// creation with actual image files and handle potential errors and edge cases.\n```",
    "tags": [
      "share",
      "utils",
      "social",
      "content-sharing",
      "platform-integration"
    ],
    "dependentPackages": [],
    "name": "share_plus",
    "_id": "uQRNMiDfrp20RZ8Id8CVRl",
    "pubPoint": 160,
    "similarPackages": [],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:15:49Z",
    "tutorial": "# Share Plus Package Tutorial\n\nThis tutorial will guide you through the process of integrating and using the Share Plus package in your Flutter application.\n\n## Step 1: Add Dependencies\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  share_plus: ^7.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:share_plus/share_plus.dart';\n```\n\n## Step 3: Implement Sharing Functionality\n\n### Sharing Text\n\nTo share text, use the `Share.share()` method:\n\n```dart\nShare.share('Check out this awesome Flutter app!');\n```\n\n### Sharing Files\n\nTo share files, use the `Share.shareFiles()` method:\n\n```dart\nfinal result = await Share.shareFiles(\n  ['path/to/your/file.pdf'],\n  text: 'Check out this PDF file',\n);\n```\n\n### Sharing URLs\n\nTo share URLs, you can use the `Share.share()` method with a URL string:\n\n```dart\nShare.share('https://flutter.dev', subject: 'Check out Flutter!');\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n### iOS\n\nFor iOS, no additional configuration is required.\n\n### Web\n\nFor web support, make sure to add the following script tag to your `web/index.html` file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/share-api-polyfill/dist/share-min.js\"></script>\n```\n\n### macOS\n\nFor macOS, add the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements` files:\n\n```xml\n<key>com.apple.security.files.user-selected.read-only</key>\n<true/>\n```\n\nBy following these steps, you'll be able to implement sharing functionality in your Flutter app across multiple platforms using the Share Plus package."
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:shimmer/shimmer.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Shimmer Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ShimmerDemo(),\n    );\n  }\n}\n\nclass ShimmerDemo extends StatefulWidget {\n  @override\n  _ShimmerDemoState createState() => _ShimmerDemoState();\n}\n\nclass _ShimmerDemoState extends State<ShimmerDemo> {\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Simulate a network request\n    _loadData();\n  }\n\n  // Step 2: Simulate loading data\n  Future<void> _loadData() async {\n    await Future.delayed(Duration(seconds: 5));\n    setState(() {\n      _isLoading = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Shimmer Demo')),\n      body: _isLoading ? _buildShimmerEffect() : _buildLoadedListView(),\n    );\n  }\n\n  // Step 3: Build shimmer effect\n  Widget _buildShimmerEffect() {\n    return Shimmer.fromColors(\n      baseColor: Colors.grey[300]!,\n      highlightColor: Colors.grey[100]!,\n      child: ListView.builder(\n        itemCount: 10,\n        itemBuilder: (_, __) => _buildShimmerItem(),\n      ),\n    );\n  }\n\n  // Step 4: Build a single shimmer item\n  Widget _buildShimmerItem() {\n    return Padding(\n      padding: const EdgeInsets.all(16.0),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Container(\n            width: 80,\n            height: 80,\n            color: Colors.white,\n          ),\n          const SizedBox(width: 16),\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Container(\n                  width: double.infinity,\n                  height: 16,\n                  color: Colors.white,\n                ),\n                const SizedBox(height: 8),\n                Container(\n                  width: double.infinity,\n                  height: 16,\n                  color: Colors.white,\n                ),\n                const SizedBox(height: 8),\n                Container(\n                  width: 100,\n                  height: 16,\n                  color: Colors.white,\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n\n  // Step 5: Build the actual content (loaded state)\n  Widget _buildLoadedListView() {\n    return ListView.builder(\n      itemCount: 10,\n      itemBuilder: (context, index) {\n        return ListTile(\n          leading: CircleAvatar(child: Text('${index + 1}')),\n          title: Text('Item ${index + 1}'),\n          subtitle: Text('Description for item ${index + 1}'),\n        );\n      },\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and shows the ShimmerDemo screen.\n// 2. Initially, _isLoading is true, so _buildShimmerEffect() is called.\n// 3. The shimmer effect is displayed, showing placeholder items with a shimmering animation.\n// 4. Meanwhile, _loadData() is called in initState(), which waits for 5 seconds.\n// 5. After 5 seconds, _isLoading is set to false, triggering a rebuild.\n// 6. The build method now calls _buildLoadedListView() instead of _buildShimmerEffect().\n// 7. The actual content (a simple list) is displayed, replacing the shimmer effect.\n\n// This demo showcases how to use Shimmer to create a loading placeholder\n// that smoothly transitions to the actual content once it's available.\n```",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cakt",
        "_type": "reference",
        "_key": "5y26nb8q"
      }
    ],
    "_updatedAt": "2024-09-06T04:12:44Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmSWg",
    "description": "# Shimmer: Add Captivating Loading Effects to Your Flutter App\n\nIn the world of mobile app development, user experience is paramount. One way to enhance the perceived performance of your app is by implementing loading animations that keep users engaged while content is being fetched. Enter the Shimmer package for Flutter  a powerful tool that allows developers to create stunning, shimmering loading effects with ease.\n\n## What is Shimmer?\n\nShimmer is a Flutter package that provides a simple way to add a shimmering effect to any widget in your application. This effect is particularly useful for creating skeleton screens or placeholder content while your app is loading data from an API or performing time-consuming operations.\n\n## Key Features of Shimmer\n\n1. **Easy Integration**: Shimmer can be easily integrated into any Flutter project with just a few lines of code.\n2. **Customizable**: The package offers a high degree of customization, allowing developers to adjust colors, directions, and durations of the shimmering effect.\n3. **Performance Optimized**: Shimmer is designed to be lightweight and performant, ensuring smooth animations even on lower-end devices.\n4. **Cross-Platform**: Like Flutter itself, Shimmer works seamlessly on both iOS and Android platforms.\n\n## Why Use Shimmer?\n\n1. **Improved User Experience**: By providing visual feedback during loading states, you keep users engaged and reduce perceived wait times.\n2. **Professional Look**: Shimmering effects add a polished, professional look to your application, enhancing its overall aesthetic appeal.\n3. **Flexible Application**: Shimmer can be used for various UI elements, from text placeholders to image loading states and beyond.\n\nIn the following sections, we'll dive deeper into how to implement Shimmer in your Flutter projects and explore some advanced usage scenarios.",
    "shortDescription": "A package provides an easy way to add shimmer effect in Flutter project",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "animation",
      "loading",
      "ui",
      "effect",
      "placeholder"
    ],
    "likesCount": 4831,
    "lastUpdate": "2023-05-20T18:30:00.000Z",
    "_type": "package",
    "_id": "uQRNMiDfrp20RZ8Id8CVx1",
    "tutorial": "# Shimmer Tutorial: Implementing Shimmering Effects in Flutter\n\nIn this tutorial, we'll walk through the process of adding the Shimmer package to your Flutter project and creating a basic shimmering effect. We'll also cover some platform-specific considerations.\n\n## Step 1: Add Shimmer to Your Project\n\nFirst, add the Shimmer package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  shimmer: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import Shimmer in Your Dart File\n\nIn the Dart file where you want to use Shimmer, add the following import:\n\n```dart\nimport 'package:shimmer/shimmer.dart';\n```\n\n## Step 3: Create a Basic Shimmering Effect\n\nHere's a simple example of how to create a shimmering effect:\n\n```dart\nShimmer.fromColors(\n  baseColor: Colors.grey[300]!,\n  highlightColor: Colors.grey[100]!,\n  child: ListView.builder(\n    itemCount: 10,\n    itemBuilder: (context, index) {\n      return ListTile(\n        leading: CircleAvatar(\n          backgroundColor: Colors.white,\n          radius: 30,\n        ),\n        title: Container(\n          width: double.infinity,\n          height: 16,\n          color: Colors.white,\n        ),\n        subtitle: Container(\n          width: double.infinity,\n          height: 14,\n          color: Colors.white,\n        ),\n      );\n    },\n  ),\n)\n```\n\nThis code creates a list of shimmering placeholders for a potential list of items.\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, the Shimmer effect works out of the box without any additional configuration. However, to ensure optimal performance, consider the following:\n\n- Use `ColorFiltered` widget to apply color tint to complex shapes instead of setting color properties directly.\n- Avoid using too many simultaneous Shimmer effects, as it might impact performance on older devices.\n\n### Android\n\nFor Android, keep these points in mind:\n\n- Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher.\n- If you encounter any rendering issues, try wrapping your Shimmer widget with a `ClipRect` widget.\n\n```dart\nClipRect(\n  child: Shimmer.fromColors(\n    // ... your Shimmer configuration\n  ),\n)\n```\n\n## Advanced Usage: Custom Shimmer Directions\n\nShimmer allows you to customize the direction of the shimmering effect. Here's an example:\n\n```dart\nShimmer.fromColors(\n  baseColor: Colors.grey[300]!,\n  highlightColor: Colors.grey[100]!,\n  direction: ShimmerDirection.ttb,  // Top to bottom\n  child: // Your widget here\n)\n```\n\nAvailable directions are:\n- `ShimmerDirection.ltr` (Left to right, default)\n- `ShimmerDirection.rtl` (Right to left)\n- `ShimmerDirection.ttb` (Top to bottom)\n- `ShimmerDirection.btt` (Bottom to top)\n\nBy mastering these basics and exploring the various customization options, you can create engaging loading states that significantly enhance your app's user experience.",
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "shimmer"
    },
    "name": "shimmer",
    "author": "hunghd.dev",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAQu",
        "_type": "reference",
        "_key": "xabm0iy1"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:15:56Z",
    "pubPoint": 160
  },
  {
    "slug": {
      "current": "connectivity_plus",
      "_type": "slug"
    },
    "pubPoint": 160,
    "description": "# Connectivity Plus: Real-Time Network Monitoring for Flutter\n\nIn the ever-connected world of mobile applications, staying informed about network status is crucial for providing a seamless user experience. Enter `connectivity_plus`, a powerful Flutter package that enables real-time network connectivity monitoring across multiple platforms.\n\n## What is Connectivity Plus?\n\n`connectivity_plus` is a Flutter plugin that allows developers to discover network connectivity and configure themselves accordingly. It provides real-time updates on network changes, supporting various connection types such as Wi-Fi, cellular, ethernet, and more.\n\n## Key Features\n\n1. **Cross-Platform Support**: Works on iOS, Android, Web, macOS, Windows, and Linux.\n2. **Real-Time Updates**: Provides a stream of connectivity changes.\n3. **Multiple Connection Types**: Differentiates between various connection types.\n4. **Easy Integration**: Simple to add to your Flutter project and use in your code.\n\n## Why Use Connectivity Plus?\n\n- **Improved User Experience**: Adapt your app's behavior based on network status.\n- **Offline Functionality**: Implement offline-first strategies effectively.\n- **Resource Optimization**: Manage network-dependent operations efficiently.\n- **Cross-Platform Consistency**: Ensure consistent network handling across different platforms.\n\nIn the following sections, we'll dive into how to implement `connectivity_plus` in your Flutter application, exploring its usage and best practices.",
    "shortDescription": "Flutter plugin for discovering the state of the network (WiFi & mobile/cellular) connectivity on Android and iOS.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaluC",
        "_type": "reference",
        "_key": "num9j3ct"
      }
    ],
    "example": "```\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Connectivity Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize variables\n  ConnectivityResult _connectionStatus = ConnectivityResult.none;\n  final Connectivity _connectivity = Connectivity();\n  late StreamSubscription<ConnectivityResult> _connectivitySubscription;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Initialize connectivity checking\n    _initConnectivity();\n    // Step 3: Set up a listener for future changes\n    _connectivitySubscription =\n        _connectivity.onConnectivityChanged.listen(_updateConnectionStatus);\n  }\n\n  // Step 4: Check initial connectivity status\n  Future<void> _initConnectivity() async {\n    late ConnectivityResult result;\n    try {\n      result = await _connectivity.checkConnectivity();\n    } catch (e) {\n      print('Couldn\\'t check connectivity status: $e');\n      return;\n    }\n    if (!mounted) {\n      return Future.value(null);\n    }\n    return _updateConnectionStatus(result);\n  }\n\n  // Step 5: Update the connection status\n  Future<void> _updateConnectionStatus(ConnectivityResult result) async {\n    setState(() {\n      _connectionStatus = result;\n    });\n  }\n\n  @override\n  void dispose() {\n    // Step 6: Cancel subscription when the widget is disposed\n    _connectivitySubscription.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Connectivity Plus Example'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 7: Display current connection status\n            Text('Connection Status: ${_connectionStatus.toString()}'),\n            SizedBox(height: 20),\n            // Step 8: Add a button to manually check connectivity\n            ElevatedButton(\n              onPressed: () async {\n                final result = await _connectivity.checkConnectivity();\n                _updateConnectionStatus(result);\n              },\n              child: Text('Check Connectivity'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the RealFlutter widget.\n// 2. In initState(), we call _initConnectivity() to check the initial connection status.\n// 3. We also set up a listener (_connectivitySubscription) to monitor future connectivity changes.\n// 4. The _updateConnectionStatus() method is called whenever there's a change in connectivity.\n// 5. The UI displays the current connection status and provides a button to manually check connectivity.\n// 6. When the user presses the \"Check Connectivity\" button, it triggers a manual check and updates the status.\n// 7. The StreamSubscription is cancelled in the dispose() method to prevent memory leaks.\n\n// Note: This example demonstrates real-time monitoring of network changes and manual checking.\n// It's a good starting point for implementing network-aware features in your Flutter application.\n```",
    "likesCount": 3339,
    "lastUpdate": "2024-08-08T18:30:00.000Z",
    "_rev": "ezMiwuUkJkbYMWycA6RdYR",
    "_type": "package",
    "tags": [
      "connectivity",
      "utils",
      "network",
      "internet",
      "online-offline"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:15:58Z",
    "tutorial": "# Implementing Connectivity Plus in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the `connectivity_plus` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd `connectivity_plus` to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  connectivity_plus: ^5.0.2\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use `connectivity_plus`:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  String _connectionStatus = 'Unknown';\n  final Connectivity _connectivity = Connectivity();\n\n  @override\n  void initState() {\n    super.initState();\n    _initConnectivity();\n    _connectivity.onConnectivityChanged.listen(_updateConnectionStatus);\n  }\n\n  Future<void> _initConnectivity() async {\n    late ConnectivityResult result;\n    try {\n      result = await _connectivity.checkConnectivity();\n    } catch (e) {\n      print('Couldn\\'t check connectivity status: $e');\n      return;\n    }\n    _updateConnectionStatus(result);\n  }\n\n  void _updateConnectionStatus(ConnectivityResult result) {\n    setState(() {\n      switch (result) {\n        case ConnectivityResult.wifi:\n          _connectionStatus = 'Wi-Fi';\n          break;\n        case ConnectivityResult.mobile:\n          _connectionStatus = 'Cellular';\n          break;\n        case ConnectivityResult.none:\n          _connectionStatus = 'No Connection';\n          break;\n        default:\n          _connectionStatus = 'Unknown';\n          break;\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Connectivity Example')),\n      body: Center(child: Text('Connection Status: $_connectionStatus')),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nAdd the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n### iOS\n\nNo additional setup required.\n\n### Web\n\nThe web implementation of `connectivity_plus` uses the browser's `navigator.onLine` and `online`/`offline` events. No additional setup is needed.\n\n### macOS\n\nAdd the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`:\n\n```xml\n<key>com.apple.security.network.client</key>\n<true/>\n```\n\n### Windows\n\nNo additional setup required.\n\n### Linux\n\nEnsure you have `NetworkManager` installed on your system.\n\nBy following these steps and considering the platform-specific requirements, you can effectively implement real-time network monitoring in your Flutter application using the `connectivity_plus` package.",
    "tutorialIncluded": true,
    "author": "fluttercommunity.dev",
    "subCategories": [
      {
        "_key": "zu3zc4g1",
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "connectivity_plus",
    "_id": "uQRNMiDfrp20RZ8Id8CW83",
    "_updatedAt": "2024-09-06T04:12:45Z",
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPb4Yq",
        "_type": "reference",
        "_key": "fh46c672"
      }
    ]
  },
  {
    "shortDescription": "RFC4122 (v1, v4, v5, v6, v7, v8) UUID Generator and Parser for Dart",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "3eoojha8",
        "_ref": "t8DYBEKn49O4mjbyRAfCdI"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:uuid/uuid.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'UUID Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const UuidDemoPage(),\n    );\n  }\n}\n\nclass UuidDemoPage extends StatefulWidget {\n  const UuidDemoPage({Key? key}) : super(key: key);\n\n  @override\n  _UuidDemoPageState createState() => _UuidDemoPageState();\n}\n\nclass _UuidDemoPageState extends State<UuidDemoPage> {\n  final Uuid _uuid = Uuid();\n  String _currentUuid = '';\n  String _validationResult = '';\n\n  // Step 1: Generate a random UUID (v4)\n  void _generateRandomUuid() {\n    setState(() {\n      _currentUuid = _uuid.v4();\n    });\n  }\n\n  // Step 2: Generate a time-based UUID (v1)\n  void _generateTimeBasedUuid() {\n    setState(() {\n      _currentUuid = _uuid.v1();\n    });\n  }\n\n  // Step 3: Generate a name-based UUID (v5)\n  void _generateNameBasedUuid() {\n    setState(() {\n      _currentUuid = _uuid.v5(Uuid.NAMESPACE_URL, 'https://flutter.dev');\n    });\n  }\n\n  // Step 4: Validate the current UUID\n  void _validateUuid() {\n    bool isValid = Uuid.isValidUUID(fromString: _currentUuid);\n    setState(() {\n      _validationResult = isValid ? 'Valid UUID' : 'Invalid UUID';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('UUID Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'Current UUID:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            Text(\n              _currentUuid,\n              style: Theme.of(context).textTheme.bodyText1,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _generateRandomUuid,\n              child: const Text('Generate Random UUID (v4)'),\n            ),\n            ElevatedButton(\n              onPressed: _generateTimeBasedUuid,\n              child: const Text('Generate Time-based UUID (v1)'),\n            ),\n            ElevatedButton(\n              onPressed: _generateNameBasedUuid,\n              child: const Text('Generate Name-based UUID (v5)'),\n            ),\n            ElevatedButton(\n              onPressed: _validateUuid,\n              child: const Text('Validate UUID'),\n            ),\n            const SizedBox(height: 20),\n            Text(\n              _validationResult,\n              style: Theme.of(context).textTheme.subtitle1,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays the UuidDemoPage.\n// 2. Initially, the _currentUuid is empty.\n// 3. When the user presses the \"Generate Random UUID (v4)\" button:\n//    - _generateRandomUuid() is called\n//    - A new random UUID is generated using _uuid.v4()\n//    - The state is updated, triggering a rebuild of the UI\n// 4. When the user presses the \"Generate Time-based UUID (v1)\" button:\n//    - _generateTimeBasedUuid() is called\n//    - A new time-based UUID is generated using _uuid.v1()\n//    - The state is updated, triggering a rebuild of the UI\n// 5. When the user presses the \"Generate Name-based UUID (v5)\" button:\n//    - _generateNameBasedUuid() is called\n//    - A new name-based UUID is generated using _uuid.v5()\n//    - The state is updated, triggering a rebuild of the UI\n// 6. When the user presses the \"Validate UUID\" button:\n//    - _validateUuid() is called\n//    - The current UUID is validated using Uuid.isValidUUID()\n//    - The validation result is stored in _validationResult\n//    - The state is updated, triggering a rebuild of the UI\n// 7. The UI always displays the current UUID and validation result (if any).\n// 8. This cycle continues as the user interacts with the app, allowing them\n//    to generate different types of UUIDs and validate them.\n```",
    "name": "uuid",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmSdE",
    "similarPackages": [],
    "lastUpdate": "2024-07-10T18:30:00.000Z",
    "description": "# UUID Package for Flutter: Generating Unique Identifiers\n\n## Introduction\n\nIn the world of software development, generating unique identifiers is a common requirement. Flutter, the popular cross-platform framework, offers a powerful package called `uuid` that simplifies this process. This blog post will dive deep into the UUID package, exploring its features, implementation, and best practices.\n\n## What is UUID?\n\nUUID stands for Universally Unique Identifier. It's a 128-bit number used to identify information in computer systems. UUIDs are standardized by the Open Software Foundation (OSF) as part of the Distributed Computing Environment (DCE).\n\n## Key Features of the UUID Package\n\n1. **Multiple UUID Versions**: Supports UUID versions 1, 4, and 5.\n2. **Platform Independence**: Works across all platforms supported by Flutter.\n3. **Cryptographically Secure**: Generates secure random UUIDs.\n4. **Customizable**: Allows creation of name-based UUIDs.\n5. **Parsing and Validation**: Offers methods to parse and validate UUID strings.\n\n## Why Use UUIDs in Flutter Applications?\n\n1. **Unique Database Keys**: Ideal for generating unique primary keys in databases.\n2. **Device Identification**: Can be used to create unique identifiers for devices.\n3. **Session Management**: Useful for creating unique session IDs.\n4. **File Naming**: Helps in generating unique file names to avoid conflicts.\n5. **Distributed Systems**: Essential for maintaining uniqueness across distributed systems.\n\nIn the following sections, we'll explore how to implement and use the UUID package in your Flutter projects.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 2311,
    "packageImage": null,
    "tutorial": "# UUID Package for Flutter: Tutorial\n\n## Installation\n\nTo get started with the UUID package in your Flutter project, follow these steps:\n\n1. Open your `pubspec.yaml` file.\n2. Add the following dependency:\n\n```yaml\ndependencies:\n  uuid: ^3.0.7\n```\n\n3. Run the following command in your terminal:\n\n```\nflutter pub get\n```\n\n## Basic Usage\n\nHere's a simple example of how to generate a UUID:\n\n```dart\nimport 'package:uuid/uuid.dart';\n\nvoid main() {\n  var uuid = Uuid();\n  String randomUuid = uuid.v4();\n  print('Random UUID: $randomUuid');\n}\n```\n\n## Advanced Features\n\n### Generating Different UUID Versions\n\nThe UUID package supports multiple versions of UUIDs:\n\n1. Version 1 (Time-based):\n\n```dart\nString timeBasedUuid = uuid.v1();\n```\n\n2. Version 4 (Random):\n\n```dart\nString randomUuid = uuid.v4();\n```\n\n3. Version 5 (Name-based):\n\n```dart\nString nameBasedUuid = uuid.v5(Uuid.NAMESPACE_URL, 'www.example.com');\n```\n\n### Parsing and Validating UUIDs\n\nThe package also provides methods to parse and validate UUID strings:\n\n```dart\nString uuidString = '123e4567-e89b-12d3-a456-426614174000';\nbool isValid = Uuid.isValidUUID(fromString: uuidString);\n\nif (isValid) {\n  print('Valid UUID');\n} else {\n  print('Invalid UUID');\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, the UUID package uses the `java.util.UUID` class internally. No additional configuration is required.\n\n### iOS\n\nFor iOS, the package utilizes the `NSUUID` class. Ensure that you have the latest version of Xcode installed for optimal performance.\n\n### Web\n\nWhen targeting web platforms, the UUID package uses the Web Crypto API for generating secure random numbers. Make sure your target browsers support this API.\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, the package uses Dart's `math.Random.secure()` for random number generation. No specific configuration is needed.\n\nBy following this tutorial, you'll be able to effectively implement and use the UUID package in your Flutter applications across various platforms.",
    "author": "yuli.dev",
    "_type": "package",
    "_createdAt": "2024-08-28T22:16:04Z",
    "_id": "uQRNMiDfrp20RZ8Id8CWOb",
    "_updatedAt": "2024-09-06T04:12:46Z",
    "slug": {
      "current": "uuid",
      "_type": "slug"
    },
    "tags": [
      "uuid",
      "identifier",
      "id",
      "unique-id",
      "generator"
    ],
    "dependentPackages": [
      {
        "_key": "kc6bpkcp",
        "_ref": "Rx1Nho763d29lawKra1f2V",
        "_type": "reference"
      }
    ]
  },
  {
    "similarPackages": [
      {
        "_key": "inyab28p",
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference"
      }
    ],
    "name": "audioplayers",
    "tutorial": "# Audioplayers Package Tutorial\n\n## Setting Up\n\n1. Add the `audioplayers` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  audioplayers: ^5.0.0\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:audioplayers/audioplayers.dart';\n```\n\n## Platform-Specific Configuration\n\n### Android\n\n1. Update your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n    }\n}\n```\n\n2. For background audio, add the following to your `AndroidManifest.xml`:\n\n```xml\n<manifest ...>\n    <application ...>\n        <service android:name=\"com.ryanheise.audioservice.AudioService\">\n            <intent-filter>\n                <action android:name=\"android.media.browse.MediaBrowserService\" />\n            </intent-filter>\n        </service>\n    </application>\n</manifest>\n```\n\n### iOS\n\n1. Enable background audio in `Info.plist`:\n\n```xml\n<key>UIBackgroundModes</key>\n<array>\n    <string>audio</string>\n</array>\n```\n\n2. For iOS 10+, add this key to `Info.plist`:\n\n```xml\n<key>NSMicrophoneUsageDescription</key>\n<string>This app uses the microphone to record audio for playback.</string>\n```\n\n### Web\n\nNo additional configuration is required for web support.\n\n## Basic Usage\n\n### Creating an AudioPlayer Instance\n\n```dart\nfinal player = AudioPlayer();\n```\n\n### Playing Audio from URL\n\n```dart\nawait player.play(UrlSource('https://example.com/audio.mp3'));\n```\n\n### Playing Audio from Asset\n\n```dart\nawait player.play(AssetSource('audio/background_music.mp3'));\n```\n\n### Playing Audio from Local File\n\n```dart\nawait player.play(DeviceFileSource('/path/to/audio.mp3'));\n```\n\n### Controlling Playback\n\n```dart\n// Pause\nawait player.pause();\n\n// Resume\nawait player.resume();\n\n// Stop\nawait player.stop();\n\n// Seek to a specific position\nawait player.seek(Duration(seconds: 10));\n\n// Set volume (0.0 to 1.0)\nawait player.setVolume(0.5);\n```\n\n### Listening to Player State Changes\n\n```dart\nplayer.onPlayerStateChanged.listen((PlayerState state) {\n  if (state == PlayerState.playing) {\n    print('Audio is playing');\n  } else if (state == PlayerState.paused) {\n    print('Audio is paused');\n  }\n});\n```\n\n### Handling Completion\n\n```dart\nplayer.onPlayerComplete.listen((event) {\n  print('Audio playback completed');\n});\n```\n\n## Advanced Features\n\n### Looping Audio\n\n```dart\nawait player.setReleaseMode(ReleaseMode.loop);\n```\n\n### Controlling Playback Speed\n\n```dart\nawait player.setPlaybackRate(1.5); // 1.5x speed\n```\n\n### Using AudioCache for Preloading\n\n```dart\nfinal cache = AudioCache();\nawait cache.load('audio/sound_effect.mp3');\nawait cache.play('audio/sound_effect.mp3');\n```\n\nThis tutorial covers the basics of using the `audioplayers` package in Flutter. In the next section, we'll look at a comprehensive example that demonstrates these features in action.",
    "lastUpdate": "2024-08-26T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:47Z",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:audioplayers/audioplayers.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Audioplayers Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: AudioPlayerDemo(),\n    );\n  }\n}\n\nclass AudioPlayerDemo extends StatefulWidget {\n  @override\n  _AudioPlayerDemoState createState() => _AudioPlayerDemoState();\n}\n\nclass _AudioPlayerDemoState extends State<AudioPlayerDemo> {\n  // Step 1: Initialize AudioPlayer instances\n  final AudioPlayer _player1 = AudioPlayer();\n  final AudioPlayer _player2 = AudioPlayer();\n  final AudioCache _cache = AudioCache();\n\n  // Step 2: Define audio sources\n  final String _urlAudio = 'https://example.com/audio.mp3';\n  final String _assetAudio = 'audio/background_music.mp3';\n  final String _cacheAudio = 'sound_effect.mp3';\n\n  // Step 3: Track player states\n  PlayerState _player1State = PlayerState.stopped;\n  PlayerState _player2State = PlayerState.stopped;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 4: Set up listeners for player state changes\n    _player1.onPlayerStateChanged.listen((state) {\n      setState(() => _player1State = state);\n    });\n    _player2.onPlayerStateChanged.listen((state) {\n      setState(() => _player2State = state);\n    });\n\n    // Step 5: Preload audio for AudioCache\n    _cache.load(_cacheAudio);\n  }\n\n  @override\n  void dispose() {\n    // Step 6: Dispose of AudioPlayer instances\n    _player1.dispose();\n    _player2.dispose();\n    super.dispose();\n  }\n\n  // Step 7: Define playback control methods\n  Future<void> _playUrl() async {\n    await _player1.play(UrlSource(_urlAudio));\n  }\n\n  Future<void> _playAsset() async {\n    await _player2.play(AssetSource(_assetAudio));\n  }\n\n  Future<void> _playCached() async {\n    await _cache.play(_cacheAudio);\n  }\n\n  Future<void> _pause(AudioPlayer player) async {\n    await player.pause();\n  }\n\n  Future<void> _resume(AudioPlayer player) async {\n    await player.resume();\n  }\n\n  Future<void> _stop(AudioPlayer player) async {\n    await player.stop();\n  }\n\n  Future<void> _seek(AudioPlayer player, Duration position) async {\n    await player.seek(position);\n  }\n\n  Future<void> _setVolume(AudioPlayer player, double volume) async {\n    await player.setVolume(volume);\n  }\n\n  Future<void> _setPlaybackRate(AudioPlayer player, double rate) async {\n    await player.setPlaybackRate(rate);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Audioplayers Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 8: Create UI controls for Player 1 (URL audio)\n            Text('Player 1 (URL Audio)', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(onPressed: _playUrl, child: Text('Play')),\n                SizedBox(width: 10),\n                ElevatedButton(\n                  onPressed: _player1State == PlayerState.playing ? () => _pause(_player1) : () => _resume(_player1),\n                  child: Text(_player1State == PlayerState.playing ? 'Pause' : 'Resume'),\n                ),\n                SizedBox(width: 10),\n                ElevatedButton(onPressed: () => _stop(_player1), child: Text('Stop')),\n              ],\n            ),\n            Slider(\n              value: 0.5,\n              onChanged: (value) => _setVolume(_player1, value),\n            ),\n            Text('Volume'),\n            \n            SizedBox(height: 20),\n            \n            // Step 9: Create UI controls for Player 2 (Asset audio)\n            Text('Player 2 (Asset Audio)', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(onPressed: _playAsset, child: Text('Play')),\n                SizedBox(width: 10),\n                ElevatedButton(\n                  onPressed: _player2State == PlayerState.playing ? () => _pause(_player2) : () => _resume(_player2),\n                  child: Text(_player2State == PlayerState.playing ? 'Pause' : 'Resume'),\n                ),\n                SizedBox(width: 10),\n                ElevatedButton(onPressed: () => _stop(_player2), child: Text('Stop')),\n              ],\n            ),\n            Slider(\n              value: 1.0,\n              min: 0.5,\n              max: 2.0,\n              onChanged: (value) => _setPlaybackRate(_player2, value),\n            ),\n            Text('Playback Speed'),\n            \n            SizedBox(height: 20),\n            \n            // Step 10: Add button for playing cached audio\n            ElevatedButton(onPressed: _playCached, child: Text('Play Cached Sound Effect')),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 11: Application Flow Explanation\n/*\n1. The application initializes two AudioPlayer instances and an AudioCache for different audio sources.\n2. In initState, we set up listeners for player state changes and preload the cached audio.\n3. The UI provides controls for two main audio players:\n   - Player 1: Plays audio from a URL\n   - Player 2: Plays audio from an asset file\n4. Each player has play, pause/resume, and stop buttons.\n5. Player 1 has a volume control slider.\n6. Player 2 has a playback speed control slider.\n7. There's an additional button to play a cached sound effect using AudioCache.\n8. When a control is activated:\n   a. The corresponding method is called (e.g., _playUrl, _pause, _setVolume).\n   b. The method interacts with the AudioPlayer instance.\n   c. State changes are reflected in the UI through the onPlayerStateChanged listeners.\n9. The dispose method ensures proper cleanup of AudioPlayer instances when the widget is removed.\n\nThis example demonstrates the core features of the audioplayers package, including:\n- Playing audio from different sources (URL, asset, cached)\n- Basic playback controls (play, pause, resume, stop)\n- Volume control\n- Playback speed adjustment\n- Concurrent playback of multiple audio files\n- State management for audio players\n\nUsers can extend this example to add more features like seeking, looping, or background audio playback.\n*/\n```",
    "tags": [
      "audio",
      "media",
      "sound",
      "music",
      "playback"
    ],
    "likesCount": 2986,
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "25rcd98v",
        "_ref": "Rx1Nho763d29lawKra1lZ1"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cb6x",
        "_type": "reference",
        "_key": "1x9m9ps4"
      }
    ],
    "slug": {
      "current": "audioplayers",
      "_type": "slug"
    },
    "_createdAt": "2024-08-28T22:16:05Z",
    "pubPoint": 160,
    "author": "blue-fire.xyz",
    "description": "# Audioplayers Package for Flutter: A Comprehensive Overview\n\n## Introduction\n\nThe `audioplayers` package is a powerful and versatile audio playback solution for Flutter applications. It provides developers with a rich set of features to handle various audio playback scenarios across multiple platforms, including iOS, Android, web, and desktop.\n\n## Key Features\n\n1. **Multiple Audio Sources**: Supports playback from URLs, asset files, and local files.\n2. **Concurrent Playback**: Allows playing multiple audio files simultaneously.\n3. **Playback Controls**: Offers play, pause, seek, and volume control functionalities.\n4. **Audio Streaming**: Enables streaming of audio content from remote sources.\n5. **Background Playback**: Supports audio playback when the app is in the background.\n6. **Platform-Specific Configurations**: Provides options for configuring audio behavior on different platforms.\n\n## Use Cases\n\n- Music players\n- Podcast applications\n- Audio book readers\n- Games with background music and sound effects\n- Educational apps with audio content\n\n## Getting Started\n\nTo use the `audioplayers` package in your Flutter project, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  audioplayers: ^5.0.0\n```\n\nThen, run `flutter pub get` to fetch the package.\n\nIn the next sections, we'll dive into a detailed tutorial on how to implement audio playback using the `audioplayers` package and showcase a comprehensive example demonstrating its features.",
    "shortDescription": "A Flutter plugin to play multiple audio files simultaneously",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_rev": "eaCZ7mIhmiYZX5KGqJmSqK",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "dcpkt8dk",
        "_ref": "4gmBGwifQuSypgRenUbW9O"
      }
    ],
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8CWZd"
  },
  {
    "_rev": "eaCZ7mIhmiYZX5KGqJmT09",
    "similarPackages": [],
    "likesCount": 3438,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-11a99a457b7d2e3db3df9a24fcf01a064f712a2d-430x460-webp",
        "_type": "reference"
      }
    },
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:48Z",
    "slug": {
      "current": "smooth_page_indicator",
      "_type": "slug"
    },
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFqE",
        "_type": "reference",
        "_key": "yxmfup32"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:smooth_page_indicator/smooth_page_indicator.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Create a PageController\n  final PageController _controller = PageController();\n  \n  // Step 2: Create a variable to track the current page\n  int _currentPage = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Add a listener to the PageController to update _currentPage\n    _controller.addListener(() {\n      setState(() {\n        _currentPage = _controller.page!.round();\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Smooth Page Indicator Demo')),\n      body: Column(\n        children: [\n          // Step 4: Implement PageView\n          Expanded(\n            child: PageView(\n              controller: _controller,\n              children: [\n                _buildPage('Page 1', Colors.red),\n                _buildPage('Page 2', Colors.green),\n                _buildPage('Page 3', Colors.blue),\n                _buildPage('Page 4', Colors.yellow),\n              ],\n            ),\n          ),\n          // Step 5: Add SmoothPageIndicator\n          Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: SmoothPageIndicator(\n              controller: _controller,\n              count: 4,\n              effect: WormEffect(),\n            ),\n          ),\n          // Step 6: Add buttons to demonstrate different effects\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: [\n              ElevatedButton(\n                onPressed: () => _changeEffect(WormEffect()),\n                child: Text('Worm'),\n              ),\n              ElevatedButton(\n                onPressed: () => _changeEffect(ExpandingDotsEffect()),\n                child: Text('Expanding Dots'),\n              ),\n              ElevatedButton(\n                onPressed: () => _changeEffect(JumpingDotEffect()),\n                child: Text('Jumping Dot'),\n              ),\n            ],\n          ),\n          SizedBox(height: 20),\n        ],\n      ),\n    );\n  }\n\n  // Step 7: Helper method to build each page\n  Widget _buildPage(String text, Color color) {\n    return Container(\n      color: color,\n      child: Center(\n        child: Text(\n          text,\n          style: TextStyle(fontSize: 24, color: Colors.white),\n        ),\n      ),\n    );\n  }\n\n  // Step 8: Method to change the indicator effect\n  void _changeEffect(SlideEffect effect) {\n    setState(() {\n      _currentEffect = effect;\n    });\n  }\n\n  // Step 9: Variable to store the current effect\n  SlideEffect _currentEffect = WormEffect();\n}\n\n// Application Flow:\n// 1. The app starts and displays a PageView with 4 colored pages.\n// 2. At the bottom, a SmoothPageIndicator shows the current page position.\n// 3. Users can swipe between pages or tap on the indicator to navigate.\n// 4. Three buttons at the bottom allow changing the indicator effect:\n//    - 'Worm' button sets the WormEffect\n//    - 'Expanding Dots' button sets the ExpandingDotsEffect\n//    - 'Jumping Dot' button sets the JumpingDotEffect\n// 5. When a button is pressed, the _changeEffect method updates the state,\n//    causing the indicator to rebuild with the new effect.\n// 6. The PageController listener ensures that _currentPage is always up to date,\n//    allowing for potential future features based on the current page.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:16:08Z",
    "tutorial": "# Smooth Page Indicator: Implementation Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `smooth_page_indicator` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nTo begin, add the `smooth_page_indicator` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  smooth_page_indicator: ^1.1.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:smooth_page_indicator/smooth_page_indicator.dart';\n```\n\n## Step 3: Basic Implementation\n\nHere's a basic example of how to use the `SmoothPageIndicator` widget:\n\n```dart\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final controller = PageController(viewportFraction: 0.8, keepPage: true);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          SizedBox(\n            height: 240,\n            child: PageView(\n              controller: controller,\n              children: List.generate(6, (_) => const Card(\n                color: Colors.grey,\n                child: Center(child: Text('Page')),\n              )),\n            ),\n          ),\n          SmoothPageIndicator(\n            controller: controller,\n            count: 6,\n            effect: const WormEffect(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Customization\n\nThe `SmoothPageIndicator` widget offers various customization options:\n\n```dart\nSmoothPageIndicator(\n  controller: controller,\n  count: 6,\n  effect: WormEffect(\n    activeDotColor: Colors.blue,\n    dotColor: Colors.blue.withOpacity(0.5),\n    dotHeight: 16,\n    dotWidth: 16,\n    type: WormType.thin,\n  ),\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to consider using the `ScrollIndicator` effect, which mimics the native iOS page indicator:\n\n```dart\neffect: ScrollingDotsEffect(\n  activeDotColor: Colors.blue,\n  dotColor: Colors.grey,\n  dotHeight: 8,\n  dotWidth: 8,\n  spacing: 4,\n),\n```\n\n### Android\n\nFor Android, the `WormEffect` or `ExpandingDotsEffect` can provide a more Material Design-inspired look:\n\n```dart\neffect: ExpandingDotsEffect(\n  activeDotColor: Colors.blue,\n  dotColor: Colors.grey,\n  dotHeight: 8,\n  dotWidth: 8,\n  spacing: 4,\n),\n```\n\n### Web\n\nWhen implementing for web, consider using larger dots for better visibility:\n\n```dart\neffect: JumpingDotEffect(\n  activeDotColor: Colors.blue,\n  dotColor: Colors.grey,\n  dotHeight: 16,\n  dotWidth: 16,\n  spacing: 8,\n  verticalOffset: 8,\n),\n```\n\nBy considering these platform-specific designs, you can ensure that your app feels native and intuitive on each platform while still maintaining a consistent brand identity.\n\nIn the next section, we'll explore a more comprehensive example that demonstrates various features of the `smooth_page_indicator` package.",
    "author": "codeness.ly",
    "_type": "package",
    "description": "# Smooth Page Indicator: Enhancing User Experience in Flutter Apps\n\n## Introduction\n\nIn the world of mobile app development, creating an engaging and intuitive user interface is crucial. One essential element that can significantly improve user experience is a smooth and visually appealing page indicator. Flutter, Google's UI toolkit for building natively compiled applications, offers various packages to achieve this. Among them, the `smooth_page_indicator` package stands out for its versatility and ease of use.\n\n## What is Smooth Page Indicator?\n\nThe `smooth_page_indicator` package is a customizable animated page indicator widget for Flutter applications. It provides a sleek and modern way to display the current page position in a PageView or any other scrollable widget. With a wide range of customization options, developers can create unique and attractive page indicators that seamlessly integrate with their app's design.\n\n## Key Features\n\n1. **Smooth Animations**: The package offers fluid animations for transitioning between pages, enhancing the overall user experience.\n\n2. **Customizable Appearance**: Developers can easily customize the size, color, shape, and spacing of the indicator dots.\n\n3. **Various Effects**: The package includes multiple built-in effects such as worm, sliding, scale, and expand effects, allowing for creative indicator designs.\n\n4. **Flexible Integration**: It can be used with PageView, TabBarView, or any custom scrollable widget, making it versatile for different app layouts.\n\n5. **Performance Optimized**: The package is designed to be lightweight and performant, ensuring smooth operation even on lower-end devices.\n\n## Why Use Smooth Page Indicator?\n\nImplementing a page indicator from scratch can be time-consuming and may not always result in the smooth, polished look that users expect. The `smooth_page_indicator` package solves this problem by providing a ready-to-use solution that not only looks great out of the box but also offers extensive customization options.\n\nBy using this package, developers can:\n- Save development time\n- Ensure consistent behavior across different devices\n- Easily implement complex animations and effects\n- Improve the overall user experience of their app\n\nIn the following sections, we'll dive into a tutorial on how to implement the `smooth_page_indicator` in your Flutter project and explore its various features through a comprehensive example.",
    "shortDescription": "Customizable animated page indicator with a set of built-in effects.",
    "name": "smooth_page_indicator",
    "pubPoint": 160,
    "tags": [
      "page-indicator",
      "dot-indicator",
      "indicator",
      "page-view",
      "navigation",
      "ui"
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-07-19T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CWf9"
  },
  {
    "tutorial": "# Flutter Camera Package Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the camera package in your Flutter application. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the camera package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  camera: ^0.10.0+4\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Platform-Specific Setup\n\n### Android\n\nAdd the following permissions to your `android/app/src/main/AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.CAMERA\" />\n<uses-feature android:name=\"android.hardware.camera\" />\n<uses-feature android:name=\"android.hardware.camera.autofocus\" />\n```\n\n### iOS\n\nAdd the following keys to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>NSCameraUsageDescription</key>\n<string>This app needs access to the camera to take photos and videos.</string>\n<key>NSMicrophoneUsageDescription</key>\n<string>This app needs access to the microphone for video recording.</string>\n```\n\n## Step 3: Implementing Camera Functionality\n\n1. Initialize the camera:\n\n```dart\nlate List<CameraDescription> cameras;\nlate CameraController _controller;\n\n@override\nvoid initState() {\n  super.initState();\n  _initializeCamera();\n}\n\nFuture<void> _initializeCamera() async {\n  cameras = await availableCameras();\n  _controller = CameraController(cameras[0], ResolutionPreset.medium);\n  await _controller.initialize();\n  if (mounted) {\n    setState(() {});\n  }\n}\n```\n\n2. Display the camera preview:\n\n```dart\n@override\nWidget build(BuildContext context) {\n  if (!_controller.value.isInitialized) {\n    return Container();\n  }\n  return AspectRatio(\n    aspectRatio: _controller.value.aspectRatio,\n    child: CameraPreview(_controller),\n  );\n}\n```\n\n3. Capture an image:\n\n```dart\nFuture<void> _takePicture() async {\n  if (!_controller.value.isInitialized) {\n    return;\n  }\n  final XFile file = await _controller.takePicture();\n  // Process the captured image\n}\n```\n\n4. Record a video:\n\n```dart\nFuture<void> _recordVideo() async {\n  if (!_controller.value.isInitialized) {\n    return;\n  }\n  await _controller.startVideoRecording();\n  // Stop recording after a certain duration or user action\n  await _controller.stopVideoRecording();\n}\n```\n\nRemember to dispose of the controller when you're done:\n\n```dart\n@override\nvoid dispose() {\n  _controller.dispose();\n  super.dispose();\n}\n```\n\nBy following these steps, you'll have a basic implementation of the camera package in your Flutter app. In the next section, we'll explore a more comprehensive example that demonstrates additional features and best practices.",
    "author": "flutter.dev",
    "description": "# Flutter Camera Package: Capturing Moments with Ease\n\n## Introduction\n\nThe Flutter camera package is a powerful tool that enables developers to integrate camera functionality into their Flutter applications seamlessly. This package provides a comprehensive set of features for capturing photos and videos, managing camera settings, and handling device-specific configurations.\n\n## Key Features\n\n1. **Photo Capture**: Take high-quality photos with customizable resolution and format options.\n2. **Video Recording**: Record videos with adjustable quality and duration settings.\n3. **Camera Control**: Switch between front and rear cameras, adjust zoom levels, and manage flash modes.\n4. **Preview Stream**: Display a real-time camera preview within your app's user interface.\n5. **Platform-Specific Integration**: Utilize platform-specific camera APIs for optimal performance on both Android and iOS.\n\n## Why Use the Camera Package?\n\nThe camera package simplifies the process of integrating camera functionality into your Flutter app. It handles the complexities of device-specific camera implementations, allowing you to focus on creating a great user experience. Whether you're building a social media app, a document scanner, or an augmented reality experience, the camera package provides the foundation you need to bring your ideas to life.\n\nIn the following sections, we'll dive deeper into how to implement the camera package in your Flutter project and explore its various features through practical examples.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:camera/camera.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late CameraController _controller;\n  late List<CameraDescription> cameras;\n  bool _isReady = false;\n  bool _isRecording = false;\n  int _selectedCameraIdx = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _initializeCamera();\n  }\n\n  // Step 1: Initialize the camera\n  Future<void> _initializeCamera() async {\n    cameras = await availableCameras();\n    _controller = CameraController(cameras[_selectedCameraIdx], ResolutionPreset.high);\n    await _controller.initialize();\n    setState(() {\n      _isReady = true;\n    });\n  }\n\n  // Step 2: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    if (!_isReady) {\n      return Center(child: CircularProgressIndicator());\n    }\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Camera')),\n      body: Column(\n        children: [\n          Expanded(\n            child: AspectRatio(\n              aspectRatio: _controller.value.aspectRatio,\n              child: CameraPreview(_controller),\n            ),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: _takePicture,\n                  child: Icon(Icons.camera),\n                ),\n                ElevatedButton(\n                  onPressed: _toggleRecording,\n                  child: Icon(_isRecording ? Icons.stop : Icons.videocam),\n                ),\n                ElevatedButton(\n                  onPressed: _switchCamera,\n                  child: Icon(Icons.switch_camera),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  // Step 3: Implement photo capture\n  Future<void> _takePicture() async {\n    try {\n      final XFile file = await _controller.takePicture();\n      print('Photo saved to: ${file.path}');\n      // TODO: Add code to display or process the captured image\n    } catch (e) {\n      print('Error taking picture: $e');\n    }\n  }\n\n  // Step 4: Implement video recording\n  Future<void> _toggleRecording() async {\n    if (_isRecording) {\n      final XFile file = await _controller.stopVideoRecording();\n      setState(() {\n        _isRecording = false;\n      });\n      print('Video saved to: ${file.path}');\n      // TODO: Add code to display or process the recorded video\n    } else {\n      await _controller.startVideoRecording();\n      setState(() {\n        _isRecording = true;\n      });\n    }\n  }\n\n  // Step 5: Implement camera switching\n  Future<void> _switchCamera() async {\n    _selectedCameraIdx = (_selectedCameraIdx + 1) % cameras.length;\n    await _controller.dispose();\n    _controller = CameraController(cameras[_selectedCameraIdx], ResolutionPreset.high);\n    await _controller.initialize();\n    setState(() {});\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}\n\n// Application flow:\n// 1. The app starts and initializes the camera in the initState method.\n// 2. Once the camera is initialized, the UI is built with a camera preview and control buttons.\n// 3. Users can take pictures, record videos, or switch cameras using the provided buttons.\n// 4. When a picture is taken or a video is recorded, the file is saved to the device.\n// 5. The app handles camera switching by disposing of the current controller and initializing a new one.\n// 6. When the app is closed, the camera controller is properly disposed of to free up resources.\n\n// Note: This example provides a basic implementation. In a production app, you would want to add:\n// - Error handling and user feedback\n// - Permission checks for camera and microphone access\n// - File management for saving and organizing captured media\n// - UI for displaying captured photos and videos\n// - Additional camera controls (flash, exposure, focus, etc.)\n```",
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8CWkf",
    "_rev": "AE3hjGWNkNE6aGQMMbaSLu",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWFv",
        "_type": "reference",
        "_key": "hx3sc75r"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "likesCount": 2182,
    "_createdAt": "2024-08-28T22:16:11Z",
    "slug": {
      "current": "camera",
      "_type": "slug"
    },
    "shortDescription": "A Flutter plugin for controlling the camera. Supports previewing the camera feed, capturing images and video, and streaming image buffers to Dart.",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "8xvtjz22",
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B"
      }
    ],
    "lastUpdate": "2024-08-05T18:30:00.000Z",
    "name": "camera",
    "_updatedAt": "2024-09-06T04:12:49Z",
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [],
    "tags": [
      "camera",
      "photo",
      "video",
      "image-capture",
      "hardware"
    ],
    "tutorialIncluded": true
  },
  {
    "dependentPackages": [],
    "packageImage": null,
    "lastUpdate": "2024-03-09T18:30:00.000Z",
    "name": "flutter_riverpod",
    "_rev": "eaCZ7mIhmiYZX5KGqJmT6h",
    "description": "# Flutter Riverpod: Simplifying State Management in Flutter\n\n## Introduction\n\nFlutter Riverpod is a powerful state management solution for Flutter applications, designed to be simple, testable, and performant. Created by Remi Rousselet, the same author of the popular Provider package, Riverpod addresses some of the limitations of Provider while maintaining a similar API.\n\n## Key Features\n\n1. **Compile-time safety**: Riverpod leverages Dart's strong type system to catch errors at compile-time, reducing runtime errors.\n\n2. **Provider independence**: Unlike the original Provider package, Riverpod doesn't rely on the Flutter framework, making it usable in any Dart project.\n\n3. **Easy testing**: Riverpod's design makes it straightforward to test your application's state management logic.\n\n4. **Code generation**: With the `riverpod_generator` package, you can reduce boilerplate code and improve maintainability.\n\n5. **Family modifiers**: Easily create providers that depend on external parameters.\n\n6. **Auto-dispose**: Riverpod automatically disposes of providers when they're no longer needed, helping to prevent memory leaks.\n\n## Why Use Riverpod?\n\nRiverpod offers several advantages over other state management solutions:\n\n1. **Simplicity**: Riverpod's API is intuitive and easy to understand, even for developers new to state management.\n\n2. **Flexibility**: It can handle both simple and complex state management scenarios with ease.\n\n3. **Performance**: Riverpod is designed to be efficient, minimizing unnecessary rebuilds.\n\n4. **Maintainability**: With its clear separation of concerns and compile-time safety, Riverpod helps create more maintainable codebases.\n\n5. **Ecosystem**: Riverpod integrates well with other Flutter packages and tools, making it a versatile choice for various projects.\n\nIn the following sections, we'll dive deeper into how to implement Riverpod in your Flutter project and explore its various features through practical examples.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n// Step 1: Define our providers\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\n@riverpod\nFuture<String> fetchWeather(FetchWeatherRef ref) async {\n  // Simulating an API call\n  await Future.delayed(Duration(seconds: 2));\n  return 'Sunny';\n}\n\n@riverpod\nclass ThemeMode extends _$ThemeMode {\n  @override\n  bool build() => false; // false for light, true for dark\n\n  void toggle() => state = !state;\n}\n\n// Step 2: Create our main app\nvoid main() {\n  runApp(ProviderScope(child: RealFlutter()));\n}\n\nclass RealFlutter extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final isDarkMode = ref.watch(themeModeProvider);\n\n    return MaterialApp(\n      theme: isDarkMode ? ThemeData.dark() : ThemeData.light(),\n      home: HomePage(),\n    );\n  }\n}\n\n// Step 3: Create our home page\nclass HomePage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    final weather = ref.watch(fetchWeatherProvider);\n    final isDarkMode = ref.watch(themeModeProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter with Riverpod'),\n        actions: [\n          // Step 4: Add a theme toggle button\n          IconButton(\n            icon: Icon(isDarkMode ? Icons.light_mode : Icons.dark_mode),\n            onPressed: () => ref.read(themeModeProvider.notifier).toggle(),\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 5: Display the counter\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$count',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            SizedBox(height: 20),\n            // Step 6: Display the weather\n            weather.when(\n              data: (data) => Text('Weather: $data'),\n              loading: () => CircularProgressIndicator(),\n              error: (error, stack) => Text('Error: $error'),\n            ),\n          ],\n        ),\n      ),\n      // Step 7: Add a button to increment the counter\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).increment(),\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Application flow:\n// 1. The app starts and initializes the ProviderScope, which makes Riverpod available throughout the app.\n// 2. RealFlutter widget builds the MaterialApp, using the theme based on the themeModeProvider.\n// 3. HomePage is created as the home widget.\n// 4. In HomePage, we watch three providers:\n//    - counterProvider for the count\n//    - fetchWeatherProvider for the weather\n//    - themeModeProvider for the current theme mode\n// 5. The UI displays the current count and weather.\n// 6. When the user presses the FloatingActionButton, it calls increment() on the counterProvider.\n// 7. When the user presses the theme toggle button in the AppBar, it calls toggle() on the themeModeProvider.\n// 8. Any changes to these providers automatically trigger a rebuild of the widgets watching them.\n// 9. The fetchWeatherProvider simulates an API call, showing a loading indicator while fetching and then displaying the result.\n\n// Note: This example demonstrates key Riverpod concepts including:\n// - Using @riverpod for code generation\n// - StateNotifier-like providers (Counter and ThemeMode)\n// - Async data handling with FutureProvider\n// - Watching providers in widgets\n// - Updating provider state\n// Remember to run 'flutter pub run build_runner build' to generate the .g.dart file!\n```",
    "tags": [
      "state-management",
      "dependency-injection",
      "provider",
      "reactive"
    ],
    "_updatedAt": "2024-09-06T04:12:50Z",
    "tutorial": "# Flutter Riverpod Tutorial\n\nIn this tutorial, we'll walk through the process of implementing Riverpod in your Flutter application. We'll cover installation, basic setup, and key concepts.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.3.6\n  riverpod_annotation: ^2.1.1\n\ndev_dependencies:\n  build_runner: ^2.4.6\n  riverpod_generator: ^2.2.3\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Setup\n\nWrap your main app widget with `ProviderScope`:\n\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n## Step 3: Creating Providers\n\nRiverpod offers several types of providers. Here are some common ones:\n\n1. **Provider**: For values that don't change.\n\n```dart\nfinal nameProvider = Provider<String>((ref) => 'John Doe');\n```\n\n2. **StateProvider**: For simple state that can change.\n\n```dart\nfinal counterProvider = StateProvider<int>((ref) => 0);\n```\n\n3. **StateNotifierProvider**: For complex state that can change.\n\n```dart\nclass Counter extends StateNotifier<int> {\n  Counter() : super(0);\n  void increment() => state++;\n}\n\nfinal counterProvider = StateNotifierProvider<Counter, int>((ref) => Counter());\n```\n\n4. **FutureProvider**: For asynchronous data.\n\n```dart\nfinal userProvider = FutureProvider<User>((ref) async {\n  return fetchUser();\n});\n```\n\n## Step 4: Using Providers in Widgets\n\nTo use a provider in a widget, you need to use either `Consumer` or `ConsumerWidget`:\n\n```dart\nclass CounterWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('Count: $count');\n  }\n}\n```\n\n## Step 5: Modifying State\n\nTo modify state, use `ref.read`:\n\n```dart\nElevatedButton(\n  onPressed: () => ref.read(counterProvider.notifier).increment(),\n  child: Text('Increment'),\n)\n```\n\n## Step 6: Using Riverpod Generator\n\nTo reduce boilerplate, you can use the `riverpod_generator` package:\n\n```dart\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'counter.g.dart';\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n```\n\nRun `flutter pub run build_runner build` to generate the code.\n\nRemember, Riverpod is platform-agnostic, so there are no specific platform considerations for Android or iOS. It works seamlessly across all platforms supported by Flutter.\n\nIn the next section, we'll explore a more comprehensive example that demonstrates additional features and best practices of Riverpod.",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CbaN",
        "_type": "reference",
        "_key": "czs8gi83"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CWqB",
    "shortDescription": "A reactive caching and data-binding framework. Riverpod makes working with asynchronous code a breeze.",
    "subCategories": [
      {
        "_key": "dkwnfhfm",
        "_ref": "t8DYBEKn49O4mjbyRAfBIU",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:16:12Z",
    "slug": {
      "current": "flutter_riverpod",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "dash-overflow.net",
    "likesCount": 2408,
    "tutorialIncluded": true
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaSQh",
    "description": "# Flutter Location Package: A Comprehensive Guide\n\n## Introduction\n\nThe location package in Flutter is a powerful tool that allows developers to easily integrate location-based services into their applications. This package provides a simple and intuitive API for accessing device location information, including real-time updates and background location tracking.\n\n## Key Features\n\n1. **Real-time Location Updates**: Get continuous updates of the device's location as it changes.\n2. **Background Location Tracking**: Continue receiving location updates even when the app is not in the foreground.\n3. **Geocoding**: Convert coordinates to human-readable addresses and vice versa.\n4. **Geofencing**: Set up virtual boundaries and receive notifications when the device enters or exits these areas.\n5. **Cross-platform Compatibility**: Works seamlessly on both Android and iOS platforms.\n\n## Why Use the Location Package?\n\nThe location package simplifies the process of integrating location services into your Flutter app. Instead of dealing with platform-specific implementations, you can use a single, unified API to handle location-related tasks across different devices.\n\nWhether you're building a navigation app, a location-based social network, or simply need to add location awareness to your existing application, the location package provides the tools you need to get started quickly and efficiently.\n\nIn the following sections, we'll dive deeper into how to implement and use this package in your Flutter projects.",
    "tags": [
      "location",
      "gps",
      "geolocation",
      "maps",
      "positioning"
    ],
    "name": "location",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:51Z",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1K9L",
        "_type": "reference",
        "_key": "e7m1uduz"
      }
    ],
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGMd",
        "_type": "reference",
        "_key": "f8j2hpcz"
      }
    ],
    "likesCount": 2935,
    "tutorial": "# Flutter Location Package: Tutorial\n\n## Getting Started\n\nTo begin using the location package in your Flutter project, follow these steps:\n\n1. Add the location package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  location: ^5.0.0\n```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:location/location.dart';\n```\n\n## Basic Usage\n\n### Checking Location Services\n\nBefore requesting location, it's important to check if location services are enabled:\n\n```dart\nLocation location = Location();\nbool serviceEnabled = await location.serviceEnabled();\nif (!serviceEnabled) {\n  serviceEnabled = await location.requestService();\n  if (!serviceEnabled) {\n    // Location services are not enabled\n    return;\n  }\n}\n```\n\n### Requesting Permission\n\nNext, request permission to access the device's location:\n\n```dart\nPermissionStatus permissionGranted = await location.hasPermission();\nif (permissionGranted == PermissionStatus.denied) {\n  permissionGranted = await location.requestPermission();\n  if (permissionGranted != PermissionStatus.granted) {\n    // Permission not granted\n    return;\n  }\n}\n```\n\n### Getting Current Location\n\nTo get the current location of the device:\n\n```dart\nLocationData currentLocation = await location.getLocation();\nprint(\"Latitude: ${currentLocation.latitude}, Longitude: ${currentLocation.longitude}\");\n```\n\n### Listening to Location Changes\n\nTo receive real-time location updates:\n\n```dart\nlocation.onLocationChanged.listen((LocationData newLocation) {\n  // Handle new location data\n  print(\"New location: ${newLocation.latitude}, ${newLocation.longitude}\");\n});\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, add the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\nFor background location tracking, add:\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" />\n```\n\n### iOS\n\nFor iOS, add the following keys to your `Info.plist` file:\n\n```xml\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>This app needs access to location when open.</string>\n<key>NSLocationAlwaysUsageDescription</key>\n<string>This app needs access to location when in the background.</string>\n```\n\nFor iOS 13 and above, also add:\n\n```xml\n<key>NSLocationAlwaysAndWhenInUseUsageDescription</key>\n<string>This app needs access to location when open and in the background.</string>\n```\n\nBy following these steps and considering platform-specific requirements, you can effectively implement location services in your Flutter application using the location package.",
    "slug": {
      "current": "location",
      "_type": "slug"
    },
    "author": "bernos.dev",
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "dependentPackages": [
      {
        "_key": "n7satbof",
        "_ref": "uQRNMiDfrp20RZ8Id8CVGj",
        "_type": "reference"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-06-27T18:30:00.000Z",
    "pubPoint": 160,
    "shortDescription": "Cross-platform plugin for easy access to device's location in real-time.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:location/location.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Location Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: LocationDemo(),\n    );\n  }\n}\n\nclass LocationDemo extends StatefulWidget {\n  @override\n  _LocationDemoState createState() => _LocationDemoState();\n}\n\nclass _LocationDemoState extends State<LocationDemo> {\n  Location location = Location();\n  LocationData? _locationData;\n  bool _isListening = false;\n  String _address = \"Not available\";\n\n  @override\n  void initState() {\n    super.initState();\n    _checkLocationPermission();\n  }\n\n  // Step 1: Check and request location permission\n  Future<void> _checkLocationPermission() async {\n    bool serviceEnabled;\n    PermissionStatus permissionGranted;\n\n    // Check if location services are enabled\n    serviceEnabled = await location.serviceEnabled();\n    if (!serviceEnabled) {\n      serviceEnabled = await location.requestService();\n      if (!serviceEnabled) {\n        return;\n      }\n    }\n\n    // Check location permission\n    permissionGranted = await location.hasPermission();\n    if (permissionGranted == PermissionStatus.denied) {\n      permissionGranted = await location.requestPermission();\n      if (permissionGranted != PermissionStatus.granted) {\n        return;\n      }\n    }\n\n    // If we reach here, permission is granted\n    _getLocation();\n  }\n\n  // Step 2: Get current location\n  Future<void> _getLocation() async {\n    try {\n      final locationData = await location.getLocation();\n      setState(() {\n        _locationData = locationData;\n      });\n      _getAddress(); // Get address after getting location\n    } catch (e) {\n      print(\"Error getting location: $e\");\n    }\n  }\n\n  // Step 3: Listen to location changes\n  void _listenLocation() {\n    if (!_isListening) {\n      location.onLocationChanged.listen((LocationData currentLocation) {\n        setState(() {\n          _locationData = currentLocation;\n          _getAddress(); // Update address when location changes\n        });\n      });\n      setState(() {\n        _isListening = true;\n      });\n    }\n  }\n\n  // Step 4: Stop listening to location changes\n  void _stopListening() {\n    location.onLocationChanged.pause();\n    setState(() {\n      _isListening = false;\n    });\n  }\n\n  // Step 5: Get address from coordinates (Geocoding)\n  Future<void> _getAddress() async {\n    // Note: In a real application, you would use a Geocoding service here.\n    // For this example, we'll just use a placeholder.\n    setState(() {\n      _address = \"123 Flutter St, Dart City, Widget Country\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Location Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'Current Location:',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 10),\n            Text(\n              _locationData != null\n                  ? 'Lat: ${_locationData!.latitude}, Lng: ${_locationData!.longitude}'\n                  : 'Location not available',\n              style: TextStyle(fontSize: 16),\n            ),\n            SizedBox(height: 20),\n            Text(\n              'Address:',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 10),\n            Text(\n              _address,\n              style: TextStyle(fontSize: 16),\n            ),\n            SizedBox(height: 30),\n            ElevatedButton(\n              onPressed: _getLocation,\n              child: Text('Get Current Location'),\n            ),\n            SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _isListening ? _stopListening : _listenLocation,\n              child: Text(_isListening ? 'Stop Listening' : 'Start Listening'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and checks for location permission.\n// 2. If permission is granted, it fetches the current location.\n// 3. The user can press \"Get Current Location\" to update the location manually.\n// 4. The user can toggle \"Start Listening\" to receive real-time location updates.\n// 5. Each time the location is updated, the app simulates fetching an address (geocoding).\n// 6. The UI updates to reflect the latest location and address information.\n\n// Note: In a real-world scenario, you would implement actual geocoding to convert\n// coordinates to addresses, handle error cases more robustly, and possibly\n// implement background location tracking for more advanced use cases.\n```",
    "_createdAt": "2024-08-28T22:16:14Z",
    "_id": "uQRNMiDfrp20RZ8Id8CWvh"
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaSVU",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\n\n// Step 1: Define the DatabaseHelper class\nclass DatabaseHelper {\n  static final DatabaseHelper _instance = DatabaseHelper._internal();\n  static Database? _database;\n\n  factory DatabaseHelper() => _instance;\n\n  DatabaseHelper._internal();\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  // Step 2: Initialize the database\n  Future<Database> _initDatabase() async {\n    String path = join(await getDatabasesPath(), 'real_flutter.db');\n    return await openDatabase(\n      path,\n      version: 1,\n      onCreate: _onCreate,\n    );\n  }\n\n  // Step 3: Create the users table\n  Future<void> _onCreate(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE users(\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        email TEXT\n      )\n    ''');\n  }\n\n  // Step 4: Implement CRUD operations\n  Future<int> insertUser(Map<String, dynamic> row) async {\n    Database db = await database;\n    return await db.insert('users', row);\n  }\n\n  Future<List<Map<String, dynamic>>> queryAllUsers() async {\n    Database db = await database;\n    return await db.query('users');\n  }\n\n  Future<int> updateUser(Map<String, dynamic> row) async {\n    Database db = await database;\n    int id = row['id'];\n    return await db.update('users', row, where: 'id = ?', whereArgs: [id]);\n  }\n\n  Future<int> deleteUser(int id) async {\n    Database db = await database;\n    return await db.delete('users', where: 'id = ?', whereArgs: [id]);\n  }\n}\n\n// Step 5: Create the main RealFlutter class\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final dbHelper = DatabaseHelper();\n  List<Map<String, dynamic>> users = [];\n\n  TextEditingController nameController = TextEditingController();\n  TextEditingController emailController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _refreshUsersList();\n  }\n\n  // Step 6: Implement UI update method\n  void _refreshUsersList() async {\n    final allUsers = await dbHelper.queryAllUsers();\n    setState(() {\n      users = allUsers;\n    });\n  }\n\n  // Step 7: Implement add user method\n  void _addUser() async {\n    await dbHelper.insertUser({\n      'name': nameController.text,\n      'email': emailController.text,\n    });\n    _refreshUsersList();\n    nameController.clear();\n    emailController.clear();\n  }\n\n  // Step 8: Implement update user method\n  void _updateUser(int id) async {\n    await dbHelper.updateUser({\n      'id': id,\n      'name': nameController.text,\n      'email': emailController.text,\n    });\n    _refreshUsersList();\n    nameController.clear();\n    emailController.clear();\n  }\n\n  // Step 9: Implement delete user method\n  void _deleteUser(int id) async {\n    await dbHelper.deleteUser(id);\n    _refreshUsersList();\n  }\n\n  // Step 10: Build the UI\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('RealFlutter SQLite Example'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: nameController,\n              decoration: InputDecoration(labelText: 'Name'),\n            ),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: emailController,\n              decoration: InputDecoration(labelText: 'Email'),\n            ),\n          ),\n          ElevatedButton(\n            onPressed: _addUser,\n            child: Text('Add User'),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: users.length,\n              itemBuilder: (context, index) {\n                return ListTile(\n                  title: Text(users[index]['name']),\n                  subtitle: Text(users[index]['email']),\n                  trailing: Row(\n                    mainAxisSize: MainAxisSize.min,\n                    children: [\n                      IconButton(\n                        icon: Icon(Icons.edit),\n                        onPressed: () {\n                          nameController.text = users[index]['name'];\n                          emailController.text = users[index]['email'];\n                          _updateUser(users[index]['id']);\n                        },\n                      ),\n                      IconButton(\n                        icon: Icon(Icons.delete),\n                        onPressed: () => _deleteUser(users[index]['id']),\n                      ),\n                    ],\n                  ),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 11: Run the app\nvoid main() {\n  runApp(MaterialApp(home: RealFlutter()));\n}\n\n// Application Flow:\n// 1. The app starts by initializing the DatabaseHelper and creating the database if it doesn't exist.\n// 2. The RealFlutter widget is created, which manages the state of the user list and UI.\n// 3. In initState, the app fetches all users from the database and displays them in a list.\n// 4. Users can add new users by entering a name and email and tapping the \"Add User\" button.\n// 5. Existing users can be updated by tapping the edit icon, which populates the text fields with the user's data.\n//    After editing, tapping the \"Add User\" button will update the user's information.\n// 6. Users can be deleted by tapping the delete icon next to each user in the list.\n// 7. After each operation (add, update, delete), the user list is refreshed to reflect the changes in the database.\n\n// This example demonstrates the basic CRUD operations using sqflite in a Flutter app.\n// It provides a simple interface for managing a list of users, showcasing how to integrate\n// SQLite database operations with Flutter's UI components.\n```",
    "likesCount": 4902,
    "packageImage": null,
    "pubPoint": 160,
    "description": "# SQLite in Flutter: Introduction to sqflite\n\nSQLite is a popular choice for local data storage in mobile applications, and Flutter provides excellent support for it through the `sqflite` package. This lightweight, serverless database engine is perfect for storing and managing structured data within your Flutter apps.\n\n## What is sqflite?\n\n`sqflite` is a Flutter plugin that provides a powerful and easy-to-use interface for working with SQLite databases. It allows developers to perform various database operations, such as creating tables, inserting data, querying records, and managing transactions.\n\n## Key Features of sqflite\n\n1. **Cross-platform compatibility**: Works seamlessly on both iOS and Android.\n2. **ACID compliance**: Ensures data integrity through Atomicity, Consistency, Isolation, and Durability.\n3. **SQL support**: Allows you to write raw SQL queries for complex operations.\n4. **Asynchronous operations**: Provides non-blocking database operations to keep your app responsive.\n5. **Transaction support**: Enables you to group multiple operations into a single, atomic transaction.\n6. **Batch operations**: Allows you to execute multiple SQL commands in a single call.\n\n## When to Use sqflite\n\nConsider using sqflite in your Flutter projects when:\n\n- You need to store structured data locally on the device.\n- Your app requires offline data access and manipulation.\n- You want to implement caching mechanisms for better performance.\n- You need to handle complex data relationships and queries.\n\nIn the following sections, we'll dive deeper into how to set up and use sqflite in your Flutter applications, along with a practical example to demonstrate its capabilities.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGH6",
        "_type": "reference",
        "_key": "eiphqory"
      }
    ],
    "tags": [
      "sql",
      "database",
      "sqlite",
      "local-storage",
      "persistence"
    ],
    "name": "sqflite",
    "_id": "uQRNMiDfrp20RZ8Id8CX1D",
    "shortDescription": "Flutter plugin for SQLite, a self-contained, high-reliability, embedded, SQL database engine.",
    "lastUpdate": "2024-05-01T18:30:00.000Z",
    "slug": {
      "current": "sqflite",
      "_type": "slug"
    },
    "_updatedAt": "2024-09-06T04:12:52Z",
    "author": "tekartik.com",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "macos"
    ],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "il2d28ze",
        "_ref": "Rx1Nho763d29lawKra1L7f"
      },
      {
        "_type": "reference",
        "_key": "gzpx429s",
        "_ref": "V06bsD4sX3T8NTHrBPah4K"
      }
    ],
    "_createdAt": "2024-08-28T22:16:15Z",
    "tutorial": "# Getting Started with sqflite: A Step-by-Step Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using sqflite in a Flutter project. We'll cover installation, database creation, and basic CRUD operations.\n\n## Step 1: Add sqflite to Your Project\n\nFirst, add the sqflite package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^2.3.0\n  path: ^1.8.3\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Import the Required Packages\n\nIn your Dart file, import the necessary packages:\n\n```dart\nimport 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\n```\n\n## Step 3: Create a Database Helper Class\n\nCreate a new file called `database_helper.dart` and define a `DatabaseHelper` class:\n\n```dart\nclass DatabaseHelper {\n  static final DatabaseHelper _instance = DatabaseHelper._internal();\n  static Database? _database;\n\n  factory DatabaseHelper() => _instance;\n\n  DatabaseHelper._internal();\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future<Database> _initDatabase() async {\n    String path = join(await getDatabasesPath(), 'real_flutter.db');\n    return await openDatabase(\n      path,\n      version: 1,\n      onCreate: _onCreate,\n    );\n  }\n\n  Future<void> _onCreate(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE users(\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        email TEXT\n      )\n    ''');\n  }\n}\n```\n\n## Step 4: Implement CRUD Operations\n\nAdd the following methods to your `DatabaseHelper` class:\n\n```dart\nclass DatabaseHelper {\n  // ... (previous code)\n\n  Future<int> insertUser(Map<String, dynamic> row) async {\n    Database db = await database;\n    return await db.insert('users', row);\n  }\n\n  Future<List<Map<String, dynamic>>> queryAllUsers() async {\n    Database db = await database;\n    return await db.query('users');\n  }\n\n  Future<int> updateUser(Map<String, dynamic> row) async {\n    Database db = await database;\n    int id = row['id'];\n    return await db.update('users', row, where: 'id = ?', whereArgs: [id]);\n  }\n\n  Future<int> deleteUser(int id) async {\n    Database db = await database;\n    return await db.delete('users', where: 'id = ?', whereArgs: [id]);\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, you don't need to do any additional setup. The sqflite plugin will work out of the box.\n\n### iOS\n\nFor iOS, you need to add the following to your `Podfile`:\n\n```ruby\nplatform :ios, '9.0'\n```\n\nThis ensures that your app uses a version of iOS that supports SQLite.\n\n## Using the DatabaseHelper in Your App\n\nNow you can use the `DatabaseHelper` class in your Flutter app to perform database operations. Here's a quick example:\n\n```dart\nfinal dbHelper = DatabaseHelper();\n\n// Insert a user\nint id = await dbHelper.insertUser({\n  'name': 'John Doe',\n  'email': 'john@example.com'\n});\n\n// Query all users\nList<Map<String, dynamic>> allUsers = await dbHelper.queryAllUsers();\n\n// Update a user\nawait dbHelper.updateUser({\n  'id': 1,\n  'name': 'Jane Doe',\n  'email': 'jane@example.com'\n});\n\n// Delete a user\nawait dbHelper.deleteUser(1);\n```\n\nIn the next section, we'll create a complete example that demonstrates these operations in a Flutter app.",
    "tutorialIncluded": true
  },
  {
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_type": "package",
    "description": "# Percent Indicator Package in Flutter\n\n## Description\n\nThe `percent_indicator` package is a powerful and flexible Flutter library that allows developers to create visually appealing and customizable progress indicators. These indicators can be used to represent percentages, loading states, or any other numerical progress in your Flutter applications.\n\nKey features of the `percent_indicator` package include:\n\n1. **Circular and Linear Indicators**: The package provides both circular and linear progress indicators, giving developers the flexibility to choose the best visual representation for their use case.\n\n2. **Customization Options**: Developers can easily customize various aspects of the indicators, such as colors, sizes, animations, and text styles.\n\n3. **Animation Support**: The package includes built-in animation capabilities, allowing for smooth transitions when updating progress values.\n\n4. **Reverse Direction**: Both circular and linear indicators support reverse direction, enabling right-to-left or counterclockwise progress display.\n\n5. **Center Widget**: For circular indicators, you can add a custom widget at the center, enhancing the visual appeal and information display.\n\n6. **Gradients**: The package supports the use of gradients for progress bars, adding an extra layer of visual polish to your indicators.\n\n7. **Responsiveness**: The indicators are designed to be responsive and work well across different screen sizes and orientations.\n\nBy leveraging the `percent_indicator` package, Flutter developers can create engaging and informative progress displays that enhance the user experience of their applications. Whether you're building a fitness app, a file upload feature, or a quiz interface, this package provides the tools to represent progress effectively and beautifully.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 2533,
    "name": "percent_indicator",
    "slug": {
      "current": "percent_indicator",
      "_type": "slug"
    },
    "author": "diegoveloper.com",
    "shortDescription": "Library that allows you to display progress widgets based on percentage, can be Circular or Linear, you can also customize it to your needs.",
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:percent_indicator/percent_indicator.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Percent Indicator Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const PercentIndicatorDemo(),\n    );\n  }\n}\n\nclass PercentIndicatorDemo extends StatefulWidget {\n  const PercentIndicatorDemo({Key? key}) : super(key: key);\n\n  @override\n  _PercentIndicatorDemoState createState() => _PercentIndicatorDemoState();\n}\n\nclass _PercentIndicatorDemoState extends State<PercentIndicatorDemo> {\n  double _circularPercent = 0.0;\n  double _linearPercent = 0.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Percent Indicator Demo')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.center,\n          children: [\n            // Step 1: Basic Circular Percent Indicator\n            CircularPercentIndicator(\n              radius: 100.0,\n              lineWidth: 10.0,\n              percent: _circularPercent,\n              center: Text(\"${(_circularPercent * 100).toStringAsFixed(1)}%\"),\n              progressColor: Colors.green,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 2: Animated Circular Percent Indicator\n            CircularPercentIndicator(\n              radius: 120.0,\n              lineWidth: 13.0,\n              animation: true,\n              animationDuration: 1200,\n              percent: _circularPercent,\n              center: Text(\"${(_circularPercent * 100).toStringAsFixed(1)}%\"),\n              circularStrokeCap: CircularStrokeCap.round,\n              progressColor: Colors.purple,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 3: Basic Linear Percent Indicator\n            LinearPercentIndicator(\n              width: MediaQuery.of(context).size.width - 50,\n              lineHeight: 20.0,\n              percent: _linearPercent,\n              center: Text(\"${(_linearPercent * 100).toStringAsFixed(1)}%\"),\n              progressColor: Colors.blue,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 4: Animated Linear Percent Indicator with Gradient\n            LinearPercentIndicator(\n              width: MediaQuery.of(context).size.width - 50,\n              animation: true,\n              animationDuration: 1000,\n              lineHeight: 20.0,\n              percent: _linearPercent,\n              center: Text(\"${(_linearPercent * 100).toStringAsFixed(1)}%\"),\n              linearGradient: const LinearGradient(\n                colors: [Colors.red, Colors.orange, Colors.yellow],\n              ),\n              linearStrokeCap: LinearStrokeCap.roundAll,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 5: Buttons to update progress\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: _incrementProgress,\n                  child: const Text('Increment'),\n                ),\n                ElevatedButton(\n                  onPressed: _decrementProgress,\n                  child: const Text('Decrement'),\n                ),\n                ElevatedButton(\n                  onPressed: _resetProgress,\n                  child: const Text('Reset'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 6: Methods to update progress\n  void _incrementProgress() {\n    setState(() {\n      _circularPercent = (_circularPercent + 0.1).clamp(0.0, 1.0);\n      _linearPercent = (_linearPercent + 0.1).clamp(0.0, 1.0);\n    });\n  }\n\n  void _decrementProgress() {\n    setState(() {\n      _circularPercent = (_circularPercent - 0.1).clamp(0.0, 1.0);\n      _linearPercent = (_linearPercent - 0.1).clamp(0.0, 1.0);\n    });\n  }\n\n  void _resetProgress() {\n    setState(() {\n      _circularPercent = 0.0;\n      _linearPercent = 0.0;\n    });\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp and theme.\n// 2. The PercentIndicatorDemo widget is created as the home screen.\n// 3. In the PercentIndicatorDemo, we initialize two variables: _circularPercent and _linearPercent to 0.0.\n// 4. The build method creates a Scaffold with an AppBar and a SingleChildScrollView containing our indicators.\n// 5. We create two CircularPercentIndicators and two LinearPercentIndicators, each demonstrating different features:\n//    - Basic circular indicator\n//    - Animated circular indicator\n//    - Basic linear indicator\n//    - Animated linear indicator with gradient\n// 6. Three buttons are added to control the progress:\n//    - Increment: Increases both circular and linear progress by 10%\n//    - Decrement: Decreases both circular and linear progress by 10%\n//    - Reset: Sets both progress values back to 0%\n// 7. When a button is pressed, it calls the corresponding method (_incrementProgress, _decrementProgress, or _resetProgress).\n// 8. These methods update the _circularPercent and _linearPercent values using setState, which triggers a rebuild of the widget.\n// 9. The rebuild causes the indicators to update their display based on the new percent values.\n// 10. The process repeats as the user interacts with the buttons, allowing them to see the various features of the percent_indicator package in action.\n```",
    "_id": "uQRNMiDfrp20RZ8Id8CXAP",
    "_updatedAt": "2024-09-06T04:12:53Z",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFqE",
        "_type": "reference",
        "_key": "04tqv3sf"
      }
    ],
    "tutorial": "# Percent Indicator Package Tutorial\n\n## Getting Started\n\nTo use the `percent_indicator` package in your Flutter project, follow these steps:\n\n1. Add the dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  percent_indicator: ^4.0.1\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:percent_indicator/percent_indicator.dart';\n```\n\n## Basic Usage\n\n### Circular Percent Indicator\n\nTo create a basic circular percent indicator:\n\n```dart\nCircularPercentIndicator(\n  radius: 60.0,\n  lineWidth: 5.0,\n  percent: 0.75,\n  center: Text(\"75%\"),\n  progressColor: Colors.green,\n)\n```\n\n### Linear Percent Indicator\n\nTo create a basic linear percent indicator:\n\n```dart\nLinearPercentIndicator(\n  width: 140.0,\n  lineHeight: 14.0,\n  percent: 0.5,\n  center: Text(\"50.0%\"),\n  linearStrokeCap: LinearStrokeCap.roundAll,\n  progressColor: Colors.blue,\n)\n```\n\n## Advanced Features\n\n### Animations\n\nTo add animations to your indicators:\n\n```dart\nCircularPercentIndicator(\n  radius: 100.0,\n  lineWidth: 10.0,\n  percent: 0.8,\n  animation: true,\n  animationDuration: 1200,\n  center: Text(\"80%\"),\n  progressColor: Colors.green,\n)\n```\n\n### Gradients\n\nTo use gradients in your indicators:\n\n```dart\nLinearPercentIndicator(\n  width: 170.0,\n  animation: true,\n  animationDuration: 1000,\n  lineHeight: 20.0,\n  percent: 0.7,\n  center: Text(\"70.0%\"),\n  linearGradient: LinearGradient(\n    colors: [Colors.red, Colors.orange],\n  ),\n)\n```\n\n### Reverse Direction\n\nTo reverse the direction of the indicator:\n\n```dart\nCircularPercentIndicator(\n  radius: 60.0,\n  lineWidth: 5.0,\n  percent: 0.6,\n  reverse: true,\n  center: Text(\"60%\"),\n  progressColor: Colors.blue,\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nWhen using `percent_indicator` in iOS, ensure that you're using the latest version of Xcode and have updated your `ios/Podfile` to use the appropriate iOS version:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n### Android\n\nFor Android, make sure your `android/app/build.gradle` file has the correct minimum SDK version:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### Web\n\nThe `percent_indicator` package is compatible with Flutter web applications. However, ensure that you're using a modern web browser for the best performance and visual consistency.\n\nBy following this tutorial and considering the platform-specific details, you can effectively implement and customize percent indicators in your Flutter applications across different platforms.",
    "_rev": "eaCZ7mIhmiYZX5KGqJmTDF",
    "tags": [
      "progress",
      "indicator",
      "percentage",
      "ui",
      "circular",
      "linear"
    ],
    "dependentPackages": [],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-bf3a6caa562f0842cd878753198eb65a615a75be-268x480-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:16:21Z",
    "lastUpdate": "2023-03-02T18:30:00.000Z"
  },
  {
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWma",
        "_type": "reference",
        "_key": "anxatu3m"
      }
    ],
    "tags": [
      "authentication",
      "apple",
      "sign-in",
      "oauth",
      "identity"
    ],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:12:54Z",
    "slug": {
      "current": "sign_in_with_apple",
      "_type": "slug"
    },
    "pubPoint": 160,
    "similarPackages": [
      {
        "_key": "98xesqks",
        "_ref": "V06bsD4sX3T8NTHrBPaLDY",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:sign_in_with_apple/sign_in_with_apple.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Sign in with Apple Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SignInPage(),\n    );\n  }\n}\n\nclass SignInPage extends StatefulWidget {\n  @override\n  _SignInPageState createState() => _SignInPageState();\n}\n\nclass _SignInPageState extends State<SignInPage> {\n  // Step 1: Initialize variables to store user information\n  String? userIdentifier;\n  String? userEmail;\n  String? userName;\n\n  // Step 2: Implement the sign in with Apple method\n  Future<void> signInWithApple() async {\n    try {\n      // Step 3: Request credential for the user\n      final credential = await SignInWithApple.getAppleIDCredential(\n        scopes: [\n          AppleIDAuthorizationScopes.email,\n          AppleIDAuthorizationScopes.fullName,\n        ],\n      );\n\n      // Step 4: Update the UI with user information\n      setState(() {\n        userIdentifier = credential.userIdentifier;\n        userEmail = credential.email;\n        userName = '${credential.givenName} ${credential.familyName}';\n      });\n\n      // Step 5: Here you would typically send the credential to your server\n      print('User identifier: $userIdentifier');\n      if (userEmail != null) print('User email: $userEmail');\n      if (userName != null) print('User name: $userName');\n\n    } catch (error) {\n      print(\"Sign in with Apple failed: $error\");\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Sign in with Apple Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 6: Display the Sign in with Apple button\n            SignInWithAppleButton(\n              onPressed: signInWithApple,\n              style: SignInWithAppleButtonStyle.black,\n            ),\n            SizedBox(height: 20),\n            // Step 7: Display user information if available\n            if (userIdentifier != null)\n              Text('Signed in with user ID: $userIdentifier'),\n            if (userEmail != null)\n              Text('User email: $userEmail'),\n            if (userName != null)\n              Text('User name: $userName'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. SignInPage is set as the home page.\n// 3. In SignInPage, we display a Sign in with Apple button.\n// 4. When the button is pressed, it calls the signInWithApple() method.\n// 5. signInWithApple() uses SignInWithApple.getAppleIDCredential to request\n//    the user's credentials.\n// 6. If successful, the method updates the state with the user's information.\n// 7. The UI is rebuilt to display the user's information.\n// 8. If an error occurs during sign-in, it's caught and printed to the console.\n\n// Note: This example demonstrates the basic flow of Sign in with Apple.\n// In a real application, you would typically:\n// - Send the credential to your server for verification\n// - Implement proper error handling and user feedback\n// - Store the user's sign-in state securely\n// - Handle cases where the user denies permission for email or name\n```",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web"
    ],
    "name": "sign_in_with_apple",
    "tutorialIncluded": true,
    "_type": "package",
    "shortDescription": "Flutter bridge to initiate Sign in with Apple (on iOS, macOS, and Android). Includes support for keychain entries as well as signing in with an Apple ID.",
    "_id": "uQRNMiDfrp20RZ8Id8CYnX",
    "description": "# Sign in with Apple: Streamlining iOS Authentication in Flutter\n\nIn the ever-evolving landscape of mobile app development, providing secure and user-friendly authentication options is crucial. The sign_in_with_apple package for Flutter offers a seamless way to implement Apple's authentication system, enhancing user experience and security for iOS users.\n\n## What is Sign in with Apple?\n\nSign in with Apple is an authentication method introduced by Apple in iOS 13. It allows users to sign in to apps and websites using their Apple ID, providing a quick, easy, and privacy-preserving alternative to traditional email-based sign-ups.\n\n## Key Features of the sign_in_with_apple Package\n\n1. **Easy Integration**: Simplifies the process of adding Sign in with Apple functionality to Flutter apps.\n2. **Cross-Platform Support**: While primarily for iOS, it also supports macOS and web platforms.\n3. **Customizable UI**: Offers flexibility in button design to match your app's aesthetics.\n4. **Secure Authentication**: Leverages Apple's robust security measures to protect user data.\n5. **Privacy-Focused**: Provides options for users to hide their email addresses from app developers.\n\n## Why Use the sign_in_with_apple Package?\n\n- **Enhanced User Experience**: Offers a quick and familiar sign-in option for iOS users.\n- **Increased Trust**: Leverages Apple's reputation for privacy and security.\n- **Compliance**: Helps meet Apple's requirement for apps that use third-party sign-in options to also offer Sign in with Apple.\n- **Reduced Development Time**: Simplifies the implementation of a complex authentication system.\n- **Future-Proofing**: Ensures your app is ready for evolving iOS authentication standards.\n\nIn the following sections, we'll dive into a hands-on tutorial and explore a comprehensive example showcasing the full potential of the sign_in_with_apple package in Flutter.",
    "dependentPackages": [],
    "likesCount": 1859,
    "_createdAt": "2024-08-28T22:16:26Z",
    "lastUpdate": "2024-08-26T18:30:00.000Z",
    "tutorial": "# Tutorial: Implementing Sign in with Apple in Your Flutter App\n\nThis tutorial will guide you through the process of adding Sign in with Apple functionality to your Flutter application using the sign_in_with_apple package.\n\n## Step 1: Installation\n\nAdd the sign_in_with_apple package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  sign_in_with_apple: ^5.0.0  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: iOS Configuration\n\n1. In Xcode, open your project's `Runner.xcworkspace`.\n2. Select the \"Runner\" target and go to the \"Signing & Capabilities\" tab.\n3. Click the \"+ Capability\" button and add \"Sign In with Apple\".\n4. In your `Info.plist`, add the following:\n\n```xml\n<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>signinwithapple</string>\n    </array>\n  </dict>\n</array>\n```\n\n## Step 3: Import the Package\n\nIn your Dart file, import the sign_in_with_apple package:\n\n```dart\nimport 'package:sign_in_with_apple/sign_in_with_apple.dart';\n```\n\n## Step 4: Implement Sign in with Apple\n\nHere's a basic implementation:\n\n```dart\nFuture<void> signInWithApple() async {\n  final credential = await SignInWithApple.getAppleIDCredential(\n    scopes: [\n      AppleIDAuthorizationScopes.email,\n      AppleIDAuthorizationScopes.fullName,\n    ],\n  );\n\n  // Use the credential.userIdentifier for your app's authentication\n  print(credential.userIdentifier);\n  \n  // If this is the first sign in, you might also want to use:\n  // credential.email\n  // credential.givenName\n  // credential.familyName\n}\n```\n\n## Step 5: Add the Sign in with Apple Button\n\nYou can use the built-in button or create a custom one:\n\n```dart\nSignInWithAppleButton(\n  onPressed: () {\n    signInWithApple();\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure your app's capabilities include \"Sign In with Apple\" in Xcode.\n- The button style automatically adapts to the iOS version and appearance settings.\n\n```dart\nSignInWithAppleButton(\n  onPressed: signInWithApple,\n  style: SignInWithAppleButtonStyle.black, // or .whiteOutlined for light backgrounds\n)\n```\n\n### Android\n- Sign in with Apple is not natively supported on Android.\n- Consider offering alternative sign-in methods for Android users.\n\n### Web\n- For web support, you need to configure your Apple Developer account and set up your domain.\n- Use the `webAuthenticationOptions` parameter when calling `getAppleIDCredential`:\n\n```dart\nawait SignInWithApple.getAppleIDCredential(\n  webAuthenticationOptions: WebAuthenticationOptions(\n    clientId: 'your.client.id',\n    redirectUri: Uri.parse('https://your-redirect-uri.com/callbacks/sign_in_with_apple'),\n  ),\n  // ... other parameters\n);\n```\n\nBy following these guidelines, you can implement Sign in with Apple across different platforms while maintaining a consistent user experience.",
    "author": "aboutyou.com",
    "_rev": "AE3hjGWNkNE6aGQMMbaSdT"
  },
  {
    "author": "getx.site",
    "description": "# get_storage Package: A Powerful Key-Value Storage Solution for Flutter\n\n## Introduction\n\nThe `get_storage` package is a lightweight and efficient key-value storage solution for Flutter applications. It provides a simple and fast way to store and retrieve data locally on the device. This package is particularly useful for caching data, storing user preferences, and managing application state.\n\n## Key Features\n\n1. **Fast Performance**: `get_storage` uses memory mapping techniques to provide rapid read and write operations, making it significantly faster than traditional storage solutions.\n\n2. **Cross-Platform Compatibility**: The package works seamlessly across multiple platforms, including iOS, Android, Web, and desktop environments.\n\n3. **Type Safety**: `get_storage` supports storing and retrieving various data types, including strings, numbers, booleans, lists, and maps, while maintaining type safety.\n\n4. **Reactive Storage**: It offers reactive capabilities, allowing you to listen for changes in stored values and update your UI accordingly.\n\n5. **Encryption Support**: For sensitive data, `get_storage` provides built-in encryption options to enhance security.\n\n6. **Synchronous and Asynchronous Operations**: The package supports both synchronous and asynchronous read/write operations, giving developers flexibility in their implementation.\n\n7. **No SQLite Dependency**: Unlike some other storage solutions, `get_storage` doesn't rely on SQLite, making it lighter and easier to integrate into your projects.\n\n## When to Use get_storage\n\n- Storing user preferences\n- Caching API responses\n- Managing application state\n- Implementing offline-first functionality\n- Storing small to medium-sized datasets\n\nIn the following sections, we'll dive deeper into how to implement `get_storage` in your Flutter projects and explore its various features through practical examples.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGEj",
        "_type": "reference",
        "_key": "soelzwvj"
      }
    ],
    "_createdAt": "2024-08-28T22:16:45Z",
    "name": "get_storage",
    "_id": "uQRNMiDfrp20RZ8Id8CZ7l",
    "tutorial": "# get_storage Package Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the `get_storage` package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  get_storage: ^2.1.1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Initialization\n\nBefore using `get_storage`, you need to initialize it. Add the following code to your `main.dart` file:\n\n```dart\nimport 'package:get_storage/get_storage.dart';\n\nvoid main() async {\n  await GetStorage.init();\n  runApp(RealFlutter());\n}\n```\n\n## Step 3: Basic Usage\n\n### Writing Data\n\nTo write data to storage, use the `write` method:\n\n```dart\nfinal box = GetStorage();\nbox.write('username', 'JohnDoe');\nbox.write('isLoggedIn', true);\nbox.write('age', 30);\n```\n\n### Reading Data\n\nTo read data from storage, use the `read` method:\n\n```dart\nfinal box = GetStorage();\nString username = box.read('username') ?? 'Guest';\nbool isLoggedIn = box.read('isLoggedIn') ?? false;\nint age = box.read('age') ?? 0;\n```\n\n### Removing Data\n\nTo remove data from storage, use the `remove` method:\n\n```dart\nfinal box = GetStorage();\nbox.remove('username');\n```\n\n### Listening for Changes\n\nYou can listen for changes in a specific key:\n\n```dart\nfinal box = GetStorage();\nbox.listenKey('username', (value) {\n  print('Username changed to: $value');\n});\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional configuration is required. The package uses the `SharedPreferences` API under the hood.\n\n### iOS\n\nFor iOS, no additional configuration is required. The package uses the `UserDefaults` API under the hood.\n\n### Web\n\nFor web applications, `get_storage` uses the browser's local storage. Ensure that your web server's Content Security Policy (CSP) allows access to local storage.\n\n### Desktop (Windows, macOS, Linux)\n\nFor desktop platforms, `get_storage` creates a file in the application's documents directory. No additional configuration is required.\n\n## Advanced Usage\n\n### Using Multiple Containers\n\nYou can create multiple storage containers:\n\n```dart\nfinal settings = GetStorage('settings');\nfinal cache = GetStorage('cache');\n\nsettings.write('theme', 'dark');\ncache.write('apiResponse', responseData);\n```\n\n### Encryption\n\nTo use encryption, provide an encryption key when initializing:\n\n```dart\nawait GetStorage.init('settings', encryptionKey: 'your_secret_key');\nfinal settings = GetStorage('settings');\n```\n\nThis tutorial covers the basics of using `get_storage` in your Flutter application. In the next section, we'll look at a complete example that demonstrates these features in action.",
    "pubPoint": 160,
    "shortDescription": "A fast, extra light and synchronous key-value storage written entirely in Dart",
    "similarPackages": [],
    "likesCount": 1704,
    "packageImage": null,
    "tutorialIncluded": true,
    "slug": {
      "current": "get_storage",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmTJn",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:get_storage/get_storage.dart';\n\n// Step 1: Initialize GetStorage\nvoid main() async {\n  await GetStorage.init();\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'GetStorage Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: StorageDemo(),\n    );\n  }\n}\n\nclass StorageDemo extends StatefulWidget {\n  @override\n  _StorageDemoState createState() => _StorageDemoState();\n}\n\nclass _StorageDemoState extends State<StorageDemo> {\n  // Step 2: Create a GetStorage instance\n  final box = GetStorage();\n  \n  TextEditingController _controller = TextEditingController();\n  String _storedValue = '';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Read initial value from storage\n    _storedValue = box.read('myKey') ?? 'No value stored';\n    \n    // Step 4: Listen for changes in the stored value\n    box.listenKey('myKey', (value) {\n      setState(() {\n        _storedValue = value ?? 'No value stored';\n      });\n    });\n  }\n\n  // Step 5: Write value to storage\n  void _writeToStorage() {\n    String value = _controller.text;\n    box.write('myKey', value);\n    _controller.clear();\n  }\n\n  // Step 6: Remove value from storage\n  void _removeFromStorage() {\n    box.remove('myKey');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('GetStorage Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            TextField(\n              controller: _controller,\n              decoration: InputDecoration(labelText: 'Enter a value'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _writeToStorage,\n              child: Text('Save to Storage'),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _removeFromStorage,\n              child: Text('Remove from Storage'),\n            ),\n            SizedBox(height: 20),\n            Text('Stored Value: $_storedValue'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app initializes GetStorage in the main function.\n// 2. RealFlutter widget sets up the MaterialApp and defines the home screen.\n// 3. StorageDemo widget creates the main UI for interacting with GetStorage.\n// 4. In initState:\n//    - The app reads the initial value from storage.\n//    - It sets up a listener for changes to the 'myKey' value.\n// 5. The UI provides:\n//    - A TextField for entering new values.\n//    - A button to save the entered value to storage.\n//    - A button to remove the value from storage.\n//    - A Text widget to display the current stored value.\n// 6. When the user enters a value and taps \"Save to Storage\":\n//    - The _writeToStorage method is called.\n//    - It writes the value to storage using the 'myKey' key.\n//    - The listener detects the change and updates the UI.\n// 7. When the user taps \"Remove from Storage\":\n//    - The _removeFromStorage method is called.\n//    - It removes the value associated with 'myKey' from storage.\n//    - The listener detects the change and updates the UI.\n// 8. The stored value is always displayed and updated in real-time thanks to the listener.\n\n// This example demonstrates basic read/write operations, listening for changes,\n// and removing data from storage using the get_storage package.\n```",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "gw8t3ss1",
        "_ref": "uQRNMiDfrp20RZ8Id8CTzf"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPaMLA",
        "_type": "reference",
        "_key": "67o04f03"
      }
    ],
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "storage",
      "persistence",
      "key-value",
      "local-storage",
      "cache"
    ],
    "lastUpdate": "2023-02-26T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:12:55Z"
  },
  {
    "packageImage": null,
    "_rev": "AE3hjGWNkNE6aGQMMbaSgf",
    "_type": "package",
    "similarPackages": [],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_typeahead/flutter_typeahead.dart';\nimport 'dart:async';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter TypeAhead Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final TextEditingController _typeAheadController = TextEditingController();\n  String _selectedCity = '';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter TypeAhead Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          children: <Widget>[\n            // Step 1: Basic TypeAhead implementation\n            TypeAheadFormField(\n              textFieldConfiguration: TextFieldConfiguration(\n                controller: _typeAheadController,\n                decoration: InputDecoration(\n                  labelText: 'City',\n                  border: OutlineInputBorder(),\n                ),\n              ),\n              suggestionsCallback: (pattern) async {\n                // Step 2: Implement suggestion logic\n                return await _getCitySuggestions(pattern);\n              },\n              itemBuilder: (context, String suggestion) {\n                // Step 3: Build suggestion item\n                return ListTile(\n                  leading: Icon(Icons.location_city),\n                  title: Text(suggestion),\n                  subtitle: Text('Tap to select'),\n                );\n              },\n              onSuggestionSelected: (String suggestion) {\n                // Step 4: Handle suggestion selection\n                setState(() {\n                  _typeAheadController.text = suggestion;\n                  _selectedCity = suggestion;\n                });\n              },\n              // Step 5: Customize suggestions box\n              suggestionsBoxDecoration: SuggestionsBoxDecoration(\n                borderRadius: BorderRadius.circular(10.0),\n                elevation: 8.0,\n                color: Theme.of(context).cardColor,\n              ),\n              // Step 6: Add validation\n              validator: (value) {\n                if (value!.isEmpty) {\n                  return 'Please select a city';\n                }\n                return null;\n              },\n            ),\n            SizedBox(height: 20),\n            // Step 7: Display selected city\n            Text(\n              'Selected City: $_selectedCity',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 8: Implement city suggestion function\n  Future<List<String>> _getCitySuggestions(String pattern) async {\n    // Simulating API delay\n    await Future.delayed(Duration(milliseconds: 500));\n    \n    final cities = [\n      'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix',\n      'Philadelphia', 'San Antonio', 'San Diego', 'Dallas', 'San Jose'\n    ];\n\n    return cities.where((city) => \n      city.toLowerCase().contains(pattern.toLowerCase())).toList();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a TextField with TypeAhead functionality.\n// 2. As the user types, the _getCitySuggestions function is called with the current input.\n// 3. The function returns a list of cities that match the input pattern.\n// 4. The suggestions are displayed in a customized suggestions box.\n// 5. When a suggestion is selected, the TextField is updated, and the selected city is stored.\n// 6. The selected city is displayed below the TextField.\n// 7. Form validation ensures that a city is selected before submission.\n\n// Key Features Demonstrated:\n// - Basic TypeAhead implementation\n// - Custom suggestion logic\n// - Customized suggestion item display\n// - Suggestion selection handling\n// - Suggestions box customization\n// - Form validation\n// - State management for selected value\n// - Simulated asynchronous data fetching\n```",
    "tags": [
      "autocomplete",
      "search",
      "suggestion",
      "input",
      "form"
    ],
    "pubPoint": 160,
    "_id": "uQRNMiDfrp20RZ8Id8CZDH",
    "slug": {
      "current": "flutter_typeahead",
      "_type": "slug"
    },
    "_createdAt": "2024-08-28T22:16:47Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:56Z",
    "author": "",
    "shortDescription": "A highly customizable typeahead (autocomplete) text input field for Flutter",
    "platforms": [
      "ios",
      "web"
    ],
    "likesCount": 1945,
    "dependentPackages": [],
    "description": "# Flutter TypeAhead Package: A Comprehensive Guide\n\n## Part 1: Description\n\nThe `flutter_typeahead` package is a powerful and flexible tool for implementing autocomplete functionality in Flutter applications. It provides a customizable typeahead (autocomplete) widget that suggests options to users as they type, enhancing the user experience and improving data input efficiency.\n\n### Key Features:\n\n1. **Customizable Suggestions:** The package allows developers to define custom suggestion logic, making it adaptable to various data sources and use cases.\n\n2. **Flexible UI:** Both the text input and the suggestions box can be fully customized to match your app's design.\n\n3. **Performance Optimization:** The package implements efficient scrolling and rendering techniques to handle large datasets smoothly.\n\n4. **Asynchronous Data Loading:** Supports loading suggestions asynchronously, perfect for API-based autocomplete features.\n\n5. **Easy Integration:** Can be easily integrated into existing Flutter projects with minimal setup.\n\n6. **Form Compatibility:** Works seamlessly with Flutter's form widgets, making it ideal for complex data entry scenarios.\n\n7. **Keyboard Navigation:** Supports keyboard navigation for selecting suggestions, improving accessibility.\n\n8. **Debounce Functionality:** Includes built-in debounce to optimize network requests and improve performance.\n\nThe `flutter_typeahead` package is particularly useful in scenarios where you need to provide users with a list of options based on their input, such as search functionalities, address lookups, or any form of data entry where suggestions can speed up the process.\n\nIn the following sections, we'll dive deeper into how to implement and customize the TypeAhead widget in your Flutter applications.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAkO",
        "_type": "reference",
        "_key": "kh9swlod"
      }
    ],
    "lastUpdate": "2024-02-07T18:30:00.000Z",
    "name": "flutter_typeahead",
    "tutorial": "# Flutter TypeAhead Package: A Comprehensive Guide\n\n## Part 2: Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the `flutter_typeahead` package in a Flutter application. We'll cover installation, basic usage, and some advanced features.\n\n### Step 1: Installation\n\nAdd the `flutter_typeahead` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_typeahead: ^4.3.7\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Basic Implementation\n\nHere's a basic example of how to use the TypeAheadFormField:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_typeahead/flutter_typeahead.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('TypeAhead Example')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: TypeAheadFormField(\n          textFieldConfiguration: TextFieldConfiguration(\n            decoration: InputDecoration(labelText: 'City'),\n          ),\n          suggestionsCallback: (pattern) async {\n            return await getSuggestions(pattern);\n          },\n          itemBuilder: (context, suggestion) {\n            return ListTile(\n              title: Text(suggestion),\n            );\n          },\n          onSuggestionSelected: (suggestion) {\n            print('Selected: $suggestion');\n          },\n        ),\n      ),\n    );\n  }\n\n  Future<List<String>> getSuggestions(String pattern) async {\n    // This is where you would typically make an API call\n    // For this example, we'll use a static list\n    final cities = [\n      'New York',\n      'Los Angeles',\n      'Chicago',\n      'Houston',\n      'Phoenix',\n    ];\n    return cities.where((city) => \n      city.toLowerCase().contains(pattern.toLowerCase())).toList();\n  }\n}\n```\n\n### Step 3: Customization\n\nYou can customize both the text field and the suggestions box:\n\n```dart\nTypeAheadFormField(\n  textFieldConfiguration: TextFieldConfiguration(\n    decoration: InputDecoration(\n      labelText: 'City',\n      border: OutlineInputBorder(),\n    ),\n    style: TextStyle(fontSize: 16),\n  ),\n  suggestionsBoxDecoration: SuggestionsBoxDecoration(\n    borderRadius: BorderRadius.circular(10),\n    elevation: 8.0,\n    color: Colors.white,\n  ),\n  // ... other properties\n)\n```\n\n### Step 4: Handling Asynchronous Data\n\nFor real-world applications, you'll often need to fetch suggestions from an API:\n\n```dart\nsuggestionsCallback: (pattern) async {\n  final response = await http.get(\n    Uri.parse('https://api.example.com/cities?query=$pattern')\n  );\n  if (response.statusCode == 200) {\n    final List<dynamic> data = json.decode(response.body);\n    return data.map((city) => city['name'].toString()).toList();\n  }\n  return [];\n},\n```\n\n### Step 5: Platform-Specific Considerations\n\n#### iOS\nFor iOS, you might want to use the `CupertinoTypeAheadField` for a more native look:\n\n```dart\nCupertinoTypeAheadField(\n  getImmediateSuggestions: true,\n  // ... other properties similar to TypeAheadFormField\n)\n```\n\n#### Android\nFor Android, you can customize the suggestions box to match Material Design:\n\n```dart\nTypeAheadFormField(\n  suggestionsBoxDecoration: SuggestionsBoxDecoration(\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(4),\n    ),\n  ),\n  // ... other properties\n)\n```\n\n#### Web\nFor web applications, consider using a debounce to reduce API calls:\n\n```dart\nTypeAheadFormField(\n  debounceDuration: Duration(milliseconds: 300),\n  // ... other properties\n)\n```\n\nBy following these steps and customizations, you can create a powerful and user-friendly typeahead feature in your Flutter application that works well across different platforms."
  },
  {
    "description": "# Understanding the Bloc Package in Flutter\n\n## What is Bloc?\n\nBloc (Business Logic Component) is a design pattern and state management solution for Flutter applications. It was created by Felix Angelov and has gained significant popularity in the Flutter community due to its ability to separate business logic from the presentation layer, making apps more maintainable and testable.\n\n## Key Concepts\n\n1. **Events**: These are the inputs to a Bloc. They are typically user actions or system events that trigger state changes.\n\n2. **States**: These represent the output of a Bloc and define the UI of your application.\n\n3. **Bloc**: This is the component that converts a stream of incoming events into a stream of outgoing states.\n\n## Advantages of Using Bloc\n\n- **Separation of Concerns**: Bloc separates the presentation layer from the business logic.\n- **Testability**: It's easy to unit test your business logic in isolation.\n- **Reusability**: Blocs can be reused across different parts of your app or even different projects.\n- **Scalability**: Bloc pattern scales well for large and complex applications.\n\n## When to Use Bloc\n\nBloc is particularly useful for:\n\n- Large-scale applications with complex business logic\n- Apps that require real-time updates\n- Projects where testability is a priority\n- Applications that need to manage multiple states\n\nIn the next sections, we'll dive into a tutorial on how to implement Bloc in a Flutter application and see a practical example of its usage.",
    "shortDescription": "A predictable state management library that helps implement the BLoC (Business Logic Component) design pattern.",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-1301ec34e26736c9a77a7a2448528f3bc885e9ab-644x767-webp",
        "_type": "reference"
      }
    },
    "_createdAt": "2024-08-28T22:17:05Z",
    "lastUpdate": "2024-03-23T18:30:00.000Z",
    "tutorialIncluded": true,
    "author": "bloclibrary.dev",
    "_rev": "eaCZ7mIhmiYZX5KGqJmTQL",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 2837,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "x81yf02h"
      },
      {
        "_type": "reference",
        "_key": "p167iw35",
        "_ref": "uQRNMiDfrp20RZ8Id8CdzJ"
      }
    ],
    "_updatedAt": "2024-09-06T04:12:57Z",
    "pubPoint": 160,
    "_type": "package",
    "name": "bloc",
    "_id": "uQRNMiDfrp20RZ8Id8Ca4b",
    "slug": {
      "current": "bloc",
      "_type": "slug"
    },
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "3gm6tce8"
      }
    ],
    "subCategories": [
      {
        "_key": "kk77bt93",
        "_ref": "EyMM3FfV3Ih5n1NWrhPG5F",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\n// Step 1: Define Events\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\nclass ResetEvent extends CounterEvent {}\n\n// Step 2: Define States\nclass CounterState {\n  final int count;\n  CounterState(this.count);\n}\n\n// Step 3: Create Bloc\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterState(0)) {\n    on<IncrementEvent>((event, emit) => emit(CounterState(state.count + 1)));\n    on<DecrementEvent>((event, emit) => emit(CounterState(state.count - 1)));\n    on<ResetEvent>((event, emit) => emit(CounterState(0)));\n  }\n}\n\n// Step 4: Create BlocObserver for logging\nclass SimpleBlocObserver extends BlocObserver {\n  @override\n  void onChange(BlocBase bloc, Change change) {\n    super.onChange(bloc, change);\n    print('${bloc.runtimeType} $change');\n  }\n}\n\n// Step 5: Main Application\nvoid main() {\n  Bloc.observer = SimpleBlocObserver();\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: CounterPage(),\n      ),\n    );\n  }\n}\n\n// Step 6: UI Implementation\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Bloc Counter Example')),\n      body: Center(\n        child: BlocBuilder<CounterBloc, CounterState>(\n          builder: (context, state) {\n            return Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text('Count: ${state.count}', style: TextStyle(fontSize: 24)),\n                SizedBox(height: 20),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    ElevatedButton(\n                      child: Icon(Icons.remove),\n                      onPressed: () => context.read<CounterBloc>().add(DecrementEvent()),\n                    ),\n                    SizedBox(width: 10),\n                    ElevatedButton(\n                      child: Icon(Icons.refresh),\n                      onPressed: () => context.read<CounterBloc>().add(ResetEvent()),\n                    ),\n                    SizedBox(width: 10),\n                    ElevatedButton(\n                      child: Icon(Icons.add),\n                      onPressed: () => context.read<CounterBloc>().add(IncrementEvent()),\n                    ),\n                  ],\n                ),\n              ],\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow Explanation:\n// 1. The application starts in the main() function, where we set up the BlocObserver and run the RealFlutter widget.\n// 2. RealFlutter creates a MaterialApp and provides the CounterBloc to its child widgets using BlocProvider.\n// 3. CounterPage is the main screen of our app. It uses BlocBuilder to listen to state changes in CounterBloc.\n// 4. The UI displays the current count and provides buttons to increment, decrement, or reset the count.\n// 5. When a button is pressed, it adds the corresponding event (IncrementEvent, DecrementEvent, or ResetEvent) to the CounterBloc.\n// 6. The CounterBloc processes these events and emits new states accordingly.\n// 7. The BlocBuilder rebuilds the UI whenever the state changes, updating the displayed count.\n// 8. The SimpleBlocObserver logs all state changes, providing visibility into the Bloc's behavior.\n\n// This example demonstrates key Bloc concepts including:\n// - Event and State definitions\n// - Bloc creation and event handling\n// - BlocProvider for dependency injection\n// - BlocBuilder for rebuilding UI based on state changes\n// - BlocObserver for logging and debugging\n```",
    "tags": [
      "bloc",
      "state-management",
      "reactive",
      "architecture",
      "pattern"
    ],
    "tutorial": "# Tutorial: Implementing Bloc in Flutter\n\nIn this tutorial, we'll create a simple counter app using the Bloc pattern. We'll cover setup, implementation, and platform-specific considerations.\n\n## Step 1: Setup\n\nFirst, add the required dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_bloc: ^8.1.3\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Create the Event\n\nCreate a file `counter_event.dart`:\n\n```dart\nabstract class CounterEvent {}\n\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n```\n\n## Step 3: Create the State\n\nCreate a file `counter_state.dart`:\n\n```dart\nclass CounterState {\n  final int count;\n  CounterState(this.count);\n}\n```\n\n## Step 4: Create the Bloc\n\nCreate a file `counter_bloc.dart`:\n\n```dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'counter_event.dart';\nimport 'counter_state.dart';\n\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterState(0)) {\n    on<IncrementEvent>((event, emit) => emit(CounterState(state.count + 1)));\n    on<DecrementEvent>((event, emit) => emit(CounterState(state.count - 1)));\n  }\n}\n```\n\n## Step 5: Implement the UI\n\nUpdate your `main.dart` file to use the Bloc:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'counter_bloc.dart';\nimport 'counter_event.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Bloc Counter')),\n      body: Center(\n        child: BlocBuilder<CounterBloc, CounterState>(\n          builder: (context, state) {\n            return Text('Count: ${state.count}', style: TextStyle(fontSize: 24));\n          },\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        crossAxisAlignment: CrossAxisAlignment.end,\n        children: [\n          FloatingActionButton(\n            child: Icon(Icons.add),\n            onPressed: () => context.read<CounterBloc>().add(IncrementEvent()),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            child: Icon(Icons.remove),\n            onPressed: () => context.read<CounterBloc>().add(DecrementEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have CocoaPods installed and initialized in your project.\n- In your `ios/Podfile`, uncomment the line `platform :ios, '9.0'` and set it to your minimum iOS version.\n\n### Android\n- Make sure your `android/app/build.gradle` file has `minSdkVersion 16` or higher.\n- If using Kotlin, ensure your `kotlin_version` is up to date in `android/build.gradle`.\n\n### Web\n- No specific setup is required for web support with Bloc.\n\nBy following these steps, you'll have a basic counter app implemented using the Bloc pattern in Flutter, with considerations for different platforms."
  },
  {
    "name": "flutter_form_builder",
    "shortDescription": "This package helps in creation of forms in Flutter by removing the boilerplate code, reusing validation, react to changes, and collect final user input.",
    "similarPackages": [],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "6mhfu18o",
        "_ref": "t8DYBEKn49O4mjbyRAfAkO"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_form_builder/flutter_form_builder.dart';\nimport 'package:form_builder_validators/form_builder_validators.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Form Builder Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final _formKey = GlobalKey<FormBuilderState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter Form Builder Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: FormBuilder(\n          key: _formKey,\n          child: SingleChildScrollView(\n            child: Column(\n              children: [\n                // Step 1: Basic Text Field\n                FormBuilderTextField(\n                  name: 'name',\n                  decoration: InputDecoration(labelText: 'Name'),\n                  validator: FormBuilderValidators.compose([\n                    FormBuilderValidators.required(),\n                    FormBuilderValidators.max(70),\n                  ]),\n                ),\n\n                // Step 2: Email Field with Validation\n                FormBuilderTextField(\n                  name: 'email',\n                  decoration: InputDecoration(labelText: 'Email'),\n                  validator: FormBuilderValidators.compose([\n                    FormBuilderValidators.required(),\n                    FormBuilderValidators.email(),\n                  ]),\n                ),\n\n                // Step 3: Dropdown\n                FormBuilderDropdown<String>(\n                  name: 'gender',\n                  decoration: InputDecoration(labelText: 'Gender'),\n                  items: ['Male', 'Female', 'Other']\n                      .map((gender) => DropdownMenuItem(\n                            value: gender,\n                            child: Text(gender),\n                          ))\n                      .toList(),\n                ),\n\n                // Step 4: Checkbox Group\n                FormBuilderCheckboxGroup<String>(\n                  name: 'hobbies',\n                  decoration: InputDecoration(labelText: 'Hobbies'),\n                  options: [\n                    FormBuilderFieldOption(value: 'Reading'),\n                    FormBuilderFieldOption(value: 'Writing'),\n                    FormBuilderFieldOption(value: 'Coding'),\n                  ],\n                ),\n\n                // Step 5: Radio Group\n                FormBuilderRadioGroup<String>(\n                  name: 'programming_language',\n                  decoration: InputDecoration(labelText: 'Favorite Programming Language'),\n                  options: [\n                    FormBuilderFieldOption(value: 'Dart'),\n                    FormBuilderFieldOption(value: 'Python'),\n                    FormBuilderFieldOption(value: 'JavaScript'),\n                  ],\n                ),\n\n                // Step 6: Slider\n                FormBuilderSlider(\n                  name: 'age',\n                  min: 0.0,\n                  max: 100.0,\n                  initialValue: 25.0,\n                  divisions: 100,\n                  decoration: InputDecoration(labelText: 'Age'),\n                ),\n\n                // Step 7: Date Picker\n                FormBuilderDateTimePicker(\n                  name: 'date_of_birth',\n                  inputType: InputType.date,\n                  decoration: InputDecoration(labelText: 'Date of Birth'),\n                ),\n\n                // Step 8: Submit Button\n                ElevatedButton(\n                  child: Text('Submit'),\n                  onPressed: () {\n                    if (_formKey.currentState?.saveAndValidate() ?? false) {\n                      // Form is valid, handle submission\n                      print(_formKey.currentState?.value);\n                      // You can send this data to an API or process it further\n                    } else {\n                      // Form is invalid, display error\n                      print('Form is invalid');\n                    }\n                  },\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a form with various input fields.\n// 2. User interacts with the form, filling in details.\n// 3. When the user taps the Submit button:\n//    a. The form is validated using the specified validators.\n//    b. If valid, the form data is printed to the console (in a real app, you'd process this data).\n//    c. If invalid, an error message is printed (in a real app, you'd show user-friendly error messages).\n// 4. The form remains on screen, allowing the user to make corrections or submit again.\n\n// Note: This example demonstrates various form field types and basic validation.\n// In a production app, you'd want to add more robust error handling, \n// possibly use a state management solution, and implement actual data processing logic.\n```",
    "tags": [
      "form",
      "forms",
      "input",
      "validation",
      "ui"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CZDH",
        "_type": "reference",
        "_key": "1rzg6y5q"
      }
    ],
    "packageImage": null,
    "likesCount": 2491,
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "tutorial": "# Flutter Form Builder: Tutorial\n\nIn this tutorial, we'll walk through the process of setting up and using the Flutter Form Builder package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_form_builder: ^9.1.0\n  form_builder_validators: ^9.1.0\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the necessary packages:\n\n```dart\nimport 'package:flutter_form_builder/flutter_form_builder.dart';\nimport 'package:form_builder_validators/form_builder_validators.dart';\n```\n\n## Step 3: Create a Form\n\nWrap your form fields with a `FormBuilder` widget:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return FormBuilder(\n      child: Column(\n        children: [\n          // Form fields will go here\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Add Form Fields\n\nAdd various form fields using `FormBuilderTextField`, `FormBuilderDropdown`, etc.:\n\n```dart\nFormBuilderTextField(\n  name: 'name',\n  decoration: InputDecoration(labelText: 'Name'),\n  validator: FormBuilderValidators.required(),\n),\nFormBuilderDropdown<String>(\n  name: 'gender',\n  decoration: InputDecoration(labelText: 'Gender'),\n  items: ['Male', 'Female', 'Other']\n      .map((gender) => DropdownMenuItem(\n            value: gender,\n            child: Text(gender),\n          ))\n      .toList(),\n),\n```\n\n## Step 5: Handle Form Submission\n\nUse a button to trigger form validation and submission:\n\n```dart\nElevatedButton(\n  onPressed: () {\n    if (_formKey.currentState?.saveAndValidate() ?? false) {\n      // Form is valid, handle submission\n      print(_formKey.currentState?.value);\n    }\n  },\n  child: Text('Submit'),\n),\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Use `CupertinoFormBuilderTextField` for iOS-style text inputs.\n- Implement date pickers using `CupertinoDatePicker` within `FormBuilderField`.\n\n### Android\n- Material Design widgets are used by default.\n- Consider using `FormBuilderDateTimePicker` for date selection.\n\nBy following these steps, you'll have a basic form set up using Flutter Form Builder. In the next section, we'll look at a more comprehensive example that demonstrates various features of the package.",
    "slug": {
      "current": "flutter_form_builder",
      "_type": "slug"
    },
    "author": "flutterformbuilderecosystem.com",
    "_rev": "AE3hjGWNkNE6aGQMMbaSlS",
    "description": "# Flutter Form Builder: A Comprehensive Guide\n\n## Introduction\n\nFlutter Form Builder is a powerful package that simplifies the process of creating and managing forms in Flutter applications. It provides a set of pre-built form fields and validators, making it easier for developers to create complex forms with minimal effort.\n\n## Key Features\n\n1. **Diverse Form Fields**: The package offers a wide range of form fields, including text fields, dropdowns, checkboxes, radio buttons, and more.\n\n2. **Built-in Validation**: It comes with pre-defined validators for common scenarios like required fields, email formats, and numeric inputs.\n\n3. **Custom Validation**: Developers can easily implement custom validation logic for specific requirements.\n\n4. **Form Management**: The package handles form state management, making it easier to track changes and validate the entire form.\n\n5. **Nested Forms**: Support for creating nested forms, allowing for more complex form structures.\n\n6. **Serialization**: Easy serialization and deserialization of form data to and from JSON.\n\n## Why Use Flutter Form Builder?\n\n- **Time-Saving**: Reduces boilerplate code and speeds up form development.\n- **Flexibility**: Easily customizable to fit various design requirements.\n- **Maintainability**: Centralized form management makes code more organized and easier to maintain.\n- **Cross-Platform**: Works seamlessly on both iOS and Android platforms.\n\nIn the following sections, we'll dive deeper into how to use Flutter Form Builder in your projects, starting with a tutorial and then exploring a comprehensive example.",
    "_id": "uQRNMiDfrp20RZ8Id8CaDn",
    "pubPoint": 160,
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:17:06Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:12:58Z"
  },
  {
    "pubPoint": 160,
    "author": "fernando-herrera.com",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "x3di4tmk"
      }
    ],
    "_createdAt": "2024-08-28T22:17:14Z",
    "name": "animate_do",
    "_updatedAt": "2024-09-06T04:13:00Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:animate_do/animate_do.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Animate_do Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  bool _visible = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Animate_do Showcase')),\n      body: SingleChildScrollView(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // Step 1: FadeIn Animation\n              FadeIn(\n                duration: Duration(seconds: 2),\n                child: Text('1. FadeIn Animation', style: TextStyle(fontSize: 20)),\n              ),\n              SizedBox(height: 20),\n\n              // Step 2: SlideInUp Animation\n              SlideInUp(\n                duration: Duration(seconds: 1),\n                child: Container(\n                  width: 200,\n                  height: 50,\n                  color: Colors.blue,\n                  child: Center(child: Text('2. SlideInUp')),\n                ),\n              ),\n              SizedBox(height: 20),\n\n              // Step 3: ElasticIn Animation\n              ElasticIn(\n                duration: Duration(seconds: 2),\n                child: Icon(Icons.favorite, color: Colors.red, size: 50),\n              ),\n              SizedBox(height: 20),\n\n              // Step 4: Spin Animation\n              Spin(\n                duration: Duration(seconds: 2),\n                infinite: true,\n                child: Icon(Icons.refresh, color: Colors.green, size: 50),\n              ),\n              SizedBox(height: 20),\n\n              // Step 5: Bounce Animation\n              Bounce(\n                duration: Duration(seconds: 2),\n                from: 100,\n                child: Container(\n                  width: 100,\n                  height: 100,\n                  color: Colors.orange,\n                  child: Center(child: Text('5. Bounce')),\n                ),\n              ),\n              SizedBox(height: 20),\n\n              // Step 6: FadeInOut Animation\n              AnimatedSwitcher(\n                duration: Duration(milliseconds: 500),\n                child: _visible\n                    ? FadeIn(key: UniqueKey(), child: Text('6. FadeInOut'))\n                    : FadeOut(key: UniqueKey(), child: Text('6. FadeInOut')),\n              ),\n              ElevatedButton(\n                onPressed: () => setState(() => _visible = !_visible),\n                child: Text('Toggle Visibility'),\n              ),\n              SizedBox(height: 20),\n\n              // Step 7: Chained Animations\n              FadeInLeft(\n                duration: Duration(seconds: 1),\n                child: SlideInUp(\n                  duration: Duration(seconds: 1),\n                  child: Container(\n                    width: 200,\n                    height: 50,\n                    color: Colors.purple,\n                    child: Center(child: Text('7. Chained Animations', style: TextStyle(color: Colors.white))),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a Scaffold with an AppBar.\n// 2. Inside the body, we have a SingleChildScrollView containing various animated widgets:\n//    - FadeIn: Text fades in over 2 seconds.\n//    - SlideInUp: Blue container slides up from the bottom.\n//    - ElasticIn: Heart icon bounces in with an elastic effect.\n//    - Spin: Refresh icon spins continuously.\n//    - Bounce: Orange container bounces into view.\n//    - FadeInOut: Text that can be toggled between visible and invisible states.\n//    - Chained Animations: Purple container that fades in from the left and slides up simultaneously.\n// 3. The FadeInOut animation is controlled by a stateful widget, allowing user interaction to toggle visibility.\n// 4. Each animation showcases different capabilities of the animate_do package, demonstrating various effects and customization options.\n// 5. Users can scroll through the list to see all animations in action.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_key": "en91lz6d",
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference"
      },
      {
        "_type": "reference",
        "_key": "4gtr08zf",
        "_ref": "Rx1Nho763d29lawKra1VMp"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CaUL",
    "_rev": "AE3hjGWNkNE6aGQMMbaSqF",
    "description": "# Animate_do: Bringing Life to Your Flutter Animations\n\nFlutter's ecosystem is rich with packages that enhance the user experience, and among these, the `animate_do` package stands out for its simplicity and effectiveness in adding beautiful animations to your app. In this blog post, we'll explore the `animate_do` package, its features, and how to implement it in your Flutter projects.\n\n## What is animate_do?\n\n`animate_do` is a Flutter package inspired by [Animate.css](https://animate.style/), bringing a collection of cool and easy-to-use animations to your Flutter applications. It offers a wide range of pre-built animations that you can apply to your widgets with minimal effort.\n\n## Key Features\n\n1. **Variety of Animations**: The package includes numerous animation types such as fading, sliding, zooming, and rotating effects.\n\n2. **Customizable**: Each animation can be customized with parameters like duration, delay, and infinite loops.\n\n3. **Easy to Implement**: With a simple widget wrap, you can add animations to any widget in your Flutter app.\n\n4. **Cross-Platform**: Works seamlessly on both iOS and Android platforms.\n\n5. **Performance Optimized**: Designed to be lightweight and efficient, ensuring smooth animations without compromising app performance.\n\nIn the following sections, we'll dive deeper into how to use `animate_do` in your Flutter projects and showcase its capabilities with practical examples.",
    "shortDescription": "Beautiful animations inspired on Animate.css, every animation is a customizable widget.",
    "likesCount": 4373,
    "lastUpdate": "2024-02-28T18:30:00.000Z",
    "tutorial": "# Getting Started with animate_do\n\nIn this tutorial, we'll walk through the process of integrating the `animate_do` package into your Flutter project and demonstrate how to use its various animations.\n\n## Step 1: Add the package to your pubspec.yaml\n\nFirst, add the `animate_do` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  animate_do: ^3.0.2  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:animate_do/animate_do.dart';\n```\n\n## Step 3: Using animations\n\nNow you can start using the animations. Here's a simple example using the `FadeIn` animation:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:animate_do/animate_do.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Animate_do Example')),\n      body: Center(\n        child: FadeIn(\n          duration: Duration(seconds: 2),\n          child: Text('Hello, Animate_do!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nThis will make the text fade in over a duration of 2 seconds.\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, animations work out of the box without any additional configuration.\n\n### Android\n\nFor Android, ensure that your `minSdkVersion` is set to 16 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // other configurations...\n    }\n}\n```\n\n## Advanced Usage\n\n### Customizing Animations\n\nMost animations in `animate_do` accept parameters like:\n\n- `duration`: How long the animation takes to complete.\n- `delay`: How long to wait before starting the animation.\n- `from`: The starting point of the animation (for directional animations).\n\nExample:\n\n```dart\nSlideInUp(\n  duration: Duration(milliseconds: 800),\n  delay: Duration(milliseconds: 200),\n  from: 100,\n  child: YourWidget(),\n)\n```\n\n### Chaining Animations\n\nYou can chain multiple animations together:\n\n```dart\nFadeIn(\n  child: SlideInUp(\n    child: YourWidget(),\n  ),\n)\n```\n\nThis will make the widget fade in and slide up simultaneously.\n\nBy following this tutorial, you'll be well on your way to creating engaging and dynamic user interfaces with the `animate_do` package in your Flutter applications.",
    "tutorialIncluded": true,
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVWC",
        "_type": "reference",
        "_key": "ucyb30oi"
      }
    ],
    "tags": [
      "animation",
      "ui",
      "effects",
      "transitions"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_type": "reference",
        "_ref": "image-8ed34ee38ba4d000c5607012d33367278c45c917-390x296-webp"
      }
    },
    "slug": {
      "current": "animate_do",
      "_type": "slug"
    }
  },
  {
    "tutorial": "# Freezed Tutorial: Getting Started\n\nThis tutorial will guide you through setting up and using the Freezed package in your Flutter project.\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  freezed_annotation: ^2.2.0\n\ndev_dependencies:\n  build_runner: ^2.3.3\n  freezed: ^2.3.2\n  json_serializable: ^6.6.1\n```\n\n## Step 2: Create a Model File\n\nCreate a new file named `real_flutter.dart` in your `lib` folder:\n\n```dart\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'real_flutter.freezed.dart';\npart 'real_flutter.g.dart';\n\n@freezed\nclass RealFlutter with _$RealFlutter {\n  const factory RealFlutter({\n    required String name,\n    required int age,\n    @Default([]) List<String> hobbies,\n  }) = _RealFlutter;\n\n  factory RealFlutter.fromJson(Map<String, dynamic> json) =>\n      _$RealFlutterFromJson(json);\n}\n```\n\n## Step 3: Run Code Generation\n\nExecute the following command in your terminal:\n\n```\nflutter pub run build_runner build --delete-conflicting-outputs\n```\n\nThis will generate the necessary Freezed and JSON serialization code.\n\n## Step 4: Use the Generated Class\n\nNow you can use the `RealFlutter` class in your code:\n\n```dart\nvoid main() {\n  final person = RealFlutter(name: 'John Doe', age: 30);\n  print(person); // RealFlutter(name: John Doe, age: 30, hobbies: [])\n\n  // Using copyWith\n  final olderPerson = person.copyWith(age: 31);\n  print(olderPerson); // RealFlutter(name: John Doe, age: 31, hobbies: [])\n\n  // Serialization\n  final json = person.toJson();\n  print(json); // {name: John Doe, age: 30, hobbies: []}\n\n  // Deserialization\n  final deserializedPerson = RealFlutter.fromJson(json);\n  print(deserializedPerson); // RealFlutter(name: John Doe, age: 30, hobbies: [])\n}\n```\n\n## Platform-Specific Details\n\n### Android\nFor Android, ensure that you have the latest version of the Android Gradle Plugin in your `android/build.gradle` file:\n\n```groovy\ndependencies {\n    classpath 'com.android.tools.build:gradle:7.0.0'\n}\n```\n\n### iOS\nFor iOS, make sure you're using a minimum deployment target of iOS 11.0 in your `ios/Podfile`:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n### Web\nFor web support, no additional configuration is needed. Freezed works out of the box with Flutter web projects.\n\nBy following these steps, you'll have Freezed set up and ready to use in your Flutter project across all supported platforms.",
    "pubPoint": 160,
    "lastUpdate": "2024-07-14T18:30:00.000Z",
    "description": "# Freezed: Simplifying Data Classes in Flutter\n\nFreezed is a code generation package for Flutter that simplifies the creation of immutable data classes. It provides a convenient way to implement the following features:\n\n1. Immutable data structures\n2. Equality comparisons\n3. Copying with modifications (copyWith)\n4. Serialization and deserialization (toJson and fromJson)\n5. Union types and pattern matching\n\n## Why Use Freezed?\n\nIn Flutter development, we often need to create data classes that represent our application's state or model objects. Writing these classes manually can be tedious and error-prone. Freezed automates this process, reducing boilerplate code and ensuring consistency across your codebase.\n\n## Key Features\n\n### 1. Immutability\nFreezed generates immutable classes by default, promoting a more predictable state management approach.\n\n### 2. Equality\nIt automatically implements `==` and `hashCode` methods, making it easy to compare instances.\n\n### 3. copyWith\nFreezed provides a `copyWith` method, allowing you to create new instances with modified properties effortlessly.\n\n### 4. Serialization\nWith minimal setup, Freezed can generate `toJson` and `fromJson` methods for easy serialization and deserialization.\n\n### 5. Union Types\nFreezed supports creating sealed classes (union types) and provides pattern matching capabilities.\n\nBy leveraging Freezed, developers can focus more on business logic and less on repetitive data class implementations, leading to cleaner, more maintainable code.",
    "shortDescription": "Code generation for immutable classes that has a simple syntax/API without compromising on the features.",
    "similarPackages": [],
    "tags": [
      "code-generation",
      "immutable",
      "serialization",
      "data-classes"
    ],
    "slug": {
      "current": "freezed",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaStR",
    "_type": "package",
    "name": "freezed",
    "_updatedAt": "2024-09-06T04:13:01Z",
    "likesCount": 3857,
    "_createdAt": "2024-08-28T22:17:15Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'main.freezed.dart';\npart 'main.g.dart';\n\n// Step 1: Define the RealFlutter class using Freezed\n@freezed\nclass RealFlutter with _$RealFlutter {\n  const factory RealFlutter({\n    required String name,\n    required int age,\n    @Default([]) List<String> hobbies,\n  }) = _RealFlutter;\n\n  factory RealFlutter.fromJson(Map<String, dynamic> json) =>\n      _$RealFlutterFromJson(json);\n}\n\n// Step 2: Define a union type for different states\n@freezed\nclass RealFlutterState with _$RealFlutterState {\n  const factory RealFlutterState.loading() = _Loading;\n  const factory RealFlutterState.loaded(RealFlutter data) = _Loaded;\n  const factory RealFlutterState.error(String message) = _Error;\n}\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: RealFlutterDemo(),\n    );\n  }\n}\n\nclass RealFlutterDemo extends StatefulWidget {\n  @override\n  _RealFlutterDemoState createState() => _RealFlutterDemoState();\n}\n\nclass _RealFlutterDemoState extends State<RealFlutterDemo> {\n  // Step 3: Initialize state\n  late RealFlutterState _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _state = RealFlutterState.loading();\n    _loadData();\n  }\n\n  // Step 4: Simulate data loading\n  Future<void> _loadData() async {\n    await Future.delayed(Duration(seconds: 2));\n    setState(() {\n      _state = RealFlutterState.loaded(\n        RealFlutter(name: 'John Doe', age: 30, hobbies: ['Reading', 'Coding']),\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Demo')),\n      body: Center(\n        // Step 5: Use pattern matching to handle different states\n        child: _state.when(\n          loading: () => CircularProgressIndicator(),\n          loaded: (data) => _buildLoadedContent(data),\n          error: (message) => Text('Error: $message'),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildLoadedContent(RealFlutter data) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text('Name: ${data.name}'),\n        Text('Age: ${data.age}'),\n        Text('Hobbies: ${data.hobbies.join(\", \")}'),\n        SizedBox(height: 20),\n        ElevatedButton(\n          child: Text('Increment Age'),\n          // Step 6: Demonstrate copyWith usage\n          onPressed: () {\n            setState(() {\n              _state = RealFlutterState.loaded(\n                (data as _$_RealFlutter).copyWith(age: data.age + 1),\n              );\n            });\n          },\n        ),\n        SizedBox(height: 20),\n        ElevatedButton(\n          child: Text('Serialize to JSON'),\n          onPressed: () {\n            // Step 7: Demonstrate JSON serialization\n            final json = data.toJson();\n            print('Serialized JSON: $json');\n            \n            // Step 8: Demonstrate JSON deserialization\n            final deserialized = RealFlutter.fromJson(json);\n            print('Deserialized: $deserialized');\n            \n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text('Check console for JSON output')),\n            );\n          },\n        ),\n      ],\n    );\n  }\n}\n\n// Application Flow Explanation:\n// 1. The app starts and shows a loading indicator.\n// 2. After a simulated delay, it loads a RealFlutter instance with initial data.\n// 3. The loaded data is displayed on the screen.\n// 4. Users can increment the age using the \"Increment Age\" button, which demonstrates the use of copyWith.\n// 5. The \"Serialize to JSON\" button shows how to convert the object to JSON and back, printing the results to the console.\n// 6. Throughout the app, we use the RealFlutterState union type to handle different states (loading, loaded, error) in a type-safe manner.\n// 7. The Freezed annotations generate the necessary code for immutability, equality, copyWith, and JSON serialization/deserialization.\n```",
    "platforms": [
      "linux",
      "macos",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "inrl31wq"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CbCT",
        "_type": "reference",
        "_key": "4wnda27g"
      }
    ],
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8CaZr",
    "tutorialIncluded": true,
    "author": "dash-overflow.net",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGCM",
        "_type": "reference",
        "_key": "vx3a2uxy"
      }
    ]
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaSyE",
    "_type": "package",
    "description": "# Loading Animation Widget: A Comprehensive Guide\n\n## Introduction\n\nIn the world of mobile app development, user experience is paramount. One crucial aspect of UX is providing visual feedback during loading processes. The `loading_animation_widget` package for Flutter offers a simple yet powerful solution to implement attractive loading animations in your apps.\n\n## What is loading_animation_widget?\n\n`loading_animation_widget` is a Flutter package that provides a collection of pre-built, customizable loading animations. These animations can be easily integrated into your Flutter applications to enhance user engagement during wait times.\n\n## Key Features\n\n1. **Variety**: The package offers a wide range of animation styles, from simple spinners to complex, eye-catching animations.\n2. **Customization**: Each animation can be customized in terms of size, color, and speed to match your app's design language.\n3. **Ease of Use**: With a simple API, you can implement these animations with just a few lines of code.\n4. **Performance**: The animations are optimized for performance, ensuring smooth rendering even on lower-end devices.\n\n## Why Use loading_animation_widget?\n\n- **Improved User Experience**: Loading animations provide visual feedback, making wait times feel shorter and keeping users engaged.\n- **Professional Look**: Well-designed loading animations add a polished feel to your app.\n- **Time-Saving**: Instead of creating complex animations from scratch, you can use pre-built ones and customize them as needed.\n- **Cross-Platform Compatibility**: These animations work seamlessly on both iOS and Android platforms.\n\nIn the following sections, we'll dive into a tutorial on how to implement these animations and explore a comprehensive example showcasing various features of the package.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFqE",
        "_type": "reference",
        "_key": "gozlxor0"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:17:27Z",
    "_id": "uQRNMiDfrp20RZ8Id8Cakt",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:loading_animation_widget/loading_animation_widget.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Loading Animation Widget Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: LoadingAnimationDemo(),\n    );\n  }\n}\n\nclass LoadingAnimationDemo extends StatefulWidget {\n  @override\n  _LoadingAnimationDemoState createState() => _LoadingAnimationDemoState();\n}\n\nclass _LoadingAnimationDemoState extends State<LoadingAnimationDemo> {\n  // Step 1: Define variables\n  bool isLoading = false;\n  int selectedAnimationIndex = 0;\n  List<String> animationTypes = [\n    'waveDots',\n    'inkDrop',\n    'twistingDots',\n    'threeRotatingDots',\n    'staggeredDotsWave',\n    'fourRotatingDots',\n    'fallingDot',\n    'progressiveDots',\n    'discreteCircle',\n    'horizontalRotatingDots',\n    'bouncingBall',\n    'newtonCradle',\n    'beat',\n    'twoRotatingArc',\n    'flickr',\n    'hexagonDots',\n  ];\n\n  // Step 2: Create a method to get the selected animation\n  Widget getSelectedAnimation() {\n    switch (animationTypes[selectedAnimationIndex]) {\n      case 'waveDots':\n        return LoadingAnimationWidget.waveDots(color: Colors.blue, size: 50);\n      case 'inkDrop':\n        return LoadingAnimationWidget.inkDrop(color: Colors.blue, size: 50);\n      case 'twistingDots':\n        return LoadingAnimationWidget.twistingDots(color: Colors.blue, size: 50);\n      // Add cases for other animation types...\n      default:\n        return LoadingAnimationWidget.waveDots(color: Colors.blue, size: 50);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Loading Animation Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 3: Display the selected animation when isLoading is true\n            if (isLoading) getSelectedAnimation(),\n            SizedBox(height: 20),\n            // Step 4: Add a button to toggle loading state\n            ElevatedButton(\n              onPressed: () {\n                setState(() {\n                  isLoading = !isLoading;\n                });\n              },\n              child: Text(isLoading ? 'Stop Loading' : 'Start Loading'),\n            ),\n            SizedBox(height: 20),\n            // Step 5: Add a dropdown to select animation type\n            DropdownButton<int>(\n              value: selectedAnimationIndex,\n              items: List.generate(animationTypes.length, (index) {\n                return DropdownMenuItem(\n                  value: index,\n                  child: Text(animationTypes[index]),\n                );\n              }),\n              onChanged: (value) {\n                setState(() {\n                  selectedAnimationIndex = value!;\n                });\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen is set to LoadingAnimationDemo, a stateful widget.\n// 3. In the LoadingAnimationDemo:\n//    - We define a list of animation types and variables to track the loading state and selected animation.\n//    - The build method creates a layout with a conditional loading animation, a toggle button, and a dropdown.\n//    - When the user presses the button, it toggles the isLoading state, showing or hiding the animation.\n//    - The dropdown allows the user to select different animation types, updating the UI accordingly.\n// 4. The getSelectedAnimation method returns the appropriate LoadingAnimationWidget based on the user's selection.\n// 5. This setup allows for easy demonstration and testing of various loading animations provided by the package.\n```",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CVx1",
        "_type": "reference",
        "_key": "xab59f5g"
      }
    ],
    "tutorial": "# Loading Animation Widget: Tutorial\n\n## Getting Started\n\nTo begin using the `loading_animation_widget` package in your Flutter project, follow these steps:\n\n1. Add the package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  loading_animation_widget: ^1.2.0+4\n```\n\n2. Run `flutter pub get` in your terminal.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:loading_animation_widget/loading_animation_widget.dart';\n```\n\n## Basic Usage\n\nHere's a simple example of how to use a loading animation:\n\n```dart\nLoadingAnimationWidget.staggeredDotsWave(\n  color: Colors.blue,\n  size: 50,\n)\n```\n\nThis will display a staggered dots wave animation in blue color with a size of 50 logical pixels.\n\n## Customization\n\nMost animations allow you to customize:\n\n- `color`: The primary color of the animation.\n- `size`: The size of the animation widget.\n- `secondRingColor` and `thirdRingColor`: For animations with multiple elements.\n- `duration`: The duration of one complete animation cycle.\n\n## Platform-Specific Considerations\n\n### iOS\n\nOn iOS, you might want to use animations that align with the platform's design guidelines. Consider using animations like `stretchedDots` or `inkDrop` for a more iOS-native feel.\n\n```dart\nLoadingAnimationWidget.inkDrop(\n  color: Colors.blue,\n  size: 50,\n)\n```\n\n### Android\n\nFor Android, material design-inspired animations like `waveDots` or `threeRotatingDots` might be more appropriate.\n\n```dart\nLoadingAnimationWidget.threeRotatingDots(\n  color: Colors.blue,\n  size: 50,\n)\n```\n\n## Advanced Usage\n\nYou can wrap the loading animation widget in a `Center` widget to position it in the middle of the screen:\n\n```dart\nCenter(\n  child: LoadingAnimationWidget.discreteCircle(\n    color: Colors.blue,\n    size: 50,\n  ),\n)\n```\n\nFor conditional rendering, you can use a ternary operator:\n\n```dart\nisLoading \n  ? LoadingAnimationWidget.hexagonDots(\n      color: Colors.blue,\n      size: 50,\n    )\n  : YourContentWidget()\n```\n\nThis will show the loading animation when `isLoading` is true, and your content when it's false.\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize loading animations using the `loading_animation_widget` package in your Flutter applications.",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:02Z",
    "pubPoint": 160,
    "author": "waterydesert.com",
    "shortDescription": "Loading animation or loading spiner or loader. It's used to show loading animation when the app is in loading state or something is processing for uncertain time.",
    "tags": [
      "loading",
      "animation",
      "progress-indicator",
      "ui"
    ],
    "likesCount": 1607,
    "similarPackages": [],
    "packageImage": null,
    "lastUpdate": "2024-03-09T18:30:00.000Z",
    "name": "loading_animation_widget",
    "slug": {
      "current": "loading_animation_widget",
      "_type": "slug"
    }
  },
  {
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaZr",
        "_type": "reference",
        "_key": "grek8kah"
      }
    ],
    "packageImage": null,
    "name": "build_runner",
    "_rev": "ezMiwuUkJkbYMWycA6RdqQ",
    "_type": "package",
    "shortDescription": "A build system for Dart code generation and modular compilation.",
    "similarPackages": [],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbX6B",
        "_type": "reference",
        "_key": "xgga2rux"
      }
    ],
    "tutorialIncluded": true,
    "author": "tools.dart.dev",
    "tags": [
      "build-runner",
      "code-generation",
      "development-tool",
      "build-system"
    ],
    "slug": {
      "current": "build_runner",
      "_type": "slug"
    },
    "_createdAt": "2024-08-28T22:17:28Z",
    "lastUpdate": "2024-07-29T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CasF",
    "tutorial": "# Tutorial: Getting Started with build_runner in Flutter\n\n## Step 1: Add Dependencies\n\nFirst, add the necessary dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  json_annotation: ^4.8.1\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  build_runner: ^2.4.6\n  json_serializable: ^6.7.1\n```\n\nRun `flutter pub get` to install these packages.\n\n## Step 2: Create a Model Class\n\nCreate a file named `real_flutter.dart` and define your `RealFlutter` class:\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'real_flutter.g.dart';\n\n@JsonSerializable()\nclass RealFlutter {\n  final String name;\n  final int age;\n\n  RealFlutter({required this.name, required this.age});\n\n  factory RealFlutter.fromJson(Map<String, dynamic> json) => _$RealFlutterFromJson(json);\n  Map<String, dynamic> toJson() => _$RealFlutterToJson(this);\n}\n```\n\n## Step 3: Run build_runner\n\nNow, run the following command in your terminal:\n\n```\nflutter pub run build_runner build\n```\n\nThis will generate the `real_flutter.g.dart` file with the necessary JSON serialization code.\n\n## Step 4: Using the Generated Code\n\nYou can now use your `RealFlutter` class with JSON serialization:\n\n```dart\nfinal realFlutter = RealFlutter(name: 'Flutter Dev', age: 25);\nfinal json = realFlutter.toJson();\nfinal fromJson = RealFlutter.fromJson(json);\n```\n\n## Platform-Specific Considerations\n\n### Android\n- Ensure your `android/app/build.gradle` file has the correct Kotlin version (usually 1.5.0 or later).\n- If using ProGuard, add rules to prevent obfuscation of generated classes.\n\n### iOS\n- No specific considerations for iOS, but ensure you're using the latest stable version of Xcode.\n\n### Web\n- When building for web, use the `--web-renderer html` flag if you encounter any issues with the default renderer.\n\n### Desktop (Windows, macOS, Linux)\n- Ensure you have the necessary SDKs installed for your target platform.\n- For macOS, you might need to adjust your `macos/Runner/DebugProfile.entitlements` file if your app requires specific permissions.\n\nRemember to run `flutter pub run build_runner build` after making changes to your model classes to regenerate the necessary code.",
    "_updatedAt": "2024-09-06T04:13:03Z",
    "pubPoint": 160,
    "description": "# Understanding the build_runner Package in Flutter\n\n## What is build_runner?\n\n`build_runner` is a powerful package in the Flutter ecosystem that automates the process of generating Dart code. It's an essential tool for many Flutter developers, especially when working with code generation packages like `json_serializable`, `freezed`, or `built_value`.\n\n## Key Features of build_runner\n\n1. **Code Generation**: Automatically generates Dart code based on your existing code and annotations.\n2. **Incremental Builds**: Only regenerates code for files that have changed, saving time on large projects.\n3. **Watch Mode**: Continuously monitors your project for changes and regenerates code as needed.\n4. **Custom Builders**: Allows for the creation of custom code generators to suit specific project needs.\n\n## When to Use build_runner\n\nYou'll typically use `build_runner` in the following scenarios:\n\n- Working with JSON serialization/deserialization\n- Implementing the BLoC pattern with code generation\n- Using immutable data classes with `freezed`\n- Generating mock classes for testing\n- Any scenario where you need to generate Dart code based on your existing codebase\n\nIn the next sections, we'll dive into how to set up and use `build_runner` in your Flutter projects.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'dart:convert';\nimport 'real_flutter.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'build_runner Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: BuildRunnerDemo(),\n    );\n  }\n}\n\nclass BuildRunnerDemo extends StatefulWidget {\n  @override\n  _BuildRunnerDemoState createState() => _BuildRunnerDemoState();\n}\n\nclass _BuildRunnerDemoState extends State<BuildRunnerDemo> {\n  late RealFlutter realFlutter;\n  String jsonString = '';\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Create a RealFlutter instance\n    realFlutter = RealFlutter(name: 'Flutter Dev', age: 25);\n  }\n\n  void _convertToJson() {\n    // Step 2: Convert RealFlutter instance to JSON\n    setState(() {\n      jsonString = jsonEncode(realFlutter.toJson());\n    });\n  }\n\n  void _convertFromJson() {\n    // Step 3: Create a new RealFlutter instance from JSON\n    if (jsonString.isNotEmpty) {\n      setState(() {\n        realFlutter = RealFlutter.fromJson(jsonDecode(jsonString));\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('build_runner Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 4: Display RealFlutter instance details\n            Text('Name: ${realFlutter.name}'),\n            Text('Age: ${realFlutter.age}'),\n            SizedBox(height: 20),\n            // Step 5: Display JSON string\n            Text('JSON: $jsonString'),\n            SizedBox(height: 20),\n            // Step 6: Buttons to trigger conversions\n            ElevatedButton(\n              onPressed: _convertToJson,\n              child: Text('Convert to JSON'),\n            ),\n            ElevatedButton(\n              onPressed: _convertFromJson,\n              child: Text('Convert from JSON'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates a RealFlutter instance with name 'Flutter Dev' and age 25.\n// 2. The UI displays the current RealFlutter instance details.\n// 3. When the user taps 'Convert to JSON', the app uses the generated toJson() method to convert the instance to a JSON string.\n// 4. The JSON string is displayed on the screen.\n// 5. If the user taps 'Convert from JSON', the app uses the generated fromJson() method to create a new RealFlutter instance from the JSON string.\n// 6. The UI updates to reflect the new RealFlutter instance (which should be identical to the original in this case).\n//\n// This demo showcases how build_runner generates methods for JSON serialization and deserialization,\n// allowing easy conversion between Dart objects and JSON representations.\n```",
    "platforms": [
      "linux",
      "macos",
      "windows"
    ],
    "likesCount": 1982
  },
  {
    "_rev": "eaCZ7mIhmiYZX5KGqJmTWt",
    "tags": [
      "audio",
      "sound",
      "recording",
      "playback",
      "media"
    ],
    "lastUpdate": "2024-08-21T18:30:00.000Z",
    "name": "flutter_sound",
    "tutorial": "# Flutter Sound Tutorial: Getting Started\n\nThis tutorial will guide you through the process of integrating the Flutter Sound package into your Flutter application. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_sound: ^9.2.13\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the necessary Flutter Sound modules:\n\n```dart\nimport 'package:flutter_sound/flutter_sound.dart';\nimport 'package:flutter_sound_platform_interface/flutter_sound_recorder_platform_interface.dart';\n```\n\n## Step 3: Initialize Flutter Sound\n\nCreate instances of `FlutterSoundPlayer` and `FlutterSoundRecorder`:\n\n```dart\nclass RealFlutter {\n  final FlutterSoundPlayer _player = FlutterSoundPlayer();\n  final FlutterSoundRecorder _recorder = FlutterSoundRecorder();\n\n  Future<void> initializeSoundModule() async {\n    await _player.openPlayer();\n    await _recorder.openRecorder();\n  }\n}\n```\n\n## Step 4: Implement Basic Functionality\n\n### Recording Audio\n\n```dart\nFuture<void> startRecording() async {\n  await _recorder.startRecorder(\n    toFile: 'path_to_save_recording.aac',\n    codec: Codec.aacADTS,\n  );\n}\n\nFuture<void> stopRecording() async {\n  await _recorder.stopRecorder();\n}\n```\n\n### Playing Audio\n\n```dart\nFuture<void> playAudio(String filePath) async {\n  await _player.startPlayer(\n    fromURI: filePath,\n    codec: Codec.aacADTS,\n  );\n}\n\nFuture<void> stopAudio() async {\n  await _player.stopPlayer();\n}\n```\n\n## Step 5: Platform-Specific Setup\n\n### iOS Configuration\n\n1. Add the following to your `Info.plist` file:\n\n```xml\n<key>NSMicrophoneUsageDescription</key>\n<string>This application needs to access your microphone</string>\n<key>UIBackgroundModes</key>\n<array>\n    <string>audio</string>\n</array>\n```\n\n2. In your `Podfile`, add:\n\n```ruby\nplatform :ios, '10.0'\n```\n\n### Android Configuration\n\n1. In your `android/app/build.gradle`, set:\n\n```gradle\nminSdkVersion 21\n```\n\n2. Add the following permissions to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\"/>\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n```\n\n## Step 6: Request Permissions\n\nBefore using audio features, request necessary permissions:\n\n```dart\nimport 'package:permission_handler/permission_handler.dart';\n\nFuture<void> requestPermissions() async {\n  await Permission.microphone.request();\n  await Permission.storage.request();\n}\n```\n\nWith these steps completed, you're ready to start using Flutter Sound in your application. In the next section, we'll look at a comprehensive example that demonstrates the full power of this package.",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "zhrj84ma",
        "_ref": "4gmBGwifQuSypgRenUbW9O"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "likesCount": 1394,
    "slug": {
      "current": "flutter_sound",
      "_type": "slug"
    },
    "description": "# Flutter Sound: Unleash the Power of Audio in Your Flutter Apps\n\nFlutter Sound is a powerful and feature-rich audio plugin for Flutter that allows developers to easily integrate audio recording, playback, and manipulation capabilities into their applications. This versatile package supports a wide range of audio formats and provides a simple, yet comprehensive API for handling various audio-related tasks.\n\n## Key Features\n\n1. **Audio Recording**: Capture high-quality audio from device microphones with customizable settings.\n2. **Audio Playback**: Play audio files from various sources, including assets, file system, and network URLs.\n3. **Format Support**: Work with popular audio formats like MP3, AAC, OGG, OPUS, and more.\n4. **Audio Manipulation**: Perform operations like trimming, concatenation, and conversion on audio files.\n5. **Streaming**: Stream audio data for real-time processing or network transmission.\n6. **Cross-platform Compatibility**: Seamlessly works on iOS, Android, and web platforms.\n\n## Why Choose Flutter Sound?\n\nFlutter Sound stands out from other audio packages due to its:\n\n- **Comprehensive Feature Set**: From basic playback to advanced audio manipulation, it covers all your audio needs.\n- **Performance**: Optimized for efficiency, ensuring smooth audio operations even on resource-constrained devices.\n- **Easy Integration**: Simple API design makes it easy to incorporate into existing Flutter projects.\n- **Active Development**: Regular updates and a responsive community ensure ongoing support and improvements.\n\nIn the following sections, we'll dive deeper into how to use Flutter Sound in your projects, providing a step-by-step tutorial and a comprehensive example showcasing its features.",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "j1orgwzf"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:46Z",
    "_id": "uQRNMiDfrp20RZ8Id8Cb6x",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:04Z",
    "pubPoint": 160,
    "author": "tau.canardoux.xyz",
    "_type": "package",
    "shortDescription": "A complete api for audio playback and recording. Audio player, audio recorder.",
    "similarPackages": [
      {
        "_key": "39rr24hr",
        "_ref": "uQRNMiDfrp20RZ8Id8CWZd",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_sound/flutter_sound.dart';\nimport 'package:permission_handler/permission_handler.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  final FlutterSoundPlayer _player = FlutterSoundPlayer();\n  final FlutterSoundRecorder _recorder = FlutterSoundRecorder();\n  bool _isRecording = false;\n  bool _isPlaying = false;\n  String? _recordingFilePath;\n\n  @override\n  void initState() {\n    super.initState();\n    _initializeAudio();\n  }\n\n  // Step 1: Initialize audio modules and request permissions\n  Future<void> _initializeAudio() async {\n    await _player.openPlayer();\n    await _recorder.openRecorder();\n    await _requestPermissions();\n  }\n\n  // Step 2: Request necessary permissions\n  Future<void> _requestPermissions() async {\n    await Permission.microphone.request();\n    await Permission.storage.request();\n  }\n\n  // Step 3: Start recording function\n  Future<void> _startRecording() async {\n    try {\n      // Get the documents directory\n      Directory appDocDir = await getApplicationDocumentsDirectory();\n      String filePath = '${appDocDir.path}/recording.aac';\n      \n      // Start recording\n      await _recorder.startRecorder(\n        toFile: filePath,\n        codec: Codec.aacADTS,\n      );\n      \n      setState(() {\n        _isRecording = true;\n        _recordingFilePath = filePath;\n      });\n    } catch (e) {\n      print('Error starting recording: $e');\n    }\n  }\n\n  // Step 4: Stop recording function\n  Future<void> _stopRecording() async {\n    try {\n      await _recorder.stopRecorder();\n      setState(() {\n        _isRecording = false;\n      });\n    } catch (e) {\n      print('Error stopping recording: $e');\n    }\n  }\n\n  // Step 5: Play audio function\n  Future<void> _playAudio() async {\n    if (_recordingFilePath != null) {\n      try {\n        await _player.startPlayer(\n          fromURI: _recordingFilePath,\n          codec: Codec.aacADTS,\n          whenFinished: () {\n            setState(() {\n              _isPlaying = false;\n            });\n          },\n        );\n        setState(() {\n          _isPlaying = true;\n        });\n      } catch (e) {\n        print('Error playing audio: $e');\n      }\n    }\n  }\n\n  // Step 6: Stop audio function\n  Future<void> _stopAudio() async {\n    try {\n      await _player.stopPlayer();\n      setState(() {\n        _isPlaying = false;\n      });\n    } catch (e) {\n      print('Error stopping audio: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Audio Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 7: Recording button\n            ElevatedButton(\n              onPressed: _isRecording ? _stopRecording : _startRecording,\n              child: Text(_isRecording ? 'Stop Recording' : 'Start Recording'),\n            ),\n            SizedBox(height: 20),\n            // Step 8: Playback button\n            ElevatedButton(\n              onPressed: _isPlaying ? _stopAudio : _playAudio,\n              child: Text(_isPlaying ? 'Stop Playing' : 'Play Recording'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 9: Clean up resources\n    _player.closePlayer();\n    _recorder.closeRecorder();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app initializes by setting up the audio modules and requesting permissions.\n// 2. The user interface displays two buttons: one for recording and one for playback.\n// 3. When the user presses the \"Start Recording\" button, the app begins recording audio.\n// 4. Pressing the button again stops the recording and saves it to a file.\n// 5. The \"Play Recording\" button becomes active once a recording is available.\n// 6. Pressing \"Play Recording\" starts playback of the most recent recording.\n// 7. The user can stop playback at any time by pressing the button again.\n// 8. The app properly manages resources by closing the player and recorder when disposed.\n\n// This example demonstrates basic audio recording and playback functionality.\n// It can be extended to include more advanced features like audio visualization,\n// multiple track management, or audio effects processing.\n```"
  },
  {
    "description": "# Understanding the built_value Package in Flutter\n\n## Introduction\n\nThe `built_value` package is a powerful tool for Flutter developers looking to implement immutable object models in their applications. It provides a robust solution for creating serializable, immutable value types with minimal boilerplate code.\n\n## Key Features\n\n1. **Immutability**: `built_value` enforces immutability, ensuring that objects cannot be modified after creation. This leads to more predictable and easier-to-reason-about code.\n\n2. **Code Generation**: The package uses code generation to minimize boilerplate. You define your classes, and `built_value` generates the necessary implementation code.\n\n3. **Serialization**: Built-in support for JSON serialization and deserialization, making it easy to work with APIs and persist data.\n\n4. **Type Safety**: Leverages Dart's strong typing system to catch errors at compile-time rather than runtime.\n\n5. **Equality and Hashing**: Automatically generates correct implementations of `==`, `hashCode`, and `toString()` methods.\n\n6. **Builder Pattern**: Uses the builder pattern for object construction, allowing for flexible and readable object creation.\n\n## When to Use built_value\n\n- When working with complex data models that benefit from immutability\n- For projects requiring efficient serialization and deserialization\n- In scenarios where you want to catch data-related errors at compile-time\n- When you need to ensure data integrity throughout your application\n\nBy leveraging `built_value`, developers can create more robust, maintainable, and efficient Flutter applications with less error-prone code.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "vz7z29z8"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CbCT",
    "_updatedAt": "2024-09-06T04:13:05Z",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbYos",
        "_type": "reference",
        "_key": "9vwubd2y"
      }
    ],
    "likesCount": 691,
    "name": "built_value",
    "tutorial": "# Tutorial: Implementing built_value in Flutter\n\n## Step 1: Setup\n\nFirst, add the necessary dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  built_value: ^8.4.0\n\ndev_dependencies:\n  build_runner: ^2.1.11\n  built_value_generator: ^8.4.0\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Define Your Model\n\nCreate a new file `lib/models/real_flutter.dart`:\n\n```dart\nimport 'package:built_value/built_value.dart';\nimport 'package:built_value/serializer.dart';\n\npart 'real_flutter.g.dart';\n\nabstract class RealFlutter implements Built<RealFlutter, RealFlutterBuilder> {\n  String get name;\n  int get version;\n  bool get isStable;\n\n  RealFlutter._();\n  factory RealFlutter([void Function(RealFlutterBuilder) updates]) = _$RealFlutter;\n\n  static Serializer<RealFlutter> get serializer => _$realFlutterSerializer;\n}\n```\n\n## Step 3: Generate Code\n\nRun the following command to generate the necessary code:\n\n```\nflutter pub run build_runner build\n```\n\nThis will create the `real_flutter.g.dart` file with the generated code.\n\n## Step 4: Using the Model\n\nNow you can use your `RealFlutter` model in your application:\n\n```dart\nfinal flutter = RealFlutter((b) => b\n  ..name = 'Flutter'\n  ..version = 2\n  ..isStable = true\n);\n\nprint(flutter.name); // Output: Flutter\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have Xcode installed and up-to-date.\n- Run `pod install` in the iOS directory if you're using CocoaPods.\n\n### Android\n- Make sure you have the latest Android SDK tools installed.\n- Update your `android/app/build.gradle` file to include the latest Kotlin version if needed.\n\n### Web\n- No specific setup required for web, but ensure you're using a compatible Flutter version.\n\n### Desktop (Windows, macOS, Linux)\n- Enable desktop support in Flutter: `flutter config --enable-<platform>-desktop`\n- Ensure you have the necessary development tools installed for your platform.\n\nBy following these steps, you'll have a basic implementation of `built_value` in your Flutter project, ready for further customization and use across all supported platforms.",
    "slug": {
      "current": "built_value",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "Value types with builders, Dart classes as enums, and serialization. This library is the runtime dependency.",
    "_createdAt": "2024-08-28T22:17:47Z",
    "tutorialIncluded": true,
    "packageImage": null,
    "lastUpdate": "2024-04-02T18:30:00.000Z",
    "author": "google.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaT4c",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:built_value/built_value.dart';\nimport 'package:built_value/serializer.dart';\nimport 'package:built_collection/built_collection.dart';\n\n// Step 1: Import the generated file\npart 'main.g.dart';\n\n// Step 2: Define the RealFlutter class\nabstract class RealFlutter implements Built<RealFlutter, RealFlutterBuilder> {\n  String get name;\n  int get version;\n  bool get isStable;\n  BuiltList<String> get features;\n\n  RealFlutter._();\n  factory RealFlutter([void Function(RealFlutterBuilder) updates]) = _$RealFlutter;\n\n  static Serializer<RealFlutter> get serializer => _$realFlutterSerializer;\n}\n\n// Step 3: Define the serializers\n@SerializersFor([RealFlutter])\nfinal Serializers serializers = _$serializers;\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutterDemo(),\n    );\n  }\n}\n\nclass RealFlutterDemo extends StatefulWidget {\n  @override\n  _RealFlutterDemoState createState() => _RealFlutterDemoState();\n}\n\nclass _RealFlutterDemoState extends State<RealFlutterDemo> {\n  late RealFlutter flutter;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 4: Initialize the RealFlutter object\n    flutter = RealFlutter((b) => b\n      ..name = 'Flutter'\n      ..version = 2\n      ..isStable = true\n      ..features = ListBuilder(['Hot Reload', 'Cross-Platform', 'Fast'])\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Name: ${flutter.name}'),\n            Text('Version: ${flutter.version}'),\n            Text('Is Stable: ${flutter.isStable}'),\n            Text('Features: ${flutter.features.join(\", \")}'),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Update Version'),\n              onPressed: () {\n                // Step 5: Demonstrate immutability and updating\n                setState(() {\n                  flutter = flutter.rebuild((b) => b..version = b.version! + 1);\n                });\n              },\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Serialize to JSON'),\n              onPressed: () {\n                // Step 6: Demonstrate serialization\n                final jsonString = serializers.serializeWith(RealFlutter.serializer, flutter);\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('Serialized: $jsonString')),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates a RealFlutter object with initial values.\n// 2. The main screen displays the current values of the RealFlutter object.\n// 3. When the \"Update Version\" button is pressed, a new RealFlutter object is created\n//    with an incremented version number, demonstrating immutability.\n// 4. When the \"Serialize to JSON\" button is pressed, the current RealFlutter object\n//    is serialized to JSON, demonstrating the serialization feature.\n// \n// Key Points:\n// - The RealFlutter class is immutable. We can't change its properties directly.\n// - To update a value, we create a new instance using the `rebuild` method.\n// - The `built_value` package generates equality methods, so two RealFlutter objects\n//   with the same values will be considered equal.\n// - Serialization is handled automatically by the generated code.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "built-value",
      "serialization",
      "immutable",
      "code-generation"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CaZr",
        "_type": "reference",
        "_key": "bz6dpaex"
      }
    ]
  },
  {
    "pubPoint": 160,
    "description": "# Country Code Picker Package for Flutter\n\nThe `country_code_picker` package is a powerful and versatile Flutter widget that allows developers to easily implement country code selection functionality in their applications. This package is particularly useful for apps that require international phone number input or any feature involving country selection.\n\n## Key Features\n\n1. **Extensive Country List**: Includes a comprehensive list of countries with their respective flags, names, and phone codes.\n\n2. **Customizable UI**: Offers various customization options for the picker's appearance, including text styles, button colors, and flag size.\n\n3. **Search Functionality**: Allows users to search for countries by name or dial code, enhancing user experience.\n\n4. **Initial Selection**: Supports setting an initial country selection, which can be based on the user's locale or a predefined choice.\n\n5. **Callback Functions**: Provides callback functions to handle country selection events, making it easy to integrate with other parts of your application.\n\n6. **Localization Support**: Includes support for multiple languages, allowing the country names to be displayed in the user's preferred language.\n\n7. **Favorite Countries**: Allows setting a list of favorite or frequently used countries to appear at the top of the list for quick access.\n\n## Use Cases\n\n- International phone number input forms\n- User registration with country selection\n- Location-based services\n- E-commerce applications with country-specific features\n- Travel and tourism apps\n\nBy incorporating the `country_code_picker` package into your Flutter project, you can significantly enhance the user experience for any feature requiring country selection or phone number input. Its ease of use and extensive customization options make it a valuable tool for Flutter developers working on internationally-oriented applications.",
    "likesCount": 823,
    "packageImage": null,
    "lastUpdate": "2023-03-09T18:30:00.000Z",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfAkO",
        "_type": "reference",
        "_key": "xbl4jd8w"
      }
    ],
    "tags": [
      "country-code",
      "phone-number",
      "input",
      "internationalization"
    ],
    "shortDescription": "A flutter package for showing a country code selector. In addition it gives the possibility to select a list of favorites countries, as well as to search using a simple searchbox",
    "similarPackages": [],
    "name": "country_code_picker",
    "_id": "uQRNMiDfrp20RZ8Id8CbHz",
    "tutorialIncluded": true,
    "slug": {
      "current": "country_code_picker",
      "_type": "slug"
    },
    "tutorial": "# Tutorial: Implementing Country Code Picker in Flutter\n\nThis tutorial will guide you through the process of implementing the `country_code_picker` package in your Flutter application.\n\n## Step 1: Add Dependencies\n\nFirst, add the `country_code_picker` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  country_code_picker: ^2.0.2\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:country_code_picker/country_code_picker.dart';\n```\n\n## Step 3: Implement the CountryCodePicker Widget\n\nAdd the `CountryCodePicker` widget to your widget tree:\n\n```dart\nCountryCodePicker(\n  onChanged: (CountryCode countryCode) {\n    print(\"New Country selected: \" + countryCode.toString());\n  },\n  initialSelection: 'US',\n  favorite: ['+1', 'US'],\n  showCountryOnly: false,\n  showOnlyCountryWhenClosed: false,\n  alignLeft: false,\n)\n```\n\n## Step 4: Customize the Picker\n\nThe `CountryCodePicker` widget offers various customization options:\n\n```dart\nCountryCodePicker(\n  onChanged: (CountryCode countryCode) {\n    print(\"New Country selected: \" + countryCode.toString());\n  },\n  initialSelection: 'US',\n  favorite: ['+1', 'US'],\n  showCountryOnly: false,\n  showOnlyCountryWhenClosed: false,\n  alignLeft: false,\n  showFlag: true,\n  showFlagDialog: true,\n  showFlagMain: true,\n  flagWidth: 30,\n  padding: EdgeInsets.all(8),\n  textStyle: TextStyle(fontSize: 16),\n  dialogTextStyle: TextStyle(fontSize: 16),\n  searchStyle: TextStyle(fontSize: 16),\n  dialogSize: Size(300, 500),\n  boxDecoration: BoxDecoration(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(8),\n    boxShadow: [\n      BoxShadow(color: Colors.grey, blurRadius: 5),\n    ],\n  ),\n)\n```\n\n## Step 5: Handle Country Selection\n\nUse the `onChanged` callback to handle country selection:\n\n```dart\nString selectedCountryCode = '';\n\nCountryCodePicker(\n  onChanged: (CountryCode countryCode) {\n    setState(() {\n      selectedCountryCode = countryCode.dialCode ?? '';\n    });\n    print(\"Selected Country Code: $selectedCountryCode\");\n  },\n  // ... other properties\n)\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional configuration is required. The package should work out of the box.\n\n### iOS\n\nFor iOS, you need to add the following keys to your `Info.plist` file to ensure proper functionality of the search feature:\n\n```xml\n<key>CFBundleLocalizations</key>\n<array>\n    <string>en</string>\n    <!-- Add other languages your app supports -->\n</array>\n```\n\nThis allows the package to access the device's language settings for proper localization.\n\n### Web\n\nFor web applications, make sure to include the necessary assets in your `web/index.html` file:\n\n```html\n<head>\n  <!-- ... other head elements ... -->\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n</head>\n```\n\nCreate a `web/styles.css` file and add any custom styles you want to apply to the country code picker on the web platform.\n\nBy following these steps and considering the platform-specific details, you can successfully implement and customize the Country Code Picker in your Flutter application across different platforms.",
    "author": "solusibejo.com",
    "_rev": "AE3hjGWNkNE6aGQMMbaT7o",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:country_code_picker/country_code_picker.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Country Code Picker Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: CountryCodePickerDemo(),\n    );\n  }\n}\n\nclass CountryCodePickerDemo extends StatefulWidget {\n  @override\n  _CountryCodePickerDemoState createState() => _CountryCodePickerDemoState();\n}\n\nclass _CountryCodePickerDemoState extends State<CountryCodePickerDemo> {\n  // Step 1: Initialize variables\n  String selectedCountryCode = '';\n  String selectedCountryName = '';\n  String phoneNumber = '';\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Country Code Picker Demo')),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 2: Implement CountryCodePicker\n            CountryCodePicker(\n              onChanged: _onCountryChange,\n              initialSelection: 'US',\n              favorite: ['+1', 'US'],\n              showCountryOnly: false,\n              showOnlyCountryWhenClosed: false,\n              alignLeft: false,\n              showFlag: true,\n              showFlagDialog: true,\n              showFlagMain: true,\n              flagWidth: 30,\n              padding: EdgeInsets.all(8),\n              textStyle: TextStyle(fontSize: 16),\n              dialogTextStyle: TextStyle(fontSize: 16),\n              searchStyle: TextStyle(fontSize: 16),\n              dialogSize: Size(300, 500),\n              boxDecoration: BoxDecoration(\n                color: Colors.white,\n                borderRadius: BorderRadius.circular(8),\n                boxShadow: [\n                  BoxShadow(color: Colors.grey, blurRadius: 5),\n                ],\n              ),\n            ),\n            SizedBox(height: 20),\n            // Step 3: Display selected country information\n            Text('Selected Country: $selectedCountryName'),\n            Text('Selected Country Code: $selectedCountryCode'),\n            SizedBox(height: 20),\n            // Step 4: Implement phone number input\n            Row(\n              children: [\n                Text(selectedCountryCode),\n                SizedBox(width: 10),\n                Expanded(\n                  child: TextField(\n                    onChanged: (value) {\n                      setState(() {\n                        phoneNumber = value;\n                      });\n                    },\n                    keyboardType: TextInputType.phone,\n                    decoration: InputDecoration(\n                      hintText: 'Enter phone number',\n                      border: OutlineInputBorder(),\n                    ),\n                  ),\n                ),\n              ],\n            ),\n            SizedBox(height: 20),\n            // Step 5: Display full phone number\n            Text('Full Phone Number: $selectedCountryCode$phoneNumber'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 6: Handle country selection\n  void _onCountryChange(CountryCode countryCode) {\n    setState(() {\n      selectedCountryCode = countryCode.dialCode ?? '';\n      selectedCountryName = countryCode.name ?? '';\n    });\n    print(\"New Country selected: $selectedCountryName\");\n    print(\"New Country Code: $selectedCountryCode\");\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. CountryCodePickerDemo is the main screen of the app.\n// 3. In the build method, we create the UI:\n//    a. CountryCodePicker widget allows users to select a country.\n//    b. Selected country information is displayed below the picker.\n//    c. A text field for phone number input is provided.\n//    d. The full phone number (country code + entered number) is displayed.\n// 4. When a user selects a country, _onCountryChange is called:\n//    a. It updates the selectedCountryCode and selectedCountryName.\n//    b. The UI is rebuilt to reflect the new selection.\n// 5. As the user types in the phone number, the state is updated, and the full\n//    phone number display is updated in real-time.\n// \n// This example demonstrates the core features of the country_code_picker package,\n// including country selection, customization, and integration with phone number input.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:17:48Z",
    "_updatedAt": "2024-09-06T04:13:07Z"
  },
  {
    "pubPoint": 160,
    "similarPackages": [],
    "subCategories": [
      {
        "_key": "2wbgmt9o",
        "_ref": "4gmBGwifQuSypgRenUbW9O",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "macos",
      "web",
      "windows"
    ],
    "tutorialIncluded": true,
    "shortDescription": "A flutter plugin for Text to Speech.  This plugin is supported on iOS, macOS, Android, Web, & Windows.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_tts/flutter_tts.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter TTS Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: TTSDemo(),\n    );\n  }\n}\n\nclass TTSDemo extends StatefulWidget {\n  @override\n  _TTSDemoState createState() => _TTSDemoState();\n}\n\nclass _TTSDemoState extends State<TTSDemo> {\n  // Step 1: Initialize FlutterTts\n  FlutterTts flutterTts = FlutterTts();\n  String text = 'Hello, welcome to the Flutter TTS demo!';\n  double volume = 0.5;\n  double pitch = 1.0;\n  double rate = 0.5;\n  String? language;\n  String? voice;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Initialize TTS settings\n    initTts();\n  }\n\n  // Step 3: Initialize TTS settings\n  Future<void> initTts() async {\n    await flutterTts.setLanguage(\"en-US\");\n    await flutterTts.setPitch(pitch);\n    await flutterTts.setSpeechRate(rate);\n    await flutterTts.setVolume(volume);\n\n    // Step 4: Set up event listeners\n    flutterTts.setStartHandler(() {\n      setState(() => print(\"TTS Started\"));\n    });\n    flutterTts.setCompletionHandler(() {\n      setState(() => print(\"TTS Completed\"));\n    });\n    flutterTts.setErrorHandler((message) {\n      setState(() => print(\"TTS Error: $message\"));\n    });\n  }\n\n  // Step 5: Implement speak function\n  Future<void> speak() async {\n    await flutterTts.speak(text);\n  }\n\n  // Step 6: Implement stop function\n  Future<void> stop() async {\n    await flutterTts.stop();\n  }\n\n  // Step 7: Implement pause function\n  Future<void> pause() async {\n    await flutterTts.pause();\n  }\n\n  // Step 8: Implement function to get available languages\n  Future<void> getLanguages() async {\n    var languages = await flutterTts.getLanguages;\n    print(languages);\n  }\n\n  // Step 9: Implement function to get available voices\n  Future<void> getVoices() async {\n    var voices = await flutterTts.getVoices;\n    print(voices);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Flutter TTS Demo')),\n      body: SingleChildScrollView(\n        padding: EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 10: Text input field\n            TextField(\n              maxLines: 3,\n              onChanged: (value) => setState(() => text = value),\n              decoration: InputDecoration(\n                hintText: 'Enter text to speak',\n                border: OutlineInputBorder(),\n              ),\n            ),\n            SizedBox(height: 20),\n            // Step 11: Volume slider\n            Text('Volume: ${volume.toStringAsFixed(2)}'),\n            Slider(\n              value: volume,\n              min: 0,\n              max: 1,\n              onChanged: (value) => setState(() => volume = value),\n              onChangeEnd: (value) => flutterTts.setVolume(value),\n            ),\n            // Step 12: Pitch slider\n            Text('Pitch: ${pitch.toStringAsFixed(2)}'),\n            Slider(\n              value: pitch,\n              min: 0.5,\n              max: 2,\n              onChanged: (value) => setState(() => pitch = value),\n              onChangeEnd: (value) => flutterTts.setPitch(value),\n            ),\n            // Step 13: Rate slider\n            Text('Rate: ${rate.toStringAsFixed(2)}'),\n            Slider(\n              value: rate,\n              min: 0.1,\n              max: 1,\n              onChanged: (value) => setState(() => rate = value),\n              onChangeEnd: (value) => flutterTts.setSpeechRate(value),\n            ),\n            SizedBox(height: 20),\n            // Step 14: Control buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(onPressed: speak, child: Text('Speak')),\n                ElevatedButton(onPressed: pause, child: Text('Pause')),\n                ElevatedButton(onPressed: stop, child: Text('Stop')),\n              ],\n            ),\n            SizedBox(height: 20),\n            // Step 15: Language and voice selection buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: getLanguages,\n                  child: Text('Get Languages'),\n                ),\n                ElevatedButton(\n                  onPressed: getVoices,\n                  child: Text('Get Voices'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. TTSDemo is the main screen of the app.\n// 3. In initState, we initialize the TTS engine and set up event listeners.\n// 4. The build method creates the UI:\n//    a. A text input field for entering the text to be spoken.\n//    b. Sliders for adjusting volume, pitch, and speech rate.\n//    c. Buttons for controlling speech (Speak, Pause, Stop).\n//    d. Buttons for getting available languages and voices.\n// 5. When the user enters text and presses 'Speak', the speak() method is called.\n// 6. The pause() and stop() methods allow the user to control ongoing speech.\n// 7. Adjusting the sliders immediately updates the UI and applies changes to the TTS engine.\n// 8. The getLanguages() and getVoices() methods print available options to the console.\n// \n// This example demonstrates the core features of the flutter_tts package,\n// including text-to-speech conversion, speech control, and customization of speech parameters.\n```",
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:50Z",
    "slug": {
      "current": "flutter_tts",
      "_type": "slug"
    },
    "author": "tundralabs.com",
    "_rev": "eaCZ7mIhmiYZX5KGqJmTnG",
    "description": "# Flutter TTS Package: Text-to-Speech for Flutter Applications\n\nThe `flutter_tts` package is a powerful and versatile text-to-speech (TTS) plugin for Flutter applications. It provides developers with the ability to convert text into synthesized speech, enhancing the accessibility and user experience of their apps across multiple platforms.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Supports Android, iOS, Web, macOS, and Windows platforms, ensuring a consistent TTS experience across devices.\n\n2. **Multiple Languages**: Offers support for a wide range of languages and locales, allowing for global app deployment.\n\n3. **Voice Control**: Provides options to adjust speech rate, pitch, and volume, giving developers fine-grained control over the speech output.\n\n4. **Voice Selection**: Allows selection from available voices on the device, including gender-specific voices where supported.\n\n5. **Asynchronous API**: Features an asynchronous API for non-blocking TTS operations, ensuring smooth app performance.\n\n6. **Playback Controls**: Includes methods to start, stop, pause, and resume speech playback, offering a complete audio control experience.\n\n7. **Event Handling**: Provides callbacks for various TTS events such as start, completion, and errors, allowing for precise app behavior control.\n\n8. **Text Chunking**: Supports breaking down long text into smaller chunks for more manageable TTS processing.\n\n9. **SSML Support**: Offers Speech Synthesis Markup Language (SSML) support for advanced control over speech synthesis.\n\n10. **Offline Mode**: Some platforms support offline TTS, reducing dependency on internet connectivity.\n\n## Use Cases\n\n- Accessibility features for visually impaired users\n- Language learning applications\n- Navigation and directions in map apps\n- Audio book or article readers\n- Voice-based user interfaces\n- Educational apps for children\n- Pronunciation guides in dictionary apps\n\nBy integrating the `flutter_tts` package into your Flutter project, you can significantly enhance the auditory experience of your application. Its extensive feature set and cross-platform compatibility make it an invaluable tool for developers looking to incorporate text-to-speech functionality in their Flutter apps.",
    "lastUpdate": "2024-03-21T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CbNV",
    "_updatedAt": "2024-09-06T04:13:08Z",
    "_type": "package",
    "tags": [
      "text-to-speech",
      "tts",
      "accessibility",
      "audio"
    ],
    "likesCount": 1250,
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cb6x",
        "_type": "reference",
        "_key": "kp3vz39f"
      }
    ],
    "name": "flutter_tts",
    "tutorial": "# Tutorial: Implementing Flutter TTS in Your Application\n\nThis tutorial will guide you through the process of implementing the `flutter_tts` package in your Flutter application.\n\n## Step 1: Add Dependencies\n\nFirst, add the `flutter_tts` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_tts: ^3.6.3\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_tts/flutter_tts.dart';\n```\n\n## Step 3: Initialize FlutterTts\n\nCreate an instance of FlutterTts in your widget:\n\n```dart\nclass _MyHomePageState extends State<MyHomePage> {\n  FlutterTts flutterTts = FlutterTts();\n\n  @override\n  void initState() {\n    super.initState();\n    initTts();\n  }\n\n  Future<void> initTts() async {\n    await flutterTts.setLanguage(\"en-US\");\n    await flutterTts.setPitch(1.0);\n    await flutterTts.setSpeechRate(0.5);\n  }\n\n  // ...\n}\n```\n\n## Step 4: Implement Basic TTS Functionality\n\nAdd methods to speak, stop, and pause:\n\n```dart\nFuture<void> speak(String text) async {\n  await flutterTts.speak(text);\n}\n\nFuture<void> stop() async {\n  await flutterTts.stop();\n}\n\nFuture<void> pause() async {\n  await flutterTts.pause();\n}\n```\n\n## Step 5: Handle TTS Events\n\nSet up event listeners for TTS events:\n\n```dart\nvoid initState() {\n  super.initState();\n  initTts();\n  flutterTts.setStartHandler(() {\n    setState(() {\n      print(\"TTS Started\");\n    });\n  });\n  flutterTts.setCompletionHandler(() {\n    setState(() {\n      print(\"TTS Completed\");\n    });\n  });\n  flutterTts.setErrorHandler((message) {\n    setState(() {\n      print(\"TTS Error: $message\");\n    });\n  });\n}\n```\n\n## Step 6: Implement Advanced Features\n\nAdd methods for changing voice, language, and using SSML:\n\n```dart\nFuture<void> setVoice(String voice) async {\n  await flutterTts.setVoice({\"name\": voice, \"locale\": \"en-US\"});\n}\n\nFuture<void> setLanguage(String language) async {\n  await flutterTts.setLanguage(language);\n}\n\nFuture<void> speakSSML(String ssml) async {\n  await flutterTts.setSpeechRate(0.5);\n  await flutterTts.speak(ssml);\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, add the following permission to your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n\n### iOS\n\nFor iOS, add the following to your `Info.plist`:\n\n```xml\n<key>NSSpeechRecognitionUsageDescription</key>\n<string>This application uses speech recognition to convert your speech to text</string>\n```\n\n### Web\n\nFor web support, add the following script to your `web/index.html`:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/flutter_tts@latest/dist/flutter_tts.min.js\"></script>\n```\n\n### macOS\n\nFor macOS, add the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`:\n\n```xml\n<key>com.apple.security.network.client</key>\n<true/>\n```\n\n### Windows\n\nFor Windows, no additional configuration is required.\n\nBy following these steps and considering the platform-specific details, you can successfully implement Text-to-Speech functionality in your Flutter application across different platforms using the flutter_tts package."
  },
  {
    "likesCount": 1922,
    "tutorial": "# Curved Navigation Bar: Implementation Tutorial\n\nThis tutorial will guide you through the process of implementing the `curved_navigation_bar` package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `curved_navigation_bar` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  curved_navigation_bar: ^1.0.3 # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:curved_navigation_bar/curved_navigation_bar.dart';\n```\n\nImplement the `CurvedNavigationBar` widget in your `Scaffold`:\n\n```dart\nScaffold(\n  bottomNavigationBar: CurvedNavigationBar(\n    backgroundColor: Colors.blueAccent,\n    items: <Widget>[\n      Icon(Icons.home, size: 30),\n      Icon(Icons.list, size: 30),\n      Icon(Icons.compare_arrows, size: 30),\n    ],\n    onTap: (index) {\n      // Handle button tap\n    },\n  ),\n  body: Container(color: Colors.blueAccent),\n)\n```\n\n## Step 3: Customization\n\nCustomize the appearance and behavior of the navigation bar:\n\n```dart\nCurvedNavigationBar(\n  backgroundColor: Colors.blueAccent,\n  color: Colors.white,\n  buttonBackgroundColor: Colors.white,\n  height: 60,\n  animationCurve: Curves.easeInOut,\n  animationDuration: Duration(milliseconds: 600),\n  items: <Widget>[\n    Icon(Icons.home, size: 30, color: Colors.blueAccent),\n    Icon(Icons.list, size: 30, color: Colors.blueAccent),\n    Icon(Icons.compare_arrows, size: 30, color: Colors.blueAccent),\n  ],\n  onTap: (index) {\n    // Handle button tap\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure that the navigation bar doesn't interfere with the home indicator on newer iPhone models. You can adjust the `height` property or add padding to the bottom of your screen:\n\n```dart\nSafeArea(\n  child: CurvedNavigationBar(\n    // ... other properties\n    height: 65, // Slightly taller to account for home indicator\n  ),\n)\n```\n\n### Android\n\nOn Android, you may want to handle the back button press to navigate through the bottom bar items before exiting the app. Implement this in your `WillPopScope` widget:\n\n```dart\nWillPopScope(\n  onWillPop: () async {\n    if (_page != 0) {\n      setState(() {\n        _page = 0;\n        _pageController.jumpToPage(0);\n      });\n      return false;\n    }\n    return true;\n  },\n  child: Scaffold(\n    // ... your scaffold content\n  ),\n)\n```\n\nBy following these steps and considering platform-specific details, you can successfully implement and customize the `curved_navigation_bar` package in your Flutter application, creating a smooth and engaging navigation experience for your users.",
    "description": "# Curved Navigation Bar: A Sleek Navigation Solution for Flutter\n\nThe `curved_navigation_bar` package is a powerful and visually appealing navigation solution for Flutter applications. It provides a customizable, animated bottom navigation bar with a unique curved design that adds a touch of elegance to your app's user interface.\n\n## Key Features\n\n1. **Smooth Animations**: The package offers fluid animations when switching between navigation items, enhancing the user experience.\n\n2. **Customizable Appearance**: Developers can easily customize the color, size, and icons of the navigation bar to match their app's design language.\n\n3. **Flexible Item Count**: The curved navigation bar supports a variable number of items, allowing for versatile navigation schemes.\n\n4. **Index Control**: Programmatically control the selected index, enabling dynamic navigation updates based on app logic.\n\n5. **Button Customization**: Each navigation item can be customized independently, allowing for unique icons or even widgets as navigation elements.\n\n6. **Responsive Design**: The package adapts well to different screen sizes, maintaining its aesthetic appeal across devices.\n\n## When to Use Curved Navigation Bar\n\nThe `curved_navigation_bar` package is ideal for:\n\n- Apps with a modern, sleek design aesthetic\n- Projects that require a standout navigation component\n- Applications with 3-5 main navigation sections\n- Developers looking to enhance user engagement through interactive UI elements\n\nBy incorporating the curved navigation bar, you can create a visually striking and user-friendly navigation experience that sets your app apart from the crowd.",
    "_rev": "eaCZ7mIhmiYZX5KGqJmTto",
    "shortDescription": "Stunning Animating Curved Shape Navigation Bar. Adjustable color, background color, animation curve, animation duration.",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CeP3",
        "_type": "reference",
        "_key": "3xwmsrkm"
      }
    ],
    "tags": [
      "navigation",
      "bottom-bar",
      "ui",
      "custom-widget"
    ],
    "packageImage": null,
    "tutorialIncluded": true,
    "slug": {
      "current": "curved_navigation_bar",
      "_type": "slug"
    },
    "author": "bednarczuk.dev",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:curved_navigation_bar/curved_navigation_bar.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Curved Navigation Bar Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  int _page = 0;\n  GlobalKey<CurvedNavigationBarState> _bottomNavigationKey = GlobalKey();\n\n  // Step 1: Create a list of widgets for each page\n  final List<Widget> _pages = [\n    HomeContent(),\n    SearchContent(),\n    ProfileContent(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Curved Navigation Bar Demo'),\n      ),\n      // Step 2: Implement CurvedNavigationBar in the bottomNavigationBar\n      bottomNavigationBar: CurvedNavigationBar(\n        key: _bottomNavigationKey,\n        index: 0,\n        height: 60.0,\n        items: <Widget>[\n          Icon(Icons.home, size: 30),\n          Icon(Icons.search, size: 30),\n          Icon(Icons.person, size: 30),\n        ],\n        color: Colors.white,\n        buttonBackgroundColor: Colors.white,\n        backgroundColor: Colors.blueAccent,\n        animationCurve: Curves.easeInOut,\n        animationDuration: Duration(milliseconds: 600),\n        onTap: (index) {\n          // Step 3: Handle navigation\n          setState(() {\n            _page = index;\n          });\n        },\n        letIndexChange: (index) => true,\n      ),\n      // Step 4: Display the selected page\n      body: _pages[_page],\n    );\n  }\n}\n\n// Step 5: Create content widgets for each page\nclass HomeContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        'Home Page',\n        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n}\n\nclass SearchContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        'Search Page',\n        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n}\n\nclass ProfileContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        'Profile Page',\n        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with the HomePage widget, which contains the CurvedNavigationBar.\n// 2. The CurvedNavigationBar is initialized with three items (home, search, profile).\n// 3. When a user taps on a navigation item, the onTap callback is triggered.\n// 4. The setState() call updates the _page variable, which determines which content to display.\n// 5. The body of the Scaffold uses the _pages list to show the appropriate content based on the selected index.\n// 6. The CurvedNavigationBar animates smoothly between selections, providing visual feedback to the user.\n// 7. Each content page (HomeContent, SearchContent, ProfileContent) is a simple stateless widget displaying text.\n// 8. The app maintains its state as long as the HomePage is active, allowing users to navigate between sections seamlessly.\n\n// Note: This example demonstrates the basic usage of CurvedNavigationBar. In a real-world application, \n// you would typically have more complex content in each section and possibly implement state management \n// solutions for handling data and user interactions across different pages.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1vvH",
        "_type": "reference",
        "_key": "624zl5m0"
      }
    ],
    "name": "curved_navigation_bar",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG0V",
        "_type": "reference",
        "_key": "2gc0whm3"
      }
    ],
    "_createdAt": "2024-08-28T22:17:51Z",
    "lastUpdate": "2024-06-12T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CbUr",
    "_updatedAt": "2024-09-06T04:13:09Z",
    "pubPoint": 160
  },
  {
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 830,
    "lastUpdate": "2024-08-17T18:30:00.000Z",
    "tutorial": "# Hooks Riverpod Tutorial\n\nThis tutorial will guide you through setting up and using Hooks Riverpod in your Flutter project. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_hooks: ^0.18.0\n  hooks_riverpod: ^2.1.1\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Setting up the ProviderScope\n\nWrap your app's root widget with `ProviderScope`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n## Step 3: Creating a Provider\n\nLet's create a simple provider to manage a counter state:\n\n```dart\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nfinal counterProvider = StateProvider((ref) => 0);\n```\n\n## Step 4: Using the Provider in a Widget\n\nNow, let's use this provider in a widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\n\nclass CounterWidget extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = ref.watch(counterProvider);\n\n    return Text('Counter: $counter');\n  }\n}\n```\n\n## Step 5: Modifying the State\n\nTo modify the state, use the `ref.read` method:\n\n```dart\nElevatedButton(\n  onPressed: () => ref.read(counterProvider.notifier).state++,\n  child: Text('Increment'),\n)\n```\n\n## Advanced Usage: AsyncNotifierProvider\n\nFor more complex state management, you can use `AsyncNotifierProvider`:\n\n```dart\nclass UserNotifier extends AsyncNotifier<User?> {\n  @override\n  Future<User?> build() => fetchUser();\n\n  Future<void> logout() async {\n    state = const AsyncValue.loading();\n    state = await AsyncValue.guard(() => logoutUser());\n  }\n}\n\nfinal userProvider = AsyncNotifierProvider<UserNotifier, User?>(() => UserNotifier());\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have CocoaPods installed and initialized in your project.\n- Run `pod install` in the iOS directory after adding new dependencies.\n\n### Android\n- Make sure your `minSdkVersion` is set to at least 16 in `android/app/build.gradle`.\n\n### Web\n- No additional setup is required for web support.\n\n### macOS, Linux, Windows\n- Enable desktop support in your Flutter project:\n  ```\n  flutter config --enable-macos-desktop\n  flutter config --enable-linux-desktop\n  flutter config --enable-windows-desktop\n  ```\n- Ensure you have the necessary development tools installed for each platform.\n\nBy following these steps and considerations, you'll have a solid foundation for using Hooks Riverpod in your Flutter project across various platforms.",
    "_updatedAt": "2024-09-06T04:13:10Z",
    "description": "# Hooks Riverpod: Simplifying State Management in Flutter\n\n## Introduction\n\nHooks Riverpod is a powerful state management solution for Flutter applications that combines the best features of two popular packages: `flutter_hooks` and `riverpod`. This combination provides a robust and flexible approach to managing state in Flutter apps, making it easier to write clean, maintainable, and testable code.\n\n## Key Features\n\n1. **Simplicity**: Hooks Riverpod offers a simple and intuitive API that reduces boilerplate code and makes state management more straightforward.\n\n2. **Flexibility**: It supports various state management patterns, including simple state objects, complex application-wide states, and everything in between.\n\n3. **Testability**: The package is designed with testability in mind, making it easy to write unit tests for your state management logic.\n\n4. **Performance**: Hooks Riverpod is optimized for performance, ensuring that your app remains responsive even with complex state management needs.\n\n5. **Compile-time safety**: It leverages Dart's strong type system to catch potential errors at compile-time, reducing runtime errors.\n\n## Why Use Hooks Riverpod?\n\nHooks Riverpod addresses many of the challenges developers face when managing state in Flutter applications:\n\n- It eliminates the need for complex inheritance hierarchies often seen in other state management solutions.\n- It provides a clear separation of concerns between UI and business logic.\n- It offers a consistent way to handle both local and global state.\n- It integrates seamlessly with Flutter's widget tree, making it easy to use alongside existing Flutter widgets and patterns.\n\nIn the following sections, we'll dive deeper into how to use Hooks Riverpod in your Flutter projects, providing a step-by-step tutorial and a comprehensive example to showcase its features.",
    "shortDescription": "A reactive caching and data-binding framework. Riverpod makes working with asynchronous code a breeze.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\n// Step 1: Define our providers\nfinal counterProvider = StateProvider((ref) => 0);\n\nfinal fetchDataProvider = FutureProvider((ref) async {\n  // Simulating an API call\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Data fetched successfully!';\n});\n\n// Step 2: Create an AsyncNotifier for more complex state management\nclass RealFlutter extends AsyncNotifier<String> {\n  @override\n  Future<String> build() async {\n    // Initialize with a default value\n    return 'Welcome to RealFlutter!';\n  }\n\n  Future<void> updateMessage(String newMessage) async {\n    state = const AsyncValue.loading();\n    // Simulating an API call or complex operation\n    await Future.delayed(const Duration(seconds: 1));\n    state = AsyncValue.data(newMessage);\n  }\n}\n\n// Step 3: Create a provider for our AsyncNotifier\nfinal realFlutterProvider = AsyncNotifierProvider<RealFlutter, String>(() => RealFlutter());\n\n// Step 4: Main app widget\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Hooks Riverpod Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const MyHomePage(),\n    );\n  }\n}\n\n// Step 5: Home page widget\nclass MyHomePage extends HookConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Step 6: Use hooks to manage local state\n    final tabIndex = useState(0);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Hooks Riverpod Demo')),\n      body: IndexedStack(\n        index: tabIndex.value,\n        children: [\n          CounterTab(),\n          DataFetchingTab(),\n          RealFlutterTab(),\n        ],\n      ),\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabIndex.value,\n        onTap: (index) => tabIndex.value = index,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.add), label: 'Counter'),\n          BottomNavigationBarItem(icon: Icon(Icons.cloud_download), label: 'Fetch Data'),\n          BottomNavigationBarItem(icon: Icon(Icons.star), label: 'RealFlutter'),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 7: Counter tab\nclass CounterTab extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = ref.watch(counterProvider);\n\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text('Counter: $counter', style: Theme.of(context).textTheme.headline4),\n          ElevatedButton(\n            onPressed: () => ref.read(counterProvider.notifier).state++,\n            child: const Text('Increment'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 8: Data fetching tab\nclass DataFetchingTab extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final dataAsync = ref.watch(fetchDataProvider);\n\n    return Center(\n      child: dataAsync.when(\n        data: (data) => Text(data, style: Theme.of(context).textTheme.headline5),\n        loading: () => const CircularProgressIndicator(),\n        error: (error, stack) => Text('Error: $error'),\n      ),\n    );\n  }\n}\n\n// Step 9: RealFlutter tab\nclass RealFlutterTab extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final realFlutterAsync = ref.watch(realFlutterProvider);\n\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          realFlutterAsync.when(\n            data: (data) => Text(data, style: Theme.of(context).textTheme.headline5),\n            loading: () => const CircularProgressIndicator(),\n            error: (error, stack) => Text('Error: $error'),\n          ),\n          const SizedBox(height: 20),\n          ElevatedButton(\n            onPressed: () => ref.read(realFlutterProvider.notifier).updateMessage('RealFlutter is awesome!'),\n            child: const Text('Update Message'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 10: Main function\nvoid main() {\n  runApp(\n    // Provide the ProviderScope at the root of the app\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Application Flow:\n// 1. The app starts by running the ProviderScope with MyApp as its child.\n// 2. MyApp sets up the MaterialApp with the MyHomePage as the home widget.\n// 3. MyHomePage uses a HookConsumerWidget to manage the bottom navigation and tab switching.\n// 4. Each tab (CounterTab, DataFetchingTab, RealFlutterTab) demonstrates different aspects of Hooks Riverpod:\n//    - CounterTab: Uses a simple StateProvider for managing a counter.\n//    - DataFetchingTab: Uses a FutureProvider to simulate data fetching.\n//    - RealFlutterTab: Uses an AsyncNotifierProvider for more complex state management.\n// 5. The app showcases how to:\n//    - Watch providers for reactive updates\n//    - Read providers for one-time actions\n//    - Handle loading and error states\n//    - Use local state with useState hook\n//    - Combine hooks and riverpod for efficient state management\n// \n// This example demonstrates the power and flexibility of Hooks Riverpod in managing\n// both simple and complex state scenarios in a Flutter application.\n```",
    "_createdAt": "2024-08-28T22:17:53Z",
    "name": "hooks_riverpod",
    "_id": "uQRNMiDfrp20RZ8Id8CbaN",
    "_rev": "ezMiwuUkJkbYMWycA6ReC0",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWqB",
        "_type": "reference",
        "_key": "grvaxyu7"
      }
    ],
    "tags": [
      "state-management",
      "hooks",
      "riverpod",
      "reactive"
    ],
    "dependentPackages": [],
    "tutorialIncluded": true,
    "slug": {
      "_type": "slug",
      "current": "hooks_riverpod"
    },
    "author": "dash-overflow.net",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfBIU",
        "_type": "reference",
        "_key": "80gni259"
      }
    ],
    "pubPoint": 160,
    "packageImage": null
  },
  {
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmU3d",
    "shortDescription": "Flutter widgets for easily adding gaps inside Flex widgets such as Columns and Rows or scrolling views.",
    "likesCount": 825,
    "author": "",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "ui",
      "layout",
      "spacing",
      "widget"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8Cbft",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:11Z",
    "tutorial": "# Gap Package Tutorial\n\nThis tutorial will guide you through setting up and using the Gap package in your Flutter project. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  gap: ^2.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Importing the Package\n\nIn the Dart files where you want to use Gap, import it:\n\n```dart\nimport 'package:gap/gap.dart';\n```\n\n## Step 3: Basic Usage\n\nTo add a vertical gap:\n\n```dart\nColumn(\n  children: [\n    Text('Above the gap'),\n    Gap(20), // 20 logical pixels of vertical space\n    Text('Below the gap'),\n  ],\n)\n```\n\nTo add a horizontal gap:\n\n```dart\nRow(\n  children: [\n    Text('Left of the gap'),\n    Gap(20), // 20 logical pixels of horizontal space\n    Text('Right of the gap'),\n  ],\n)\n```\n\n## Step 4: Responsive Gaps\n\nYou can create gaps that adapt to screen size:\n\n```dart\nGap(20 * MediaQuery.of(context).size.width / 375)\n```\n\nThis will create a gap that's proportional to the screen width.\n\n## Step 5: Customizing Gap Appearance\n\nWhile not often necessary, you can customize the appearance of a Gap:\n\n```dart\nGap(\n  20,\n  color: Colors.blue,\n)\n```\n\nThis creates a blue-colored gap, which can be useful for debugging or specific design requirements.\n\n## Platform-Specific Considerations\n\n### iOS\n- Gap works out of the box with no additional setup required.\n\n### Android\n- No special configuration needed for Android.\n\n### Web\n- Gap is fully compatible with Flutter web projects.\n\n### macOS, Linux, Windows\n- Gap supports desktop platforms without any additional configuration.\n- To enable desktop support in your Flutter project:\n  ```\n  flutter config --enable-macos-desktop\n  flutter config --enable-linux-desktop\n  flutter config --enable-windows-desktop\n  ```\n\nBy following these steps and considerations, you'll have a solid foundation for using the Gap package in your Flutter project across various platforms. The Gap package's simplicity means it works consistently across all supported Flutter platforms without any platform-specific code.",
    "_type": "package",
    "description": "# Gap Package: Simplifying Spacing in Flutter\n\n## Introduction\n\nThe `gap` package is a simple yet powerful tool for Flutter developers that aims to simplify the process of adding space between widgets. In the world of Flutter development, managing spacing and layout can sometimes be cumbersome, especially when dealing with complex UIs. The `gap` package provides an elegant solution to this problem by introducing a straightforward way to add whitespace in your layouts.\n\n## Key Features\n\n1. **Simplicity**: The Gap widget offers a clean and intuitive API, making it easy to add space without nested containers or SizedBox widgets.\n\n2. **Flexibility**: Gap can be used both vertically and horizontally, adapting to the context it's used in.\n\n3. **Customization**: While simple by default, Gap allows for customization of its appearance when needed.\n\n4. **Efficiency**: Gap is designed to be lightweight and efficient, with minimal impact on your app's performance.\n\n5. **Responsive**: Gap can adapt to different screen sizes, making it useful for responsive designs.\n\n## Why Use the Gap Package?\n\nThe Gap package addresses several common pain points in Flutter development:\n\n- It reduces the need for nested Padding and SizedBox widgets, leading to cleaner, more readable code.\n- It provides a consistent way to add space across your app, improving maintainability.\n- It simplifies the process of creating responsive layouts that adapt to different screen sizes.\n- It integrates seamlessly with Flutter's existing layout system, making it easy to adopt in both new and existing projects.\n\nIn the following sections, we'll explore how to use the Gap package in your Flutter projects, providing a step-by-step tutorial and a comprehensive example to showcase its features.",
    "similarPackages": [],
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPamQK",
        "_type": "reference",
        "_key": "6qsj6qkz"
      }
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:17:54Z",
    "subCategories": [
      {
        "_key": "y20n9ytc",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFlU",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:gap/gap.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Gap Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: GapDemoHome(),\n    );\n  }\n}\n\nclass GapDemoHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Gap Package Demo')),\n      body: SingleChildScrollView(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            // Step 1: Basic vertical gap usage\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('1. Basic Vertical Gap', style: Theme.of(context).textTheme.headline6),\n                  Text('Above gap'),\n                  Gap(20), // 20 logical pixels of vertical space\n                  Text('Below gap'),\n                ],\n              ),\n            ),\n\n            Divider(),\n\n            // Step 2: Basic horizontal gap usage\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('2. Basic Horizontal Gap', style: Theme.of(context).textTheme.headline6),\n                  Row(\n                    children: [\n                      Text('Left'),\n                      Gap(20), // 20 logical pixels of horizontal space\n                      Text('Right'),\n                    ],\n                  ),\n                ],\n              ),\n            ),\n\n            Divider(),\n\n            // Step 3: Responsive gap\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('3. Responsive Gap', style: Theme.of(context).textTheme.headline6),\n                  Text('Above responsive gap'),\n                  Gap(20 * MediaQuery.of(context).size.width / 375), // Responsive gap\n                  Text('Below responsive gap'),\n                ],\n              ),\n            ),\n\n            Divider(),\n\n            // Step 4: Colored gap for visualization\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('4. Colored Gap', style: Theme.of(context).textTheme.headline6),\n                  Text('Above colored gap'),\n                  Gap(20, color: Colors.blue.withOpacity(0.3)), // Colored gap\n                  Text('Below colored gap'),\n                ],\n              ),\n            ),\n\n            Divider(),\n\n            // Step 5: Using Gap in complex layouts\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('5. Gap in Complex Layout', style: Theme.of(context).textTheme.headline6),\n                  Gap(10),\n                  Card(\n                    child: Padding(\n                      padding: const EdgeInsets.all(16.0),\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          Text('Card Title', style: Theme.of(context).textTheme.headline6),\n                          Gap(8),\n                          Text('Card subtitle'),\n                          Gap(16),\n                          Row(\n                            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                            children: [\n                              ElevatedButton(onPressed: () {}, child: Text('Action 1')),\n                              Gap(8), // Horizontal gap between buttons\n                              ElevatedButton(onPressed: () {}, child: Text('Action 2')),\n                            ],\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. GapDemoHome is set as the home widget, which creates a Scaffold with an AppBar.\n// 3. The body of the Scaffold contains a SingleChildScrollView with a Column as its child.\n// 4. The Column showcases different uses of the Gap widget:\n//    - Basic vertical gap usage\n//    - Basic horizontal gap usage\n//    - Responsive gap that adapts to screen width\n//    - Colored gap for visualization purposes\n//    - Gap used in a more complex layout (card with buttons)\n// 5. Each example is separated by a Divider for clarity.\n// 6. The use of SingleChildScrollView ensures that all content is accessible on smaller screens.\n//\n// This example demonstrates the versatility and simplicity of the Gap package in various\n// layout scenarios, from basic spacing to more complex responsive designs.\n```",
    "lastUpdate": "2023-06-23T18:30:00.000Z",
    "name": "gap",
    "slug": {
      "current": "gap",
      "_type": "slug"
    }
  },
  {
    "_createdAt": "2024-08-28T22:17:56Z",
    "tutorialIncluded": true,
    "slug": {
      "current": "another_flushbar",
      "_type": "slug"
    },
    "tags": [
      "notification",
      "snackbar",
      "toast",
      "ui"
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CgZH",
        "_type": "reference",
        "_key": "953s2yl4"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1u2B",
        "_type": "reference",
        "_key": "nnun4ov2"
      }
    ],
    "_rev": "AE3hjGWNkNE6aGQMMbaTKa",
    "_type": "package",
    "shortDescription": "A flexible widget for user notification. Customize your text, button, duration, animations and much more. For Android devs, it is made to replace Snackbars and Toasts.",
    "subCategories": [
      {
        "_key": "ric27hoz",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:another_flushbar/flushbar.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Another Flushbar Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: FlushbarDemoHome(),\n    );\n  }\n}\n\nclass FlushbarDemoHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Another Flushbar Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 1: Basic Flushbar\n            ElevatedButton(\n              child: Text('Show Basic Flushbar'),\n              onPressed: () {\n                Flushbar(\n                  message: \"This is a basic flushbar\",\n                  duration: Duration(seconds: 3),\n                ).show(context);\n              },\n            ),\n            SizedBox(height: 20),\n\n            // Step 2: Customized Flushbar\n            ElevatedButton(\n              child: Text('Show Customized Flushbar'),\n              onPressed: () {\n                Flushbar(\n                  title: \"Hello RealFlutter\",\n                  message: \"This is a customized flushbar\",\n                  icon: Icon(\n                    Icons.info_outline,\n                    size: 28.0,\n                    color: Colors.blue[300],\n                  ),\n                  duration: Duration(seconds: 3),\n                  leftBarIndicatorColor: Colors.blue[300],\n                ).show(context);\n              },\n            ),\n            SizedBox(height: 20),\n\n            // Step 3: Flushbar with Action\n            ElevatedButton(\n              child: Text('Show Flushbar with Action'),\n              onPressed: () {\n                Flushbar(\n                  title: \"RealFlutter Action\",\n                  message: \"This flushbar has an action button!\",\n                  duration: Duration(seconds: 3),\n                  mainButton: TextButton(\n                    child: Text(\n                      \"CLICK ME\",\n                      style: TextStyle(color: Colors.white),\n                    ),\n                    onPressed: () {\n                      print(\"Flushbar button clicked\");\n                    },\n                  ),\n                ).show(context);\n              },\n            ),\n            SizedBox(height: 20),\n\n            // Step 4: Top-positioned Flushbar\n            ElevatedButton(\n              child: Text('Show Top-positioned Flushbar'),\n              onPressed: () {\n                Flushbar(\n                  message: \"I'm positioned at the top!\",\n                  duration: Duration(seconds: 3),\n                  flushbarPosition: FlushbarPosition.TOP,\n                ).show(context);\n              },\n            ),\n            SizedBox(height: 20),\n\n            // Step 5: Flushbar Queue\n            ElevatedButton(\n              child: Text('Show Flushbar Queue'),\n              onPressed: () {\n                FlushbarHelper.createInformation(message: \"First in queue\")\n                    .show(context);\n                FlushbarHelper.createSuccess(message: \"Second in queue\")\n                    .show(context);\n                FlushbarHelper.createError(message: \"Third in queue\")\n                    .show(context);\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home screen (FlushbarDemoHome) is displayed, showing several buttons.\n// 3. Each button demonstrates a different feature of Another Flushbar:\n//    - Basic Flushbar: Shows a simple message at the bottom of the screen.\n//    - Customized Flushbar: Displays a more complex notification with an icon and custom colors.\n//    - Flushbar with Action: Shows a notification with an interactive button.\n//    - Top-positioned Flushbar: Demonstrates how to change the position of the notification.\n//    - Flushbar Queue: Shows how multiple notifications can be queued and displayed sequentially.\n// 4. When a button is pressed, the corresponding Flushbar is created and shown.\n// 5. The Flushbars are displayed for a set duration (usually 3 seconds) before automatically dismissing.\n// 6. For the Flushbar with an action, clicking the button will trigger a console log.\n// 7. The Flushbar Queue demonstrates how multiple notifications can be stacked and shown one after another.\n//\n// This example showcases the versatility of Another Flushbar, from basic usage to more advanced features,\n// allowing developers to create rich, interactive in-app notifications in their Flutter applications.\n```",
    "likesCount": 881,
    "pubPoint": 160,
    "author": "hamidwakili.com",
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:13:12Z",
    "similarPackages": [],
    "_id": "uQRNMiDfrp20RZ8Id8CblP",
    "lastUpdate": "2023-05-10T18:30:00.000Z",
    "name": "another_flushbar",
    "tutorial": "# Another Flushbar Tutorial\n\nThis tutorial will guide you through setting up and using Another Flushbar in your Flutter project. We'll cover installation, basic usage, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  another_flushbar: ^1.12.30\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Importing the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:another_flushbar/flushbar.dart';\n```\n\n## Step 3: Creating a Basic Flushbar\n\nHere's how to create and show a basic Flushbar:\n\n```dart\nFlushbar(\n  message: \"This is a basic flushbar\",\n  duration: Duration(seconds: 3),\n).show(context);\n```\n\n## Step 4: Customizing the Flushbar\n\nLet's create a more customized Flushbar:\n\n```dart\nFlushbar(\n  title: \"Hello RealFlutter\",\n  message: \"This is a customized flushbar\",\n  icon: Icon(\n    Icons.info_outline,\n    size: 28.0,\n    color: Colors.blue[300],\n  ),\n  duration: Duration(seconds: 3),\n  leftBarIndicatorColor: Colors.blue[300],\n).show(context);\n```\n\n## Step 5: Adding User Interaction\n\nYou can add buttons to your Flushbar for user interaction:\n\n```dart\nFlushbar(\n  title: \"RealFlutter Action\",\n  message: \"This flushbar has an action button!\",\n  duration: Duration(seconds: 3),\n  mainButton: TextButton(\n    child: Text(\n      \"CLICK ME\",\n      style: TextStyle(color: Colors.white),\n    ),\n    onPressed: () {\n      print(\"Flushbar button clicked\");\n    },\n  ),\n).show(context);\n```\n\n## Step 6: Positioning the Flushbar\n\nYou can control the position of the Flushbar:\n\n```dart\nFlushbar(\n  message: \"I'm positioned at the top!\",\n  duration: Duration(seconds: 3),\n  flushbarPosition: FlushbarPosition.TOP,\n).show(context);\n```\n\n## Advanced Usage: Flushbar Queue\n\nTo queue multiple Flushbars:\n\n```dart\nFlushbarHelper.createInformation(message: \"First in queue\")\n    .show(context);\nFlushbarHelper.createSuccess(message: \"Second in queue\")\n    .show(context);\nFlushbarHelper.createError(message: \"Third in queue\")\n    .show(context);\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure you have CocoaPods installed and initialized in your project.\n- Run `pod install` in the iOS directory after adding new dependencies.\n\n### Android\n- No additional setup is required for Android.\n\n### Web\n- Another Flushbar is fully compatible with Flutter web.\n\n### macOS, Linux, Windows\n- Enable desktop support in your Flutter project:\n  ```\n  flutter config --enable-macos-desktop\n  flutter config --enable-linux-desktop\n  flutter config --enable-windows-desktop\n  ```\n- Ensure you have the necessary development tools installed for each platform.\n\nBy following these steps and considerations, you'll have a solid foundation for using Another Flushbar in your Flutter project across various platforms.",
    "description": "# Another Flushbar: Enhancing User Notifications in Flutter\n\n## Introduction\n\nAnother Flushbar is a powerful and flexible Flutter package that provides an elegant solution for displaying in-app notifications, tooltips, and snackbars. It offers a rich set of customization options, allowing developers to create visually appealing and informative notifications that seamlessly integrate with their app's design.\n\n## Key Features\n\n1. **Customization**: Another Flushbar offers extensive customization options, including colors, icons, animations, and positioning.\n\n2. **Flexibility**: It can be used to display various types of notifications, from simple messages to more complex interactions.\n\n3. **User Interaction**: The package supports user interactions, allowing developers to add buttons or make the entire flushbar tappable.\n\n4. **Animation Control**: Developers have fine-grained control over the show and dismiss animations.\n\n5. **Queuing System**: Multiple flushbars can be queued and displayed sequentially.\n\n6. **Accessibility**: The package includes features to enhance accessibility, such as support for screen readers.\n\n## Why Use Another Flushbar?\n\nAnother Flushbar addresses several common challenges in implementing in-app notifications:\n\n- It provides a consistent look and feel across different parts of your app.\n- It offers more customization options than Flutter's built-in SnackBar.\n- It allows for more complex notifications with multiple actions or longer display durations.\n- It can be easily integrated into existing Flutter projects with minimal setup.\n\nAnother Flushbar is particularly useful for:\n\n- Displaying success or error messages after user actions\n- Showing temporary information without disrupting the main UI\n- Creating tooltips or help messages\n- Implementing a non-intrusive notification system\n\nIn the following sections, we'll explore how to integrate Another Flushbar into your Flutter projects, providing a step-by-step tutorial and a comprehensive example to showcase its features.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ]
  },
  {
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "A rich text editor built for the modern Android, iOS, web and desktop platforms. It is the WYSIWYG editor and a Quill component for Flutter.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_quill/flutter_quill.dart' hide Text;\nimport 'dart:convert';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Quill Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const QuillEditorPage(),\n    );\n  }\n}\n\nclass QuillEditorPage extends StatefulWidget {\n  const QuillEditorPage({Key? key}) : super(key: key);\n\n  @override\n  _QuillEditorPageState createState() => _QuillEditorPageState();\n}\n\nclass _QuillEditorPageState extends State<QuillEditorPage> {\n  QuillController _controller = QuillController.basic();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 1: Initialize the QuillController with some default content\n    _controller = QuillController(\n      document: Document.fromJson(json.decode(\n          '{\"ops\":[{\"insert\":\"Welcome to Flutter Quill!\\\\n\"},{\"attributes\":{\"header\":1},\"insert\":\"\\\\n\"},{\"insert\":\"This is a demo of the flutter_quill package.\\\\n\"}]}')),\n      selection: const TextSelection.collapsed(offset: 0),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flutter Quill Demo'),\n        // Step 2: Add actions to the AppBar for additional functionality\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.save),\n            onPressed: _saveDocument,\n          ),\n          IconButton(\n            icon: const Icon(Icons.restore),\n            onPressed: _loadDocument,\n          ),\n        ],\n      ),\n      body: Column(\n        children: [\n          // Step 3: Add the QuillToolbar for formatting options\n          QuillToolbar.basic(controller: _controller),\n          Expanded(\n            // Step 4: Add the QuillEditor for rich text editing\n            child: Container(\n              padding: const EdgeInsets.all(8),\n              child: QuillEditor.basic(\n                controller: _controller,\n                readOnly: false,\n              ),\n            ),\n          ),\n        ],\n      ),\n      // Step 5: Add a FloatingActionButton for inserting images\n      floatingActionButton: FloatingActionButton(\n        onPressed: _insertImage,\n        tooltip: 'Insert Image',\n        child: const Icon(Icons.image),\n      ),\n    );\n  }\n\n  // Step 6: Implement _saveDocument method\n  void _saveDocument() {\n    // Convert the document to JSON\n    final contents = jsonEncode(_controller.document.toDelta().toJson());\n    // Here you would typically save the contents to a file or database\n    print('Saved document: $contents');\n    ScaffoldMessenger.of(context).showSnackBar(\n      const SnackBar(content: Text('Document saved (check console)')),\n    );\n  }\n\n  // Step 7: Implement _loadDocument method\n  void _loadDocument() {\n    // Here you would typically load the contents from a file or database\n    const jsonString = '{\"ops\":[{\"insert\":\"Loaded document\\\\n\"},{\"attributes\":{\"bold\":true},\"insert\":\"This is bold text.\\\\n\"}]}';\n    final doc = Document.fromJson(jsonDecode(jsonString));\n    _controller = QuillController(\n      document: doc,\n      selection: const TextSelection.collapsed(offset: 0),\n    );\n    setState(() {});\n    ScaffoldMessenger.of(context).showSnackBar(\n      const SnackBar(content: Text('Document loaded')),\n    );\n  }\n\n  // Step 8: Implement _insertImage method\n  void _insertImage() {\n    // In a real app, you'd use an image picker here\n    // For this example, we'll insert a placeholder image\n    _controller.formatSelection(Attribute.image, 'https://via.placeholder.com/150');\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays the QuillEditorPage.\n// 2. The QuillController is initialized with some default content.\n// 3. The build method sets up the UI with a QuillToolbar and QuillEditor.\n// 4. Users can interact with the editor, format text, and insert images.\n// 5. The save button in the AppBar allows saving the document (simulated in this example).\n// 6. The restore button in the AppBar allows loading a predefined document.\n// 7. The FloatingActionButton allows inserting images (simulated with a placeholder in this example).\n\n// Note: In a production app, you would implement proper error handling,\n// use actual file or database operations for saving/loading,\n// and implement a real image picker for inserting images.\n```",
    "name": "flutter_quill",
    "similarPackages": [],
    "tags": [
      "ui",
      "widget",
      "rich-text-editor",
      "quill",
      "text-editing",
      "wysiwyg"
    ],
    "dependentPackages": [],
    "lastUpdate": "2024-08-26T18:30:00.000Z",
    "slug": {
      "current": "flutter_quill",
      "_type": "slug"
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmUK0",
    "description": "# Flutter Quill: Rich Text Editor for Flutter Applications\n\nFlutter Quill is a powerful and customizable rich text editor package for Flutter applications. It provides a wide range of text editing and formatting capabilities, making it an excellent choice for developers looking to implement advanced text editing features in their Flutter projects.\n\n## Key Features\n\n1. **Rich Text Editing**: Supports various text formatting options such as bold, italic, underline, and strikethrough.\n2. **Text Alignment**: Offers left, center, right, and justified text alignment options.\n3. **Lists**: Enables creation of ordered and unordered lists.\n4. **Code Blocks**: Allows insertion of code blocks with syntax highlighting.\n5. **Image Embedding**: Supports embedding images within the text.\n6. **Custom Styles**: Provides the ability to define and apply custom styles to text.\n7. **Undo/Redo**: Implements undo and redo functionality for text changes.\n8. **Customizable Toolbar**: Offers a customizable toolbar for easy access to formatting options.\n9. **Cross-Platform**: Works seamlessly on iOS, Android, and web platforms.\n\n## Why Choose Flutter Quill?\n\nFlutter Quill stands out due to its extensive feature set, ease of integration, and active community support. Whether you're building a note-taking app, a content management system, or any application requiring rich text editing capabilities, Flutter Quill provides a robust solution that can be tailored to your specific needs.\n\nIn the following sections, we'll dive into a tutorial on how to implement Flutter Quill in your Flutter project and explore a comprehensive example showcasing its features.",
    "_createdAt": "2024-08-28T22:18:00Z",
    "tutorial": "# Flutter Quill Tutorial: Implementing Rich Text Editing in Your Flutter App\n\nThis tutorial will guide you through the process of integrating the Flutter Quill package into your Flutter application. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the flutter_quill package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter_quill: ^latest_version\n```\n\nReplace `latest_version` with the current version of the package. Then, run:\n\n```\nflutter pub get\n```\n\n## Step 2: Basic Implementation\n\nImport the necessary packages in your Dart file:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_quill/flutter_quill.dart';\n```\n\nCreate a `QuillController` to manage the editor's content:\n\n```dart\nfinal QuillController _controller = QuillController.basic();\n```\n\nImplement the `QuillEditor` and `QuillToolbar` widgets in your build method:\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Flutter Quill Editor')),\n    body: Column(\n      children: [\n        QuillToolbar.basic(controller: _controller),\n        Expanded(\n          child: QuillEditor.basic(\n            controller: _controller,\n            readOnly: false,\n          ),\n        ),\n      ],\n    ),\n  );\n}\n```\n\n## Step 3: Platform-Specific Considerations\n\n### Android\n\nFor Android, you need to add the following permission to your `AndroidManifest.xml` file if you want to enable image picking:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n```\n\n### iOS\n\nFor iOS, add the following keys to your `Info.plist` file:\n\n```xml\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app requires access to the photo library for image insertion in the editor.</string>\n<key>NSCameraUsageDescription</key>\n<string>This app requires access to the camera for image capture and insertion in the editor.</string>\n```\n\n### Web\n\nFor web support, make sure to add the following script tags to your `web/index.html` file:\n\n```html\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js\"></script>\n```\n\nThese scripts are necessary for math equation rendering and code syntax highlighting on the web platform.\n\n## Step 4: Customizing the Editor\n\nYou can customize the appearance and behavior of the editor by modifying the `QuillEditor` and `QuillToolbar` widgets. For example, to change the toolbar options:\n\n```dart\nQuillToolbar.basic(\n  controller: _controller,\n  showBoldButton: true,\n  showItalicButton: true,\n  showUnderLineButton: true,\n  showColorButton: true,\n  showBackgroundColorButton: true,\n  showClearFormat: true,\n  showAlignmentButtons: true,\n)\n```\n\nTo customize the editor's appearance:\n\n```dart\nQuillEditor.basic(\n  controller: _controller,\n  readOnly: false,\n  padding: EdgeInsets.all(8),\n  scrollable: true,\n  autoFocus: false,\n  expands: false,\n  focusNode: FocusNode(),\n)\n```\n\nBy following these steps, you'll have a fully functional rich text editor in your Flutter application. In the next section, we'll look at a comprehensive example that demonstrates all the features of the Flutter Quill package.",
    "author": "bulletjournal.us",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGvP",
        "_type": "reference",
        "_key": "mb2kt4xd"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 1706,
    "packageImage": {
      "asset": {
        "_ref": "image-7c50738b734f6d1176970bddae4a90995b63540a-1179x2556-webp",
        "_type": "reference"
      },
      "_type": "image"
    },
    "_id": "uQRNMiDfrp20RZ8Id8Cc1x",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:13Z"
  },
  {
    "tutorial": "# Tutorial: Implementing Toggle Switch in Flutter\n\nThis tutorial will guide you through the process of integrating the `toggle_switch` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `toggle_switch` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  toggle_switch: ^2.0.1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:toggle_switch/toggle_switch.dart';\n```\n\nCreate a basic Toggle Switch widget:\n\n```dart\nToggleSwitch(\n  initialLabelIndex: 0,\n  totalSwitches: 2,\n  labels: ['Off', 'On'],\n  onToggle: (index) {\n    print('switched to: $index');\n  },\n)\n```\n\n## Step 3: Customization\n\nCustomize the Toggle Switch with various properties:\n\n```dart\nToggleSwitch(\n  initialLabelIndex: 0,\n  totalSwitches: 2,\n  labels: ['Off', 'On'],\n  onToggle: (index) {\n    print('switched to: $index');\n  },\n  cornerRadius: 20.0,\n  activeBgColor: [Colors.green],\n  inactiveBgColor: Colors.grey,\n  dividerColor: Colors.grey,\n  activeFgColor: Colors.white,\n  inactiveFgColor: Colors.white,\n  iconSize: 30.0,\n  fontSize: 16.0,\n  minWidth: 90.0,\n  minHeight: 50.0,\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure you have the following in your `Info.plist` file:\n\n```xml\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n```\n\nThis enables support for platform views, which may be necessary for certain Toggle Switch functionalities.\n\n### Android\n\nFor Android, no specific configuration is required. However, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to 16 or higher:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // ...\n    }\n}\n```\n\n## Advanced Usage\n\n### Custom Icons\n\nUse custom icons for the toggle switch:\n\n```dart\nToggleSwitch(\n  initialLabelIndex: 0,\n  totalSwitches: 2,\n  labels: ['Off', 'On'],\n  onToggle: (index) {\n    print('switched to: $index');\n  },\n  icons: [Icons.close, Icons.check],\n  iconSize: 30.0,\n)\n```\n\n### Custom Layout\n\nCreate a custom toggle switch layout:\n\n```dart\nToggleSwitch(\n  initialLabelIndex: 0,\n  totalSwitches: 2,\n  labels: ['Off', 'On'],\n  onToggle: (index) {\n    print('switched to: $index');\n  },\n  cornerRadius: 20.0,\n  activeBgColor: [Colors.green],\n  inactiveBgColor: Colors.grey,\n  animate: true,\n  animationDuration: 150,\n  isVertical: true,\n)\n```\n\nBy following this tutorial, you should now have a good understanding of how to implement and customize the Toggle Switch package in your Flutter application. In the next section, we'll look at a comprehensive example that demonstrates all the features of this package.",
    "_updatedAt": "2024-09-06T04:13:14Z",
    "slug": {
      "current": "toggle_switch",
      "_type": "slug"
    },
    "author": "pramod.dev",
    "_rev": "ezMiwuUkJkbYMWycA6ReQO",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "ui",
      "toggle",
      "switch",
      "toggle-switch",
      "widget",
      "input"
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_type": "reference",
        "_ref": "image-6c9628a9964941924e78e7850bdc27e1a1fb358e-1272x2487-webp"
      }
    },
    "tutorialIncluded": true,
    "pubPoint": 160,
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFsb",
        "_type": "reference",
        "_key": "g3zvdogc"
      }
    ],
    "likesCount": 1368,
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPbQvk",
        "_type": "reference",
        "_key": "p3wg4ofd"
      }
    ],
    "_createdAt": "2024-08-28T22:18:02Z",
    "lastUpdate": "2024-03-24T18:30:00.000Z",
    "_type": "package",
    "description": "# Toggle Switch Package for Flutter: A Comprehensive Guide\n\n## Introduction\n\nIn the dynamic world of mobile app development, creating intuitive and visually appealing user interfaces is crucial. The `toggle_switch` package for Flutter provides developers with a powerful tool to implement sleek and customizable toggle switch controls in their applications. This blog post will delve into the features, usage, and implementation of the `toggle_switch` package.\n\n## What is Toggle Switch?\n\nToggle Switch is a Flutter package that enables developers to create toggle switch controls with ease. It offers a wide range of customization options, seamless animations, and various layouts, making it an excellent choice for building modern and interactive user interfaces.\n\n## Key Features\n\n1. **Multiple Layouts**: Supports various layouts including round, rectangular, and custom.\n2. **Customizable Animations**: Offers smooth, customizable animations for toggle transitions.\n3. **Customizable Appearance**: Allows customization of colors, sizes, and icons for the toggle switch.\n4. **Responsive Design**: Adapts to different screen sizes and orientations.\n5. **Accessibility**: Provides built-in support for accessibility features like screen readers.\n6. **State Management**: Offers flexible state management through callbacks and value change notifications.\n7. **Platform Specific Styling**: Provides platform-specific styling for iOS and Android.\n\n## Why Use Toggle Switch?\n\n- **Intuitive User Experience**: Toggle switches are a familiar and intuitive UI element for users.\n- **Versatility**: Suitable for various use cases, from settings screens to custom controls.\n- **Customization**: Allows developers to create visually appealing and branded toggle switch controls.\n- **Smooth Transitions**: Provides seamless and responsive animations for toggle switch interactions.\n- **Easy Integration**: Simple to integrate into existing Flutter projects.\n\nIn the following sections, we'll dive into a tutorial on how to implement Toggle Switch in your Flutter application and explore a comprehensive example showcasing its features.",
    "shortDescription": "Toggle Switch - A simple toggle switch widget. It can be fully customized with desired icons, width, colors, text, corner radius etc. It also maintains selection state.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:toggle_switch/toggle_switch.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Toggle Switch Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: ToggleSwitchDemo(),\n    );\n  }\n}\n\nclass ToggleSwitchDemo extends StatefulWidget {\n  @override\n  _ToggleSwitchDemoState createState() => _ToggleSwitchDemoState();\n}\n\nclass _ToggleSwitchDemoState extends State<ToggleSwitchDemo> {\n  // Step 1: Define the initial state of the toggle switch\n  int _currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Toggle Switch Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Create a basic toggle switch\n            ToggleSwitch(\n              initialLabelIndex: _currentIndex,\n              totalSwitches: 2,\n              labels: ['Off', 'On'],\n              onToggle: (index) {\n                // Step 3: Update the state when the toggle switch is toggled\n                setState(() {\n                  _currentIndex = index;\n                });\n              },\n            ),\n            SizedBox(height: 20.0),\n            // Step 4: Create a customized toggle switch\n            ToggleSwitch(\n              initialLabelIndex: _currentIndex,\n              totalSwitches: 2,\n              labels: ['Disabled', 'Enabled'],\n              cornerRadius: 20.0,\n              activeBgColor: [Colors.green],\n              inactiveBgColor: Colors.grey,\n              dividerColor: Colors.grey,\n              activeFgColor: Colors.white,\n              inactiveFgColor: Colors.white,\n              iconSize: 30.0,\n              fontSize: 16.0,\n              minWidth: 90.0,\n              minHeight: 50.0,\n              onToggle: (index) {\n                // Step 5: Update the state when the toggle switch is toggled\n                setState(() {\n                  _currentIndex = index;\n                });\n              },\n            ),\n            SizedBox(height: 20.0),\n            // Step 6: Create a vertical toggle switch with custom icons\n            ToggleSwitch(\n              initialLabelIndex: _currentIndex,\n              totalSwitches: 2,\n              labels: ['Inactive', 'Active'],\n              cornerRadius: 20.0,\n              activeBgColor: [Colors.green],\n              inactiveBgColor: Colors.grey,\n              animate: true,\n              animationDuration: 150,\n              isVertical: true,\n              icons: [Icons.close, Icons.check],\n              iconSize: 30.0,\n              onToggle: (index) {\n                // Step 7: Update the state when the toggle switch is toggled\n                setState(() {\n                  _currentIndex = index;\n                });\n              },\n            ),\n            SizedBox(height: 20.0),\n            // Step 8: Display the current toggle switch state\n            Text(\n              'Current toggle state: $_currentIndex',\n              style: TextStyle(fontSize: 18.0),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n// 2. The home page is set to ToggleSwitchDemo, a stateful widget.\n// 3. In the state class _ToggleSwitchDemoState:\n//    - We define a variable to keep track of the current toggle switch state.\n// 4. In the build method:\n//    - We create a Scaffold with an AppBar and a Center widget in the body.\n//    - Inside the Center widget, we create a Column with several Toggle Switch widgets.\n//    - The first Toggle Switch is a basic implementation with labels 'Off' and 'On'.\n//    - The second Toggle Switch is a customized implementation with various properties.\n//    - The third Toggle Switch is a vertical implementation with custom icons.\n//    - Underneath the Toggle Switches, we display the current toggle state.\n// 5. When a user interacts with the app:\n//    - They can toggle the switches, which will update the _currentIndex variable.\n//    - The updated _currentIndex is then used to display the current toggle state.\n//    - The Toggle Switch widgets use the onToggle callback to update the state when the user interacts with them.\n// \n// This example showcases the versatility of the toggle_switch package, \n// demonstrating features like custom layouts, animations, icons, and state management.\n```",
    "name": "toggle_switch",
    "_id": "uQRNMiDfrp20RZ8Id8CcB9"
  },
  {
    "author": "google.dev",
    "shortDescription": "Utility for wrapping an asynchronous function in automatic retry logic with exponential back-off, useful when making requests over network.",
    "likesCount": 897,
    "_createdAt": "2024-08-28T22:18:21Z",
    "lastUpdate": "2023-05-15T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:13:15Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmUaN",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbVwK",
        "_type": "reference",
        "_key": "m116n12c"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:retry/retry.dart';\nimport 'dart:math';\nimport 'dart:async';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Retry Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RetryDemo(),\n    );\n  }\n}\n\nclass RetryDemo extends StatefulWidget {\n  @override\n  _RetryDemoState createState() => _RetryDemoState();\n}\n\nclass _RetryDemoState extends State<RetryDemo> {\n  String _result = '';\n\n  // Step 1: Basic retry function\n  Future<String> _basicRetry() async {\n    return await retry(\n      () => _simulateNetworkRequest(),\n      retryIf: (e) => e is NetworkException,\n      maxAttempts: 3,\n    );\n  }\n\n  // Step 2: Advanced retry function with custom settings\n  Future<String> _advancedRetry() async {\n    return await retry(\n      () => _simulateNetworkRequest(),\n      retryIf: (e) => e is NetworkException,\n      maxAttempts: 5,\n      delayFactor: const Duration(seconds: 1),\n      maxDelay: const Duration(seconds: 10),\n    );\n  }\n\n  // Step 3: Retry function with error handling\n  Future<String> _retryWithErrorHandling() async {\n    try {\n      return await retry(\n        () => _simulateNetworkRequest(),\n        retryIf: (e) => e is NetworkException || e is TimeoutException,\n        onRetry: (e) => print('Retry attempt due to error: $e'),\n      );\n    } catch (e) {\n      print('All retry attempts failed. Error: $e');\n      rethrow;\n    }\n  }\n\n  // Step 4: Simulate a network request (this would be a real API call in a production app)\n  Future<String> _simulateNetworkRequest() async {\n    await Future.delayed(Duration(seconds: 1)); // Simulate network delay\n    if (Random().nextBool()) {\n      throw NetworkException('Failed to fetch data');\n    }\n    return 'Data fetched successfully';\n  }\n\n  // Step 5: UI interaction method\n  void _performRetry(Future<String> Function() retryFunction) async {\n    setState(() => _result = 'Loading...');\n    try {\n      final result = await retryFunction();\n      setState(() => _result = result);\n    } catch (e) {\n      setState(() => _result = 'Error: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Retry Package Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: () => _performRetry(_basicRetry),\n              child: Text('Basic Retry'),\n            ),\n            ElevatedButton(\n              onPressed: () => _performRetry(_advancedRetry),\n              child: Text('Advanced Retry'),\n            ),\n            ElevatedButton(\n              onPressed: () => _performRetry(_retryWithErrorHandling),\n              child: Text('Retry with Error Handling'),\n            ),\n            SizedBox(height: 20),\n            Text(_result, style: TextStyle(fontSize: 18)),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass NetworkException implements Exception {\n  final String message;\n  NetworkException(this.message);\n  @override\n  String toString() => 'NetworkException: $message';\n}\n\n// Application flow explanation:\n// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp.\n// 2. The RetryDemo widget is the main screen, containing three buttons for different retry scenarios.\n// 3. When a button is pressed, it calls _performRetry with the corresponding retry function.\n// 4. _performRetry updates the UI to show 'Loading...', then calls the retry function.\n// 5. The retry function (_basicRetry, _advancedRetry, or _retryWithErrorHandling) uses the retry package to attempt the operation.\n// 6. _simulateNetworkRequest simulates a network call that may succeed or fail randomly.\n// 7. If the operation succeeds, the result is displayed on the screen.\n// 8. If it fails, the retry logic kicks in, attempting the operation again based on the specified parameters.\n// 9. The final result (success or failure) is displayed on the screen.\n// \n// This example demonstrates how the retry package can be used to handle network operations with different retry strategies,\n// improving the robustness of the application in the face of network failures.\n```",
    "tags": [
      "network",
      "http",
      "error-handling",
      "retry-mechanism"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "kwyfshxx"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1LSx",
        "_type": "reference",
        "_key": "yvyruwdx"
      }
    ],
    "pubPoint": 160,
    "_type": "package",
    "similarPackages": [],
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8Cclv",
    "tutorial": "# Retry Package Tutorial\n\nIn this tutorial, we'll walk through the process of integrating and using the retry package in a Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the retry package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  retry: ^3.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nHere's a simple example of how to use the retry package:\n\n```dart\nimport 'package:retry/retry.dart';\n\nFuture<String> fetchData() async {\n  return await retry(\n    () => _makeHttpRequest(),\n    retryIf: (e) => e is NetworkException,\n    maxAttempts: 3,\n  );\n}\n\nFuture<String> _makeHttpRequest() async {\n  // Simulating a network request\n  // In a real scenario, this would be an actual API call\n  if (Random().nextBool()) {\n    throw NetworkException('Failed to fetch data');\n  }\n  return 'Data fetched successfully';\n}\n```\n\n## Step 3: Customizing Retry Behavior\n\nYou can customize the retry behavior using various parameters:\n\n```dart\nFuture<String> fetchDataWithCustomRetry() async {\n  return await retry(\n    () => _makeHttpRequest(),\n    retryIf: (e) => e is NetworkException,\n    maxAttempts: 5,\n    delayFactor: const Duration(seconds: 1),\n    maxDelay: const Duration(seconds: 10),\n  );\n}\n```\n\n## Step 4: Platform-Specific Considerations\n\n### Android\n\nFor Android, you may need to handle specific exceptions like `SocketException` or `TimeoutException`. Ensure you have the necessary permissions in your `AndroidManifest.xml`:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n### iOS\n\nFor iOS, you might encounter `NSURLErrorDomain` errors. Make sure to add the following to your `Info.plist` file:\n\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n\n## Step 5: Error Handling\n\nImplement proper error handling to manage different types of exceptions:\n\n```dart\nFuture<String> fetchDataWithErrorHandling() async {\n  try {\n    return await retry(\n      () => _makeHttpRequest(),\n      retryIf: (e) => e is NetworkException || e is TimeoutException,\n      onRetry: (e) => print('Retry attempt due to error: $e'),\n    );\n  } catch (e) {\n    print('All retry attempts failed. Error: $e');\n    rethrow;\n  }\n}\n```\n\nBy following these steps, you can effectively implement the retry package in your Flutter application, enhancing its resilience to network issues across different platforms.",
    "tutorialIncluded": true,
    "slug": {
      "current": "retry",
      "_type": "slug"
    },
    "description": "# Retry Package in Flutter: Enhancing Network Resilience\n\n## Introduction\n\nIn the world of mobile app development, handling network requests efficiently is crucial for providing a seamless user experience. Flutter, a popular cross-platform framework, offers various packages to simplify this process. One such package is the `retry` package, which provides a robust mechanism for retrying failed operations.\n\n## What is the Retry Package?\n\nThe `retry` package is a powerful tool that allows developers to implement retry logic for any asynchronous operation in Dart and Flutter. It's particularly useful for network requests, where temporary failures are common due to poor connectivity or server issues.\n\n## Key Features\n\n1. **Flexible Retry Attempts**: Customize the number of retry attempts based on your application's needs.\n2. **Configurable Delay**: Set up progressive delays between retries to avoid overwhelming the server.\n3. **Error Handling**: Define custom error handling logic for different types of exceptions.\n4. **Timeout Support**: Implement timeouts for each retry attempt to prevent indefinite waiting.\n5. **Easy Integration**: Seamlessly integrate with existing Flutter projects and network layers.\n\n## Why Use the Retry Package?\n\n1. **Improved User Experience**: Automatically handle temporary network failures without user intervention.\n2. **Reduced Error Rates**: Increase the success rate of operations by retrying failed attempts.\n3. **Customizable Behavior**: Tailor the retry logic to fit your specific use case and requirements.\n4. **Code Cleanliness**: Encapsulate retry logic in a reusable and maintainable way.\n\nIn the following sections, we'll dive deeper into how to implement and use the retry package in your Flutter applications, demonstrating its power and flexibility in handling network operations.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "retry"
  },
  {
    "tutorialIncluded": true,
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPamQK",
        "_type": "reference",
        "_key": "r2cnz0pz"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_createdAt": "2024-08-28T22:18:22Z",
    "lastUpdate": "2024-07-02T18:30:00.000Z",
    "name": "responsive_builder",
    "description": "# Understanding the responsive_builder Package in Flutter\n\nThe `responsive_builder` package is a powerful tool for creating responsive layouts in Flutter applications. It provides a set of widgets and utilities that make it easier to build UIs that adapt to different screen sizes and orientations.\n\n## Key Features\n\n1. **ScreenTypeLayout**: This widget allows you to define different layouts for various screen types (mobile, tablet, desktop).\n\n2. **ResponsiveBuilder**: A flexible widget that provides information about the current screen size and type, allowing you to build responsive UIs.\n\n3. **OrientationLayoutBuilder**: Similar to ScreenTypeLayout, but for different orientations (portrait and landscape).\n\n4. **RefineBuilder**: Enables you to make more granular adjustments based on specific width brackets within a screen type.\n\n5. **ResponsiveSizingConfig**: Allows you to customize the breakpoints for different screen types.\n\n## Why Use responsive_builder?\n\n- **Simplified Responsive Design**: The package abstracts away the complexity of managing different screen sizes and orientations.\n- **Improved Code Organization**: By separating layouts for different screen types, your code becomes more maintainable.\n- **Flexible and Customizable**: You can easily adjust breakpoints and create custom responsive behaviors.\n- **Performance Optimized**: The package is designed to be efficient, reducing unnecessary rebuilds.\n\nIn the following sections, we'll explore how to use the `responsive_builder` package in your Flutter projects, with a focus on creating a responsive UI for the RealFlutter app.",
    "shortDescription": "A set of widgets that can be used to define a readable responsive UI for widgets.",
    "dependentPackages": [],
    "_id": "uQRNMiDfrp20RZ8Id8CcrR",
    "author": "filledstacks.com",
    "_type": "package",
    "tutorial": "# Tutorial: Implementing Responsive Design with responsive_builder\n\nIn this tutorial, we'll walk through the process of using the `responsive_builder` package to create a responsive UI for the RealFlutter app.\n\n## Step 1: Add the Package\n\nFirst, add the `responsive_builder` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  responsive_builder: ^0.7.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Create a Responsive Layout\n\nLet's create a basic responsive layout using the `ScreenTypeLayout` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:responsive_builder/responsive_builder.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter')),\n      body: ScreenTypeLayout.builder(\n        mobile: (BuildContext context) => MobileLayout(),\n        tablet: (BuildContext context) => TabletLayout(),\n        desktop: (BuildContext context) => DesktopLayout(),\n      ),\n    );\n  }\n}\n\nclass MobileLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Mobile Layout'));\n  }\n}\n\nclass TabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Tablet Layout'));\n  }\n}\n\nclass DesktopLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Desktop Layout'));\n  }\n}\n```\n\n## Step 3: Use ResponsiveBuilder for Fine-Grained Control\n\nFor more control over the layout, use the `ResponsiveBuilder` widget:\n\n```dart\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter')),\n      body: ResponsiveBuilder(\n        builder: (context, sizingInformation) {\n          if (sizingInformation.deviceScreenType == DeviceScreenType.desktop) {\n            return DesktopLayout();\n          }\n          \n          if (sizingInformation.deviceScreenType == DeviceScreenType.tablet) {\n            return TabletLayout();\n          }\n          \n          return MobileLayout();\n        },\n      ),\n    );\n  }\n}\n```\n\n## Step 4: Implement Orientation-Specific Layouts\n\nUse `OrientationLayoutBuilder` for orientation-specific layouts:\n\n```dart\nclass MobileLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return OrientationLayoutBuilder(\n      portrait: (context) => PortraitLayout(),\n      landscape: (context) => LandscapeLayout(),\n    );\n  }\n}\n```\n\n## Step 5: Refine Layouts with RefineBuilder\n\nFor more granular control within a screen type:\n\n```dart\nclass TabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return RefineBuilder.builder(\n      refinements: [\n        Refinement(\n          trait: 'Small Tablet',\n          condition: (sizingInfo) => sizingInfo.screenSize.width < 800,\n          builder: (context, sizingInfo) => SmallTabletLayout(),\n        ),\n        Refinement(\n          trait: 'Large Tablet',\n          condition: (sizingInfo) => sizingInfo.screenSize.width >= 800,\n          builder: (context, sizingInfo) => LargeTabletLayout(),\n        ),\n      ],\n      defaultBuilder: (context, sizingInfo) => DefaultTabletLayout(),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, ensure your layouts adhere to Apple's Human Interface Guidelines. Use `CupertinoApp` and Cupertino-style widgets for a native iOS feel.\n\n### Android\nFor Android, follow Material Design guidelines. Use `MaterialApp` and Material widgets for consistency with Android design patterns.\n\n### Web\nFor web applications, consider using a more desktop-oriented layout when running in a browser environment. You can detect the platform using:\n\n```dart\nimport 'package:flutter/foundation.dart' show kIsWeb;\n\nif (kIsWeb) {\n  // Web-specific layout\n} else {\n  // Mobile app layout\n}\n```\n\nBy following these steps and considerations, you can create a responsive UI that adapts to different screen sizes, orientations, and platforms using the `responsive_builder` package.",
    "_updatedAt": "2024-09-06T04:13:16Z",
    "slug": {
      "current": "responsive_builder",
      "_type": "slug"
    },
    "likesCount": 1613,
    "packageImage": null,
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6Reem",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "n5md50be",
        "_ref": "EyMM3FfV3Ih5n1NWrhPFlU"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:responsive_builder/responsive_builder.dart';\n\nvoid main() {\n  // Step 1: Set up ResponsiveSizingConfig (optional)\n  ResponsiveSizingConfig.instance.setCustomBreakpoints(\n    ScreenBreakpoints(desktop: 1200, tablet: 650, watch: 300),\n  );\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Responsive Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: ResponsiveHomePage(),\n    );\n  }\n}\n\nclass ResponsiveHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 2: Use ScreenTypeLayout for basic responsiveness\n    return ScreenTypeLayout.builder(\n      mobile: (BuildContext context) => MobileLayout(),\n      tablet: (BuildContext context) => TabletLayout(),\n      desktop: (BuildContext context) => DesktopLayout(),\n    );\n  }\n}\n\nclass MobileLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 3: Use OrientationLayoutBuilder for orientation-specific layouts\n    return OrientationLayoutBuilder(\n      portrait: (context) => MobilePortraitLayout(),\n      landscape: (context) => MobileLandscapeLayout(),\n    );\n  }\n}\n\nclass MobilePortraitLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Mobile Portrait')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.phone_android, size: 100),\n          SizedBox(height: 20),\n          Text('This is a mobile portrait layout'),\n        ],\n      ),\n    );\n  }\n}\n\nclass MobileLandscapeLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Mobile Landscape')),\n      body: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: [\n          Icon(Icons.phone_android, size: 100),\n          Text('This is a mobile landscape layout'),\n        ],\n      ),\n    );\n  }\n}\n\nclass TabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 4: Use RefineBuilder for more granular control\n    return RefineBuilder.builder(\n      refinements: [\n        Refinement(\n          trait: 'Small Tablet',\n          condition: (sizingInfo) => sizingInfo.screenSize.width < 800,\n          builder: (context, sizingInfo) => SmallTabletLayout(),\n        ),\n        Refinement(\n          trait: 'Large Tablet',\n          condition: (sizingInfo) => sizingInfo.screenSize.width >= 800,\n          builder: (context, sizingInfo) => LargeTabletLayout(),\n        ),\n      ],\n      defaultBuilder: (context, sizingInfo) => DefaultTabletLayout(),\n    );\n  }\n}\n\nclass SmallTabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Small Tablet')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.tablet, size: 100),\n            Text('This is a small tablet layout'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass LargeTabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Large Tablet')),\n      body: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            Icon(Icons.tablet, size: 100),\n            Text('This is a large tablet layout'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass DefaultTabletLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Default Tablet')),\n      body: Center(child: Text('This is the default tablet layout')),\n    );\n  }\n}\n\nclass DesktopLayout extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Step 5: Use ResponsiveBuilder for custom responsive behavior\n    return ResponsiveBuilder(\n      builder: (context, sizingInformation) {\n        return Scaffold(\n          appBar: AppBar(title: Text('Desktop')),\n          body: Row(\n            children: [\n              Expanded(\n                flex: 1,\n                child: Container(\n                  color: Colors.blue[100],\n                  child: Center(child: Text('Sidebar')),\n                ),\n              ),\n              Expanded(\n                flex: 3,\n                child: Container(\n                  child: Center(\n                    child: Column(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: [\n                        Icon(Icons.desktop_windows, size: 100),\n                        SizedBox(height: 20),\n                        Text('This is a desktop layout'),\n                        SizedBox(height: 20),\n                        Text('Screen Width: ${sizingInformation.screenSize.width}'),\n                        Text('Screen Height: ${sizingInformation.screenSize.height}'),\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts by setting custom breakpoints for responsive sizing.\n// 2. The RealFlutter widget sets up the MaterialApp with a ResponsiveHomePage.\n// 3. ResponsiveHomePage uses ScreenTypeLayout to determine the device type.\n// 4. For mobile devices:\n//    - MobileLayout uses OrientationLayoutBuilder to switch between portrait and landscape layouts.\n// 5. For tablets:\n//    - TabletLayout uses RefineBuilder to further categorize into small and large tablet layouts.\n// 6. For desktop:\n//    - DesktopLayout uses ResponsiveBuilder to create a custom layout with a sidebar and main content area.\n// 7. Each layout provides specific UI elements and arrangements suitable for its screen size and orientation.\n// 8. The app continuously adapts to changes in screen size or orientation, providing a seamless responsive experience.\n```",
    "tags": [
      "responsive",
      "layout",
      "ui",
      "adaptive"
    ]
  },
  {
    "_createdAt": "2024-08-28T22:18:37Z",
    "_rev": "AE3hjGWNkNE6aGQMMbaTSZ",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cb6x",
        "_type": "reference",
        "_key": "s4ugtu34"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "example": "```\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const RealFlutterApp());\n}\n\nclass RealFlutterApp extends StatelessWidget {\n  const RealFlutterApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter Record Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const RealFlutterHomePage(),\n    );\n  }\n}\n\nclass RealFlutterHomePage extends StatefulWidget {\n  const RealFlutterHomePage({Key? key}) : super(key: key);\n\n  @override\n  _RealFlutterHomePageState createState() => _RealFlutterHomePageState();\n}\n\nclass _RealFlutterHomePageState extends State<RealFlutterHomePage> {\n  // Step 1: Define a record type for RealFlutter version info\n  late (String name, int version, String releaseDate) _versionInfo;\n\n  // Step 2: Define a record type for user data\n  late (String name, int age, String email) _userData;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Initialize the records\n    _versionInfo = getRealFlutterInfo();\n    _userData = ('John Doe', 30, 'john@example.com');\n  }\n\n  // Step 4: Function that returns a record\n  (String, int, String) getRealFlutterInfo() {\n    return ('RealFlutter', 2, '2024-09-05');\n  }\n\n  // Step 5: Function that uses pattern matching with records\n  String getVersionDescription((String name, int version, String date)) {\n    return switch (record) {\n      (_, 1, _) => 'Original version',\n      (_, 2, _) => 'Improved version',\n      (String name, int version, _) when version > 2 => 'Future version: $name $version',\n      _ => 'Unknown version'\n    };\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('RealFlutter Record Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 6: Use record fields in UI\n            Text('App: ${_versionInfo.$1}'),\n            Text('Version: ${_versionInfo.$2}'),\n            Text('Release Date: ${_versionInfo.$3}'),\n            const SizedBox(height: 20),\n            Text('Description: ${getVersionDescription(_versionInfo)}'),\n            const SizedBox(height: 20),\n            Text('User: ${_userData.name}'),\n            Text('Age: ${_userData.age}'),\n            Text('Email: ${_userData.email}'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutterApp.\n// 2. RealFlutterHomePage is set as the home widget.\n// 3. In the state's initState method, we initialize two records:\n//    - _versionInfo: Contains information about the RealFlutter version.\n//    - _userData: Contains user information.\n// 4. The getRealFlutterInfo() function demonstrates returning a record from a function.\n// 5. The getVersionDescription() function shows how to use pattern matching with records.\n// 6. In the build method, we use the record fields to display information in the UI.\n//    This demonstrates how to access both named and unnamed fields of a record.\n// \n// Key Points:\n// - Records provide a concise way to group related data without creating a class.\n// - They can be used to return multiple values from a function (getRealFlutterInfo).\n// - Pattern matching with records allows for expressive conditional logic (getVersionDescription).\n// - Records can have both named and unnamed fields, providing flexibility in data structuring.\n// - The immutability of records ensures data integrity throughout the application.\n```",
    "name": "record",
    "_id": "uQRNMiDfrp20RZ8Id8CdXj",
    "tutorialIncluded": true,
    "slug": {
      "current": "record",
      "_type": "slug"
    },
    "_type": "package",
    "description": "# Flutter Record Package: Empowering Data Structures\n\n## Introduction\n\nFlutter's record package introduces a powerful feature to the Dart language: the ability to create lightweight, immutable groups of values. Records provide a way to bundle multiple values together without the need for defining a custom class. This feature enhances code readability, improves type safety, and offers a more concise syntax for handling multiple return values.\n\n## Key Features\n\n1. **Immutability**: Records are immutable by design, ensuring data integrity and thread safety.\n2. **Type Safety**: Each field in a record has a specific type, providing compile-time type checking.\n3. **Pattern Matching**: Records can be used in pattern matching, enabling powerful and expressive code.\n4. **Lightweight**: Records are more lightweight than full-fledged classes, making them ideal for simple data groupings.\n5. **Multiple Return Values**: Functions can easily return multiple values using records, improving API design.\n\n## Use Cases\n\n- **Returning multiple values**: Instead of creating a custom class or using a `List`, records offer a type-safe way to return multiple values from a function.\n- **Grouping related data**: When you need to group related data without the overhead of creating a class, records are an excellent choice.\n- **API responses**: Records can simplify the handling of API responses, especially when dealing with partial data or multiple related pieces of information.\n- **Tuple-like structures**: For languages that support tuples, records in Dart provide similar functionality.\n\nIn the following sections, we'll explore how to use records in your Flutter projects, including platform-specific considerations and a comprehensive example demonstrating their full potential.",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbWMS",
        "_type": "reference",
        "_key": "vkbqywnc"
      }
    ],
    "packageImage": null,
    "shortDescription": "Audio recorder from microphone to file or stream with multiple codecs, bit rate and sampling rate options.",
    "tags": [
      "audio",
      "recording",
      "media",
      "sound"
    ],
    "likesCount": 604,
    "lastUpdate": "2024-06-24T18:30:00.000Z",
    "tutorial": "# Flutter Record Package: A Comprehensive Tutorial\n\n## Getting Started\n\nTo use records in your Flutter project, you need to ensure you're using Dart 3.0 or later. Update your `pubspec.yaml` file to specify the Dart SDK version:\n\n```yaml\nenvironment:\n  sdk: '>=3.0.0 <4.0.0'\n```\n\n## Basic Usage\n\n### Creating a Record\n\nRecords are created using parentheses `()`. Each field can have an optional name and type annotation:\n\n```dart\nvar person = ('John Doe', 30);  // Unnamed fields\nvar namedPerson = (name: 'John Doe', age: 30);  // Named fields\n```\n\n### Accessing Record Fields\n\nFor unnamed fields, use positional access:\n\n```dart\nprint(person.$1);  // Prints: John Doe\nprint(person.$2);  // Prints: 30\n```\n\nFor named fields, use dot notation:\n\n```dart\nprint(namedPerson.name);  // Prints: John Doe\nprint(namedPerson.age);   // Prints: 30\n```\n\n### Record Types\n\nYou can specify record types for better type safety:\n\n```dart\n(String, int) typedPerson = ('Jane Doe', 25);\n(String name, int age) typedNamedPerson = (name: 'Jane Doe', age: 25);\n```\n\n## Advanced Features\n\n### Pattern Matching\n\nRecords can be used in pattern matching, which is particularly useful in switch statements:\n\n```dart\nvoid describeRealFlutter((String name, int version)) {\n  switch (record) {\n    case ('RealFlutter', 1):\n      print('Original version');\n    case ('RealFlutter', 2):\n      print('Improved version');\n    case (String name, int version) when version > 2:\n      print('Future version: $name $version');\n    default:\n      print('Unknown version');\n  }\n}\n```\n\n### Using Records in Functions\n\nRecords are excellent for returning multiple values from a function:\n\n```dart\n(String, int) getRealFlutterInfo() {\n  return ('RealFlutter', 2);\n}\n\nvoid main() {\n  var (name, version) = getRealFlutterInfo();\n  print('$name version $version');\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nWhen using records in Android-specific code (e.g., in platform channels), ensure that you're using the latest version of the Android Gradle plugin that supports Dart 3.0.\n\n### iOS\n\nFor iOS, make sure your Podfile is configured to use a version of Flutter that supports Dart 3.0. You may need to update your CocoaPods installation.\n\n### Web\n\nRecords are fully supported in Flutter web applications. However, ensure that your web renderer (HTML or CanvasKit) is compatible with the version of Flutter that supports Dart 3.0.\n\n### Desktop (Windows, macOS, Linux)\n\nDesktop platforms fully support records. Ensure you're using the latest stable version of Flutter that includes Dart 3.0 support.\n\nBy following this tutorial, you'll be well-equipped to leverage the power of records in your Flutter applications across various platforms.",
    "_updatedAt": "2024-09-06T04:13:17Z",
    "pubPoint": 160,
    "author": "openapi4j.org",
    "dependentPackages": [
      {
        "_key": "z18iv0ud",
        "_ref": "V06bsD4sX3T8NTHrBPbPCe",
        "_type": "reference"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "bagk03og"
      }
    ]
  },
  {
    "tags": [
      "signature",
      "drawing",
      "input",
      "canvas"
    ],
    "likesCount": 541,
    "author": "4q.eu",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "zppcalss"
      }
    ],
    "example": "```\nimport 'dart:typed_data';\nimport 'package:flutter/material.dart';\nimport 'package:signature/signature.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Signature Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: RealFlutter(),\n    );\n  }\n}\n\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  // Step 1: Initialize the SignatureController\n  final SignatureController _controller = SignatureController(\n    penStrokeWidth: 5,\n    penColor: Colors.black,\n    exportBackgroundColor: Colors.white,\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Add a listener to the controller\n    _controller.addListener(() => print('Signature changed'));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Signature Demo')),\n      body: Column(\n        children: <Widget>[\n          // Step 3: Add the Signature widget\n          Signature(\n            controller: _controller,\n            height: 300,\n            backgroundColor: Colors.grey[200]!,\n          ),\n          // Step 4: Add control buttons\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: <Widget>[\n              // Clear button\n              ElevatedButton(\n                onPressed: () {\n                  setState(() => _controller.clear());\n                },\n                child: Text('Clear'),\n              ),\n              // Undo button\n              ElevatedButton(\n                onPressed: () {\n                  setState(() => _controller.undo());\n                },\n                child: Text('Undo'),\n              ),\n              // Save button\n              ElevatedButton(\n                onPressed: () async {\n                  if (_controller.isNotEmpty) {\n                    // Step 5: Export the signature as a PNG image\n                    final Uint8List? data = await _controller.toPngBytes();\n                    if (data != null) {\n                      await showDialog(\n                        context: context,\n                        builder: (context) => AlertDialog(\n                          title: Text('Saved Signature'),\n                          content: Image.memory(data),\n                          actions: <Widget>[\n                            TextButton(\n                              child: Text('Close'),\n                              onPressed: () => Navigator.of(context).pop(),\n                            )\n                          ],\n                        ),\n                      );\n                    }\n                  }\n                },\n                child: Text('Save'),\n              ),\n            ],\n          ),\n          // Step 6: Add signature info\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Text(\n              'The signature has ${_controller.points.length} points',\n              style: Theme.of(context).textTheme.bodyLarge,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 7: Dispose the controller when the widget is disposed\n    _controller.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a signature pad with control buttons.\n// 2. Users can draw on the signature pad using touch or stylus input.\n// 3. The 'Clear' button erases the entire signature.\n// 4. The 'Undo' button removes the last stroke.\n// 5. The 'Save' button converts the signature to a PNG image and displays it in a dialog.\n// 6. The number of points in the signature is displayed and updated in real-time.\n// 7. When the widget is disposed, the controller is also disposed to free up resources.\n\n// This example demonstrates the core features of the Flutter signature package,\n// including drawing, clearing, undoing, saving, and retrieving signature information.\n```",
    "_createdAt": "2024-08-28T22:18:58Z",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaTXM",
    "_type": "package",
    "_id": "uQRNMiDfrp20RZ8Id8CdmR",
    "shortDescription": "A Flutter plugin providing performance optimized signature canvas with ability to set custom style, boundaries and initial state.",
    "similarPackages": [],
    "lastUpdate": "2024-05-09T18:30:00.000Z",
    "packageImage": null,
    "name": "signature",
    "tutorial": "# Flutter Signature Package: Implementation Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the Flutter signature package in your application. We'll cover installation, basic setup, and platform-specific considerations.\n\n## Step 1: Installation\n\nFirst, add the signature package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  signature: ^5.3.0  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Implementation\n\nHere's a basic implementation of the signature package:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:signature/signature.dart';\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Signature Example')),\n      body: Signature(\n        controller: SignatureController(\n          penStrokeWidth: 5,\n          penColor: Colors.black,\n          exportBackgroundColor: Colors.white,\n        ),\n        height: 300,\n        backgroundColor: Colors.grey[200]!,\n      ),\n    );\n  }\n}\n```\n\nThis creates a basic signature pad with a black pen on a light grey background.\n\n## Step 3: Adding Functionality\n\nLet's add buttons to clear the signature and save it as an image:\n\n```dart\nimport 'dart:typed_data';\nimport 'package:flutter/material.dart';\nimport 'package:signature/signature.dart';\n\nclass RealFlutter extends StatelessWidget {\n  final SignatureController _controller = SignatureController(\n    penStrokeWidth: 5,\n    penColor: Colors.black,\n    exportBackgroundColor: Colors.white,\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Signature Example')),\n      body: Column(\n        children: <Widget>[\n          Signature(\n            controller: _controller,\n            height: 300,\n            backgroundColor: Colors.grey[200]!,\n          ),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: <Widget>[\n              ElevatedButton(\n                onPressed: () {\n                  _controller.clear();\n                },\n                child: Text('Clear'),\n              ),\n              ElevatedButton(\n                onPressed: () async {\n                  if (_controller.isNotEmpty) {\n                    final Uint8List? data = await _controller.toPngBytes();\n                    if (data != null) {\n                      await Navigator.of(context).push(\n                        MaterialPageRoute(\n                          builder: (context) => Scaffold(\n                            appBar: AppBar(\n                              title: Text('Signed Image'),\n                            ),\n                            body: Image.memory(data),\n                          ),\n                        ),\n                      );\n                    }\n                  }\n                },\n                child: Text('Save'),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\nFor iOS, no additional setup is required. The package works out of the box.\n\n### Android\nFor Android, ensure you have the latest version of the package, as older versions may require additional permissions setup.\n\n### Web\nFor web support, add the following to your `web/index.html` file inside the `<head>` tag:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/signature_pad@4.0.0/dist/signature_pad.umd.min.js\"></script>\n```\n\nThis includes the necessary JavaScript library for signature functionality on the web platform.\n\nWith these steps, you've successfully implemented the Flutter signature package in your application, complete with platform-specific considerations. In the next section, we'll look at a more comprehensive example that demonstrates all the features of this package.",
    "_updatedAt": "2024-09-06T04:13:19Z",
    "slug": {
      "_type": "slug",
      "current": "signature"
    },
    "description": "# Flutter Signature Package: A Comprehensive Guide\n\nIn the world of mobile app development, capturing and managing digital signatures has become increasingly important. Whether you're building an e-commerce app, a document signing tool, or any application that requires user authorization, the ability to capture and store signatures is crucial. This is where the Flutter signature package comes into play.\n\n## What is the Flutter Signature Package?\n\nThe Flutter signature package is a powerful and flexible tool that allows developers to easily implement signature functionality in their Flutter applications. It provides a customizable signature pad where users can draw their signatures using touch or stylus input.\n\nKey features of the signature package include:\n\n1. **Customizable Canvas**: Adjust the size, color, and background of the signature pad to match your app's design.\n2. **Multi-platform Support**: Works seamlessly on iOS, Android, and web platforms.\n3. **Export Options**: Save signatures as images in various formats (PNG, JPEG, SVG).\n4. **Undo/Clear Functionality**: Allows users to undo strokes or clear the entire signature.\n5. **Signature Validation**: Provides methods to check if a signature has been drawn.\n\n## Why Use the Flutter Signature Package?\n\nImplementing a signature capture feature from scratch can be time-consuming and prone to errors. The Flutter signature package offers a robust, ready-to-use solution that can be easily integrated into your app. It handles the complexities of touch input, stroke rendering, and image export, allowing you to focus on other aspects of your application.\n\nWhether you're developing a contract signing app, a delivery confirmation system, or any application that requires user authorization, the Flutter signature package provides a reliable and user-friendly way to capture and manage digital signatures.\n\nIn the following sections, we'll dive deeper into how to implement this package in your Flutter application, exploring its features and demonstrating its usage through practical examples.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": []
  },
  {
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_type": "package",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "oyhlvram",
        "_ref": "EyMM3FfV3Ih5n1NWrhPG5F"
      }
    ],
    "tags": [
      "bloc",
      "concurrency",
      "state-management",
      "async"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CdzJ",
    "tutorial": "# Tutorial: Implementing bloc_concurrency in Flutter\n\nIn this tutorial, we'll walk through the process of implementing the `bloc_concurrency` package in a Flutter application. We'll use the RealFlutter class as our main example.\n\n## Step 1: Add Dependencies\n\nFirst, add the required dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  bloc: ^8.1.0\n  flutter_bloc: ^8.1.1\n  bloc_concurrency: ^0.2.0\n```\n\nRun `flutter pub get` to install the dependencies.\n\n## Step 2: Create the RealFlutter Event and State\n\nCreate a new file `real_flutter_bloc.dart` and define the event and state:\n\n```dart\nimport 'package:equatable/equatable.dart';\n\nabstract class RealFlutterEvent extends Equatable {\n  @override\n  List<Object> get props => [];\n}\n\nclass FetchDataEvent extends RealFlutterEvent {}\n\nclass RealFlutterState extends Equatable {\n  final String data;\n  final bool isLoading;\n\n  const RealFlutterState({this.data = '', this.isLoading = false});\n\n  RealFlutterState copyWith({String? data, bool? isLoading}) {\n    return RealFlutterState(\n      data: data ?? this.data,\n      isLoading: isLoading ?? this.isLoading,\n    );\n  }\n\n  @override\n  List<Object> get props => [data, isLoading];\n}\n```\n\n## Step 3: Implement the RealFlutter Bloc\n\nIn the same file, implement the RealFlutterBloc:\n\n```dart\nimport 'package:bloc/bloc.dart';\nimport 'package:bloc_concurrency/bloc_concurrency.dart';\n\nclass RealFlutterBloc extends Bloc<RealFlutterEvent, RealFlutterState> {\n  RealFlutterBloc() : super(const RealFlutterState()) {\n    on<FetchDataEvent>(_onFetchData, transformer: restartable());\n  }\n\n  Future<void> _onFetchData(FetchDataEvent event, Emitter<RealFlutterState> emit) async {\n    emit(state.copyWith(isLoading: true));\n    // Simulate API call\n    await Future.delayed(const Duration(seconds: 2));\n    emit(state.copyWith(data: 'Fetched Data', isLoading: false));\n  }\n}\n```\n\n## Step 4: Use the Bloc in UI\n\nCreate a new file `real_flutter_page.dart` and implement the UI:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'real_flutter_bloc.dart';\n\nclass RealFlutterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) => RealFlutterBloc(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('RealFlutter Example')),\n        body: Center(\n          child: BlocBuilder<RealFlutterBloc, RealFlutterState>(\n            builder: (context, state) {\n              if (state.isLoading) {\n                return CircularProgressIndicator();\n              }\n              return Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Text(state.data),\n                  ElevatedButton(\n                    onPressed: () => context.read<RealFlutterBloc>().add(FetchDataEvent()),\n                    child: Text('Fetch Data'),\n                  ),\n                ],\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Details\n\n### Android\n\nFor Android, ensure you have the following in your `android/app/build.gradle`:\n\n```gradle\nandroid {\n    compileSdkVersion 31\n    // ...\n    defaultConfig {\n        // ...\n        minSdkVersion 16\n        targetSdkVersion 31\n        // ...\n    }\n}\n```\n\n### iOS\n\nFor iOS, update your `ios/Podfile` to use the latest platform:\n\n```ruby\nplatform :ios, '11.0'\n```\n\nBy following these steps, you've successfully implemented the `bloc_concurrency` package in your Flutter application using the RealFlutter class. The `restartable()` transformer ensures that if a new FetchDataEvent is added while one is already processing, the current one will be canceled and the new one will start.",
    "_updatedAt": "2024-09-06T04:13:20Z",
    "author": "bloclibrary.dev",
    "shortDescription": "Custom event transformers inspired by ember concurrency. Built to be used with the bloc state management package.",
    "likesCount": 465,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-13a7cfe19ec3325282b0fa7606e425683b2dc77e-569x650-webp",
        "_type": "reference"
      }
    },
    "lastUpdate": "2024-03-23T18:30:00.000Z",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Vsl",
        "_type": "reference",
        "_key": "fnks2dk8"
      },
      {
        "_type": "reference",
        "_key": "qnplyrwh",
        "_ref": "Rx1Nho763d29lawKra1kah"
      }
    ],
    "_createdAt": "2024-08-28T22:19:07Z",
    "name": "bloc_concurrency",
    "slug": {
      "current": "bloc_concurrency",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaTaY",
    "description": "# Understanding the bloc_concurrency Package in Flutter\n\nThe `bloc_concurrency` package is a powerful tool for managing concurrency in Flutter applications that use the BLoC (Business Logic Component) pattern. It provides a set of event transformers that allow developers to control how events are processed within a Bloc.\n\n## Key Features\n\n1. **restartable**: Cancels the current event processing and starts a new one when a new event is added.\n2. **droppable**: Ignores any new events while the current event is being processed.\n3. **sequential**: Processes events one at a time in the order they were added.\n4. **concurrent**: Processes all events concurrently without any restrictions.\n\nThese transformers help in handling various scenarios like debouncing user input, canceling ongoing operations, or ensuring events are processed in a specific order.\n\n## Why Use bloc_concurrency?\n\n- **Improved Performance**: By controlling event processing, you can avoid unnecessary computations and reduce load on system resources.\n- **Better User Experience**: Manage UI updates more efficiently, especially in scenarios involving rapid user interactions or network requests.\n- **Simplified State Management**: Easily handle complex event sequences without cluttering your Bloc implementation.\n\nIn the following sections, we'll explore how to implement these features in a real-world Flutter application using the RealFlutter class.",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Ca4b",
        "_type": "reference",
        "_key": "jgbeze2v"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Jyh",
        "_type": "reference",
        "_key": "kpug16pr"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:bloc_concurrency/bloc_concurrency.dart';\n\n// Step 1: Define Events\nabstract class RealFlutterEvent {}\n\nclass FetchDataEvent extends RealFlutterEvent {\n  final String query;\n  FetchDataEvent(this.query);\n}\n\n// Step 2: Define States\nclass RealFlutterState {\n  final List<String> data;\n  final bool isLoading;\n  final String error;\n\n  RealFlutterState({this.data = const [], this.isLoading = false, this.error = ''});\n\n  RealFlutterState copyWith({List<String>? data, bool? isLoading, String? error}) {\n    return RealFlutterState(\n      data: data ?? this.data,\n      isLoading: isLoading ?? this.isLoading,\n      error: error ?? this.error,\n    );\n  }\n}\n\n// Step 3: Implement the Bloc\nclass RealFlutterBloc extends Bloc<RealFlutterEvent, RealFlutterState> {\n  RealFlutterBloc() : super(RealFlutterState()) {\n    on<FetchDataEvent>(_onFetchData, transformer: droppable());\n  }\n\n  Future<void> _onFetchData(FetchDataEvent event, Emitter<RealFlutterState> emit) async {\n    emit(state.copyWith(isLoading: true));\n    try {\n      // Simulate API call\n      await Future.delayed(Duration(seconds: 2));\n      final result = await _fetchData(event.query);\n      emit(state.copyWith(data: result, isLoading: false));\n    } catch (e) {\n      emit(state.copyWith(error: e.toString(), isLoading: false));\n    }\n  }\n\n  Future<List<String>> _fetchData(String query) async {\n    // Simulate data fetching\n    return List.generate(5, (index) => '$query result ${index + 1}');\n  }\n}\n\n// Step 4: Implement the UI\nclass RealFlutterApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => RealFlutterBloc(),\n        child: RealFlutterHome(),\n      ),\n    );\n  }\n}\n\nclass RealFlutterHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('RealFlutter Example')),\n      body: Column(\n        children: [\n          Padding(\n            padding: EdgeInsets.all(8.0),\n            child: TextField(\n              onChanged: (query) {\n                context.read<RealFlutterBloc>().add(FetchDataEvent(query));\n              },\n              decoration: InputDecoration(\n                labelText: 'Search',\n                border: OutlineInputBorder(),\n              ),\n            ),\n          ),\n          Expanded(\n            child: BlocBuilder<RealFlutterBloc, RealFlutterState>(\n              builder: (context, state) {\n                if (state.isLoading) {\n                  return Center(child: CircularProgressIndicator());\n                } else if (state.error.isNotEmpty) {\n                  return Center(child: Text('Error: ${state.error}'));\n                } else if (state.data.isEmpty) {\n                  return Center(child: Text('No results'));\n                } else {\n                  return ListView.builder(\n                    itemCount: state.data.length,\n                    itemBuilder: (context, index) {\n                      return ListTile(title: Text(state.data[index]));\n                    },\n                  );\n                }\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Step 5: Run the app\nvoid main() {\n  runApp(RealFlutterApp());\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutterBloc.\n// 2. The UI displays a search field and an empty list.\n// 3. As the user types in the search field, FetchDataEvents are triggered.\n// 4. The bloc uses the droppable() transformer, which means if a new event comes in while one is being processed, the new one is ignored.\n// 5. When an event is processed, the bloc simulates an API call and updates the state with new data.\n// 6. The UI reflects the changes in state, showing loading indicators, error messages, or the fetched data as appropriate.\n// 7. This implementation demonstrates efficient handling of rapid user input, preventing unnecessary API calls and ensuring a smooth user experience.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ]
  },
  {
    "tutorial": "# Custom Lint Package Tutorial\n\nThis tutorial will guide you through setting up and using the `custom_lint` package in your Flutter project. We'll cover installation, configuration, and creating a simple custom lint rule.\n\n## Step 1: Installation\n\nFirst, add the `custom_lint` package to your `pubspec.yaml` file:\n\n```yaml\ndev_dependencies:\n  custom_lint:\n  custom_lint_builder:\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Configuration\n\nCreate a `custom_lint.yaml` file in your project root:\n\n```yaml\ncustom_lint:\n  rules:\n    - prefer_relative_imports\n    - avoid_print\n```\n\nThis file specifies which lint rules to enable.\n\n## Step 3: Create a Custom Lint Rule\n\n1. Create a new package for your custom lint rules:\n\n```bash\nflutter create --template=package custom_lints\n```\n\n2. In the `custom_lints` package, add the following to `pubspec.yaml`:\n\n```yaml\ndependencies:\n  custom_lint_builder:\n\nenvironment:\n  sdk: '>=2.17.0 <3.0.0'\n```\n\n3. Create a new file `lib/custom_lints.dart`:\n\n```dart\nimport 'package:custom_lint_builder/custom_lint_builder.dart';\n\nclass RealFlutter extends PluginBase {\n  @override\n  List<LintRule> getLintRules(CustomLintConfigs configs) => [\n        PreferRelativeImports(),\n      ];\n}\n\nclass PreferRelativeImports extends DartLintRule {\n  PreferRelativeImports() : super(code: 'prefer_relative_imports');\n\n  @override\n  void run(\n    CustomLintResolver resolver,\n    ErrorReporter reporter,\n    CustomLintContext context,\n  ) {\n    context.registry.addImportDirective((node) {\n      if (node.uri.stringValue.startsWith('package:') &&\n          node.uri.stringValue.contains(resolver.current.package.name)) {\n        reporter.reportErrorForNode(\n          LintCode(code, 'Prefer relative imports for files in lib/'),\n          node,\n        );\n      }\n    });\n  }\n}\n```\n\n## Step 4: Use Your Custom Lint Package\n\n1. In your main Flutter project, add your custom lint package to `pubspec.yaml`:\n\n```yaml\ndev_dependencies:\n  custom_lint:\n  custom_lints:\n    path: ../custom_lints\n```\n\n2. Run `flutter pub get` to update dependencies.\n\n## Platform-Specific Details\n\n### Android\n\nFor Android Studio users, ensure you have the Dart plugin installed and up-to-date. Custom lint rules should be automatically picked up by the IDE.\n\n### iOS (macOS)\n\nFor Xcode users, you can run custom lint checks from the terminal:\n\n```bash\nflutter pub run custom_lint\n```\n\n### VS Code (Cross-platform)\n\nInstall the \"Dart\" extension. Custom lint rules should be automatically picked up and displayed in the \"Problems\" panel.\n\n## Running Custom Lint\n\nTo run custom lint checks, use the following command:\n\n```bash\nflutter pub run custom_lint\n```\n\nThis will analyze your code and report any issues based on your custom lint rules.\n\nWith these steps, you've successfully set up and created a custom lint rule for your Flutter project!",
    "tutorialIncluded": true,
    "_type": "package",
    "description": "# Custom Lint Package for Flutter: Enhancing Code Quality\n\n## Introduction\n\nIn the world of Flutter development, maintaining code quality is paramount. While Flutter provides built-in linting rules, there are times when you need more specific or custom rules tailored to your project's needs. This is where the `custom_lint` package comes into play.\n\n## What is Custom Lint?\n\n`custom_lint` is a powerful Dart package that allows developers to create and use custom lint rules in their Flutter projects. It extends the capabilities of the default linter, enabling you to enforce project-specific coding standards, catch common errors, and improve overall code quality.\n\n## Key Features\n\n1. **Custom Rule Creation**: Develop lint rules specific to your project or team's coding standards.\n2. **Easy Integration**: Seamlessly integrates with existing Flutter projects and IDEs.\n3. **Performance**: Designed to be fast and efficient, even on large codebases.\n4. **Extensibility**: Can be extended to create complex rules and even auto-fixes.\n\n## Why Use Custom Lint?\n\n1. **Enforce Consistency**: Ensure all team members follow the same coding standards.\n2. **Catch Errors Early**: Identify potential issues before they become problems in production.\n3. **Improve Code Quality**: Encourage best practices and cleaner code throughout your project.\n4. **Project-Specific Rules**: Create rules that are tailored to your project's unique requirements.\n\nIn the following sections, we'll dive into how to set up and use the `custom_lint` package in your Flutter projects, and demonstrate its capabilities with practical examples.",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CasF",
        "_type": "reference",
        "_key": "xs2pdfxe"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CgMP",
        "_type": "reference",
        "_key": "buuaukx1"
      }
    ],
    "name": "custom_lint",
    "example": "```\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:custom_lint/custom_lint.dart';\n\n// Step 1: Define a custom lint rule\nclass PreferConstConstructors extends DartLintRule {\n  PreferConstConstructors() : super(code: 'prefer_const_constructors');\n\n  @override\n  void run(\n    CustomLintResolver resolver,\n    ErrorReporter reporter,\n    CustomLintContext context,\n  ) {\n    context.registry.addInstanceCreationExpression((node) {\n      if (!node.isConst && node.constructorName.type.name.name == 'Widget') {\n        reporter.reportErrorForNode(\n          LintCode(code, 'Prefer const constructors for Widgets'),\n          node,\n        );\n      }\n    });\n  }\n}\n\n// Step 2: Define the main RealFlutter class\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom Lint Example'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Step 3: Use a non-const constructor (will trigger lint warning)\n              ElevatedButton(\n                onPressed: () {},\n                child: Text('Non-const Button'),\n              ),\n              // Step 4: Use a const constructor (follows lint rule)\n              const ElevatedButton(\n                onPressed: null,\n                child: Text('Const Button'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Step 5: Main function\nvoid main() {\n  // Register custom lint rule\n  CustomLint.registerLintRule(() => PreferConstConstructors());\n  \n  // Run the app\n  runApp(const RealFlutter());\n}\n\n// Application Flow:\n// 1. The custom lint rule 'PreferConstConstructors' is defined, which checks for non-const Widget constructors.\n// 2. The main RealFlutter class is defined, which sets up the basic app structure.\n// 3. In the build method, we intentionally use a non-const constructor for one ElevatedButton to demonstrate the lint warning.\n// 4. We also use a const constructor for another ElevatedButton to show the correct usage.\n// 5. In the main function, we register our custom lint rule using CustomLint.registerLintRule().\n// 6. Finally, we run the app with the RealFlutter widget.\n\n// When you run this code with custom_lint enabled:\n// - You'll see a lint warning for the non-const ElevatedButton.\n// - The const ElevatedButton will not trigger a warning.\n// - The app will display two buttons, demonstrating both cases.\n\n// Note: To see the lint warnings, you need to run the custom_lint analysis tool:\n// flutter pub run custom_lint\n```",
    "likesCount": 193,
    "_createdAt": "2024-08-28T22:19:10Z",
    "slug": {
      "current": "custom_lint",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "invertase.io",
    "_rev": "eaCZ7mIhmiYZX5KGqJmVGw",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXCi",
        "_type": "reference",
        "_key": "xa6ncfzi"
      }
    ],
    "shortDescription": "Lint rules are a powerful way to improve the maintainability of a project. Custom Lint allows package authors and developers to easily write custom lint rules.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ea7",
        "_type": "reference",
        "_key": "ndjjljpo"
      }
    ],
    "tags": [
      "linter",
      "static-analysis",
      "code-quality",
      "development-tool"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8Ce4p",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "packageImage": null,
    "lastUpdate": "2024-08-14T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:13:22Z"
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:intl/intl.dart';\n\n// Step 1: Define the main function\nvoid main() {\n  runApp(RealFlutter());\n}\n\n// Step 2: Create the main app class\nclass RealFlutter extends StatefulWidget {\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  Locale _currentLocale = Locale('en', '');\n\n  // Step 3: Define supported locales\n  final List<Locale> _supportedLocales = [\n    Locale('en', ''),\n    Locale('es', ''),\n    Locale('fr', ''),\n  ];\n\n  // Step 4: Create a method to change the locale\n  void _changeLocale(Locale newLocale) {\n    setState(() {\n      _currentLocale = newLocale;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 5: Set up the MaterialApp with localization support\n    return MaterialApp(\n      title: 'Flutter Localization Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      locale: _currentLocale,\n      localizationsDelegates: [\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n        AppLocalizations.delegate,\n      ],\n      supportedLocales: _supportedLocales,\n      home: HomePage(changeLocale: _changeLocale),\n    );\n  }\n}\n\n// Step 6: Create a HomePage widget\nclass HomePage extends StatelessWidget {\n  final Function(Locale) changeLocale;\n\n  HomePage({required this.changeLocale});\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 7: Use localized strings\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(AppLocalizations.of(context).appTitle),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              AppLocalizations.of(context).greeting,\n              style: TextStyle(fontSize: 24),\n            ),\n            SizedBox(height: 20),\n            Text(\n              AppLocalizations.of(context).dateExample(DateTime.now()),\n              style: TextStyle(fontSize: 18),\n            ),\n            SizedBox(height: 20),\n            Text(\n              AppLocalizations.of(context).pluralExample(5),\n              style: TextStyle(fontSize: 18),\n            ),\n            SizedBox(height: 40),\n            // Step 8: Add language selection buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: _supportedLocales.map((locale) {\n                return ElevatedButton(\n                  onPressed: () => changeLocale(locale),\n                  child: Text(locale.languageCode.toUpperCase()),\n                );\n              }).toList(),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 9: Create a class for managing localizations\nclass AppLocalizations {\n  final Locale locale;\n\n  AppLocalizations(this.locale);\n\n  static AppLocalizations of(BuildContext context) {\n    return Localizations.of<AppLocalizations>(context, AppLocalizations)!;\n  }\n\n  static const LocalizationsDelegate<AppLocalizations> delegate =\n      _AppLocalizationsDelegate();\n\n  static Map<String, Map<String, String>> _localizedValues = {\n    'en': {\n      'appTitle': 'Localization Demo',\n      'greeting': 'Hello, World!',\n      'dateExample': 'Today is {date}',\n      'pluralExample': '{count} item(s)',\n    },\n    'es': {\n      'appTitle': 'Demo de Localizacin',\n      'greeting': 'Hola, Mundo!',\n      'dateExample': 'Hoy es {date}',\n      'pluralExample': '{count} artculo(s)',\n    },\n    'fr': {\n      'appTitle': 'Dmo de Localisation',\n      'greeting': 'Bonjour, le Monde!',\n      'dateExample': \"Aujourd'hui c'est {date}\",\n      'pluralExample': '{count} objet(s)',\n    },\n  };\n\n  String get appTitle {\n    return _localizedValues[locale.languageCode]!['appTitle']!;\n  }\n\n  String get greeting {\n    return _localizedValues[locale.languageCode]!['greeting']!;\n  }\n\n  String dateExample(DateTime date) {\n    return _localizedValues[locale.languageCode]!['dateExample']!\n        .replaceAll('{date}', DateFormat.yMMMd(locale.toString()).format(date));\n  }\n\n  String pluralExample(int count) {\n    return _localizedValues[locale.languageCode]!['pluralExample']!\n        .replaceAll('{count}', count.toString());\n  }\n}\n\n// Step 10: Create a custom LocalizationsDelegate\nclass _AppLocalizationsDelegate\n    extends LocalizationsDelegate<AppLocalizations> {\n  const _AppLocalizationsDelegate();\n\n  @override\n  bool isSupported(Locale locale) {\n    return ['en', 'es', 'fr'].contains(locale.languageCode);\n  }\n\n  @override\n  Future<AppLocalizations> load(Locale locale) async {\n    return AppLocalizations(locale);\n  }\n\n  @override\n  bool shouldReload(_AppLocalizationsDelegate old) => false;\n}\n\n// Application Flow:\n// 1. The app starts by running the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp with localization support.\n// 3. The HomePage is displayed, showing localized strings.\n// 4. Users can change the language using the buttons at the bottom.\n// 5. When a language button is pressed, the _changeLocale method is called.\n// 6. The state is updated with the new locale, triggering a rebuild.\n// 7. The app re-renders with the new locale, updating all localized strings.\n// 8. AppLocalizations class manages the localized string values.\n// 9. The custom LocalizationsDelegate handles loading the correct localizations.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 280,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:23Z",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ljf",
        "_type": "reference",
        "_key": "ejy90z37"
      }
    ],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfHGg",
        "_type": "reference",
        "_key": "vfemidx5"
      }
    ],
    "tags": [
      "localization",
      "internationalization",
      "i18n",
      "translation"
    ],
    "packageImage": null,
    "name": "flutter_localization",
    "tutorial": "# Flutter Localization Tutorial\n\nThis tutorial will guide you through the process of implementing localization in your Flutter app using the `flutter_localization` package. We'll cover setup, configuration, and usage across different platforms.\n\n## Step 1: Add Dependencies\n\nFirst, add the required dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_localizations:\n    sdk: flutter\n  intl: ^0.17.0\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  intl_translation: ^0.17.10\n```\n\n## Step 2: Configure Localization\n\nIn your `main.dart` file, import the necessary packages and set up localization:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:intl/intl.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Localization Demo',\n      localizationsDelegates: [\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n      ],\n      supportedLocales: [\n        Locale('en', ''), // English\n        Locale('es', ''), // Spanish\n        // Add more locales as needed\n      ],\n      home: HomePage(),\n    );\n  }\n}\n```\n\n## Step 3: Create Localization Files\n\nCreate a `l10n` folder in your project root and add JSON files for each supported language:\n\n`l10n/intl_en.arb`:\n```json\n{\n  \"helloWorld\": \"Hello World!\",\n  \"@helloWorld\": {\n    \"description\": \"The conventional newborn programmer greeting\"\n  }\n}\n```\n\n`l10n/intl_es.arb`:\n```json\n{\n  \"helloWorld\": \"Hola Mundo!\"\n}\n```\n\n## Step 4: Generate Dart Files\n\nRun the following command to generate Dart files from your ARB files:\n\n```\nflutter pub run intl_translation:generate_from_arb --output-dir=lib/l10n --no-use-deferred-loading lib/main.dart lib/l10n/intl_*.arb\n```\n\n## Step 5: Use Localized Strings\n\nNow you can use localized strings in your widgets:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(Intl.message('helloWorld', name: 'helloWorld')),\n      ),\n      body: Center(\n        child: Text(Intl.message('helloWorld', name: 'helloWorld')),\n      ),\n    );\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, add the supported languages to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>CFBundleLocalizations</key>\n<array>\n  <string>en</string>\n  <string>es</string>\n</array>\n```\n\n### Android\n\nFor Android, create a `res/values/strings.xml` file for each language:\n\n`android/app/src/main/res/values/strings.xml`:\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"app_name\">Your App Name</string>\n</resources>\n```\n\n`android/app/src/main/res/values-es/strings.xml`:\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"app_name\">Nombre de tu aplicacin</string>\n</resources>\n```\n\n### Web\n\nFor web applications, no additional configuration is needed. The `flutter_localizations` package handles localization for web projects automatically.\n\nBy following these steps, you'll have a fully localized Flutter app that supports multiple languages across different platforms.",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RfEk",
    "_type": "package",
    "lastUpdate": "2024-08-19T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CeAL",
    "slug": {
      "current": "flutter_localization",
      "_type": "slug"
    },
    "author": "",
    "description": "# Flutter Localization: Empowering Your App with Multi-Language Support\n\nFlutter, Google's UI toolkit for building natively compiled applications for mobile, web, and desktop from a single codebase, offers robust support for internationalization through its `flutter_localization` package. This powerful tool enables developers to create apps that can adapt to various languages and regions, providing a seamless user experience across different locales.\n\n## What is flutter_localization?\n\nThe `flutter_localization` package is an essential part of Flutter's internationalization (i18n) and localization (l10n) framework. It provides a set of classes and utilities that make it easy to manage and implement multi-language support in your Flutter applications.\n\n## Key Features\n\n1. **Locale-aware widgets**: Flutter provides widgets like `LocalizationsDelegate` and `Localizations` that help in managing localized resources.\n\n2. **Automatic resource loading**: The package can automatically load the appropriate language resources based on the device's locale settings.\n\n3. **Custom translations**: Developers can define their own translations for various strings used in the app.\n\n4. **RTL support**: Built-in support for right-to-left (RTL) languages, ensuring proper layout and text direction.\n\n5. **Plurals and date/number formatting**: Handling of plural forms and locale-specific date and number formatting.\n\n## Why Use flutter_localization?\n\n1. **Global reach**: Expand your app's audience by supporting multiple languages.\n2. **Improved user experience**: Provide a native feel to users from different regions.\n3. **Centralized management**: Manage all your app's strings in one place, making updates and maintenance easier.\n4. **Flexibility**: Easily switch between languages at runtime.\n\nIn the following sections, we'll dive into a tutorial on how to implement flutter_localization in your project and showcase a complete example demonstrating its features.",
    "shortDescription": "Flutter Localization is a package use for in-app localization with map data. More easier and faster to implement and inspired by the flutter_localizations itself.",
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:19:13Z"
  },
  {
    "likesCount": 302,
    "_type": "package",
    "description": "# PetitParser: A Powerful Parsing Library for Flutter\n\n## Introduction\n\nPetitParser is a robust parsing library for Dart and Flutter that enables developers to create complex parsers with ease. It provides a flexible and expressive way to define grammars and parse various types of structured text, making it an invaluable tool for tasks such as parsing domain-specific languages, configuration files, or custom data formats.\n\n## Key Features\n\n1. **Composability**: PetitParser allows you to build complex parsers by combining smaller, simpler parsers.\n\n2. **Expressiveness**: The library offers a wide range of built-in parsers and combinators, making it easy to express complex parsing rules.\n\n3. **Performance**: PetitParser is designed to be efficient, with optimizations for common parsing scenarios.\n\n4. **Error Handling**: The library provides detailed error messages and the ability to recover from parsing errors.\n\n5. **Flexibility**: PetitParser can be used for both simple string parsing and more complex structured data parsing.\n\n## Use Cases\n\n- Parsing domain-specific languages (DSLs)\n- Interpreting custom configuration files\n- Processing structured text data\n- Building compilers or interpreters\n- Validating and transforming complex input formats\n\nPetitParser's versatility makes it an excellent choice for a wide range of parsing tasks in Flutter applications, from simple string manipulation to complex language processing.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1kQ3",
        "_type": "reference",
        "_key": "nzx42bl1"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "lg6gs7i2",
        "_ref": "Rx1Nho763d29lawKra1fNn"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-45c1e7173679fef120cdfc8fde6d376d8053de5a-512x512-webp",
        "_type": "reference"
      }
    },
    "_id": "uQRNMiDfrp20RZ8Id8CeJX",
    "tutorialIncluded": true,
    "_rev": "AE3hjGWNkNE6aGQMMbaTlj",
    "slug": {
      "current": "petitparser",
      "_type": "slug"
    },
    "subCategories": [
      {
        "_key": "ni352doe",
        "_ref": "t8DYBEKn49O4mjbyRAfIgM",
        "_type": "reference"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:petitparser/petitparser.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'PetitParser Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const CalculatorPage(),\n    );\n  }\n}\n\n// Step 1: Define the grammar for our calculator\nclass CalculatorGrammar extends GrammarDefinition {\n  @override\n  Parser start() => ref0(expression).end();\n\n  Parser expression() => ref0(term).sep(char('+') | char('-'));\n\n  Parser term() => ref0(factor).sep(char('*') | char('/'));\n\n  Parser factor() =>\n      ref0(number) |\n      char('(') & ref0(expression) & char(')') |\n      char('-') & ref0(factor);\n\n  Parser number() =>\n      digit().plus().seq(char('.').seq(digit().plus()).optional())\n      .flatten().trim().map(num.parse);\n}\n\n// Step 2: Create a parser instance\nfinal parser = CalculatorGrammar().build();\n\nclass CalculatorPage extends StatefulWidget {\n  const CalculatorPage({Key? key}) : super(key: key);\n\n  @override\n  _CalculatorPageState createState() => _CalculatorPageState();\n}\n\nclass _CalculatorPageState extends State<CalculatorPage> {\n  final TextEditingController _controller = TextEditingController();\n  String _result = '';\n\n  // Step 3: Evaluate the expression\n  void _evaluateExpression() {\n    final input = _controller.text;\n    final result = parser.parse(input);\n\n    setState(() {\n      if (result.isSuccess) {\n        _result = 'Result: ${result.value}';\n      } else {\n        _result = 'Error: ${result.message}';\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('PetitParser Calculator')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            TextField(\n              controller: _controller,\n              decoration: const InputDecoration(\n                labelText: 'Enter arithmetic expression',\n              ),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: _evaluateExpression,\n              child: const Text('Evaluate'),\n            ),\n            const SizedBox(height: 16),\n            Text(_result, style: const TextStyle(fontSize: 18)),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a text field and an \"Evaluate\" button.\n// 2. The user enters an arithmetic expression in the text field.\n// 3. When the user taps the \"Evaluate\" button, the _evaluateExpression method is called.\n// 4. The input is passed to the parser.parse method, which attempts to parse the expression.\n// 5. If parsing is successful, the result is displayed.\n// 6. If parsing fails, an error message is shown.\n//\n// The PetitParser is used to define a grammar for arithmetic expressions.\n// This grammar can handle addition, subtraction, multiplication, division,\n// parentheses, and negative numbers. The parser combines these rules to\n// evaluate complex expressions entered by the user.\n```convex_bottom_bar",
    "lastUpdate": "2023-11-29T18:30:00.000Z",
    "name": "petitparser",
    "tutorial": "# PetitParser Tutorial: Building a Simple Calculator\n\nIn this tutorial, we'll build a simple calculator using the PetitParser package in Flutter. We'll create a parser that can handle basic arithmetic operations.\n\n## Step 1: Add Dependencies\n\nFirst, add the PetitParser package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  petitparser: ^5.1.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the PetitParser package:\n\n```dart\nimport 'package:petitparser/petitparser.dart';\n```\n\n## Step 3: Define the Grammar\n\nLet's define a simple grammar for our calculator:\n\n```dart\nclass CalculatorGrammar extends GrammarDefinition {\n  @override\n  Parser start() => ref0(expression).end();\n\n  Parser expression() => ref0(term).sep(char('+') | char('-'));\n\n  Parser term() => ref0(factor).sep(char('*') | char('/'));\n\n  Parser factor() =>\n      ref0(number) |\n      char('(') & ref0(expression) & char(')') |\n      char('-') & ref0(factor);\n\n  Parser number() =>\n      digit().plus().seq(char('.').seq(digit().plus()).optional())\n      .flatten().trim().map(num.parse);\n}\n```\n\n## Step 4: Create the Parser\n\nNow, let's create the parser using our grammar:\n\n```dart\nfinal parser = CalculatorGrammar().build();\n```\n\n## Step 5: Use the Parser\n\nYou can now use the parser to evaluate arithmetic expressions:\n\n```dart\nString input = '2 + 3 * (4 - 1)';\nfinal result = parser.parse(input);\n\nif (result.isSuccess) {\n  print('Result: ${result.value}');\n} else {\n  print('Error: ${result.message}');\n}\n```\n\n## Platform-Specific Considerations\n\n### iOS\n- Ensure that you have the latest version of Xcode installed.\n- In your `ios/Podfile`, make sure you're using a compatible iOS version:\n\n```ruby\nplatform :ios, '11.0'\n```\n\n### Android\n- Make sure you have the latest Android SDK tools and build tools installed.\n- In your `android/app/build.gradle`, set the minimum SDK version:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n    }\n}\n```\n\n### Web\n- No specific configuration is needed for web support with PetitParser.\n- Ensure you have enabled web support in your Flutter project:\n\n```\nflutter config --enable-web\n```\n\nBy following these steps and considering the platform-specific details, you can integrate PetitParser into your Flutter project and start building powerful parsing functionality across all supported platforms.",
    "_updatedAt": "2024-09-06T04:13:25Z",
    "author": "lukas-renggli.ch",
    "shortDescription": "A dynamic parser framework to build efficient grammars and parsers quickly.",
    "tags": [
      "grammar",
      "parser",
      "parser-combinator",
      "parsing",
      "peg",
      "language-processing"
    ],
    "_createdAt": "2024-08-28T22:19:16Z",
    "pubPoint": 160
  },
  {
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CbUr",
        "_type": "reference",
        "_key": "ungsyb2b"
      }
    ],
    "likesCount": 2655,
    "packageImage": null,
    "lastUpdate": "2023-01-27T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8CeP3",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:26Z",
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "name": "convex_bottom_bar",
    "slug": {
      "current": "convex_bottom_bar",
      "_type": "slug"
    },
    "author": "hacktons.cn",
    "description": "# Convex Bottom Bar in Flutter: Elevate Your App's Navigation\n\n## Introduction\n\nIn the world of mobile app development, creating an intuitive and visually appealing navigation system is crucial. Flutter, with its rich ecosystem of packages, offers developers various options to enhance user experience. One such package that stands out is the `convex_bottom_bar`. This powerful tool allows you to create a stylish and functional bottom navigation bar with a convex shape, adding a unique touch to your app's interface.\n\n## What is Convex Bottom Bar?\n\nThe `convex_bottom_bar` package is a customizable bottom bar widget for Flutter applications. It provides a convex-shaped bottom navigation bar that can host multiple items, each with its own icon and label. The package offers various styles and animations, making it easy to create a navigation bar that fits your app's design language.\n\n## Key Features\n\n1. **Customizable Appearance**: Adjust colors, sizes, and shapes to match your app's theme.\n2. **Multiple Styles**: Choose from different pre-defined styles or create your own.\n3. **Animated Transitions**: Smooth animations when switching between tabs.\n4. **Convex Button**: A prominent, centrally located button for primary actions.\n5. **Flexible Item Count**: Support for 2 to 5 items in the bottom bar.\n6. **RTL Support**: Built-in support for right-to-left languages.\n\n## Why Use Convex Bottom Bar?\n\n1. **Unique Design**: Stand out from standard bottom navigation bars.\n2. **Improved User Experience**: The convex shape provides better touch targets and visual feedback.\n3. **Easy Integration**: Simple to implement and customize in Flutter projects.\n4. **Performance**: Optimized for smooth performance, even with animations.\n\nIn the following sections, we'll dive into a tutorial on how to implement the `convex_bottom_bar` in your Flutter project and explore a comprehensive example showcasing its features.",
    "shortDescription": "A Flutter package which implements a ConvexAppBar to show a convex tab in the bottom bar. Theming supported.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPG0V",
        "_type": "reference",
        "_key": "1oujfn9x"
      }
    ],
    "tags": [
      "bottom-bar",
      "navigation",
      "ui",
      "custom-widget"
    ],
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RfaK",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:convex_bottom_bar/convex_bottom_bar.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Convex Bottom Bar Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  // Step 1: Initialize variables\n  int _selectedIndex = 0;\n  List<Widget> _pages = [];\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Populate the pages list\n    _pages = [\n      Center(child: Text('Home Page')),\n      Center(child: Text('Discovery Page')),\n      Center(child: Text('Add Page')),\n      Center(child: Text('Message Page')),\n      Center(child: Text('Profile Page')),\n    ];\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Convex Bottom Bar Demo')),\n      // Step 3: Display the selected page\n      body: _pages[_selectedIndex],\n      // Step 4: Implement the ConvexAppBar\n      bottomNavigationBar: ConvexAppBar(\n        // Step 5: Define the items in the bottom bar\n        items: [\n          TabItem(icon: Icons.home, title: 'Home'),\n          TabItem(icon: Icons.map, title: 'Discovery'),\n          TabItem(icon: Icons.add, title: 'Add'),\n          TabItem(icon: Icons.message, title: 'Message'),\n          TabItem(icon: Icons.people, title: 'Profile'),\n        ],\n        // Step 6: Set the initial active index\n        initialActiveIndex: _selectedIndex,\n        // Step 7: Implement the onTap callback\n        onTap: (int index) {\n          setState(() {\n            _selectedIndex = index;\n          });\n        },\n        // Step 8: Customize the appearance\n        backgroundColor: Colors.blue,\n        activeColor: Colors.white,\n        style: TabStyle.reactCircle,\n        // Step 9: Add a custom curve for animations\n        curve: Curves.easeInOut,\n        // Step 10: Adjust height for platform consistency\n        height: 60,\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays the HomePage.\n// 2. The ConvexAppBar is initialized with 5 items.\n// 3. The initial active index is set to 0 (Home).\n// 4. When a user taps on a tab:\n//    a. The onTap callback is triggered.\n//    b. The _selectedIndex is updated.\n//    c. setState is called, which rebuilds the widget.\n//    d. The corresponding page from _pages is displayed.\n// 5. The ConvexAppBar animates the selection change using the specified curve.\n// 6. The process repeats for each tab selection.\n\n// Note: This example demonstrates basic usage. For more advanced features,\n// consider implementing custom styles, adding badges, or using named routes\n// for navigation.\n```",
    "dependentPackages": [
      {
        "_key": "qy72onsl",
        "_ref": "Rx1Nho763d29lawKra1qwZ",
        "_type": "reference"
      },
      {
        "_key": "znc116l7",
        "_ref": "Rx1Nho763d29lawKra1vvH",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:19:17Z",
    "tutorial": "# Implementing Convex Bottom Bar in Flutter: A Step-by-Step Tutorial\n\nIn this tutorial, we'll walk through the process of adding a convex bottom bar to your Flutter application using the `convex_bottom_bar` package. We'll cover installation, basic usage, and customization options.\n\n## Step 1: Add the Package to Your Project\n\nFirst, add the `convex_bottom_bar` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  convex_bottom_bar: ^3.2.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:convex_bottom_bar/convex_bottom_bar.dart';\n```\n\n## Step 3: Implement the ConvexAppBar\n\nReplace your existing `BottomNavigationBar` or add a new `ConvexAppBar` to your `Scaffold`:\n\n```dart\nScaffold(\n  bottomNavigationBar: ConvexAppBar(\n    items: [\n      TabItem(icon: Icons.home, title: 'Home'),\n      TabItem(icon: Icons.map, title: 'Discovery'),\n      TabItem(icon: Icons.add, title: 'Add'),\n      TabItem(icon: Icons.message, title: 'Message'),\n      TabItem(icon: Icons.people, title: 'Profile'),\n    ],\n    onTap: (int i) => print('click index=$i'),\n  ),\n)\n```\n\n## Step 4: Customize the Appearance\n\nYou can customize various aspects of the `ConvexAppBar`:\n\n```dart\nConvexAppBar(\n  backgroundColor: Colors.blue,\n  activeColor: Colors.white,\n  style: TabStyle.react,\n  curve: Curves.easeInOut,\n  items: [\n    // ... your tab items\n  ],\n)\n```\n\n## Step 5: Handle Tab Selection\n\nImplement the `onTap` callback to handle tab selection:\n\n```dart\nConvexAppBar(\n  // ... other properties\n  onTap: (int index) {\n    setState(() {\n      _selectedIndex = index;\n    });\n    // Navigate to the corresponding page\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you might want to adjust the `height` property to match the default tab bar height:\n\n```dart\nConvexAppBar(\n  // ... other properties\n  height: 50, // Matches iOS tab bar height\n)\n```\n\n### Android\n\nFor Android, consider using Material Design colors and possibly a larger height:\n\n```dart\nConvexAppBar(\n  // ... other properties\n  backgroundColor: Theme.of(context).primaryColor,\n  activeColor: Colors.white,\n  height: 60, // Slightly taller for Android\n)\n```\n\n## Advanced Customization\n\nFor more advanced customization, you can create a custom `StyleProvider`:\n\n```dart\nConvexAppBar(\n  // ... other properties\n  style: TabStyle.custom,\n  styleProvider: ConvexBarStyleCustom(),\n)\n\nclass ConvexBarStyleCustom extends StyleHook {\n  @override\n  double get activeIconSize => 40;\n\n  @override\n  double get activeIconMargin => 10;\n\n  @override\n  double get iconSize => 20;\n\n  @override\n  TextStyle textStyle(Color color, String? fontFamily) {\n    return TextStyle(fontSize: 14, color: color, fontFamily: fontFamily);\n  }\n}\n```\n\nBy following these steps and customization options, you can easily integrate and tailor the `convex_bottom_bar` to fit your Flutter application's needs."
  },
  {
    "author": "flutter.dev",
    "_type": "package",
    "description": "# Palette Generator in Flutter: Extracting Colors from Images\n\n## Introduction\n\nThe `palette_generator` package in Flutter is a powerful tool that allows developers to extract dominant colors from images. This capability is particularly useful when you want to create dynamic, visually appealing user interfaces that adapt to the content being displayed.\n\n## Key Features\n\n1. **Color Extraction**: The package analyzes an image and extracts a palette of dominant colors.\n2. **Customizable**: Developers can specify the number of colors to extract and set various parameters to fine-tune the results.\n3. **Performance**: It's designed to be efficient, making it suitable for real-time applications.\n4. **Cross-platform**: Works on both iOS and Android platforms.\n\n## Use Cases\n\n- Dynamically theming app UI based on displayed images\n- Creating color-coordinated layouts for image galleries\n- Generating color schemes for data visualization\n\n## How It Works\n\nThe `palette_generator` uses advanced image processing algorithms to analyze the colors in an image. It then clusters these colors and selects representative colors from each cluster, ensuring a diverse and visually appealing palette.\n\nIn the following sections, we'll dive deeper into how to use this package in your Flutter applications, providing both a tutorial and a comprehensive example.",
    "tags": [
      "color",
      "ui",
      "image-processing",
      "design"
    ],
    "packageImage": null,
    "slug": {
      "current": "palette_generator",
      "_type": "slug"
    },
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm",
        "_type": "reference",
        "_key": "7ypdee40"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "9qg1tsjs"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CeUZ",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmVNU",
    "shortDescription": "Flutter package for generating palette colors from a source image.",
    "likesCount": 618,
    "_createdAt": "2024-08-28T22:19:22Z",
    "name": "palette_generator",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CgBN",
        "_type": "reference",
        "_key": "4jntwmm9"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:palette_generator/palette_generator.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Palette Generator Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: PaletteDemo(),\n    );\n  }\n}\n\nclass PaletteDemo extends StatefulWidget {\n  @override\n  _PaletteDemoState createState() => _PaletteDemoState();\n}\n\nclass _PaletteDemoState extends State<PaletteDemo> {\n  // Step 1: Define variables to store palette and image\n  PaletteGenerator? _paletteGenerator;\n  Image? _image;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Load image and generate palette when the widget initializes\n    _loadImageAndGeneratePalette();\n  }\n\n  // Step 3: Function to load image and generate palette\n  Future<void> _loadImageAndGeneratePalette() async {\n    // Load image from assets\n    final imageProvider = AssetImage('assets/sample_image.jpg');\n    _image = Image(image: imageProvider);\n\n    // Generate palette from image\n    final paletteGenerator = await PaletteGenerator.fromImageProvider(\n      imageProvider,\n      size: Size(200, 100), // Resize image for faster processing\n      maximumColorCount: 8, // Set maximum number of colors to generate\n    );\n\n    // Update state with new palette\n    setState(() {\n      _paletteGenerator = paletteGenerator;\n    });\n  }\n\n  // Step 4: Function to build color boxes\n  Widget _buildColorBox(Color color, String label) {\n    return Column(\n      children: [\n        Container(\n          width: 50,\n          height: 50,\n          color: color,\n        ),\n        SizedBox(height: 5),\n        Text(label),\n      ],\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 5: Build the UI\n    return Scaffold(\n      appBar: AppBar(title: Text('Palette Generator Demo')),\n      body: SingleChildScrollView(\n        child: Column(\n          children: [\n            // Step 6: Display the image\n            if (_image != null) _image!,\n            SizedBox(height: 20),\n            \n            // Step 7: Display generated palette\n            if (_paletteGenerator != null) ...[\n              Text('Generated Palette:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n              SizedBox(height: 10),\n              Wrap(\n                spacing: 10,\n                runSpacing: 10,\n                children: [\n                  _buildColorBox(_paletteGenerator!.dominantColor?.color ?? Colors.grey, 'Dominant'),\n                  _buildColorBox(_paletteGenerator!.vibrantColor?.color ?? Colors.grey, 'Vibrant'),\n                  _buildColorBox(_paletteGenerator!.mutedColor?.color ?? Colors.grey, 'Muted'),\n                  _buildColorBox(_paletteGenerator!.lightVibrantColor?.color ?? Colors.grey, 'Light Vibrant'),\n                  _buildColorBox(_paletteGenerator!.lightMutedColor?.color ?? Colors.grey, 'Light Muted'),\n                  _buildColorBox(_paletteGenerator!.darkVibrantColor?.color ?? Colors.grey, 'Dark Vibrant'),\n                  _buildColorBox(_paletteGenerator!.darkMutedColor?.color ?? Colors.grey, 'Dark Muted'),\n                ],\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the RealFlutter widget is created.\n// 2. RealFlutter sets up the MaterialApp and navigates to the PaletteDemo widget.\n// 3. PaletteDemo's state is initialized, triggering _loadImageAndGeneratePalette().\n// 4. The image is loaded from assets and a palette is generated from it.\n// 5. Once the palette is generated, the state is updated, triggering a rebuild.\n// 6. The build method creates the UI, displaying the image and color boxes for each color in the palette.\n// 7. Each color box shows a sample of the color and its label (e.g., \"Dominant\", \"Vibrant\", etc.).\n// 8. The user can scroll through the page to view all generated colors.\n\n// Note: Make sure to add a sample image named 'sample_image.jpg' in your assets folder\n// and update the pubspec.yaml file to include it:\n// assets:\n//   - assets/sample_image.jpg\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-07-10T18:30:00.000Z",
    "tutorial": "# Palette Generator Tutorial\n\nThis tutorial will guide you through the process of integrating the `palette_generator` package into your Flutter application.\n\n## Step 1: Add Dependencies\n\nFirst, add the `palette_generator` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  palette_generator: ^0.3.3\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:palette_generator/palette_generator.dart';\n```\n\n## Step 3: Generate a Palette\n\nTo generate a palette from an image, use the `PaletteGenerator.fromImageProvider` method:\n\n```dart\nFuture<PaletteGenerator> _generatePalette(ImageProvider imageProvider) async {\n  final PaletteGenerator paletteGenerator = await PaletteGenerator.fromImageProvider(\n    imageProvider,\n    size: Size(200, 100), // Optional: Resize image for faster processing\n    maximumColorCount: 8, // Optional: Set the maximum number of colors to generate\n  );\n  return paletteGenerator;\n}\n```\n\n## Step 4: Use the Generated Palette\n\nOnce you have a `PaletteGenerator` object, you can access various color properties:\n\n```dart\nPaletteGenerator paletteGenerator = await _generatePalette(AssetImage('assets/image.jpg'));\n\n// Access dominant color\nColor? dominantColor = paletteGenerator.dominantColor?.color;\n\n// Access vibrant color\nColor? vibrantColor = paletteGenerator.vibrantColor?.color;\n\n// Access muted color\nColor? mutedColor = paletteGenerator.mutedColor?.color;\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, ensure that you have the latest version of the Android Gradle plugin in your `android/build.gradle` file:\n\n```groovy\ndependencies {\n    classpath 'com.android.tools.build:gradle:4.1.0'\n}\n```\n\n### iOS\n\nFor iOS, no additional configuration is required. However, ensure that your deployment target is set to iOS 9.0 or later in your Xcode project settings.\n\nIn the next section, we'll look at a complete example that demonstrates all the features of the `palette_generator` package.",
    "_updatedAt": "2024-09-06T04:13:28Z"
  },
  {
    "lastUpdate": "2024-08-08T18:30:00.000Z",
    "tutorial": "# sensors_plus Package Tutorial\n\nThis tutorial will guide you through the process of implementing the sensors_plus package in your Flutter application, including platform-specific details.\n\n## Step 1: Add Dependencies\n\nFirst, add the sensors_plus package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  sensors_plus: ^latest_version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the sensors_plus package:\n\n```dart\nimport 'package:sensors_plus/sensors_plus.dart';\n```\n\n## Step 3: Implement Sensor Listeners\n\n### Accelerometer\n\n```dart\naccelerometerEvents.listen((AccelerometerEvent event) {\n  print(event);\n});\n```\n\n### User Accelerometer\n\n```dart\nuserAccelerometerEvents.listen((UserAccelerometerEvent event) {\n  print(event);\n});\n```\n\n### Gyroscope\n\n```dart\ngyroscopeEvents.listen((GyroscopeEvent event) {\n  print(event);\n});\n```\n\n### Magnetometer\n\n```dart\nmagnetometerEvents.listen((MagnetometerEvent event) {\n  print(event);\n});\n```\n\n## Platform-Specific Details\n\n### Android\n\nAdd the following permissions to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n```\n\n### iOS\n\nNo additional configuration is required for iOS.\n\n### Web\n\nFor web support, add the following script tag to your `web/index.html` file:\n\n```html\n<script src=\"https://unpkg.com/sensors_plus_web/sensors_plus_web.js\"></script>\n```\n\n### macOS\n\nAdd the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`:\n\n```xml\n<key>com.apple.security.device.sensors</key>\n<true/>\n```\n\n### Windows\n\nNo additional configuration is required for Windows.\n\n## Step 4: Handling Sensor Data\n\nTo use the sensor data effectively, you'll typically want to update your UI based on the incoming events. Here's a basic example:\n\n```dart\nclass SensorDisplay extends StatefulWidget {\n  @override\n  _SensorDisplayState createState() => _SensorDisplayState();\n}\n\nclass _SensorDisplayState extends State<SensorDisplay> {\n  double _accelerometerX = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    accelerometerEvents.listen((AccelerometerEvent event) {\n      setState(() {\n        _accelerometerX = event.x;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Accelerometer X: $_accelerometerX');\n  }\n}\n```\n\nThis example updates a Text widget with the current X-axis value from the accelerometer.\n\nIn the next section, we'll look at a complete example that demonstrates all features of the sensors_plus package.",
    "tags": [
      "sensor",
      "sensors",
      "utils",
      "hardware",
      "device"
    ],
    "name": "sensors_plus",
    "tutorialIncluded": true,
    "author": "fluttercommunity.dev",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "n90ofzyr",
        "_ref": "uQRNMiDfrp20RZ8Id8Ch2h"
      }
    ],
    "example": "```\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\n\nvoid main() => runApp(RealFlutter());\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sensors Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: SensorDashboard(),\n    );\n  }\n}\n\nclass SensorDashboard extends StatefulWidget {\n  @override\n  _SensorDashboardState createState() => _SensorDashboardState();\n}\n\nclass _SensorDashboardState extends State<SensorDashboard> {\n  // Step 1: Initialize variables to store sensor data\n  List<double> _accelerometerValues = List.filled(3, 0);\n  List<double> _userAccelerometerValues = List.filled(3, 0);\n  List<double> _gyroscopeValues = List.filled(3, 0);\n  List<double> _magnetometerValues = List.filled(3, 0);\n\n  // Step 2: Create StreamSubscription objects for each sensor\n  List<StreamSubscription<dynamic>> _streamSubscriptions = [];\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Step 3: Set up stream listeners for each sensor\n    _streamSubscriptions.add(\n      accelerometerEvents.listen((AccelerometerEvent event) {\n        setState(() {\n          _accelerometerValues = [event.x, event.y, event.z];\n        });\n      })\n    );\n\n    _streamSubscriptions.add(\n      userAccelerometerEvents.listen((UserAccelerometerEvent event) {\n        setState(() {\n          _userAccelerometerValues = [event.x, event.y, event.z];\n        });\n      })\n    );\n\n    _streamSubscriptions.add(\n      gyroscopeEvents.listen((GyroscopeEvent event) {\n        setState(() {\n          _gyroscopeValues = [event.x, event.y, event.z];\n        });\n      })\n    );\n\n    _streamSubscriptions.add(\n      magnetometerEvents.listen((MagnetometerEvent event) {\n        setState(() {\n          _magnetometerValues = [event.x, event.y, event.z];\n        });\n      })\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 4: Cancel all stream subscriptions when the widget is disposed\n    for (final subscription in _streamSubscriptions) {\n      subscription.cancel();\n    }\n    super.dispose();\n  }\n\n  // Step 5: Helper method to create a sensor display widget\n  Widget _buildSensorRow(String title, List<double> values) {\n    return Padding(\n      padding: const EdgeInsets.all(16.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(title),\n          Text('X: ${values[0].toStringAsFixed(3)}'),\n          Text('Y: ${values[1].toStringAsFixed(3)}'),\n          Text('Z: ${values[2].toStringAsFixed(3)}'),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Step 6: Build the UI\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sensors Plus Demo'),\n      ),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: <Widget>[\n          _buildSensorRow('Accelerometer', _accelerometerValues),\n          _buildSensorRow('User Accelerometer', _userAccelerometerValues),\n          _buildSensorRow('Gyroscope', _gyroscopeValues),\n          _buildSensorRow('Magnetometer', _magnetometerValues),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the RealFlutter widget is created.\n// 2. The SensorDashboard widget is rendered as the home screen.\n// 3. In the initState method, stream listeners are set up for each sensor type.\n// 4. As sensor data is received, the setState method is called to update the UI.\n// 5. The build method creates a column with rows for each sensor type, displaying X, Y, and Z values.\n// 6. The _buildSensorRow helper method is used to create consistent UI for each sensor type.\n// 7. When the app is closed or the widget is removed from the tree, the dispose method cancels all stream subscriptions.\n\n// This example demonstrates real-time updates from all supported sensors in the sensors_plus package.\n// It provides a clean, organized way to display the data and properly manages resources by disposing of streams when no longer needed.\n```",
    "platforms": [
      "android",
      "ios",
      "web"
    ],
    "likesCount": 797,
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:13:29Z",
    "pubPoint": 160,
    "shortDescription": "Flutter plugin for accessing accelerometer, gyroscope, and magnetometer sensors.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfECi",
        "_type": "reference",
        "_key": "jcm1lt8m"
      }
    ],
    "dependentPackages": [
      {
        "_key": "todhkxm5",
        "_ref": "Rx1Nho763d29lawKra1K9L",
        "_type": "reference"
      },
      {
        "_key": "zh5egv6b",
        "_ref": "uQRNMiDfrp20RZ8Id8CWvh",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:19:23Z",
    "_id": "uQRNMiDfrp20RZ8Id8Cefb",
    "slug": {
      "current": "sensors_plus",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaU1h",
    "_type": "package",
    "description": "# Exploring the sensors_plus Package in Flutter\n\n## Introduction\n\nThe `sensors_plus` package is a powerful Flutter plugin that provides a unified interface to access various device sensors across different platforms. It's an essential tool for developers looking to create interactive and responsive applications that can react to device movements and environmental changes.\n\n## Key Features\n\n1. **Cross-platform Compatibility**: Works seamlessly on iOS, Android, Web, macOS, and Windows.\n2. **Multiple Sensor Support**: Provides access to accelerometer, gyroscope, magnetometer, and user accelerometer.\n3. **Real-time Data**: Offers real-time sensor data streams for responsive applications.\n4. **Easy Integration**: Simple to incorporate into existing Flutter projects.\n\n## Supported Sensors\n\n- **Accelerometer**: Measures the device's acceleration forces in three dimensions (x, y, z).\n- **User Accelerometer**: Similar to the accelerometer, but excludes the force of gravity.\n- **Gyroscope**: Measures the device's rate of rotation around three axes.\n- **Magnetometer**: Measures the ambient magnetic field in three dimensions.\n\n## Use Cases\n\n1. **Motion-based Games**: Create interactive games that respond to device tilting or shaking.\n2. **Fitness Apps**: Track user movement and activity levels.\n3. **Augmented Reality**: Enhance AR experiences with precise device orientation data.\n4. **Compass Applications**: Develop digital compass apps using magnetometer data.\n\n## Getting Started\n\nTo start using the `sensors_plus` package in your Flutter project, add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  sensors_plus: ^latest_version\n```\n\nReplace `latest_version` with the most recent version of the package.\n\nIn the next sections, we'll dive deeper into how to implement and use the sensors_plus package in your Flutter applications."
  },
  {
    "tags": [
      "flame",
      "game-engine",
      "games",
      "animations",
      "2d"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1VMp",
        "_type": "reference",
        "_key": "z1lff2bt"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ZND",
        "_type": "reference",
        "_key": "ll3d84ku"
      }
    ],
    "packageImage": {
      "asset": {
        "_ref": "image-bfd881747df4fe371c944f46ea0f0c773159d10c-512x512-webp",
        "_type": "reference"
      },
      "_type": "image"
    },
    "_createdAt": "2024-08-28T22:19:27Z",
    "tutorialIncluded": true,
    "example": "```\nimport 'package:flame/game.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/particles.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/collisions.dart';\nimport 'package:flutter/material.dart';\nimport 'dart:math' as math;\n\nvoid main() {\n  runApp(GameWidget(game: RealFlutter()));\n}\n\n// Step 1: Main Game Class\nclass RealFlutter extends FlameGame with HasTappables, HasCollisionDetection {\n  late Player player;\n  late TextComponent scoreText;\n  int score = 0;\n\n  @override\n  Future<void> onLoad() async {\n    // Step 2: Load Assets\n    await images.loadAll(['player.png', 'enemy.png', 'background.png']);\n\n    // Step 3: Add Background\n    add(SpriteComponent(\n      sprite: await loadSprite('background.png'),\n      size: size,\n    ));\n\n    // Step 4: Add Player\n    player = Player();\n    add(player);\n\n    // Step 5: Add Enemies\n    for (int i = 0; i < 5; i++) {\n      add(Enemy());\n    }\n\n    // Step 6: Add Score Display\n    scoreText = TextComponent(\n      text: 'Score: 0',\n      position: Vector2(10, 10),\n    );\n    add(scoreText);\n\n    // Step 7: Add Joystick for Movement\n    final joystick = JoystickComponent(\n      knob: CircleComponent(radius: 15, paint: Paint()..color = Colors.blue),\n      background: CircleComponent(radius: 50, paint: Paint()..color = Colors.blue.withOpacity(0.5)),\n      position: Vector2(size.x - 80, size.y - 80),\n    );\n    add(joystick);\n\n    // Connect joystick to player movement\n    player.joystick = joystick;\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n    scoreText.text = 'Score: $score';\n  }\n\n  // Step 8: Add Particle Effect\n  void addExplosion(Vector2 position) {\n    final random = math.Random();\n    add(\n      ParticleSystemComponent(\n        particle: Particle.generate(\n          count: 20,\n          lifespan: 1,\n          generator: (i) => AcceleratedParticle(\n            acceleration: getRandomVector(random, 20),\n            speed: getRandomVector(random, 50),\n            position: position.clone(),\n            child: CircleParticle(\n              radius: 2,\n              paint: Paint()..color = Colors.red,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  Vector2 getRandomVector(math.Random random, double multiplier) {\n    return (Vector2.random(random) - Vector2.random(random)) * multiplier;\n  }\n}\n\n// Step 9: Player Component\nclass Player extends SpriteComponent with HasGameRef<RealFlutter>, CollisionCallbacks {\n  Player() : super(size: Vector2(50, 50));\n  JoystickComponent? joystick;\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await gameRef.loadSprite('player.png');\n    position = gameRef.size / 2;\n    add(CircleHitbox());\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n    if (joystick != null) {\n      position += joystick!.delta * 100 * dt;\n      position.clamp(Vector2.zero(), gameRef.size - size);\n    }\n  }\n\n  @override\n  void onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n    super.onCollision(intersectionPoints, other);\n    if (other is Enemy) {\n      gameRef.addExplosion(position);\n      gameRef.remove(other);\n      gameRef.score += 10;\n    }\n  }\n}\n\n// Step 10: Enemy Component\nclass Enemy extends SpriteComponent with HasGameRef<RealFlutter>, Tappable {\n  Enemy() : super(size: Vector2(40, 40));\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await gameRef.loadSprite('enemy.png');\n    position = Vector2(\n      gameRef.random.nextDouble() * (gameRef.size.x - size.x),\n      gameRef.random.nextDouble() * (gameRef.size.y - size.y),\n    );\n    add(CircleHitbox());\n    add(MoveEffect.by(\n      Vector2(100, 0),\n      EffectController(duration: 1, alternate: true, infinite: true),\n    ));\n  }\n\n  @override\n  bool onTapDown(TapDownInfo info) {\n    gameRef.addExplosion(position);\n    gameRef.remove(this);\n    gameRef.score += 5;\n    return true;\n  }\n}\n\n// Application Flow:\n// 1. The main() function runs the RealFlutter game using GameWidget.\n// 2. RealFlutter.onLoad() sets up the game by loading assets and adding components:\n//    - Background is added first.\n//    - Player is added and positioned at the center.\n//    - Multiple enemies are added at random positions.\n//    - Score display is added to the top-left corner.\n//    - Joystick is added for player movement.\n// 3. During the game:\n//    - The update() method is called every frame, updating the score display.\n//    - Player moves based on joystick input.\n//    - Enemies move back and forth horizontally.\n//    - Collision detection checks for player-enemy collisions.\n//    - When a collision occurs or an enemy is tapped:\n//      - An explosion particle effect is created.\n//      - The enemy is removed.\n//      - The score is increased.\n// 4. The game continues indefinitely, with the player trying to eliminate enemies and increase their score.\n```",
    "_type": "package",
    "description": "# Flame Package for Flutter: Powering Your 2D Games\n\n## Introduction\n\nFlame is a modular 2D game engine built on top of Flutter. It provides a complete set of out-of-the-box solutions for game development, including rendering, audio, input, and more. With Flame, you can create stunning 2D games for multiple platforms using Flutter's powerful framework.\n\n## Key Features\n\n1. **Component System**: Flame uses a component-based architecture, allowing for easy organization and management of game objects.\n\n2. **Built-in Game Loop**: The package provides a robust game loop that handles updates and rendering efficiently.\n\n3. **Asset Management**: Easily load and manage various assets like images, audio files, and fonts.\n\n4. **Input Handling**: Flame offers comprehensive input handling for touch, keyboard, and gamepad inputs.\n\n5. **Collision Detection**: Built-in systems for detecting collisions between game objects.\n\n6. **Particle Systems**: Create dynamic particle effects to enhance your game's visual appeal.\n\n7. **Audio Support**: Integrated audio playback for background music and sound effects.\n\n8. **Camera and Viewport**: Implement scrolling and zooming effects with ease.\n\n9. **Effects and Animations**: A wide range of pre-built effects and animation capabilities.\n\n10. **Cross-platform Support**: Develop games that run on multiple platforms, including mobile, web, and desktop.\n\n## Why Choose Flame?\n\nFlame combines the power of Flutter's hot reload and extensive widget library with dedicated game development features. This makes it an excellent choice for both beginners and experienced developers looking to create 2D games efficiently.\n\nWhether you're building a simple puzzle game or a complex RPG, Flame provides the tools and structure needed to bring your game ideas to life.",
    "shortDescription": "A minimalist Flutter game engine, provides a nice set of somewhat independent modules you can choose from.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1Yd5",
        "_type": "reference",
        "_key": "x2iurxfs"
      }
    ],
    "likesCount": 1952,
    "lastUpdate": "2024-08-26T18:30:00.000Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmVqx",
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbYT6",
        "_type": "reference",
        "_key": "zhrymfcd"
      }
    ],
    "name": "flame",
    "pubPoint": 160,
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8Cel7",
    "tutorial": "# Getting Started with Flame: A Step-by-Step Tutorial\n\nThis tutorial will guide you through setting up a basic Flame project and creating a simple game. We'll cover platform-specific details as well.\n\n## Step 1: Setting Up Your Project\n\n1. Create a new Flutter project:\n   ```\n   flutter create real_flutter_game\n   cd real_flutter_game\n   ```\n\n2. Add Flame to your `pubspec.yaml`:\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     flame: ^1.8.1\n   ```\n\n3. Run `flutter pub get` to install the dependencies.\n\n## Step 2: Creating Your Game Class\n\nCreate a new file called `real_flutter_game.dart` and add the following code:\n\n```dart\nimport 'package:flame/game.dart';\n\nclass RealFlutter extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    // Game initialization code goes here\n  }\n\n  @override\n  void update(double dt) {\n    // Game update logic goes here\n    super.update(dt);\n  }\n}\n```\n\n## Step 3: Setting Up the Main File\n\nUpdate your `main.dart` file:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flame/game.dart';\nimport 'real_flutter_game.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: RealFlutter(),\n    ),\n  );\n}\n```\n\n## Step 4: Adding Game Components\n\n1. Create a simple player component:\n\n```dart\nimport 'package:flame/components.dart';\n\nclass Player extends SpriteComponent with HasGameRef<RealFlutter> {\n  Player() : super(size: Vector2(50, 50));\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n    position = gameRef.size / 2;\n  }\n\n  @override\n  void update(double dt) {\n    // Add player update logic here\n    super.update(dt);\n  }\n}\n```\n\n2. Add the player to your game:\n\n```dart\nclass RealFlutter extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    add(Player());\n  }\n}\n```\n\n## Step 5: Handling Input\n\nAdd touch input to move the player:\n\n```dart\nimport 'package:flame/input.dart';\n\nclass RealFlutter extends FlameGame with TapDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    player = Player();\n    add(player);\n  }\n\n  @override\n  void onTapDown(TapDownInfo info) {\n    player.position = info.eventPosition.game;\n  }\n}\n```\n\n## Platform-Specific Considerations\n\n### Android\n- Ensure your `AndroidManifest.xml` includes necessary permissions:\n  ```xml\n  <uses-permission android:name=\"android.permission.INTERNET\"/>\n  ```\n\n### iOS\n- Update your `Info.plist` to include required permissions:\n  ```xml\n  <key>NSMicrophoneUsageDescription</key>\n  <string>This app uses the microphone for game audio features.</string>\n  ```\n\n### Web\n- No additional setup required for basic functionality.\n\n### Desktop (Windows, macOS, Linux)\n- Ensure you have the latest Flutter SDK that supports desktop development.\n- Run `flutter config --enable-<platform>-desktop` to enable desktop support.\n\nBy following these steps, you'll have a basic Flame game up and running on multiple platforms. Experiment with adding more components, implementing game logic, and exploring Flame's extensive features to create your unique game!",
    "_updatedAt": "2024-09-06T04:13:31Z",
    "slug": {
      "current": "flame",
      "_type": "slug"
    },
    "author": "flame-engine.org"
  },
  {
    "shortDescription": "A library for generating fake data. faker is heavily inspired by the Python package faker and, the Ruby package ffaker.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPb4Im",
        "_type": "reference",
        "_key": "qpe9o8w7"
      }
    ],
    "subCategories": [
      {
        "_ref": "4gmBGwifQuSypgRenUbXJF",
        "_type": "reference",
        "_key": "cf83yh03"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 785,
    "_createdAt": "2024-08-28T22:19:52Z",
    "tutorial": "# Tutorial: Using Faker in Flutter\n\nThis tutorial will guide you through the process of integrating and using the Faker package in your Flutter project.\n\n## Step 1: Add Dependency\n\nAdd the Faker package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  faker: ^2.1.0  # Use the latest version\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the Faker package:\n\n```dart\nimport 'package:faker/faker.dart';\n```\n\n## Step 3: Create a Faker Instance\n\nCreate an instance of the Faker class:\n\n```dart\nfinal faker = Faker();\n```\n\n## Step 4: Generate Fake Data\n\nNow you can use various methods to generate fake data:\n\n```dart\n// Generate a random name\nString name = faker.person.name();\n\n// Generate a random email\nString email = faker.internet.email();\n\n// Generate a random sentence\nString sentence = faker.lorem.sentence();\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 16:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 16\n        // ... other configurations\n    }\n}\n```\n\n### iOS\n\nFor iOS, add the following to your `ios/Runner/Info.plist` file to ensure proper text rendering:\n\n```xml\n<key>io.flutter.embedded_views_preview</key>\n<string>YES</string>\n```\n\n### Web\n\nFor web projects, no additional configuration is needed. However, be mindful of performance when generating large amounts of data in web applications.\n\n## Advanced Usage\n\n### Localization\n\nYou can generate localized data by specifying a locale:\n\n```dart\nfinal fakerDe = Faker(provider: FakerDataProviderGe());\nString germanName = fakerDe.person.name();\n```\n\n### Seeding\n\nTo generate consistent random data, use a seed:\n\n```dart\nfinal faker = Faker(seed: 123);\n```\n\n### Custom Providers\n\nCreate custom data providers by extending `Provider` class:\n\n```dart\nclass MyCustomProvider extends Provider {\n  String getCustomData() => 'Custom Data';\n}\n\nfinal faker = Faker();\nfaker.providers.add(MyCustomProvider());\nString customData = faker.format('${customData}');\n```\n\nIn the next section, we'll look at a complete example that demonstrates these concepts in action.",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6RgHU",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CWOb",
        "_type": "reference",
        "_key": "h5azzb7s"
      }
    ],
    "name": "faker",
    "description": "# Faker Package for Flutter: Generating Realistic Mock Data\n\n## Introduction\n\nIn the world of app development, having realistic mock data is crucial for testing and prototyping. The Faker package for Flutter provides an elegant solution to this common need. It allows developers to generate a wide variety of fake data, from names and addresses to lorem ipsum text and beyond.\n\n## What is Faker?\n\nFaker is a powerful Dart library that generates fake data for various purposes. It's particularly useful in Flutter development for:\n\n1. Populating UI prototypes with realistic-looking data\n2. Creating sample datasets for testing\n3. Generating placeholder content during development\n\nThe package offers a wide range of data types, including:\n\n- Personal information (names, addresses, phone numbers)\n- Internet-related data (emails, usernames, URLs)\n- Date and time values\n- Lorem ipsum text\n- And much more!\n\n## Key Features\n\n- **Diverse Data Types**: Generate a wide variety of data types to suit different needs.\n- **Localization**: Support for multiple languages and regions.\n- **Customization**: Ability to create custom data providers.\n- **Consistency**: Option to use seeds for reproducible random data.\n\n## Why Use Faker in Flutter?\n\n1. **Rapid Prototyping**: Quickly populate your Flutter UI with realistic data.\n2. **Improved Testing**: Create diverse test scenarios with randomly generated data.\n3. **Localization Testing**: Generate data in different languages to test your app's localization.\n4. **Time-Saving**: Avoid manual creation of mock data.\n\nIn the following sections, we'll dive into a tutorial on how to use Faker in your Flutter projects and provide a comprehensive example showcasing its features.",
    "packageImage": null,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:32Z",
    "slug": {
      "current": "faker",
      "_type": "slug"
    },
    "author": "",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:faker/faker.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Faker Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const FakerHomePage(title: 'Faker Package Demo'),\n    );\n  }\n}\n\nclass FakerHomePage extends StatefulWidget {\n  const FakerHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  State<FakerHomePage> createState() => _FakerHomePageState();\n}\n\nclass _FakerHomePageState extends State<FakerHomePage> {\n  // Step 1: Initialize Faker instance\n  final faker = Faker();\n\n  // Step 2: Create variables to hold fake data\n  late String name;\n  late String email;\n  late String address;\n  late String phoneNumber;\n  late String company;\n  late String lorem;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Generate initial fake data\n    _generateFakeData();\n  }\n\n  // Step 4: Method to generate fake data\n  void _generateFakeData() {\n    setState(() {\n      name = faker.person.name();\n      email = faker.internet.email();\n      address = faker.address.streetAddress();\n      phoneNumber = faker.phoneNumber.us();\n      company = faker.company.name();\n      lorem = faker.lorem.sentence();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: <Widget>[\n            // Step 5: Display fake data\n            Text('Name: $name', style: Theme.of(context).textTheme.headline6),\n            Text('Email: $email'),\n            Text('Address: $address'),\n            Text('Phone: $phoneNumber'),\n            Text('Company: $company'),\n            Text('Lorem: $lorem'),\n            const SizedBox(height: 20),\n            // Step 6: Add a button to regenerate data\n            ElevatedButton(\n              onPressed: _generateFakeData,\n              child: const Text('Generate New Data'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Step 7: Explanation of the application flow\n/*\nApplication Flow:\n1. The app starts by running the RealFlutter widget, which sets up the MaterialApp.\n2. FakerHomePage is set as the home widget.\n3. In the _FakerHomePageState:\n   a. A Faker instance is created.\n   b. Variables are declared to hold different types of fake data.\n   c. In initState(), _generateFakeData() is called to populate initial data.\n4. _generateFakeData() method:\n   a. Uses the faker instance to generate various types of fake data.\n   b. setState() is called to update the UI with new data.\n5. The build method creates the UI:\n   a. Displays the generated fake data in Text widgets.\n   b. Provides a button to regenerate data.\n6. When the \"Generate New Data\" button is pressed, _generateFakeData() is called again,\n   updating all the fake data fields and refreshing the UI.\n\nThis example demonstrates how to use the Faker package to generate various types of\nrealistic-looking mock data and how to integrate it into a Flutter application for\ntesting or prototyping purposes.\n*/\n```",
    "tags": [
      "testing",
      "mock-data",
      "fake-data",
      "development-tool"
    ],
    "lastUpdate": "2024-08-20T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8Ceqd"
  },
  {
    "tags": [
      "nosql",
      "database",
      "local-storage",
      "persistence"
    ],
    "likesCount": 1011,
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:33Z",
    "packageImage": null,
    "name": "sembast",
    "pubPoint": 160,
    "author": "tekartik.com",
    "_rev": "eaCZ7mIhmiYZX5KGqJmVxV",
    "_type": "package",
    "subCategories": [
      {
        "_type": "reference",
        "_key": "ab03w2xj",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGH6"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:sembast/sembast.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart';\n\n// Step 1: Define the RealFlutter class for database management\nclass RealFlutter {\n  static final RealFlutter _singleton = RealFlutter._();\n  static Database? _database;\n\n  RealFlutter._();\n\n  factory RealFlutter() {\n    return _singleton;\n  }\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future<Database> _initDatabase() async {\n    final appDocumentDir = await getApplicationDocumentsDirectory();\n    final dbPath = join(appDocumentDir.path, 'real_flutter.db');\n    return await databaseFactoryIo.openDatabase(dbPath);\n  }\n}\n\n// Step 2: Define a Task model\nclass Task {\n  int? id;\n  String title;\n  bool isCompleted;\n\n  Task({this.id, required this.title, this.isCompleted = false});\n\n  Map<String, dynamic> toMap() {\n    return {\n      'id': id,\n      'title': title,\n      'isCompleted': isCompleted,\n    };\n  }\n\n  static Task fromMap(Map<String, dynamic> map) {\n    return Task(\n      id: map['id'] as int?,\n      title: map['title'] as String,\n      isCompleted: map['isCompleted'] as bool,\n    );\n  }\n}\n\n// Step 3: Create a TaskRepository to handle database operations\nclass TaskRepository {\n  final Database _db;\n  final StoreRef<int, Map<String, dynamic>> _store;\n\n  TaskRepository(this._db) : _store = intMapStoreFactory.store('tasks');\n\n  Future<int> insertTask(Task task) async {\n    return await _store.add(_db, task.toMap());\n  }\n\n  Future<List<Task>> getAllTasks() async {\n    final snapshots = await _store.find(_db);\n    return snapshots.map((snapshot) {\n      final task = Task.fromMap(snapshot.value);\n      task.id = snapshot.key;\n      return task;\n    }).toList();\n  }\n\n  Future<void> updateTask(Task task) async {\n    final finder = Finder(filter: Filter.byKey(task.id));\n    await _store.update(_db, task.toMap(), finder: finder);\n  }\n\n  Future<void> deleteTask(int id) async {\n    final finder = Finder(filter: Filter.byKey(id));\n    await _store.delete(_db, finder: finder);\n  }\n}\n\n// Step 4: Create the main app widget\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  final database = await RealFlutter().database;\n  runApp(MyApp(database: database));\n}\n\nclass MyApp extends StatelessWidget {\n  final Database database;\n\n  const MyApp({Key? key, required this.database}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sembast Todo App',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: TodoListScreen(taskRepository: TaskRepository(database)),\n    );\n  }\n}\n\n// Step 5: Create the TodoListScreen\nclass TodoListScreen extends StatefulWidget {\n  final TaskRepository taskRepository;\n\n  const TodoListScreen({Key? key, required this.taskRepository}) : super(key: key);\n\n  @override\n  _TodoListScreenState createState() => _TodoListScreenState();\n}\n\nclass _TodoListScreenState extends State<TodoListScreen> {\n  List<Task> _tasks = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _loadTasks();\n  }\n\n  // Step 6: Load tasks from the database\n  Future<void> _loadTasks() async {\n    final tasks = await widget.taskRepository.getAllTasks();\n    setState(() {\n      _tasks = tasks;\n    });\n  }\n\n  // Step 7: Add a new task\n  Future<void> _addTask(String title) async {\n    final task = Task(title: title);\n    await widget.taskRepository.insertTask(task);\n    await _loadTasks();\n  }\n\n  // Step 8: Toggle task completion\n  Future<void> _toggleTaskCompletion(Task task) async {\n    task.isCompleted = !task.isCompleted;\n    await widget.taskRepository.updateTask(task);\n    await _loadTasks();\n  }\n\n  // Step 9: Delete a task\n  Future<void> _deleteTask(Task task) async {\n    await widget.taskRepository.deleteTask(task.id!);\n    await _loadTasks();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Sembast Todo App')),\n      body: ListView.builder(\n        itemCount: _tasks.length,\n        itemBuilder: (context, index) {\n          final task = _tasks[index];\n          return ListTile(\n            title: Text(task.title),\n            leading: Checkbox(\n              value: task.isCompleted,\n              onChanged: (_) => _toggleTaskCompletion(task),\n            ),\n            trailing: IconButton(\n              icon: Icon(Icons.delete),\n              onPressed: () => _deleteTask(task),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () async {\n          final result = await showDialog<String>(\n            context: context,\n            builder: (context) => _AddTaskDialog(),\n          );\n          if (result != null && result.isNotEmpty) {\n            await _addTask(result);\n          }\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Step 10: Create a dialog for adding new tasks\nclass _AddTaskDialog extends StatelessWidget {\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return AlertDialog(\n      title: Text('Add Task'),\n      content: TextField(\n        controller: _controller,\n        decoration: InputDecoration(hintText: 'Enter task title'),\n      ),\n      actions: [\n        TextButton(\n          onPressed: () => Navigator.of(context).pop(),\n          child: Text('Cancel'),\n        ),\n        TextButton(\n          onPressed: () => Navigator.of(context).pop(_controller.text),\n          child: Text('Add'),\n        ),\n      ],\n    );\n  }\n}\n\n// Flow of the application:\n// 1. The app starts by initializing the Sembast database in the main function.\n// 2. The MyApp widget is created with the initialized database.\n// 3. The TodoListScreen is set as the home screen, which uses a TaskRepository to interact with the database.\n// 4. In the TodoListScreen's initState, _loadTasks() is called to fetch all tasks from the database.\n// 5. The UI displays a list of tasks using a ListView.builder.\n// 6. Users can add new tasks by tapping the FloatingActionButton, which opens the _AddTaskDialog.\n// 7. When a new task is added, it's inserted into the database, and the task list is refreshed.\n// 8. Users can toggle task completion by tapping the checkbox, which updates the task in the database.\n// 9. Tasks can be deleted by tapping the delete icon, which removes them from the database.\n// 10. After each operation (add, toggle, delete), the _loadTasks() method is called to refresh the UI with the latest data from the database.\n\n// This example demonstrates the key features of Sembast:\n// - Database initialization and connection\n// - CRUD operations (Create, Read, Update, Delete)\n// - Querying data (getAllTasks)\n// - Real-time updates to the UI based on database changes\n\n// The app follows a simple architecture:\n// - RealFlutter class manages the database connection\n// - Task model represents the data structure\n// - TaskRepository handles all database operations\n// - UI components (TodoListScreen and _AddTaskDialog) interact with the Task\n```",
    "tutorial": "# Sembast Tutorial: Implementing NoSQL Database in Flutter\n\nIn this tutorial, we'll walk through the process of integrating Sembast into a Flutter application. We'll cover installation, basic CRUD operations, and some advanced features.\n\n## Step 1: Installation\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  sembast: ^3.4.0\n  path_provider: ^2.0.15\n```\n\nRun `flutter pub get` to install the packages.\n\n## Step 2: Setting up the Database\n\nCreate a new file called `database.dart` and add the following code:\n\n```dart\nimport 'package:sembast/sembast.dart';\nimport 'package:sembast/sembast_io.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart';\n\nclass RealFlutter {\n  static final RealFlutter _singleton = RealFlutter._();\n  static Database? _database;\n\n  RealFlutter._();\n\n  factory RealFlutter() {\n    return _singleton;\n  }\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future<Database> _initDatabase() async {\n    final appDocumentDir = await getApplicationDocumentsDirectory();\n    final dbPath = join(appDocumentDir.path, 'real_flutter.db');\n    return await databaseFactoryIo.openDatabase(dbPath);\n  }\n}\n```\n\nThis code sets up a singleton class `RealFlutter` that manages the database connection.\n\n## Step 3: Basic CRUD Operations\n\nNow, let's implement basic CRUD (Create, Read, Update, Delete) operations:\n\n```dart\nimport 'package:sembast/sembast.dart';\n\nclass RealFlutterCRUD {\n  final Database _db;\n  final StoreRef _store;\n\n  RealFlutterCRUD(this._db) : _store = intMapStoreFactory.store('real_flutter_store');\n\n  Future<int> insert(Map<String, dynamic> data) async {\n    return await _store.add(_db, data);\n  }\n\n  Future<List<RecordSnapshot<int, Map<String, dynamic>>>> getAll() async {\n    return await _store.find(_db);\n  }\n\n  Future<int> update(int id, Map<String, dynamic> data) async {\n    final finder = Finder(filter: Filter.byKey(id));\n    return await _store.update(_db, data, finder: finder);\n  }\n\n  Future<int> delete(int id) async {\n    final finder = Finder(filter: Filter.byKey(id));\n    return await _store.delete(_db, finder: finder);\n  }\n}\n```\n\n## Step 4: Platform-Specific Considerations\n\n### Android\n\nFor Android, no additional setup is required. Sembast works out of the box.\n\n### iOS\n\nFor iOS, you need to add the following to your `ios/Runner/Info.plist` file:\n\n```xml\n<key>NSDocumentsFolderUsageDescription</key>\n<string>This app needs access to store and retrieve database files.</string>\n```\n\n### Web\n\nFor web applications, you'll need to use the `sembast_web` package instead of `sembast`. Update your `pubspec.yaml`:\n\n```yaml\ndependencies:\n  sembast_web: ^2.1.0\n```\n\nThen, modify your database initialization code:\n\n```dart\nimport 'package:sembast_web/sembast_web.dart';\n\n// ... (in the _initDatabase method)\nfinal dbFactory = databaseFactoryWeb;\nreturn await dbFactory.openDatabase('real_flutter.db');\n```\n\n## Step 5: Advanced Features\n\n### Encryption\n\nTo add encryption, install the `sembast_encryption` package and modify your database initialization:\n\n```dart\nimport 'package:sembast_encryption/sembast_encryption.dart';\n\n// ... (in the _initDatabase method)\nfinal encryptionKey = 'your_secret_key';\nfinal codec = getXXTeaCodec(password: encryptionKey);\nreturn await databaseFactoryIo.openDatabase(dbPath, codec: codec);\n```\n\n### Queries and Filtering\n\nSembast provides powerful querying capabilities:\n\n```dart\nFuture<List<RecordSnapshot<int, Map<String, dynamic>>>> queryData(String field, dynamic value) async {\n  final finder = Finder(filter: Filter.equals(field, value));\n  return await _store.find(_db, finder: finder);\n}\n\nFuture<List<RecordSnapshot<int, Map<String, dynamic>>>> getSortedData(String field, {bool ascending = true}) async {\n  final finder = Finder(sortOrders: [SortOrder(field, ascending: ascending)]);\n  return await _store.find(_db, finder: finder);\n}\n```\n\nWith these building blocks, you can now create powerful, data-driven Flutter applications using Sembast as your database solution.",
    "slug": {
      "current": "sembast",
      "_type": "slug"
    },
    "description": "# Exploring Sembast: A Powerful NoSQL Database for Flutter\n\n## Introduction\n\nIn the world of Flutter development, efficient data management is crucial for creating robust and responsive applications. While there are various options available, one package that stands out for its simplicity and performance is Sembast (Simple Embedded Application Store). In this blog post, we'll dive deep into Sembast and explore how it can revolutionize your Flutter app's data handling capabilities.\n\n## What is Sembast?\n\nSembast is a NoSQL persistent embedded file system document-based database for Dart and Flutter. It's designed to be a lightweight, yet powerful solution for storing and retrieving data in your mobile applications. Unlike SQLite, Sembast doesn't require platform-specific implementation, making it a versatile choice for cross-platform development.\n\n## Key Features of Sembast\n\n1. **Document-based Storage**: Sembast stores data as documents, which are essentially key-value pairs. This flexible structure allows for easy data manipulation and retrieval.\n\n2. **In-memory and Persistent Storage**: Sembast supports both in-memory and file-based storage, giving developers the flexibility to choose based on their app's requirements.\n\n3. **Encryption Support**: With the sembast_encryption package, you can easily encrypt your database, ensuring data security.\n\n4. **Reactive Programming**: Sembast integrates well with streams, making it suitable for reactive programming paradigms.\n\n5. **Cross-platform Compatibility**: It works seamlessly across different platforms, including iOS, Android, and web applications.\n\n6. **ACID Compliant**: Sembast ensures Atomicity, Consistency, Isolation, and Durability in database operations.\n\n7. **Query Capabilities**: It offers powerful querying features, including filtering, sorting, and limiting results.\n\n## Why Choose Sembast for Your Flutter App?\n\n1. **Simplicity**: Sembast's API is intuitive and easy to use, reducing the learning curve for developers.\n\n2. **Performance**: It's optimized for mobile environments, providing fast read and write operations.\n\n3. **No Native Dependencies**: Unlike SQLite, Sembast doesn't require any platform-specific setup, simplifying the development process.\n\n4. **Flexibility**: Its document-based nature allows for easy schema changes and adaptable data structures.\n\n5. **Active Development**: The package is actively maintained and updated, ensuring compatibility with the latest Flutter versions.\n\nIn the following sections, we'll explore how to implement Sembast in your Flutter application and leverage its powerful features to create efficient, data-driven apps.",
    "similarPackages": [
      {
        "_key": "ftlgxpf8",
        "_ref": "uQRNMiDfrp20RZ8Id8CX1D",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "tnyu9lcj"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPatKi",
        "_type": "reference",
        "_key": "bkqsmz7w"
      }
    ],
    "lastUpdate": "2024-08-19T18:30:00.000Z",
    "shortDescription": "NoSQL persistent embedded file system document-based database for Dart VM and Flutter with encryption support.",
    "_createdAt": "2024-08-28T22:20:01Z",
    "_id": "uQRNMiDfrp20RZ8Id8Cew9"
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:realm/realm.dart';\n\n// Step 1: Define the Realm model\npart 'main.g.dart';\n\n@RealmModel()\nclass _Task {\n  @PrimaryKey()\n  late ObjectId id;\n  late String title;\n  late bool isCompleted;\n  late DateTime createdAt;\n}\n\n// Step 2: Create the main RealFlutter class\nclass RealFlutter extends StatefulWidget {\n  final Realm realm;\n\n  const RealFlutter({Key? key, required this.realm}) : super(key: key);\n\n  @override\n  _RealFlutterState createState() => _RealFlutterState();\n}\n\nclass _RealFlutterState extends State<RealFlutter> {\n  late RealmResults<Task> _tasks;\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Initialize tasks with all Task objects from Realm\n    _tasks = widget.realm.all<Task>();\n  }\n\n  // Step 4: Add a new task\n  void _addTask(String title) {\n    final task = Task(ObjectId(), title, false, DateTime.now());\n    widget.realm.write(() {\n      widget.realm.add(task);\n    });\n    _controller.clear();\n  }\n\n  // Step 5: Toggle task completion status\n  void _toggleTask(Task task) {\n    widget.realm.write(() {\n      task.isCompleted = !task.isCompleted;\n    });\n  }\n\n  // Step 6: Delete a task\n  void _deleteTask(Task task) {\n    widget.realm.write(() {\n      widget.realm.delete(task);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('RealFlutter Todo App')),\n      body: Column(\n        children: [\n          // Step 7: Add task input field\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _controller,\n              decoration: const InputDecoration(\n                labelText: 'New Task',\n                suffixIcon: IconButton(\n                  icon: Icon(Icons.add),\n                  onPressed: () => _addTask(_controller.text),\n                ),\n              ),\n              onSubmitted: _addTask,\n            ),\n          ),\n          // Step 8: Display tasks using StreamBuilder\n          Expanded(\n            child: StreamBuilder<RealmResultsChanges<Task>>(\n              stream: _tasks.changes,\n              builder: (context, snapshot) {\n                return ListView.builder(\n                  itemCount: _tasks.length,\n                  itemBuilder: (context, index) {\n                    final task = _tasks[index];\n                    return ListTile(\n                      title: Text(task.title),\n                      leading: Checkbox(\n                        value: task.isCompleted,\n                        onChanged: (_) => _toggleTask(task),\n                      ),\n                      trailing: IconButton(\n                        icon: const Icon(Icons.delete),\n                        onPressed: () => _deleteTask(task),\n                      ),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Step 9: Initialize Realm\n  final config = Configuration.local([Task.schema]);\n  final realm = Realm(config);\n  \n  runApp(MaterialApp(home: RealFlutter(realm: realm)));\n}\n\n/* \nApplication Flow:\n\n1. The application starts by initializing Realm with the Task schema.\n2. The RealFlutter widget is created with the initialized Realm instance.\n3. In the initState method, we fetch all Task objects from Realm.\n4. The UI consists of an input field for adding new tasks and a list of existing tasks.\n5. When a user adds a task:\n   - The _addTask method is called.\n   - A new Task object is created and added to Realm.\n   - The UI automatically updates due to the StreamBuilder listening to Realm changes.\n6. When a user toggles a task's completion status:\n   - The _toggleTask method is called.\n   - The task's isCompleted property is updated in Realm.\n   - The UI reflects the change immediately.\n7. When a user deletes a task:\n   - The _deleteTask method is called.\n   - The task is removed from Realm.\n   - The UI updates to remove the deleted task from the list.\n8. The StreamBuilder continuously listens for changes in the Realm database and rebuilds the list whenever there's a change.\n\nThis example demonstrates Realm's real-time capabilities, CRUD operations, and seamless integration with Flutter's reactive UI.\n*/\n```",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "2a0w1xxh"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cew9",
        "_type": "reference",
        "_key": "gdl6ozqm"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2024-08-13T18:30:00.000Z",
    "pubPoint": 160,
    "author": "realm.io",
    "_type": "package",
    "description": "# Realm Flutter Package: A Comprehensive Overview\n\n## Introduction\n\nRealm is a powerful mobile database solution that offers a seamless integration with Flutter, allowing developers to create efficient and responsive applications with ease. In this blog post, we'll explore the Realm Flutter package, its features, and how it can revolutionize your app development process.\n\n## Key Features of Realm Flutter\n\n1. **Object-Oriented Data Model**: Realm uses a simple, object-oriented data model that maps directly to your Flutter classes, making it intuitive and easy to use.\n\n2. **Cross-Platform Support**: Realm works seamlessly across iOS and Android platforms, ensuring consistent performance and functionality.\n\n3. **Reactive Architecture**: Realm's reactive nature allows for real-time updates and synchronization, keeping your UI in sync with your data.\n\n4. **Offline-First Approach**: Realm enables offline-first app development, allowing your app to function smoothly even without an internet connection.\n\n5. **Easy Migration**: Realm provides built-in migration capabilities, making it simple to update your data schema as your app evolves.\n\n6. **Encryption**: Realm offers built-in encryption to keep your data secure on the device.\n\n7. **Efficient Queries**: Realm's query engine is optimized for mobile devices, providing fast and efficient data retrieval.\n\n## Why Choose Realm for Flutter?\n\nRealm offers several advantages over traditional SQLite databases and other mobile database solutions:\n\n- **Performance**: Realm is designed to be fast and efficient, outperforming SQLite in many scenarios.\n- **Ease of Use**: With its object-oriented approach, Realm reduces the complexity of database operations.\n- **Scalability**: Realm can handle large datasets with ease, making it suitable for both small and large-scale applications.\n- **Real-time Synchronization**: Realm's reactive architecture makes it ideal for apps requiring real-time data updates.\n\nIn the following sections, we'll dive deeper into how to use Realm in your Flutter projects, providing a tutorial and a comprehensive example to showcase its capabilities.",
    "tutorial": "# Realm Flutter Package: Step-by-Step Tutorial\n\nIn this tutorial, we'll walk through the process of integrating Realm into your Flutter project and performing basic operations.\n\n## Step 1: Add Dependencies\n\nFirst, add the Realm Flutter package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  realm: ^1.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Define Your Data Model\n\nCreate a new file called `person.dart` and define your Realm object:\n\n```dart\nimport 'package:realm/realm.dart';\n\npart 'person.g.dart';\n\n@RealmModel()\nclass _Person {\n  @PrimaryKey()\n  late String id;\n  \n  late String name;\n  late int age;\n}\n```\n\nRun the following command to generate the Realm model:\n\n```\nflutter pub run realm generate\n```\n\n## Step 3: Initialize Realm\n\nIn your `main.dart` file, initialize Realm:\n\n```dart\nimport 'package:realm/realm.dart';\nimport 'person.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  final config = Configuration.local([Person.schema]);\n  final realm = Realm(config);\n  \n  runApp(MyApp(realm: realm));\n}\n```\n\n## Step 4: Perform CRUD Operations\n\nNow you can perform CRUD (Create, Read, Update, Delete) operations using Realm:\n\n### Create\n\n```dart\nfinal person = Person(ObjectId(), 'John Doe', 30);\nrealm.write(() {\n  realm.add(person);\n});\n```\n\n### Read\n\n```dart\nfinal allPersons = realm.all<Person>();\nfinal johnDoe = realm.find<Person>('objectId');\n```\n\n### Update\n\n```dart\nrealm.write(() {\n  person.age = 31;\n});\n```\n\n### Delete\n\n```dart\nrealm.write(() {\n  realm.delete(person);\n});\n```\n\n## Step 5: Use Realm in Widgets\n\nYou can use Realm's reactive nature in your widgets:\n\n```dart\nStreamBuilder<RealmResultsChanges<Person>>(\n  stream: realm.all<Person>().changes,\n  builder: (context, snapshot) {\n    final persons = snapshot.data?.results ?? [];\n    return ListView.builder(\n      itemCount: persons.length,\n      itemBuilder: (context, index) {\n        final person = persons[index];\n        return ListTile(\n          title: Text(person.name),\n          subtitle: Text('Age: ${person.age}'),\n        );\n      },\n    );\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, you need to add the following to your `ios/Podfile`:\n\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)', 'HAVE_USLEEP=1']\n    end\n  end\nend\n```\n\n### Android\n\nFor Android, add the following to your `android/app/build.gradle`:\n\n```gradle\nandroid {\n    defaultConfig {\n        ...\n        ndk {\n            abiFilters \"armeabi-v7a\", \"arm64-v8a\", \"x86\", \"x86_64\"\n        }\n    }\n}\n```\n\nWith these steps, you've successfully integrated Realm into your Flutter project and learned how to perform basic operations. In the next section, we'll look at a more comprehensive example that demonstrates additional features of the Realm Flutter package.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGH6",
        "_type": "reference",
        "_key": "c2oqujss"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "tags": [
      "database",
      "persistence",
      "local-storage",
      "nosql"
    ],
    "slug": {
      "_type": "slug",
      "current": "realm"
    },
    "shortDescription": "The official Realm SDK for Flutter. Realm is a mobile database - an alternative to SQLite and key-value stores.",
    "_createdAt": "2024-08-28T22:20:03Z",
    "name": "realm",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:34Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmW43",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPatKi",
        "_type": "reference",
        "_key": "0pbfb7qq"
      }
    ],
    "likesCount": 628,
    "_id": "uQRNMiDfrp20RZ8Id8Cf5L"
  },
  {
    "description": "# Flutter Home Widget Package: Enhancing Your App with Dynamic Home Screen Widgets\n\n## Introduction\n\nIn the ever-evolving world of mobile app development, creating an engaging user experience extends beyond the app itself. Home screen widgets have become a popular feature, allowing users to interact with key app functionalities without opening the application. Flutter, known for its versatility, offers a powerful solution through the `home_widget` package.\n\n## What is the Home Widget Package?\n\nThe `home_widget` package is a Flutter plugin that enables developers to create and update home screen widgets for both Android and iOS platforms. This package bridges the gap between your Flutter app and the native widget frameworks, allowing you to display dynamic content on the user's home screen.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Works seamlessly on both Android and iOS devices.\n2. **Dynamic Updates**: Allows real-time updates to widget content without launching the app.\n3. **Data Synchronization**: Facilitates data sharing between the app and the widget.\n4. **Customization**: Supports various widget sizes and layouts to suit your app's needs.\n5. **Background Updates**: Enables updating widget content even when the app is not running.\n\n## Why Use Home Widgets?\n\n1. **Enhanced User Engagement**: Widgets provide quick access to important information, encouraging frequent interactions.\n2. **Improved User Experience**: Users can view key data without opening the app, saving time and effort.\n3. **Increased Visibility**: Widgets serve as a constant reminder of your app's value, potentially boosting retention rates.\n4. **Competitive Edge**: Offering home screen widgets can set your app apart in a crowded marketplace.\n\nIn the following sections, we'll dive deeper into how to implement home widgets in your Flutter application using the `home_widget` package, exploring both the setup process and a practical example.",
    "_updatedAt": "2024-09-06T04:13:36Z",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1qJX",
        "_type": "reference",
        "_key": "nxioo1uh"
      }
    ],
    "subCategories": [
      {
        "_type": "reference",
        "_key": "x8th0fpp",
        "_ref": "EyMM3FfV3Ih5n1NWrhPGxm"
      }
    ],
    "lastUpdate": "2024-08-27T18:30:00.000Z",
    "slug": {
      "current": "home_widget",
      "_type": "slug"
    },
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmWDs",
    "shortDescription": "A plugin to provide a common interface for creating HomeScreen Widgets for Android and iOS.",
    "_createdAt": "2024-08-28T22:20:08Z",
    "author": "antonborri.es",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1err",
        "_type": "reference",
        "_key": "lprgdlt2"
      }
    ],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_type": "reference",
        "_ref": "image-cb3893a77c3d3662b907791c32a1986c69fb20bb-450x450-webp"
      }
    },
    "tags": [
      "home-screen-widget",
      "native",
      "android",
      "ios",
      "widget"
    ],
    "likesCount": 1649,
    "name": "home_widget",
    "_id": "uQRNMiDfrp20RZ8Id8CfRP",
    "tutorial": "# Implementing Home Widgets in Flutter: A Step-by-Step Tutorial\n\nThis tutorial will guide you through the process of adding home screen widgets to your Flutter application using the `home_widget` package. We'll cover setup for both Android and iOS platforms.\n\n## Prerequisites\n\n- Flutter SDK installed and configured\n- Basic knowledge of Flutter development\n- Android Studio (for Android development)\n- Xcode (for iOS development)\n\n## Step 1: Add Dependencies\n\nAdd the following dependencies to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  home_widget: ^0.3.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Android Setup\n\n1. Open the `android/app/src/main/AndroidManifest.xml` file and add the following permissions:\n\n```xml\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n```\n\n2. Create a new Kotlin file named `HomeWidgetExampleProvider.kt` in the `android/app/src/main/kotlin/com/example/your_app_name/` directory:\n\n```kotlin\npackage com.example.your_app_name\n\nimport android.appwidget.AppWidgetManager\nimport android.content.Context\nimport android.content.SharedPreferences\nimport android.net.Uri\nimport android.widget.RemoteViews\nimport es.antonborri.home_widget.HomeWidgetBackgroundIntent\nimport es.antonborri.home_widget.HomeWidgetLaunchIntent\nimport es.antonborri.home_widget.HomeWidgetProvider\n\nclass HomeWidgetExampleProvider : HomeWidgetProvider() {\n    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray, widgetData: SharedPreferences) {\n        appWidgetIds.forEach { widgetId ->\n            val views = RemoteViews(context.packageName, R.layout.widget_layout).apply {\n                // Implement your widget UI update logic here\n                setTextViewText(R.id.widget_title, widgetData.getString(\"title\", null))\n                setTextViewText(R.id.widget_message, widgetData.getString(\"message\", null))\n                \n                // Set up a PendingIntent to launch the app when the widget is tapped\n                val pendingIntent = HomeWidgetLaunchIntent.getActivity(\n                    context,\n                    MainActivity::class.java)\n                setOnClickPendingIntent(R.id.widget_container, pendingIntent)\n                \n                // Set up a PendingIntent to update the widget in the background\n                val backgroundIntent = HomeWidgetBackgroundIntent.getBroadcast(\n                    context,\n                    Uri.parse(\"myAppWidget://updatewidget\"))\n                setOnClickPendingIntent(R.id.widget_button, backgroundIntent)\n            }\n            appWidgetManager.updateAppWidget(widgetId, views)\n        }\n    }\n}\n```\n\n3. Create a new XML layout file named `widget_layout.xml` in the `android/app/src/main/res/layout/` directory:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/widget_container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:padding=\"8dp\"\n    android:background=\"#FFFFFF\">\n\n    <TextView\n        android:id=\"@+id/widget_title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"18sp\"\n        android:textStyle=\"bold\"\n        android:textColor=\"#000000\"/>\n\n    <TextView\n        android:id=\"@+id/widget_message\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"14sp\"\n        android:textColor=\"#000000\"/>\n\n    <Button\n        android:id=\"@+id/widget_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Update\"\n        android:layout_marginTop=\"8dp\"/>\n\n</LinearLayout>\n```\n\n4. Create a new XML file named `home_widget_example.xml` in the `android/app/src/main/res/xml/` directory:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minWidth=\"180dp\"\n    android:minHeight=\"110dp\"\n    android:updatePeriodMillis=\"86400000\"\n    android:initialLayout=\"@layout/widget_layout\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:widgetCategory=\"home_screen\">\n</appwidget-provider>\n```\n\n5. Update the `android/app/src/main/AndroidManifest.xml` file to include the widget provider:\n\n```xml\n<application>\n    <!-- ... other app components ... -->\n    <receiver android:name=\".HomeWidgetExampleProvider\" android:exported=\"true\">\n        <intent-filter>\n            <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n        </intent-filter>\n        <meta-data android:name=\"android.appwidget.provider\"\n            android:resource=\"@xml/home_widget_example\" />\n    </receiver>\n</application>\n```\n\n## Step 3: iOS Setup\n\n1. Open your Xcode project and navigate to the \"Runner\" target.\n\n2. In the \"Signing & Capabilities\" tab, add the \"App Groups\" capability.\n\n3. Create a new App Group with a unique identifier (e.g., \"group.com.example.your_app_name\").\n\n4. Create a new Swift file named `HomeWidgetExample.swift` in the `ios/Runner` directory:\n\n```swift\nimport WidgetKit\nimport SwiftUI\n\nstruct Provider: TimelineProvider {\n    func placeholder(in context: Context) -> SimpleEntry {\n        SimpleEntry(date: Date(), title: \"Placeholder\", message: \"Placeholder\")\n    }\n\n    func getSnapshot(in context: Context, completion: @escaping (SimpleEntry) -> ()) {\n        let entry = SimpleEntry(date: Date(), title: \"Snapshot\", message: \"Snapshot\")\n        completion(entry)\n    }\n\n    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {\n        var entries: [SimpleEntry] = []\n\n        // Generate a timeline consisting of five entries an hour apart, starting from the current date.\n        let currentDate = Date()\n        for hourOffset in 0 ..< 5 {\n            let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!\n            let entry = SimpleEntry(date: entryDate, title: \"Timeline\", message: \"Timeline \\(hourOffset)\")\n            entries.append(entry)\n        }\n\n        let timeline = Timeline(entries: entries, policy: .atEnd)\n        completion(timeline)\n    }\n}\n\nstruct SimpleEntry: TimelineEntry {\n    let date: Date\n    let title: String\n    let message: String\n}\n\nstruct HomeWidgetExampleEntryView : View {\n    var entry: Provider.Entry\n\n    var body: some View {\n        VStack {\n            Text(entry.title)\n                .font(.headline)\n            Text(entry.message)\n                .font(.subheadline)\n        }\n    }\n}\n\n@main\nstruct HomeWidgetExample: Widget {\n    let kind: String = \"HomeWidgetExample\"\n\n    var body: some WidgetConfiguration {\n        StaticConfiguration(kind: kind, provider: Provider()) { entry in\n            HomeWidgetExampleEntryView(entry: entry)\n        }\n        .configurationDisplayName(\"My Widget\")\n        .description(\"This is an example widget.\")\n    }\n}\n```\n\n5. Create a new target in your Xcode project for the widget extension:\n   - File > New > Target\n   - Choose \"Widget Extension\"\n   - Name it \"HomeWidgetExample\"\n   - Make sure \"Include Configuration Intent\" is unchecked\n\n6. Update the `Info.plist` file in your widget extension target to include the App Group:\n\n```xml\n<key>AppGroupIdentifier</key>\n<string>group.com.example.your_app_name</string>\n```\n\n7. In your main app's `Info.plist`, add the following:\n\n```xml\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>HomeWidgetExample</string>\n        </array>\n    </dict>\n</array>\n```\n\nWith these steps completed, you've set up the foundation for implementing home widgets in your Flutter app using the `home_widget` package. In the next section, we'll look at a main file example that demonstrates how to use this package in your Flutter code.",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:home_widget/home_widget.dart';\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  HomeWidget.registerBackgroundCallback(backgroundCallback);\n  runApp(const RealFlutter());\n}\n\n// Step 1: Define the background callback function\nFuture<void> backgroundCallback(Uri? uri) async {\n  if (uri?.host == 'updatewidget') {\n    await HomeWidget.saveWidgetData<String>('title', 'Updated from Background');\n    await HomeWidget.saveWidgetData<String>('message', 'This is a background update');\n    await HomeWidget.updateWidget(\n      name: 'HomeWidgetExampleProvider',\n      iOSName: 'HomeWidgetExample',\n    );\n  }\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Home Widget Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({Key? key}) : super(key: key);\n\n  @override\n  _HomeScreenState createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> {\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _messageController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Initialize the home widget\n    HomeWidget.setAppGroupId('group.com.example.your_app_name');\n    _loadData();\n  }\n\n  // Step 3: Load existing data from the widget\n  Future<void> _loadData() async {\n    final title = await HomeWidget.getWidgetData<String>('title');\n    final message = await HomeWidget.getWidgetData<String>('message');\n    setState(() {\n      _titleController.text = title ?? '';\n      _messageController.text = message ?? '';\n    });\n  }\n\n  // Step 4: Update the widget data\n  Future<void> _updateWidget() async {\n    await HomeWidget.saveWidgetData<String>('title', _titleController.text);\n    await HomeWidget.saveWidgetData<String>('message', _messageController.text);\n    await HomeWidget.updateWidget(\n      name: 'HomeWidgetExampleProvider',\n      iOSName: 'HomeWidgetExample',\n    );\n    ScaffoldMessenger.of(context).showSnackBar(\n      const SnackBar(content: Text('Widget updated!')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Widget Demo'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            TextField(\n              controller: _titleController,\n              decoration: const InputDecoration(labelText: 'Widget Title'),\n            ),\n            const SizedBox(height: 16),\n            TextField(\n              controller: _messageController,\n              decoration: const InputDecoration(labelText: 'Widget Message'),\n            ),\n            const SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: _updateWidget,\n              child: const Text('Update Widget'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _messageController.dispose();\n    super.dispose();\n  }\n}\n\n// Application flow explanation:\n/*\n1. The app starts by registering a background callback function and initializing the HomeWidget.\n   This allows the app to respond to widget interactions even when it's not running.\n\n2. In the HomeScreen, we set up the app group ID for iOS (this is ignored on Android).\n   This is crucial for data sharing between the app and the widget on iOS.\n\n3. We load any existing data from the widget when the screen initializes.\n   This ensures that the app displays the most recent widget data.\n\n4. The UI allows users to input a title and message for the widget.\n   These text fields are controlled by _titleController and _messageController.\n\n5. When the \"Update Widget\" button is pressed, we:\n   a. Save the new title and message data using HomeWidget.saveWidgetData().\n   b. Trigger an update of the widget on both Android and iOS using HomeWidget.updateWidget().\n   c. Show a confirmation message to the user using a SnackBar.\n\n6. The widget on the home screen will now display the updated title and message.\n\n7. The backgroundCallback function is set up to handle background updates:\n   - It checks if the update request came from the widget (uri?.host == 'updatewidget').\n   - If so, it updates the widget data with a predefined title and message.\n   - Finally, it triggers a widget update to reflect these changes.\n\n8. This setup allows for three types of widget updates:\n   a. Direct updates from the app when the user presses the \"Update Widget\" button.\n   b. Background updates triggered by widget interactions on the home screen.\n   c. Potential periodic updates (not implemented in this example, but possible with platform-specific code).\n\n9. The app uses a StatefulWidget (HomeScreen) to manage the state of the text inputs and handle widget updates.\n\n10. When the HomeScreen is disposed, the TextEditingControllers are also disposed to prevent memory leaks.\n\nThis implementation demonstrates a full cycle of reading from, writing to, and updating a home screen widget,\nshowcasing the core functionality of the home_widget package in a Flutter application.\n*/\n```",
    "platforms": [
      "android",
      "ios"
    ],
    "tutorialIncluded": true
  },
  {
    "_type": "package",
    "description": "# Barcode Widget Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `barcode_widget` package is a powerful and versatile tool for Flutter developers who need to generate and display barcodes in their applications. This package supports a wide range of barcode formats, including QR codes, making it suitable for various use cases such as inventory management, ticketing systems, and product identification.\n\n### Key Features:\n\n1. **Multiple Barcode Formats**: Supports various 1D and 2D barcode formats, including QR Code, Code 128, EAN-13, and more.\n2. **Customizable Appearance**: Allows developers to customize the size, colors, and overall appearance of the barcode.\n3. **Easy Integration**: Seamlessly integrates with Flutter widgets, making it simple to add barcodes to your UI.\n4. **Platform Independence**: Works across multiple platforms, including iOS, Android, and web.\n5. **Error Handling**: Provides built-in error handling and correction levels for improved reliability.\n\n### Use Cases:\n\n- E-commerce applications for product identification\n- Event ticketing systems for generating unique ticket barcodes\n- Inventory management solutions for tracking items\n- Contact sharing applications using QR codes\n- Document management systems for quick access to information\n\nIn the following sections, we'll dive deeper into how to use the `barcode_widget` package in your Flutter applications, including a step-by-step tutorial and a comprehensive example showcasing its features.",
    "shortDescription": "Barcode generation widget for Flutter with support for standard barcodes.",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1aLX",
        "_type": "reference",
        "_key": "h4uuc1ir"
      }
    ],
    "packageImage": null,
    "lastUpdate": "2023-05-21T18:30:00.000Z",
    "name": "barcode_widget",
    "_rev": "ezMiwuUkJkbYMWycA6RgVs",
    "_updatedAt": "2024-09-06T04:13:37Z",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:barcode_widget/barcode_widget.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Barcode Widget Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const BarcodeDemo(),\n    );\n  }\n}\n\nclass BarcodeDemo extends StatefulWidget {\n  const BarcodeDemo({Key? key}) : super(key: key);\n\n  @override\n  _BarcodeDemoState createState() => _BarcodeDemoState();\n}\n\nclass _BarcodeDemoState extends State<BarcodeDemo> {\n  String _barcodeData = 'https://example.com';\n  Barcode _barcodeType = Barcode.qrCode();\n  Color _barcodeColor = Colors.black;\n  Color _backgroundColor = Colors.white;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Barcode Widget Demo'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Step 1: Display the barcode\n            BarcodeWidget(\n              barcode: _barcodeType,\n              data: _barcodeData,\n              width: 200,\n              height: 200,\n              color: _barcodeColor,\n              backgroundColor: _backgroundColor,\n            ),\n            const SizedBox(height: 20),\n\n            // Step 2: Input field for barcode data\n            TextField(\n              decoration: const InputDecoration(labelText: 'Enter barcode data'),\n              onChanged: (value) {\n                setState(() {\n                  _barcodeData = value;\n                });\n              },\n            ),\n            const SizedBox(height: 20),\n\n            // Step 3: Dropdown to select barcode type\n            DropdownButton<Barcode>(\n              value: _barcodeType,\n              items: [\n                DropdownMenuItem(value: Barcode.qrCode(), child: const Text('QR Code')),\n                DropdownMenuItem(value: Barcode.code128(), child: const Text('Code 128')),\n                DropdownMenuItem(value: Barcode.ean13(), child: const Text('EAN-13')),\n              ],\n              onChanged: (Barcode? newValue) {\n                if (newValue != null) {\n                  setState(() {\n                    _barcodeType = newValue;\n                  });\n                }\n              },\n            ),\n            const SizedBox(height: 20),\n\n            // Step 4: Color pickers for barcode and background\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(\n                  onPressed: () => _pickColor(true),\n                  child: const Text('Pick Barcode Color'),\n                ),\n                ElevatedButton(\n                  onPressed: () => _pickColor(false),\n                  child: const Text('Pick Background Color'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 5: Color picker function\n  void _pickColor(bool isBarcode) {\n    showDialog(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: Text(isBarcode ? 'Pick Barcode Color' : 'Pick Background Color'),\n          content: SingleChildScrollView(\n            child: ColorPicker(\n              pickerColor: isBarcode ? _barcodeColor : _backgroundColor,\n              onColorChanged: (Color color) {\n                setState(() {\n                  if (isBarcode) {\n                    _barcodeColor = color;\n                  } else {\n                    _backgroundColor = color;\n                  }\n                });\n              },\n            ),\n          ),\n          actions: <Widget>[\n            ElevatedButton(\n              child: const Text('Got it'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n\n// Note: You'll need to add the 'flutter_colorpicker' package to your pubspec.yaml file\n// and import it at the top of this file:\n// import 'package:flutter_colorpicker/flutter_colorpicker.dart';\n\n// Application flow:\n// 1. The app starts with a default QR code displaying 'https://example.com'.\n// 2. Users can input custom data for the barcode using the text field.\n// 3. The barcode type can be changed using the dropdown menu.\n// 4. Barcode and background colors can be customized using color pickers.\n// 5. The barcode updates in real-time as the user makes changes.\n// \n// This example demonstrates the key features of the barcode_widget package:\n// - Generating different types of barcodes\n// - Customizing barcode data\n// - Changing barcode and background colors\n// - Real-time updates as user input changes\n//\n// The app is responsive and works across different platforms (iOS, Android, web)\n// thanks to Flutter's cross-platform nature and the barcode_widget package's compatibility.\n```",
    "dependentPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPaovc",
        "_type": "reference",
        "_key": "8khd3b23"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1s1z",
        "_type": "reference",
        "_key": "i605j2mv"
      }
    ],
    "author": "nfet.net",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 299,
    "_createdAt": "2024-08-28T22:20:11Z",
    "_id": "uQRNMiDfrp20RZ8Id8CfWv",
    "tutorialIncluded": true,
    "slug": {
      "current": "barcode_widget",
      "_type": "slug"
    },
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGrS",
        "_type": "reference",
        "_key": "aqh2ig0c"
      }
    ],
    "tags": [
      "barcode",
      "qr-code",
      "widget",
      "generator"
    ],
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `barcode_widget` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the `barcode_widget` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  barcode_widget: ^2.0.2\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:barcode_widget/barcode_widget.dart';\n```\n\n### Step 3: Basic Usage\n\nHere's a simple example of how to create a QR code:\n\n```dart\nBarcodeWidget(\n  barcode: Barcode.qrCode(),\n  data: 'https://example.com',\n  width: 200,\n  height: 200,\n)\n```\n\n### Step 4: Customizing the Barcode\n\nYou can customize the appearance of the barcode:\n\n```dart\nBarcodeWidget(\n  barcode: Barcode.code128(),\n  data: '123456',\n  width: 200,\n  height: 80,\n  color: Colors.blue,\n  backgroundColor: Colors.white,\n)\n```\n\n### Platform-Specific Considerations\n\n#### iOS\n\nFor iOS, no additional configuration is required. The package works out of the box.\n\n#### Android\n\nFor Android, ensure that your `minSdkVersion` is set to 18 or higher in your `android/app/build.gradle` file:\n\n```gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 18\n        ...\n    }\n}\n```\n\n#### Web\n\nFor web support, add the following script to your `web/index.html` file:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/jsbarcode@3.11.0/dist/JsBarcode.all.min.js\"></script>\n```\n\n### Advanced Usage\n\n1. **Error Correction**: For QR codes, you can set the error correction level:\n\n```dart\nBarcodeWidget(\n  barcode: Barcode.qrCode(\n    errorCorrectLevel: BarcodeQRCorrectionLevel.high,\n  ),\n  data: 'https://example.com',\n)\n```\n\n2. **Custom Painter**: You can create a custom painter for more control over the rendering:\n\n```dart\nBarcodeWidget(\n  barcode: Barcode.code39(),\n  data: 'CUSTOM',\n  width: 200,\n  height: 80,\n  style: const TextStyle(fontSize: 20),\n  padding: const EdgeInsets.all(10),\n  decoration: const BoxDecoration(\n    border: Border.all(color: Colors.black, width: 2),\n  ),\n)\n```\n\nBy following these steps and examples, you should be able to integrate and customize the `barcode_widget` package in your Flutter application across different platforms.",
    "pubPoint": 160
  },
  {
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-b4c42c3ae83a6c83eee4c167983b5fba68013b8b-1168x736-webp",
        "_type": "reference"
      }
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmWKQ",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1L7f",
        "_type": "reference",
        "_key": "xxg9rvif"
      },
      {
        "_ref": "V06bsD4sX3T8NTHrBPah4K",
        "_type": "reference",
        "_key": "rpbb6xk3"
      }
    ],
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfFE2",
        "_type": "reference",
        "_key": "r6rrrv87"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CfnT",
    "tutorial": "# Win32 Package for Flutter: A Comprehensive Tutorial\n\nThis tutorial will guide you through the process of integrating the win32 package into your Flutter project and utilizing its features effectively.\n\n## Step 1: Setting Up Your Project\n\n1. Create a new Flutter project:\n   ```\n   flutter create win32_demo\n   cd win32_demo\n   ```\n\n2. Add the win32 package to your `pubspec.yaml`:\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     win32: ^[latest_version]\n   ```\n\n3. Run `flutter pub get` to fetch the package.\n\n## Step 2: Importing and Using win32\n\n1. In your Dart file, import the win32 package:\n   ```dart\n   import 'package:win32/win32.dart';\n   ```\n\n2. Create a new class called `RealFlutter` to encapsulate our Win32 functionality:\n   ```dart\n   class RealFlutter {\n     // We'll add methods here\n   }\n   ```\n\n## Step 3: Implementing Win32 Features\n\nLet's implement some common Win32 features:\n\n1. **Getting System Information**:\n   ```dart\n   static String getWindowsVersion() {\n     final osInfo = OSVERSIONINFO.allocate();\n     GetVersionEx(osInfo.addressOf);\n     return 'Windows ${osInfo.dwMajorVersion}.${osInfo.dwMinorVersion}';\n   }\n   ```\n\n2. **Creating a Native Windows MessageBox**:\n   ```dart\n   static void showMessageBox(String title, String message) {\n     MessageBox(\n       NULL,\n       TEXT(message),\n       TEXT(title),\n       MB_OK,\n     );\n   }\n   ```\n\n3. **Listing Files in a Directory**:\n   ```dart\n   static List<String> listFilesInDirectory(String path) {\n     final files = <String>[];\n     final findData = WIN32_FIND_DATA.allocate();\n     final hFind = FindFirstFile(TEXT('$path\\\\*'), findData.addressOf);\n\n     if (hFind != INVALID_HANDLE_VALUE) {\n       do {\n         if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY == 0) {\n           files.add(findData.cFileName.toDartString());\n         }\n       } while (FindNextFile(hFind, findData.addressOf) != 0);\n       FindClose(hFind);\n     }\n\n     return files;\n   }\n   ```\n\n## Step 4: Platform-Specific Considerations\n\nWhen using the win32 package, keep in mind:\n\n1. **Platform Checks**: Always wrap Win32 calls in platform checks to ensure your app doesn't crash on non-Windows platforms:\n   ```dart\n   if (Platform.isWindows) {\n     // Win32 code here\n   }\n   ```\n\n2. **Error Handling**: Use `GetLastError()` to handle Windows API errors:\n   ```dart\n   if (someWin32Function() == 0) {\n     final error = GetLastError();\n     print('Error: $error');\n   }\n   ```\n\n3. **Memory Management**: Properly free allocated resources to prevent memory leaks:\n   ```dart\n   final buffer = allocate<WCHAR>(count: 256);\n   // Use buffer\n   free(buffer);\n   ```\n\nBy following these steps and considerations, you can effectively integrate Win32 functionality into your Flutter application, creating a powerful Windows-native experience.",
    "pubPoint": 160,
    "author": "halildurmus.dev",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1o8h",
        "_type": "reference",
        "_key": "rzmkrtz2"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:win32/win32.dart';\nimport 'dart:io';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Win32 Flutter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: MyHomePage(title: 'Win32 Flutter Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  String _windowsVersion = 'Unknown';\n  List<String> _files = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _getWindowsVersion();\n    _listFiles();\n  }\n\n  // Step 1: Get Windows Version\n  void _getWindowsVersion() {\n    if (Platform.isWindows) {\n      setState(() {\n        _windowsVersion = RealFlutter.getWindowsVersion();\n      });\n    }\n  }\n\n  // Step 2: List files in the current directory\n  void _listFiles() {\n    if (Platform.isWindows) {\n      setState(() {\n        _files = RealFlutter.listFilesInDirectory(Directory.current.path);\n      });\n    }\n  }\n\n  // Step 3: Show a native Windows MessageBox\n  void _showMessageBox() {\n    if (Platform.isWindows) {\n      RealFlutter.showMessageBox('Hello', 'This is a native Windows MessageBox!');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(widget.title)),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Windows Version: $_windowsVersion'),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _showMessageBox,\n              child: Text('Show Native MessageBox'),\n            ),\n            SizedBox(height: 20),\n            Text('Files in current directory:'),\n            Expanded(\n              child: ListView.builder(\n                itemCount: _files.length,\n                itemBuilder: (context, index) {\n                  return ListTile(title: Text(_files[index]));\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass RealFlutter {\n  // Step 4: Get Windows Version\n  static String getWindowsVersion() {\n    final osInfo = OSVERSIONINFO.allocate();\n    GetVersionEx(osInfo.addressOf);\n    final version = 'Windows ${osInfo.dwMajorVersion}.${osInfo.dwMinorVersion}';\n    free(osInfo.addressOf);\n    return version;\n  }\n\n  // Step 5: Show Native Windows MessageBox\n  static void showMessageBox(String title, String message) {\n    MessageBox(\n      NULL,\n      TEXT(message),\n      TEXT(title),\n      MB_OK,\n    );\n  }\n\n  // Step 6: List Files in a Directory\n  static List<String> listFilesInDirectory(String path) {\n    final files = <String>[];\n    final findData = WIN32_FIND_DATA.allocate();\n    final hFind = FindFirstFile(TEXT('$path\\\\*'), findData.addressOf);\n\n    if (hFind != INVALID_HANDLE_VALUE) {\n      do {\n        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY == 0) {\n          files.add(findData.cFileName.toDartString());\n        }\n      } while (FindNextFile(hFind, findData.addressOf) != 0);\n      FindClose(hFind);\n    }\n\n    free(findData.addressOf);\n    return files;\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the MyApp widget.\n// 2. MyHomePage is created as the home page.\n// 3. In the initState method of _MyHomePageState:\n//    - _getWindowsVersion() is called to retrieve the Windows version.\n//    - _listFiles() is called to get the list of files in the current directory.\n// 4. The build method creates the UI with:\n//    - A text displaying the Windows version.\n//    - A button to show a native Windows MessageBox.\n//    - A list view showing files in the current directory.\n// 5. When the user taps the \"Show Native MessageBox\" button, _showMessageBox() is called.\n// 6. The RealFlutter class contains static methods that interact with the Win32 API:\n//    - getWindowsVersion(): Retrieves the Windows version using OSVERSIONINFO.\n//    - showMessageBox(): Displays a native Windows MessageBox.\n//    - listFilesInDirectory(): Uses FindFirstFile and FindNextFile to list files.\n// 7. All Win32 API calls are wrapped in Platform.isWindows checks to ensure\n//    the app doesn't crash on non-Windows platforms.\n// 8. Proper memory management is implemented by freeing allocated resources\n//    after use to prevent memory leaks.\n```",
    "tags": [
      "win32",
      "windows",
      "ffi",
      "native",
      "desktop"
    ],
    "likesCount": 768,
    "name": "win32",
    "_type": "package",
    "shortDescription": "Access common Win32 APIs directly from Dart using FFI  no C required!",
    "_createdAt": "2024-08-28T22:20:16Z",
    "lastUpdate": "2024-08-11T18:30:00.000Z",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:38Z",
    "slug": {
      "current": "win32",
      "_type": "slug"
    },
    "description": "# Win32 Package for Flutter: Bridging the Gap Between Flutter and Windows APIs\n\nThe win32 package is a powerful tool for Flutter developers looking to harness the full potential of Windows-specific functionalities in their applications. This package provides a comprehensive set of bindings to the Win32 API, allowing Flutter apps to interact seamlessly with native Windows features.\n\n## Key Features:\n\n1. **Native Windows API Access**: Directly interact with Windows system calls and functions.\n2. **Performance Optimization**: Leverage low-level Windows operations for enhanced performance.\n3. **Extended Functionality**: Access Windows-specific features not available in standard Flutter.\n4. **Customization**: Create unique Windows experiences within your Flutter app.\n\n## Use Cases:\n\n- Developing Windows-specific system utilities\n- Creating advanced file management tools\n- Implementing custom UI elements that match Windows native look and feel\n- Integrating with Windows-only hardware or software components\n\nBy incorporating the win32 package, developers can create Flutter applications that feel truly native on Windows platforms while maintaining cross-platform compatibility.",
    "platforms": [
      "windows"
    ]
  },
  {
    "author": "",
    "description": "# Decimal Package in Flutter: Precision Mathematics for Your Apps\n\n## Introduction\n\nIn the world of mobile app development, precision in mathematical calculations is crucial. Flutter, Google's UI toolkit for building natively compiled applications, offers a powerful solution through its `decimal` package. This blog post will delve into the intricacies of the `decimal` package, exploring its features, use cases, and implementation in Flutter applications.\n\n## What is the Decimal Package?\n\nThe `decimal` package in Flutter provides a `Decimal` class that allows for precise decimal arithmetic. Unlike the built-in `double` type, which can sometimes lead to rounding errors due to its floating-point nature, the `Decimal` class offers exact decimal representation and arithmetic.\n\n## Key Features\n\n1. **Precise Arithmetic**: Perform addition, subtraction, multiplication, and division without losing precision.\n2. **Rounding Control**: Choose from various rounding modes for different scenarios.\n3. **Parsing and Formatting**: Easily convert between strings and `Decimal` objects.\n4. **Comparison Operations**: Compare decimal values with accuracy.\n5. **Platform Independence**: Works consistently across all platforms supported by Flutter.\n\n## Use Cases\n\nThe `decimal` package is particularly useful in scenarios where precision is paramount:\n\n- Financial calculations\n- Scientific computations\n- Data analysis and statistics\n- Any application where rounding errors could lead to significant issues\n\nIn the following sections, we'll explore how to implement and use the `decimal` package in your Flutter applications, ensuring that your calculations are always precise and reliable.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfCdI",
        "_type": "reference",
        "_key": "iy28lk3b"
      }
    ],
    "_updatedAt": "2024-09-06T04:13:38Z",
    "pubPoint": 160,
    "_rev": "eaCZ7mIhmiYZX5KGqJmWQy",
    "shortDescription": "The decimal package allows you to deal with decimal numbers without losing precision.",
    "tags": [
      "math",
      "decimal",
      "precision",
      "arithmetic"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:27Z",
    "tutorialIncluded": true,
    "slug": {
      "current": "decimal",
      "_type": "slug"
    },
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:decimal/decimal.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Decimal Package Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const DecimalDemoScreen(),\n    );\n  }\n}\n\nclass DecimalDemoScreen extends StatefulWidget {\n  const DecimalDemoScreen({Key? key}) : super(key: key);\n\n  @override\n  _DecimalDemoScreenState createState() => _DecimalDemoScreenState();\n}\n\nclass _DecimalDemoScreenState extends State<DecimalDemoScreen> {\n  // Step 1: Initialize variables\n  Decimal num1 = Decimal.zero;\n  Decimal num2 = Decimal.zero;\n  Decimal result = Decimal.zero;\n  String operation = '';\n\n  // Step 2: Create TextEditingControllers for input fields\n  final TextEditingController _controller1 = TextEditingController();\n  final TextEditingController _controller2 = TextEditingController();\n\n  // Step 3: Define a method to perform calculations\n  void calculate(String op) {\n    setState(() {\n      // Parse input values\n      num1 = Decimal.parse(_controller1.text);\n      num2 = Decimal.parse(_controller2.text);\n\n      // Perform the selected operation\n      switch (op) {\n        case '+':\n          result = num1 + num2;\n          break;\n        case '-':\n          result = num1 - num2;\n          break;\n        case '*':\n          result = num1 * num2;\n          break;\n        case '/':\n          result = num1 / num2;\n          break;\n      }\n\n      operation = op;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Decimal Package Demo'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            // Step 4: Create input fields\n            TextField(\n              controller: _controller1,\n              keyboardType: const TextInputType.numberWithOptions(decimal: true),\n              decoration: const InputDecoration(labelText: 'Enter first number'),\n            ),\n            TextField(\n              controller: _controller2,\n              keyboardType: const TextInputType.numberWithOptions(decimal: true),\n              decoration: const InputDecoration(labelText: 'Enter second number'),\n            ),\n            const SizedBox(height: 20),\n\n            // Step 5: Create operation buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                ElevatedButton(onPressed: () => calculate('+'), child: const Text('+')),\n                ElevatedButton(onPressed: () => calculate('-'), child: const Text('-')),\n                ElevatedButton(onPressed: () => calculate('*'), child: const Text('*')),\n                ElevatedButton(onPressed: () => calculate('/'), child: const Text('/')),\n              ],\n            ),\n            const SizedBox(height: 20),\n\n            // Step 6: Display the result\n            Text(\n              'Result: $num1 $operation $num2 = ${result.toStringAsFixed(4)}',\n              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n\n            const SizedBox(height: 40),\n\n            // Step 7: Demonstrate additional Decimal features\n            Text('Rounded to 2 decimal places: ${result.round(scale: 2)}'),\n            Text('As a fraction: ${result.toFraction()}'),\n            Text('Is the result an integer? ${result.isInteger}'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 8: Dispose of the controllers\n    _controller1.dispose();\n    _controller2.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays two input fields for numbers and operation buttons.\n// 2. User enters two decimal numbers in the input fields.\n// 3. User selects an operation by tapping one of the operation buttons.\n// 4. The `calculate` method is called with the selected operation.\n// 5. The method parses the input values, performs the calculation using the Decimal package.\n// 6. The result is stored and the UI is updated to show the calculation and result.\n// 7. Additional Decimal features are demonstrated below the main result.\n// 8. The process can be repeated with new inputs or operations.\n\n// Note: This example showcases basic arithmetic, rounding, fraction conversion,\n// and integer checking. The Decimal package offers more advanced features for\n// specific use cases in financial or scientific applications.\n```",
    "dependentPackages": [],
    "lastUpdate": "2024-06-08T18:30:00.000Z",
    "name": "decimal",
    "_id": "uQRNMiDfrp20RZ8Id8Cg41",
    "similarPackages": [
      {
        "_key": "aofv1pmg",
        "_ref": "V06bsD4sX3T8NTHrBPbUDE",
        "_type": "reference"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "likesCount": 347,
    "tutorial": "# Decimal Package in Flutter: A Comprehensive Tutorial\n\n## Getting Started\n\nTo begin using the `decimal` package in your Flutter project, follow these steps:\n\n1. Add the `decimal` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  decimal: ^2.3.2\n```\n\n2. Run `flutter pub get` to fetch the package.\n\n3. Import the package in your Dart file:\n\n```dart\nimport 'package:decimal/decimal.dart';\n```\n\n## Basic Usage\n\n### Creating Decimal Objects\n\nYou can create `Decimal` objects in several ways:\n\n```dart\n// From a string\nDecimal d1 = Decimal.parse('3.14159');\n\n// From an integer\nDecimal d2 = Decimal.fromInt(42);\n\n// From a double (be cautious with this method due to potential precision loss)\nDecimal d3 = Decimal.parse(3.14.toString());\n```\n\n### Arithmetic Operations\n\nPerform arithmetic operations with precision:\n\n```dart\nDecimal a = Decimal.parse('0.1');\nDecimal b = Decimal.parse('0.2');\nDecimal sum = a + b; // Results in 0.3 exactly\n```\n\n### Comparison\n\nCompare `Decimal` objects:\n\n```dart\nDecimal x = Decimal.parse('1.0');\nDecimal y = Decimal.parse('1.00');\nbool isEqual = x == y; // true\n```\n\n### Rounding\n\nControl rounding behavior:\n\n```dart\nDecimal value = Decimal.parse('3.14159');\nDecimal rounded = value.round(scale: 2); // 3.14\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, the `decimal` package uses Java's `BigDecimal` class under the hood, ensuring high-precision arithmetic on Android devices.\n\n### iOS\n\nFor iOS, the package implements its own decimal arithmetic algorithm in Dart, providing consistent behavior across platforms.\n\n### Web\n\nWhen running Flutter web applications, the `decimal` package operates entirely in Dart, maintaining precision in browser environments.\n\n## Advanced Features\n\n### Custom Rounding Modes\n\nThe package supports various rounding modes:\n\n```dart\nDecimal value = Decimal.parse('3.14159');\nDecimal roundedDown = value.round(scale: 2, roundingMode: RoundingMode.floor); // 3.14\nDecimal roundedUp = value.parse('3.14159').round(scale: 2, roundingMode: RoundingMode.ceiling); // 3.15\n```\n\n### Parsing and Formatting\n\nConvert between strings and `Decimal` objects with ease:\n\n```dart\nDecimal number = Decimal.parse('1234.5678');\nString formatted = number.toStringAsFixed(2); // \"1234.57\"\n```\n\nBy mastering these concepts, you'll be well-equipped to handle precise decimal arithmetic in your Flutter applications across all supported platforms."
  },
  {
    "tutorial": "# Flex Color Picker: Implementation Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `flex_color_picker` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `flex_color_picker` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flex_color_picker: ^3.0.0\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:flex_color_picker/flex_color_picker.dart';\n```\n\nTo use the color picker, you can create a simple dialog:\n\n```dart\nFuture<Color> pickColor(BuildContext context, Color currentColor) async {\n  return await showColorPickerDialog(\n    context,\n    currentColor,\n    title: Text('Pick a color!'),\n    width: 40,\n    height: 40,\n    spacing: 0,\n    runSpacing: 0,\n    borderRadius: 0,\n    wheelDiameter: 165,\n    enableOpacity: true,\n    showColorCode: true,\n    colorCodeHasColor: true,\n    pickersEnabled: {\n      ColorPickerType.wheel: true,\n      ColorPickerType.accent: true,\n    },\n    copyPasteBehavior: const ColorPickerCopyPasteBehavior(\n      longPressMenu: true,\n    ),\n    actionButtons: const ColorPickerActionButtons(\n      okButton: true,\n      closeButton: true,\n      dialogActionButtons: true,\n    ),\n  );\n}\n```\n\n## Step 3: Platform-Specific Considerations\n\n### Android\n\nFor Android, the color picker will use Material Design by default. To ensure proper theming, wrap your `MaterialApp` with a `Theme`:\n\n```dart\nreturn MaterialApp(\n  theme: ThemeData(\n    colorSchemeSeed: Colors.blue,\n    useMaterial3: true,\n  ),\n  home: RealFlutter(),\n);\n```\n\n### iOS\n\nFor iOS, you may want to use a more iOS-native look. You can customize the appearance:\n\n```dart\nFuture<Color> pickColor(BuildContext context, Color currentColor) async {\n  return await showColorPickerDialog(\n    context,\n    currentColor,\n    title: Text('Pick a color!'),\n    width: 40,\n    height: 40,\n    spacing: 0,\n    runSpacing: 0,\n    borderRadius: 20,\n    wheelDiameter: 165,\n    enableOpacity: true,\n    showColorCode: true,\n    colorCodeHasColor: true,\n    pickersEnabled: {\n      ColorPickerType.wheel: true,\n      ColorPickerType.accent: true,\n    },\n    copyPasteBehavior: const ColorPickerCopyPasteBehavior(\n      longPressMenu: true,\n    ),\n    actionButtons: const ColorPickerActionButtons(\n      okButton: true,\n      closeButton: true,\n      dialogActionButtons: false,\n    ),\n    constraints: const BoxConstraints(minHeight: 480, minWidth: 320, maxWidth: 320),\n  );\n}\n```\n\n### Web\n\nFor web applications, consider using a responsive layout:\n\n```dart\nLayoutBuilder(\n  builder: (context, constraints) {\n    return SizedBox(\n      width: constraints.maxWidth > 650 ? 650 : constraints.maxWidth,\n      child: ColorPicker(\n        // ... other properties\n      ),\n    );\n  },\n)\n```\n\nBy following these steps and considerations, you'll be able to implement the Flex Color Picker in your Flutter application across different platforms effectively.",
    "tutorialIncluded": true,
    "_rev": "eaCZ7mIhmiYZX5KGqJmWXW",
    "shortDescription": "A customizable Flutter primary, accent and custom color picker. Includes an optional HSV wheel color picker.",
    "dependentPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CU5B",
        "_type": "reference",
        "_key": "pi3htarw"
      }
    ],
    "_createdAt": "2024-08-28T22:20:30Z",
    "lastUpdate": "2024-06-27T18:30:00.000Z",
    "description": "# Flex Color Picker: A Versatile Color Selection Tool for Flutter\n\n## Introduction\n\nThe `flex_color_picker` package is a powerful and customizable color picker widget for Flutter applications. It provides a wide range of features for selecting and manipulating colors, making it an essential tool for developers who need to implement color selection functionality in their apps.\n\n## Key Features\n\n1. **Multiple Selection Modes**: Supports various color selection modes, including wheel, HSV, material, custom swatches, and recently used colors.\n\n2. **Customizable UI**: Offers extensive customization options for the picker's appearance and behavior.\n\n3. **Color Models**: Provides support for different color models, including RGB, HSL, HSV, and more.\n\n4. **Opacity Control**: Allows users to adjust color opacity with a built-in slider.\n\n5. **Accessibility**: Includes features to enhance accessibility, such as color names and contrast ratio calculations.\n\n6. **Localization**: Supports multiple languages and can be easily localized.\n\n7. **Platform Adaptivity**: Automatically adapts to different platforms (iOS, Android, web) for a native look and feel.\n\n## Why Choose Flex Color Picker?\n\nThe `flex_color_picker` package stands out due to its flexibility and comprehensive feature set. Whether you're building a design tool, a theme customizer, or any application that requires color selection, this package provides the tools you need to create a polished and user-friendly color picking experience.\n\nIn the following sections, we'll dive into a tutorial on how to implement the Flex Color Picker in your Flutter application and showcase its features through a practical example.",
    "subCategories": [
      {
        "_key": "daxjvit7",
        "_ref": "4gmBGwifQuSypgRenUbVnc",
        "_type": "reference"
      }
    ],
    "tags": [
      "colorpicker",
      "color",
      "material",
      "hct",
      "rgb",
      "ui",
      "customization"
    ],
    "pubPoint": 160,
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flex_color_picker/flex_color_picker.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flex Color Picker Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        useMaterial3: true,\n      ),\n      home: const ColorPickerDemo(),\n    );\n  }\n}\n\nclass ColorPickerDemo extends StatefulWidget {\n  const ColorPickerDemo({Key? key}) : super(key: key);\n\n  @override\n  _ColorPickerDemoState createState() => _ColorPickerDemoState();\n}\n\nclass _ColorPickerDemoState extends State<ColorPickerDemo> {\n  // Step 1: Initialize variables\n  late Color _selectedColor;\n  late ColorPickerType _currentPickerType;\n  bool _showOpacitySlider = true;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Set initial values\n    _selectedColor = Colors.blue;\n    _currentPickerType = ColorPickerType.wheel;\n  }\n\n  // Step 3: Create a method to show the color picker dialog\n  Future<void> _showColorPicker() async {\n    final Color newColor = await showColorPickerDialog(\n      context,\n      _selectedColor,\n      title: Text('Pick a color!'),\n      width: 40,\n      height: 40,\n      spacing: 0,\n      runSpacing: 0,\n      borderRadius: 0,\n      wheelDiameter: 165,\n      enableOpacity: _showOpacitySlider,\n      showColorCode: true,\n      colorCodeHasColor: true,\n      pickersEnabled: <ColorPickerType, bool>{\n        ColorPickerType.wheel: true,\n        ColorPickerType.accent: true,\n        ColorPickerType.primary: true,\n        ColorPickerType.custom: true,\n      },\n      copyPasteBehavior: const ColorPickerCopyPasteBehavior(\n        longPressMenu: true,\n      ),\n      actionButtons: const ColorPickerActionButtons(\n        okButton: true,\n        closeButton: true,\n        dialogActionButtons: true,\n      ),\n    );\n\n    // Step 4: Update the selected color\n    setState(() {\n      _selectedColor = newColor;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Flex Color Picker Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 5: Display the selected color\n            Container(\n              width: 100,\n              height: 100,\n              color: _selectedColor,\n            ),\n            const SizedBox(height: 20),\n            Text(\n              'Selected Color: ${ColorTools.materialNameAndCode(_selectedColor)}',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedfBox(height: 20),\n            // Step 6: Add a button to open the color picker\n            ElevatedButton(\n              onPressed: _showColorPicker,\n              child: const Text('Open Color Picker'),\n            ),\n            const SizedBox(height: 20),\n            // Step 7: Add a switch to toggle opacity slider\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                const Text('Show Opacity Slider'),\n                Switch(\n                  value: _showOpacitySlider,\n                  onChanged: (value) {\n                    setState(() {\n                      _showOpacitySlider = value;\n                    });\n                  },\n                ),\n              ],\n            ),\n            // Step 8: Add a dropdown to change picker type\n            DropdownButton<ColorPickerType>(\n              value: _currentPickerType,\n              items: ColorPickerType.values.map((ColorPickerType type) {\n                return DropdownMenuItem<ColorPickerType>(\n                  value: type,\n                  child: Text(type.toString().split('.').last),\n                );\n              }).toList(),\n              onChanged: (ColorPickerType? newValue) {\n                if (newValue != null) {\n                  setState(() {\n                    _currentPickerType = newValue;\n                  });\n                }\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with a blue color selected and the wheel picker type.\n// 2. Users can see the selected color displayed in a square container.\n// 3. The color's name and code are shown below the container.\n// 4. Pressing the \"Open Color Picker\" button opens the color picker dialog.\n// 5. In the dialog, users can choose colors using various picker types.\n// 6. The opacity slider can be toggled on/off using the switch.\n// 7. Users can change the default picker type using the dropdown.\n// 8. After selecting a color and pressing OK, the new color is displayed.\n// 9. The process can be repeated to choose different colors.\n\n// This example demonstrates the core features of the flex_color_picker package,\n// including different picker types, opacity control, and custom UI elements.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "_updatedAt": "2024-09-06T04:13:40Z",
    "slug": {
      "current": "flex_color_picker",
      "_type": "slug"
    },
    "name": "flex_color_picker",
    "_id": "uQRNMiDfrp20RZ8Id8CgBN",
    "author": "rydmike.com",
    "_type": "package",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "yxgcqz1p",
        "_ref": "uQRNMiDfrp20RZ8Id8CeUZ"
      }
    ],
    "likesCount": 487,
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-6e05bd2502c298dc11a26f0f9b9ec5f9379403aa-620x918-webp",
        "_type": "reference"
      }
    }
  },
  {
    "tutorial": "# Pointer Interceptor Package Tutorial\n\n## Getting Started\n\n1. Add the package to your `pubspec.yaml` file:\n   ```yaml\n   dependencies:\n     pointer_interceptor: ^0.9.3+4\n   ```\n\n2. Run `flutter pub get` to install the package.\n\n3. Import the package in your Dart file:\n   ```dart\n   import 'package:pointer_interceptor/pointer_interceptor.dart';\n   ```\n\n## Basic Usage\n\nWrap the widget that needs to intercept pointer events with `PointerInterceptor`:\n\n```dart\nPointerInterceptor(\n  child: YourWidget(),\n)\n```\n\n## Platform-Specific Considerations\n\n### Web\n- The `PointerInterceptor` is primarily designed for web applications.\n- It's crucial when your app includes iframes or other embedded content.\n\n### Mobile and Desktop\n- On non-web platforms, `PointerInterceptor` acts as a transparent wrapper.\n- It doesn't affect the behavior of your app on these platforms.\n\n## Advanced Usage\n\n### Conditional Interception\nYou can conditionally apply the interceptor:\n\n```dart\nPointerInterceptor(\n  intercepting: shouldIntercept, // boolean value\n  child: YourWidget(),\n)\n```\n\n### Debugging\nTo visualize the area where pointer events are being intercepted:\n\n```dart\nPointerInterceptor(\n  debug: true,\n  child: YourWidget(),\n)\n```\n\nThis will display a semi-transparent red overlay on the intercepted area.\n\n## Best Practices\n\n1. Use `PointerInterceptor` judiciously to avoid unnecessary overhead.\n2. Always test your web application thoroughly to ensure proper event handling.\n3. Consider the impact on accessibility and ensure your app remains usable with keyboard navigation.\n\nBy following this tutorial, you'll be able to effectively implement the `pointer_interceptor` package in your Flutter web applications, ensuring smooth interaction even with complex layouts involving iframes.",
    "pubPoint": 160,
    "description": "# Pointer Interceptor Package in Flutter\n\n## Description\n\nThe `pointer_interceptor` package is a powerful tool for Flutter developers working on web applications. It addresses a common issue in Flutter web apps where widgets rendered on top of `<iframe>` elements may not receive pointer events as expected.\n\n### Key Features:\n\n1. **Event Interception**: Intercepts pointer events that would otherwise be captured by underlying iframes.\n2. **Seamless Integration**: Easy to incorporate into existing Flutter web projects.\n3. **Customizable**: Allows fine-tuning of which events to intercept and how to handle them.\n4. **Performance Optimized**: Designed to have minimal impact on app performance.\n\n### When to Use:\n\n- Developing Flutter web apps with complex layouts involving iframes\n- Creating overlays or modals that need to be interactive when placed above iframe content\n- Building responsive web designs where Flutter widgets need to interact with iframe-based content\n\n### How It Works:\n\nThe package works by creating a transparent overlay that captures pointer events before they reach the iframe. This overlay then passes these events to the Flutter widgets, ensuring they respond as expected.\n\nBy using the `PointerInterceptor` widget, developers can wrap sections of their UI that need to receive pointer events, effectively solving the \"iframe event eating\" problem in Flutter web applications.",
    "shortDescription": "A widget to prevent clicks from being swallowed by underlying HtmlElementViews on the web.",
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8CgGt",
    "slug": {
      "current": "pointer_interceptor",
      "_type": "slug"
    },
    "_rev": "AE3hjGWNkNE6aGQMMbaU9g",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:pointer_interceptor/pointer_interceptor.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pointer Interceptor Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: PointerInterceptorDemo(),\n    );\n  }\n}\n\nclass PointerInterceptorDemo extends StatefulWidget {\n  @override\n  _PointerInterceptorDemoState createState() => _PointerInterceptorDemoState();\n}\n\nclass _PointerInterceptorDemoState extends State<PointerInterceptorDemo> {\n  bool _intercepting = true;\n  bool _debug = false;\n  int _clickCount = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Pointer Interceptor Demo')),\n      body: Column(\n        children: [\n          // Step 1: Create a container to simulate an iframe\n          Container(\n            height: 200,\n            color: Colors.grey[300],\n            child: Center(child: Text('Simulated iframe content')),\n          ),\n          SizedBox(height: 20),\n          // Step 2: Add controls for intercepting and debugging\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: [\n              ElevatedButton(\n                onPressed: () => setState(() => _intercepting = !_intercepting),\n                child: Text(_intercepting ? 'Disable Intercept' : 'Enable Intercept'),\n              ),\n              ElevatedButton(\n                onPressed: () => setState(() => _debug = !_debug),\n                child: Text(_debug ? 'Disable Debug' : 'Enable Debug'),\n              ),\n            ],\n          ),\n          SizedBox(height: 20),\n          // Step 3: Use PointerInterceptor to wrap the interactive content\n          PointerInterceptor(\n            intercepting: _intercepting,\n            debug: _debug,\n            child: ElevatedButton(\n              onPressed: () => setState(() => _clickCount++),\n              child: Text('Click me!'),\n            ),\n          ),\n          SizedBox(height: 20),\n          // Step 4: Display the click count\n          Text('Button clicked $_clickCount times'),\n        ],\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with a simulated iframe at the top of the screen.\n// 2. Below it, there are two control buttons to toggle interception and debug mode.\n// 3. The main interactive element is a button wrapped in a PointerInterceptor.\n// 4. When interception is enabled (default), clicks on the button are counted normally.\n// 5. If interception is disabled, on a real web app with an iframe, clicks might not register.\n// 6. The debug mode, when enabled, shows a red overlay on the intercepted area.\n// 7. The click count at the bottom updates with each successful button press.\n\n// Key Points:\n// - The PointerInterceptor ensures that clicks reach the button even if it were above an iframe.\n// - Toggling interception demonstrates the difference in behavior with and without the interceptor.\n// - The debug mode helps visualize where the interception is occurring.\n// - This example simulates the behavior you'd see in a real web app with iframes.\n```",
    "platforms": [
      "ios",
      "web"
    ],
    "name": "pointer_interceptor",
    "_updatedAt": "2024-09-06T04:13:41Z",
    "author": "flutter.dev",
    "similarPackages": [
      {
        "_key": "21w6v6f3",
        "_ref": "V06bsD4sX3T8NTHrBPamAG",
        "_type": "reference"
      }
    ],
    "_createdAt": "2024-08-28T22:20:32Z",
    "lastUpdate": "2024-08-04T18:30:00.000Z",
    "tutorialIncluded": true,
    "_type": "package",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGfb",
        "_type": "reference",
        "_key": "6wqsafz3"
      }
    ],
    "tags": [
      "web",
      "widget",
      "pointer-interceptor",
      "event-handling"
    ],
    "likesCount": 226,
    "dependentPackages": []
  },
  {
    "dependentPackages": [
      {
        "_key": "cqn3dvfg",
        "_ref": "uQRNMiDfrp20RZ8Id8CasF",
        "_type": "reference"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1ea7",
        "_type": "reference",
        "_key": "7ghycj19"
      }
    ],
    "_type": "package",
    "shortDescription": "A parser for YAML, a human-friendly data serialization standard",
    "_rev": "eaCZ7mIhmiYZX5KGqJmWe4",
    "_createdAt": "2024-08-28T22:20:33Z",
    "lastUpdate": "2023-05-03T18:30:00.000Z",
    "name": "yaml",
    "tutorial": "# YAML Package for Flutter: A Comprehensive Tutorial\n\n## Step 1: Add Dependencies\n\nFirst, add the YAML package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  yaml: ^3.1.0\n```\n\nRun `flutter pub get` to fetch the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the YAML package:\n\n```dart\nimport 'package:yaml/yaml.dart';\n```\n\n## Step 3: Reading YAML Data\n\n### From a String\n\n```dart\nString yamlString = '''\nname: John Doe\nage: 30\nhobbies:\n  - reading\n  - hiking\n''';\n\nMap<String, dynamic> data = loadYaml(yamlString);\nprint(data['name']); // Output: John Doe\n```\n\n### From a File\n\n```dart\nimport 'dart:io';\n\nFuture<void> loadYamlFile() async {\n  String yamlContent = await File('assets/config.yaml').readAsString();\n  Map<String, dynamic> data = loadYaml(yamlContent);\n  print(data);\n}\n```\n\n## Step 4: Writing YAML Data\n\nTo convert Dart objects to YAML format:\n\n```dart\nimport 'package:yaml/yaml.dart';\n\nMap<String, dynamic> data = {\n  'name': 'Jane Smith',\n  'age': 28,\n  'hobbies': ['painting', 'traveling']\n};\n\nString yamlString = toYamlString(data);\nprint(yamlString);\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nFor Android, ensure that your YAML files are included in the `assets` section of your `pubspec.yaml`:\n\n```yaml\nflutter:\n  assets:\n    - assets/config.yaml\n```\n\n### iOS\n\nFor iOS, the process is similar to Android. Make sure your YAML files are in the `assets` folder and listed in `pubspec.yaml`.\n\n### Web\n\nWhen deploying for web, place your YAML files in the `web` directory of your Flutter project to ensure they're accessible at runtime.\n\n## Best Practices\n\n1. Use `try-catch` blocks when parsing YAML to handle potential errors.\n2. Consider using typed models to represent your YAML data for better type safety.\n3. Keep your YAML files simple and well-structured for easy maintenance.\n\nBy following this tutorial, you'll be able to effectively use the YAML package in your Flutter applications across different platforms.",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "author": "tools.dart.dev",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGdE",
        "_type": "reference",
        "_key": "m8k8skbi"
      }
    ],
    "tags": [
      "yaml",
      "config-format",
      "parsing",
      "serialization"
    ],
    "packageImage": null,
    "_updatedAt": "2024-09-06T04:13:42Z",
    "description": "# YAML Package for Flutter: Simplifying Configuration Management\n\n## Introduction\n\nThe YAML (YAML Ain't Markup Language) package for Flutter is a powerful tool that simplifies the process of reading and writing YAML-formatted data in your Flutter applications. YAML, known for its human-readable format, is widely used for configuration files and data serialization.\n\n## Key Features of the YAML Package\n\n1. **Easy Parsing**: Quickly parse YAML strings into Dart objects.\n2. **Serialization**: Convert Dart objects back into YAML format.\n3. **Type Safety**: Maintain strong typing when working with YAML data.\n4. **Flexibility**: Handle complex nested structures and various data types.\n\n## Why Use YAML in Flutter?\n\n- **Readability**: YAML's clean syntax makes it easy for both developers and non-technical users to understand and edit.\n- **Configurability**: Ideal for managing app configurations, localizations, or any structured data.\n- **Integration**: Seamlessly integrates with Flutter's ecosystem and Dart's type system.\n\nIn the following sections, we'll dive deeper into how to use the YAML package in your Flutter projects, including a step-by-step tutorial and a comprehensive example demonstrating its features.",
    "similarPackages": [],
    "likesCount": 242,
    "_id": "uQRNMiDfrp20RZ8Id8CgMP",
    "slug": {
      "current": "yaml",
      "_type": "slug"
    },
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:yaml/yaml.dart';\nimport 'dart:async';\nimport 'package:flutter/services.dart' show rootBundle;\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'YAML Flutter Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const YamlDemoHome(),\n    );\n  }\n}\n\nclass YamlDemoHome extends StatefulWidget {\n  const YamlDemoHome({Key? key}) : super(key: key);\n\n  @override\n  _YamlDemoHomeState createState() => _YamlDemoHomeState();\n}\n\nclass _YamlDemoHomeState extends State<YamlDemoHome> {\n  Map<String, dynamic>? _configData;\n  String _yamlOutput = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _loadYamlData();\n  }\n\n  // Step 1: Load YAML data from asset file\n  Future<void> _loadYamlData() async {\n    try {\n      final yamlString = await rootBundle.loadString('assets/config.yaml');\n      setState(() {\n        _configData = loadYaml(yamlString);\n        _yamlOutput = 'Loaded YAML Data:\\n$_configData';\n      });\n    } catch (e) {\n      setState(() {\n        _yamlOutput = 'Error loading YAML: $e';\n      });\n    }\n  }\n\n  // Step 2: Update YAML data\n  void _updateYamlData() {\n    if (_configData != null) {\n      setState(() {\n        _configData!['appName'] = 'Updated YAML Demo';\n        _configData!['version'] = 2.0;\n        _configData!['features'].add('new feature');\n        _yamlOutput = 'Updated YAML Data:\\n$_configData';\n      });\n    }\n  }\n\n  // Step 3: Convert Dart map to YAML string\n  void _convertToYaml() {\n    if (_configData != null) {\n      final yamlString = toYamlString(_configData!);\n      setState(() {\n        _yamlOutput = 'Converted to YAML:\\n$yamlString';\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('YAML Flutter Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            ElevatedButton(\n              onPressed: _loadYamlData,\n              child: const Text('Load YAML'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _updateYamlData,\n              child: const Text('Update YAML'),\n            ),\n            const SizedBox(height: 10),\n            ElevatedButton(\n              onPressed: _convertToYaml,\n              child: const Text('Convert to YAML'),\n            ),\n            const SizedBox(height: 20),\n            Expanded(\n              child: SingleChildScrollView(\n                child: Text(_yamlOutput),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays three buttons: Load YAML, Update YAML, and Convert to YAML.\n// 2. When \"Load YAML\" is pressed, it reads the config.yaml file from assets and displays its content.\n// 3. \"Update YAML\" modifies the loaded data in memory, updating specific fields.\n// 4. \"Convert to YAML\" takes the current data (either loaded or updated) and converts it back to a YAML string.\n// 5. The output of each operation is displayed in the scrollable text area below the buttons.\n//\n// This demo showcases:\n// - Loading YAML from an asset file\n// - Parsing YAML into a Dart Map\n// - Modifying YAML data programmatically\n// - Converting Dart objects back to YAML format\n//\n// Note: Ensure you have a config.yaml file in your assets folder for this demo to work correctly.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ]
  },
  {
    "tutorialIncluded": true,
    "pubPoint": 160,
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:audio_video_progress_bar/audio_video_progress_bar.dart';\nimport 'package:just_audio/just_audio.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Audio Video Progress Bar Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const AudioPlayerScreen(),\n    );\n  }\n}\n\nclass AudioPlayerScreen extends StatefulWidget {\n  const AudioPlayerScreen({Key? key}) : super(key: key);\n\n  @override\n  _AudioPlayerScreenState createState() => _AudioPlayerScreenState();\n}\n\nclass _AudioPlayerScreenState extends State<AudioPlayerScreen> {\n  // Step 1: Initialize the AudioPlayer\n  late AudioPlayer _audioPlayer;\n\n  // Step 2: Define variables for tracking playback state\n  Duration _duration = Duration.zero;\n  Duration _position = Duration.zero;\n  bool _isPlaying = false;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 3: Set up the AudioPlayer and its event listeners\n    _audioPlayer = AudioPlayer();\n    _setupAudioPlayer();\n  }\n\n  void _setupAudioPlayer() async {\n    // Step 4: Load the audio file\n    await _audioPlayer.setAsset('assets/audio/sample.mp3');\n\n    // Step 5: Set up listeners for player state changes\n    _audioPlayer.durationStream.listen((newDuration) {\n      setState(() {\n        _duration = newDuration ?? Duration.zero;\n      });\n    });\n\n    _audioPlayer.positionStream.listen((newPosition) {\n      setState(() {\n        _position = newPosition;\n      });\n    });\n\n    _audioPlayer.playerStateStream.listen((playerState) {\n      setState(() {\n        _isPlaying = playerState.playing;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Audio Player Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(20.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Step 6: Implement the ProgressBar widget\n            ProgressBar(\n              progress: _position,\n              total: _duration,\n              buffered: Duration.zero, // Add buffering if streaming\n              onSeek: (duration) {\n                _audioPlayer.seek(duration);\n              },\n              onDragUpdate: (details) {\n                // Optional: Implement custom behavior while dragging\n              },\n              // Customization options\n              progressBarColor: Colors.red,\n              baseBarColor: Colors.grey[300],\n              bufferedBarColor: Colors.grey[500],\n              thumbColor: Colors.red,\n              barHeight: 5.0,\n              thumbRadius: 7.0,\n            ),\n            const SizedBox(height: 20),\n            // Step 7: Add play/pause button\n            IconButton(\n              icon: Icon(_isPlaying ? Icons.pause : Icons.play_arrow),\n              iconSize: 50,\n              onPressed: () {\n                if (_isPlaying) {\n                  _audioPlayer.pause();\n                } else {\n                  _audioPlayer.play();\n                }\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 8: Dispose of the AudioPlayer when the widget is removed\n    _audioPlayer.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The app starts and initializes the AudioPlayer in the initState method.\n// 2. The audio file is loaded and event listeners are set up to track duration, position, and playback state.\n// 3. The UI is built with a ProgressBar widget that displays the current position and total duration of the audio.\n// 4. The ProgressBar allows seeking by tapping or dragging on the bar.\n// 5. A play/pause button is provided to control playback.\n// 6. The UI updates in real-time as the audio plays or when the user interacts with the controls.\n// 7. When the widget is disposed, the AudioPlayer is also disposed to free up resources.\n\n// Note: Make sure to add the audio file to your assets and declare it in the pubspec.yaml file.\n// Also, remember to add necessary permissions for audio playback in your AndroidManifest.xml and Info.plist files as mentioned in the tutorial section.\n```",
    "tags": [
      "audio",
      "video",
      "progress-bar",
      "media",
      "ui"
    ],
    "_createdAt": "2024-08-28T22:20:36Z",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1ZXr",
        "_type": "reference",
        "_key": "smw2cymx"
      }
    ],
    "name": "audio_video_progress_bar",
    "tutorial": "# Tutorial: Implementing audio_video_progress_bar in Flutter\n\nThis tutorial will guide you through the process of integrating the `audio_video_progress_bar` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `audio_video_progress_bar` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  audio_video_progress_bar: ^1.0.1\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:audio_video_progress_bar/audio_video_progress_bar.dart';\n```\n\n## Step 3: Basic Usage\n\nHere's a simple example of how to use the `ProgressBar` widget:\n\n```dart\nProgressBar(\n  progress: Duration(milliseconds: 1000),\n  total: Duration(milliseconds: 5000),\n  onSeek: (duration) {\n    // Handle seek\n  },\n)\n```\n\n## Step 4: Customization\n\nYou can customize the appearance of the progress bar:\n\n```dart\nProgressBar(\n  progress: Duration(milliseconds: 1000),\n  total: Duration(milliseconds: 5000),\n  progressBarColor: Colors.red,\n  baseBarColor: Colors.white.withOpacity(0.24),\n  bufferedBarColor: Colors.white.withOpacity(0.24),\n  thumbColor: Colors.white,\n  barHeight: 3.0,\n  thumbRadius: 5.0,\n  onSeek: (duration) {\n    // Handle seek\n  },\n)\n```\n\n## Platform-Specific Considerations\n\n### iOS\n\nFor iOS, ensure that you have the latest Xcode version installed. In your `ios/Runner/Info.plist` file, add the following permissions if you're using this with audio or video playback:\n\n```xml\n<key>NSMicrophoneUsageDescription</key>\n<string>This app needs access to microphone for audio playback</string>\n```\n\n### Android\n\nFor Android, add the following permissions to your `android/app/src/main/AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n```\n\nIf you're targeting Android 12 (API level 31) or higher, also add:\n\n```xml\n<uses-permission android:name=\"android.permission.SCHEDULE_EXACT_ALARM\"/>\n```\n\n## Integrating with Audio Players\n\nThe `audio_video_progress_bar` package works well with various audio player packages. Here's an example using the `just_audio` package:\n\n```dart\nimport 'package:just_audio/just_audio.dart';\n\n// ... in your widget\nfinal _player = AudioPlayer();\n\n// ... in your build method\nStreamBuilder<Duration?>(\n  stream: _player.positionStream,\n  builder: (context, snapshot) {\n    final position = snapshot.data ?? Duration.zero;\n    return ProgressBar(\n      progress: position,\n      total: _player.duration ?? Duration.zero,\n      onSeek: (duration) {\n        _player.seek(duration);\n      },\n    );\n  },\n)\n```\n\nThis setup will update the progress bar in real-time as the audio plays and allow seeking through the audio file.\n\nBy following these steps and considering the platform-specific details, you can successfully implement the `audio_video_progress_bar` package in your Flutter project, enhancing the media playback experience for your users.",
    "likesCount": 385,
    "lastUpdate": "2024-05-21T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:13:43Z",
    "description": "# Audio Video Progress Bar Package for Flutter\n\n## Introduction\n\nThe `audio_video_progress_bar` package is a powerful and customizable widget for Flutter applications that provides a sleek and interactive progress bar for audio and video playback. This package is essential for developers looking to implement media players with advanced seeking capabilities and real-time progress tracking.\n\n## Key Features\n\n1. **Customizable Appearance**: The progress bar can be easily styled to match your app's design, with options to change colors, sizes, and shapes.\n\n2. **Smooth Seeking**: Users can interact with the progress bar to seek to different parts of the media, providing a seamless playback experience.\n\n3. **Buffer Indication**: The widget can display buffered regions, which is particularly useful for streaming media.\n\n4. **Adaptive Layout**: The progress bar automatically adjusts to fit various screen sizes and orientations.\n\n5. **Real-time Updates**: The progress bar updates in real-time as the media plays, providing accurate visual feedback to the user.\n\n6. **Compatibility**: Works well with both audio and video players in Flutter, making it a versatile choice for various media applications.\n\n## Why Use audio_video_progress_bar?\n\n- **Enhanced User Experience**: Provides visual feedback on media progress and allows intuitive seeking.\n- **Easy Integration**: Simple to implement and customize within your Flutter project.\n- **Performance**: Optimized for smooth performance, even with frequent updates.\n- **Cross-platform**: Works seamlessly on both iOS and Android platforms.\n\nIn the following sections, we'll dive into a tutorial on how to implement this package in your Flutter project and showcase its features with a comprehensive example.",
    "shortDescription": "A progress bar widget to show or change the position of an audio or video stream.",
    "similarPackages": [
      {
        "_key": "m304vacf",
        "_ref": "V06bsD4sX3T8NTHrBPagYC",
        "_type": "reference"
      }
    ],
    "subCategories": [
      {
        "_key": "kd4bveut",
        "_ref": "4gmBGwifQuSypgRenUbW9O",
        "_type": "reference"
      }
    ],
    "_id": "uQRNMiDfrp20RZ8Id8CgTl",
    "slug": {
      "current": "audio_video_progress_bar",
      "_type": "slug"
    },
    "author": "suragch.dev",
    "_rev": "AE3hjGWNkNE6aGQMMbaUCs",
    "_type": "package",
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-16bd06b438fbf6b603c979e8ba12d67012b8a94a-322x67-webp",
        "_type": "reference"
      }
    }
  },
  {
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "8yya5fhz",
        "_ref": "uQRNMiDfrp20RZ8Id8CblP"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:awesome_snackbar_content/awesome_snackbar_content.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Awesome Snackbar Content Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        useMaterial3: true,\n      ),\n      home: const SnackbarDemo(),\n    );\n  }\n}\n\nclass SnackbarDemo extends StatelessWidget {\n  const SnackbarDemo({Key? key}) : super(key: key);\n\n  // Step 1: Create a method to show the awesome snackbar\n  void _showAwesomeSnackbar(BuildContext context, String title, String message, ContentType contentType) {\n    final snackBar = SnackBar(\n      elevation: 0,\n      behavior: SnackBarBehavior.floating,\n      backgroundColor: Colors.transparent,\n      content: AwesomeSnackbarContent(\n        title: title,\n        message: message,\n        contentType: contentType,\n      ),\n    );\n\n    ScaffoldMessenger.of(context)\n      ..hideCurrentSnackBar()\n      ..showSnackBar(snackBar);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Awesome Snackbar Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Add buttons to trigger different types of snackbars\n            ElevatedButton(\n              onPressed: () => _showAwesomeSnackbar(\n                context,\n                'Success!',\n                'You have successfully used the awesome snackbar!',\n                ContentType.success,\n              ),\n              child: const Text('Show Success Snackbar'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _showAwesomeSnackbar(\n                context,\n                'Warning!',\n                'This is a warning message. Please proceed with caution.',\n                ContentType.warning,\n              ),\n              child: const Text('Show Warning Snackbar'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _showAwesomeSnackbar(\n                context,\n                'Error!',\n                'An error occurred. Please try again later.',\n                ContentType.failure,\n              ),\n              child: const Text('Show Error Snackbar'),\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () => _showAwesomeSnackbar(\n                context,\n                'Help',\n                'This is a help message. Tap for more information.',\n                ContentType.help,\n              ),\n              child: const Text('Show Help Snackbar'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts with a simple UI containing four buttons.\n// 2. Each button corresponds to a different type of snackbar (Success, Warning, Error, Help).\n// 3. When a button is pressed, it calls the _showAwesomeSnackbar method.\n// 4. The _showAwesomeSnackbar method creates and shows a customized snackbar based on the input parameters.\n// 5. The snackbar appears at the bottom of the screen with smooth animation.\n// 6. The snackbar displays the title, message, and an icon corresponding to its content type.\n// 7. The snackbar automatically dismisses after a few seconds, or the user can swipe it away.\n// 8. If a new snackbar is triggered while one is already showing, the current one is hidden and the new one is displayed.\n\n// This example demonstrates the core features of the awesome_snackbar_content package,\n// including different content types, customized messages, and easy integration with Flutter's ScaffoldMessenger.\n```",
    "lastUpdate": "2023-04-14T18:30:00.000Z",
    "tutorial": "# Awesome Snackbar Content: Implementation Tutorial\n\nIn this tutorial, we'll walk through the process of integrating the `awesome_snackbar_content` package into your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `awesome_snackbar_content` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  awesome_snackbar_content: ^0.1.3\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Basic Usage\n\nImport the package in your Dart file:\n\n```dart\nimport 'package:awesome_snackbar_content/awesome_snackbar_content.dart';\n```\n\nTo use the awesome snackbar, you can create it like this:\n\n```dart\nvoid showAwesomeSnackbar(BuildContext context, String title, String message, ContentType contentType) {\n  final snackBar = SnackBar(\n    elevation: 0,\n    behavior: SnackBarBehavior.floating,\n    backgroundColor: Colors.transparent,\n    content: AwesomeSnackbarContent(\n      title: title,\n      message: message,\n      contentType: contentType,\n    ),\n  );\n\n  ScaffoldMessenger.of(context)\n    ..hideCurrentSnackBar()\n    ..showSnackBar(snackBar);\n}\n```\n\n## Step 3: Platform-Specific Considerations\n\n### Android\n\nFor Android, the snackbar will use Material Design by default. To ensure proper theming, wrap your `MaterialApp` with a `Theme`:\n\n```dart\nreturn MaterialApp(\n  theme: ThemeData(\n    colorSchemeSeed: Colors.blue,\n    useMaterial3: true,\n  ),\n  home: RealFlutter(),\n);\n```\n\n### iOS\n\nFor iOS, you may want to adjust the snackbar's appearance to fit the iOS design language:\n\n```dart\nfinal snackBar = SnackBar(\n  elevation: 0,\n  behavior: SnackBarBehavior.floating,\n  backgroundColor: Colors.transparent,\n  content: AwesomeSnackbarContent(\n    title: title,\n    message: message,\n    contentType: contentType,\n    // Adjust these properties for iOS\n    inMaterialBanner: false,\n    // You can also customize colors and fonts here\n  ),\n);\n```\n\n### Web\n\nFor web applications, consider the positioning of the snackbar:\n\n```dart\nfinal snackBar = SnackBar(\n  elevation: 0,\n  behavior: SnackBarBehavior.floating,\n  backgroundColor: Colors.transparent,\n  content: AwesomeSnackbarContent(\n    title: title,\n    message: message,\n    contentType: contentType,\n  ),\n  // Adjust positioning for web\n  margin: EdgeInsets.only(\n    bottom: MediaQuery.of(context).size.height - 100,\n    right: 20,\n    left: 20,\n  ),\n);\n```\n\nBy following these steps and considerations, you'll be able to implement the Awesome Snackbar Content in your Flutter application across different platforms effectively.",
    "pubPoint": 160,
    "description": "# Awesome Snackbar Content: Elevating User Notifications in Flutter\n\n## Introduction\n\nThe `awesome_snackbar_content` package is a powerful and customizable solution for creating visually appealing and informative snackbars in Flutter applications. It provides an enhanced way to display notifications, messages, and feedback to users, going beyond the standard SnackBar widget provided by Flutter.\n\n## Key Features\n\n1. **Pre-designed Templates**: Offers ready-to-use templates for different types of messages (e.g., success, warning, error, help).\n\n2. **Customizable Appearance**: Allows extensive customization of colors, icons, and layouts to match your app's design.\n\n3. **Rich Content**: Supports title, message, and custom icons for more informative notifications.\n\n4. **Animated Presentation**: Includes smooth animations for a polished user experience.\n\n5. **Accessibility**: Designed with accessibility in mind, ensuring that notifications are clear and readable.\n\n6. **Easy Integration**: Simple to implement and integrate into existing Flutter projects.\n\n7. **Cross-platform Compatibility**: Works seamlessly across iOS, Android, and web platforms.\n\n## Why Choose Awesome Snackbar Content?\n\nThe `awesome_snackbar_content` package stands out due to its combination of aesthetics and functionality. It allows developers to create eye-catching notifications that not only look great but also effectively communicate important information to users. Whether you're building a social media app, a productivity tool, or any application that requires user feedback, this package provides the tools you need to create a superior notification experience.\n\nIn the following sections, we'll dive into a tutorial on how to implement Awesome Snackbar Content in your Flutter application and showcase its features through a practical example.",
    "_id": "uQRNMiDfrp20RZ8Id8CgZH",
    "tutorialIncluded": true,
    "slug": {
      "current": "awesome_snackbar_content",
      "_type": "slug"
    },
    "_type": "package",
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1u2B",
        "_type": "reference",
        "_key": "hdignpbh"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8ChOl",
        "_type": "reference",
        "_key": "vlxnyuwf"
      }
    ],
    "likesCount": 720,
    "shortDescription": "Uplift your snackbar experience with various alert messages i.e. success, failure, help or warning with unique UI design.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr",
        "_type": "reference",
        "_key": "z1qaatbh"
      }
    ],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tags": [
      "snackbar",
      "notification",
      "ui",
      "toast"
    ],
    "packageImage": null,
    "_createdAt": "2024-08-28T22:20:37Z",
    "name": "awesome_snackbar_content",
    "_updatedAt": "2024-09-06T04:13:44Z",
    "author": "mhmz.dev",
    "_rev": "ezMiwuUkJkbYMWycA6RgkG"
  },
  {
    "slug": {
      "current": "flutter_timezone",
      "_type": "slug"
    },
    "pubPoint": 160,
    "author": "wolverinebeach.net",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "c82jf9up",
        "_ref": "V06bsD4sX3T8NTHrBPamwS"
      }
    ],
    "tags": [
      "timezone",
      "date-time",
      "localization"
    ],
    "lastUpdate": "2024-08-20T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:13:45Z",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:flutter_timezone/flutter_timezone.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Timezone Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: TimeZonePage(),\n    );\n  }\n}\n\nclass TimeZonePage extends StatefulWidget {\n  @override\n  _TimeZonePageState createState() => _TimeZonePageState();\n}\n\nclass _TimeZonePageState extends State<TimeZonePage> {\n  String _localTimeZone = 'Unknown';\n  List<String> _availableTimeZones = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _loadTimeZoneInfo();\n  }\n\n  // Step 1: Load time zone information\n  Future<void> _loadTimeZoneInfo() async {\n    try {\n      // Step 2: Get the local time zone\n      String localTimeZone = await FlutterTimezone.getLocalTimezone();\n      \n      // Step 3: Get the list of available time zones\n      List<String> availableTimeZones = await FlutterTimezone.getAvailableTimezones();\n      \n      // Step 4: Update the state with the retrieved information\n      setState(() {\n        _localTimeZone = localTimeZone;\n        _availableTimeZones = availableTimeZones;\n      });\n    } catch (e) {\n      // Step 5: Handle any errors that occur during the process\n      print('Error loading time zone info: $e');\n      setState(() {\n        _localTimeZone = 'Error: Unable to get local time zone';\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Flutter Timezone Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 6: Display the local time zone\n            Text(\n              'Local Time Zone:',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            Text(\n              _localTimeZone,\n              style: TextStyle(fontSize: 18),\n            ),\n            SizedBox(height: 20),\n            // Step 7: Display the list of available time zones\n            Text(\n              'Available Time Zones:',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            Expanded(\n              child: ListView.builder(\n                itemCount: _availableTimeZones.length,\n                itemBuilder: (context, index) {\n                  return ListTile(\n                    title: Text(_availableTimeZones[index]),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and the RealFlutter widget is created, which sets up the MaterialApp.\n// 2. The TimeZonePage is set as the home page.\n// 3. In the TimeZonePage's initState, _loadTimeZoneInfo() is called.\n// 4. _loadTimeZoneInfo() asynchronously fetches the local time zone and available time zones.\n// 5. Once the data is fetched, the state is updated, triggering a rebuild of the UI.\n// 6. The UI displays the local time zone at the top.\n// 7. Below that, a scrollable list of all available time zones is shown.\n// 8. If any errors occur during the process, they are caught and handled appropriately.\n\n// This example demonstrates how to use the flutter_timezone package to retrieve\n// and display time zone information in a Flutter app. It showcases both getting\n// the local time zone and listing all available time zones.\n```",
    "dependentPackages": [],
    "_id": "uQRNMiDfrp20RZ8Id8Cgen",
    "_rev": "eaCZ7mIhmiYZX5KGqJmWkc",
    "description": "# Flutter Timezone Package: Simplifying Time Zone Management in Flutter Apps\n\nThe `flutter_timezone` package is a powerful tool for Flutter developers who need to work with time zones in their applications. This package provides a simple and efficient way to get the device's time zone and list all available time zones.\n\n## Key Features\n\n1. **Get Local Time Zone**: Easily retrieve the device's current time zone.\n2. **List All Time Zones**: Access a comprehensive list of all available time zones.\n3. **Cross-Platform Compatibility**: Works seamlessly on both Android and iOS platforms.\n4. **Easy Integration**: Simple to add to your Flutter project and start using right away.\n\n## Why Use flutter_timezone?\n\nTime zone management is crucial for many applications, especially those dealing with scheduling, travel, or international operations. The `flutter_timezone` package simplifies this process by providing direct access to the device's time zone information, eliminating the need for complex workarounds or platform-specific code.\n\nWhether you're building a world clock app, a flight booking system, or any application that needs to be time zone aware, `flutter_timezone` offers a straightforward solution to handle time zone-related tasks efficiently.\n\nIn the following sections, we'll dive into how to set up and use this package in your Flutter applications, along with a practical example to demonstrate its capabilities.",
    "shortDescription": "A flutter plugin for getting the local timezone of the device.",
    "platforms": [
      "android",
      "ios",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "subCategories": [
      {
        "_type": "reference",
        "_key": "xz7z4xa0",
        "_ref": "4gmBGwifQuSypgRenUbXf1"
      }
    ],
    "likesCount": 199,
    "_createdAt": "2024-08-28T22:20:41Z",
    "name": "flutter_timezone",
    "tutorial": "# Flutter Timezone Package: Tutorial\n\nThis tutorial will guide you through the process of integrating and using the `flutter_timezone` package in your Flutter application.\n\n## Step 1: Add Dependencies\n\nFirst, add the `flutter_timezone` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_timezone: ^1.0.4\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:flutter_timezone/flutter_timezone.dart';\n```\n\n## Step 3: Platform-Specific Setup\n\n### Android Setup\n\nFor Android, no additional setup is required. The package works out of the box.\n\n### iOS Setup\n\nFor iOS, you need to add the following keys to your `Info.plist` file:\n\n```xml\n<key>NSTimeZoneUsageDescription</key>\n<string>This app requires access to the device's time zone.</string>\n```\n\nThis step is necessary to request permission to access the device's time zone information on iOS.\n\n## Step 4: Using the Package\n\nNow you're ready to use the `flutter_timezone` package in your app. Here are the main functions you'll be using:\n\n### Get the Local Time Zone\n\nTo get the device's current time zone:\n\n```dart\nString timeZoneName = await FlutterTimezone.getLocalTimezone();\n```\n\n### Get the List of Available Time Zones\n\nTo get a list of all available time zones:\n\n```dart\nList<String> timeZones = await FlutterTimezone.getAvailableTimezones();\n```\n\n## Step 5: Error Handling\n\nIt's important to handle potential errors when working with device-specific information. Wrap your calls in a try-catch block:\n\n```dart\ntry {\n  String timeZoneName = await FlutterTimezone.getLocalTimezone();\n  // Use the time zone name\n} catch (e) {\n  print('Error getting time zone: $e');\n  // Handle the error appropriately\n}\n```\n\nBy following these steps, you'll be able to effectively integrate and use the `flutter_timezone` package in your Flutter application. In the next section, we'll look at a complete example that demonstrates all the features of this package.",
    "tutorialIncluded": true
  },
  {
    "tags": [
      "dialog",
      "adaptive",
      "alert",
      "popup",
      "ui"
    ],
    "dependentPackages": [],
    "packageImage": {
      "_type": "image",
      "asset": {
        "_ref": "image-d06e7be35d28dc8ed78050368d09c49ef5275fec-616x404-webp",
        "_type": "reference"
      }
    },
    "_rev": "eaCZ7mIhmiYZX5KGqJmWxi",
    "description": "# Adaptive Dialog Package in Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `adaptive_dialog` package is a powerful tool for Flutter developers looking to create platform-adaptive dialogs and sheets. This package allows you to easily implement dialogs that automatically adjust their appearance and behavior based on the platform they're running on, providing a native look and feel for both iOS and Android devices.\n\n### Key Features:\n\n1. **Platform Adaptivity**: Automatically adjusts dialog appearance and behavior based on the operating system.\n2. **Variety of Dialog Types**: Supports various dialog types including alerts, confirmations, text input, and more.\n3. **Customization Options**: Offers extensive customization possibilities for dialog content and style.\n4. **Ease of Use**: Provides a simple API for quick implementation of complex dialogs.\n5. **Accessibility**: Ensures dialogs are accessible and follow platform-specific guidelines.\n\n### Why Use Adaptive Dialog?\n\nWhen developing cross-platform applications, maintaining a consistent user experience while adhering to platform-specific design guidelines can be challenging. The `adaptive_dialog` package solves this problem by:\n\n- Reducing development time and effort required to create platform-specific dialogs.\n- Ensuring a native look and feel on both iOS and Android platforms.\n- Providing a unified API for creating various types of dialogs.\n- Allowing easy customization to match your app's design language.\n\nIn the following sections, we'll dive deeper into how to implement and use the `adaptive_dialog` package in your Flutter projects.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr",
        "_type": "reference",
        "_key": "5rkw1vrb"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:adaptive_dialog/adaptive_dialog.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Adaptive Dialog Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: AdaptiveDialogDemo(),\n    );\n  }\n}\n\nclass AdaptiveDialogDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Adaptive Dialog Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Show Alert Dialog'),\n              onPressed: () => _showAlertDialog(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Confirmation Dialog'),\n              onPressed: () => _showConfirmationDialog(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Text Input Dialog'),\n              onPressed: () => _showTextInputDialog(context),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Platform-Specific Dialog'),\n              onPressed: () => _showPlatformSpecificDialog(context),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Implement Alert Dialog\n  Future<void> _showAlertDialog(BuildContext context) async {\n    await showOkAlertDialog(\n      context: context,\n      title: 'Alert',\n      message: 'This is a simple alert dialog.',\n    );\n  }\n\n  // Step 2: Implement Confirmation Dialog\n  Future<void> _showConfirmationDialog(BuildContext context) async {\n    final result = await showOkCancelAlertDialog(\n      context: context,\n      title: 'Confirmation',\n      message: 'Are you sure you want to proceed?',\n      okLabel: 'Yes',\n      cancelLabel: 'No',\n    );\n    \n    if (result == OkCancelResult.ok) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Action confirmed')),\n      );\n    } else {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Action cancelled')),\n      );\n    }\n  }\n\n  // Step 3: Implement Text Input Dialog\n  Future<void> _showTextInputDialog(BuildContext context) async {\n    final result = await showTextInputDialog(\n      context: context,\n      title: 'Enter your name',\n      textFields: [\n        DialogTextField(hintText: 'First Name'),\n        DialogTextField(hintText: 'Last Name'),\n      ],\n    );\n    \n    if (result != null && result.length == 2) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Hello, ${result[0]} ${result[1]}!')),\n      );\n    }\n  }\n\n  // Step 4: Implement Platform-Specific Dialog\n  Future<void> _showPlatformSpecificDialog(BuildContext context) async {\n    await showAlertDialog(\n      context: context,\n      title: 'Platform-Specific Dialog',\n      message: 'This dialog adapts to the current platform.',\n      style: Theme.of(context).platform == TargetPlatform.iOS\n          ? AdaptiveStyle.iOS\n          : AdaptiveStyle.material,\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons.\n// 2. When \"Show Alert Dialog\" is pressed, a simple alert dialog is shown.\n// 3. When \"Show Confirmation Dialog\" is pressed, a confirmation dialog appears.\n//    The user's choice is then displayed in a snackbar.\n// 4. When \"Show Text Input Dialog\" is pressed, a dialog with two text fields appears.\n//    The entered names are then displayed in a snackbar.\n// 5. When \"Show Platform-Specific Dialog\" is pressed, a dialog adapts its style\n//    based on the current platform (iOS or Android).\n// \n// This example demonstrates the versatility of the adaptive_dialog package,\n// showing how it can be used to create various types of dialogs that\n// automatically adapt to the platform they're running on.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2024-08-26T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8Cgrf",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:46Z",
    "shortDescription": "Show alert dialog or modal action sheet adaptively according to platform.",
    "likesCount": 983,
    "_createdAt": "2024-08-28T22:20:50Z",
    "name": "adaptive_dialog",
    "tutorial": "## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of implementing the `adaptive_dialog` package in a Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nTo get started with the `adaptive_dialog` package, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  adaptive_dialog: ^1.9.0-0\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Basic Usage\n\nTo use the `adaptive_dialog` package in your Flutter project, first import it:\n\n```dart\nimport 'package:adaptive_dialog/adaptive_dialog.dart';\n```\n\nNow, let's look at how to implement various types of dialogs:\n\n#### Alert Dialog\n\n```dart\nFuture<void> showAlertDialog(BuildContext context) async {\n  await showOkAlertDialog(\n    context: context,\n    title: 'Alert',\n    message: 'This is a simple alert dialog.',\n  );\n}\n```\n\n#### Confirmation Dialog\n\n```dart\nFuture<void> showConfirmationDialog(BuildContext context) async {\n  final result = await showOkCancelAlertDialog(\n    context: context,\n    title: 'Confirmation',\n    message: 'Are you sure you want to proceed?',\n    okLabel: 'Yes',\n    cancelLabel: 'No',\n  );\n  \n  if (result == OkCancelResult.ok) {\n    // User confirmed\n  } else {\n    // User cancelled\n  }\n}\n```\n\n#### Text Input Dialog\n\n```dart\nFuture<void> showTextInputDialog(BuildContext context) async {\n  final result = await showTextInputDialog(\n    context: context,\n    title: 'Enter your name',\n    textFields: [\n      DialogTextField(hintText: 'Name'),\n    ],\n  );\n  \n  if (result != null && result.isNotEmpty) {\n    print('Entered name: ${result[0]}');\n  }\n}\n```\n\n### Platform-Specific Considerations\n\nThe `adaptive_dialog` package automatically adjusts its appearance based on the platform. However, you can further customize the dialogs for each platform:\n\n#### iOS-Specific\n\nFor iOS, the package uses `CupertinoAlertDialog`. You can customize the iOS style by providing `ios` specific parameters:\n\n```dart\nawait showOkAlertDialog(\n  context: context,\n  title: 'iOS Alert',\n  message: 'This is an iOS-style alert.',\n  style: AdaptiveStyle.iOS,\n);\n```\n\n#### Android-Specific\n\nFor Android, the package uses `AlertDialog`. You can customize the Android style by providing `android` specific parameters:\n\n```dart\nawait showOkAlertDialog(\n  context: context,\n  title: 'Android Alert',\n  message: 'This is an Android-style alert.',\n  style: AdaptiveStyle.material,\n);\n```\n\nBy leveraging these platform-specific options, you can ensure that your dialogs look and feel native on both iOS and Android devices while maintaining a single codebase.",
    "pubPoint": 160,
    "author": "mono0926.com",
    "_type": "package",
    "similarPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1uCp",
        "_type": "reference",
        "_key": "f8v2qmqr"
      }
    ],
    "slug": {
      "current": "adaptive_dialog",
      "_type": "slug"
    }
  },
  {
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:characters/characters.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Characters Package Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const CharactersDemoPage(),\n    );\n  }\n}\n\nclass CharactersDemoPage extends StatefulWidget {\n  const CharactersDemoPage({Key? key}) : super(key: key);\n\n  @override\n  _CharactersDemoPageState createState() => _CharactersDemoPageState();\n}\n\nclass _CharactersDemoPageState extends State<CharactersDemoPage> {\n  final String _sampleText = 'Hello ! Caf ';\n  String _result = '';\n\n  // Step 1: Character Count\n  void _countCharacters() {\n    setState(() {\n      _result = 'Character count: ${_sampleText.characters.length}';\n    });\n  }\n\n  // Step 2: Reverse String\n  void _reverseString() {\n    setState(() {\n      _result = 'Reversed: ${_sampleText.characters.toList().reversed.join()}';\n    });\n  }\n\n  // Step 3: Substring Operation\n  void _substringOperation() {\n    setState(() {\n      _result = 'First 5 characters: ${_sampleText.characters.take(5).toString()}';\n    });\n  }\n\n  // Step 4: Character Iteration\n  void _iterateCharacters() {\n    final buffer = StringBuffer();\n    for (final char in _sampleText.characters) {\n      buffer.writeln(char);\n    }\n    setState(() {\n      _result = 'Characters (one per line):\\n$buffer';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Characters Package Demo')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Sample Text: $_sampleText', style: const TextStyle(fontSize: 18)),\n            const SizedBox(height: 20),\n            ElevatedButton(onPressed: _countCharacters, child: const Text('Count Characters')),\n            ElevatedButton(onPressed: _reverseString, child: const Text('Reverse String')),\n            ElevatedButton(onPressed: _substringOperation, child: const Text('Substring Operation')),\n            ElevatedButton(onPressed: _iterateCharacters, child: const Text('Iterate Characters')),\n            const SizedBox(height: 20),\n            const Text('Result:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n            const SizedBox(height: 10),\n            Text(_result, style: const TextStyle(fontSize: 16)),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays the sample text \"Hello ! Caf \".\n// 2. Users can interact with four buttons, each demonstrating a different feature of the characters package:\n//    a. Count Characters: Uses characters.length to accurately count the number of user-perceived characters.\n//    b. Reverse String: Demonstrates how to correctly reverse a string containing complex Unicode characters.\n//    c. Substring Operation: Shows how to perform a substring operation using the characters API.\n//    d. Iterate Characters: Illustrates how to iterate over each character in the string.\n// 3. When a button is pressed, the corresponding method is called, which updates the _result state variable.\n// 4. The setState() call triggers a rebuild of the widget, displaying the new result on the screen.\n// 5. This example showcases how the characters package handles complex Unicode strings correctly,\n//    ensuring proper display and manipulation of emojis and other multi-code point characters.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "tutorial": "# Characters Package Tutorial\n\n## Installation\n\nTo use the `characters` package in your Flutter project, add it to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  characters: ^1.2.0\n```\n\nThen run `flutter pub get` to fetch the package.\n\n## Basic Usage\n\n1. Import the package in your Dart file:\n\n```dart\nimport 'package:characters/characters.dart';\n```\n\n2. Use the `characters` extension on `String`:\n\n```dart\nString text = 'Hello !';\nprint(text.characters.length); // Output: 8\n```\n\n## Platform-Specific Considerations\n\n### Android\n\n- Ensure your `minSdkVersion` in `android/app/build.gradle` is at least 16 for full Unicode support.\n\n### iOS\n\n- Set the deployment target in `ios/Podfile` to at least iOS 9.0:\n\n```ruby\nplatform :ios, '9.0'\n```\n\n### Web\n\n- No specific configuration is needed for web support.\n\n## Advanced Usage\n\n### Iterating Over Characters\n\n```dart\nString text = 'Caf ';\nfor (var char in text.characters) {\n  print(char);\n}\n// Output:\n// C\n// a\n// f\n// \n// \n// \n```\n\n### Reversing a String\n\n```dart\nString text = 'Hello !';\nString reversed = text.characters.toList().reversed.join();\nprint(reversed); // ! olleH\n```\n\n### Substring Operations\n\n```dart\nString text = 'Hello !';\nprint(text.characters.skipLast(2).toString()); // Hello \n```\n\nBy using these methods, you can ensure that your Flutter app handles text correctly across all supported platforms and languages.",
    "author": "dart.dev",
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "8f0uc7bs",
        "_ref": "Rx1Nho763d29lawKra1f2V"
      }
    ],
    "_createdAt": "2024-08-28T22:20:51Z",
    "lastUpdate": "2023-02-16T18:30:00.000Z",
    "name": "characters",
    "tutorialIncluded": true,
    "_updatedAt": "2024-09-06T04:13:47Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmX4G",
    "description": "# Flutter Characters Package: A Deep Dive\n\n## Introduction\n\nThe `characters` package in Flutter is a powerful tool for handling Unicode grapheme clusters, also known as user-perceived characters. In an increasingly globalized world, proper text handling is crucial for creating applications that can accurately display and manipulate text in various languages and writing systems.\n\n## What are Grapheme Clusters?\n\nGrapheme clusters are sequences of one or more Unicode code points that should be treated as a single user-perceived character. For example, the flag emoji  is composed of two code points (U+1F1FA and U+1F1F8) but is displayed and perceived as a single character.\n\n## Why Use the Characters Package?\n\n1. **Accuracy**: It ensures correct handling of complex Unicode characters, preventing text display issues and improper string manipulation.\n\n2. **Internationalization**: It's essential for apps that need to support multiple languages and writing systems.\n\n3. **Emoji Support**: It correctly handles emoji sequences, including those composed of multiple code points.\n\n4. **Performance**: The package is optimized for efficient character iteration and manipulation.\n\n## Key Features\n\n- Iteration over user-perceived characters\n- Character counting\n- Substring operations\n- String manipulation (reversing, trimming, etc.)\n\nIn the following sections, we'll explore how to use this package in your Flutter applications and demonstrate its capabilities through practical examples.",
    "similarPackages": [],
    "tags": [
      "string",
      "text-processing",
      "unicode"
    ],
    "likesCount": 402,
    "_id": "uQRNMiDfrp20RZ8Id8CgxB",
    "pubPoint": 160,
    "_type": "package",
    "shortDescription": "String replacement with operations that are Unicode/grapheme cluster aware.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfCdI",
        "_type": "reference",
        "_key": "n4jp1zq5"
      }
    ],
    "packageImage": null,
    "slug": {
      "current": "characters",
      "_type": "slug"
    }
  },
  {
    "_type": "package",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "packageImage": null,
    "_id": "uQRNMiDfrp20RZ8Id8Ch2h",
    "pubPoint": 160,
    "_rev": "AE3hjGWNkNE6aGQMMbaUKr",
    "similarPackages": [
      {
        "_ref": "uQRNMiDfrp20RZ8Id8Cefb",
        "_type": "reference",
        "_key": "cc73hubs"
      }
    ],
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:battery_plus/battery_plus.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Battery Plus Demo',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const BatteryInfoPage(),\n    );\n  }\n}\n\nclass BatteryInfoPage extends StatefulWidget {\n  const BatteryInfoPage({Key? key}) : super(key: key);\n\n  @override\n  _BatteryInfoPageState createState() => _BatteryInfoPageState();\n}\n\nclass _BatteryInfoPageState extends State<BatteryInfoPage> {\n  final Battery _battery = Battery();\n  int _batteryLevel = 0;\n  BatteryState _batteryState = BatteryState.unknown;\n  bool _isCharging = false;\n  bool _isPowerSaveMode = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _initBatteryInfo();\n  }\n\n  // Step 1: Initialize battery information\n  void _initBatteryInfo() {\n    _getBatteryLevel();\n    _getBatteryState();\n    _getChargingStatus();\n    _getPowerSaveMode();\n    _listenToBatteryChanges();\n  }\n\n  // Step 2: Get current battery level\n  Future<void> _getBatteryLevel() async {\n    final batteryLevel = await _battery.batteryLevel;\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  // Step 3: Get current battery state\n  Future<void> _getBatteryState() async {\n    final batteryState = await _battery.batteryState;\n    setState(() {\n      _batteryState = batteryState;\n    });\n  }\n\n  // Step 4: Check if the device is charging\n  Future<void> _getChargingStatus() async {\n    final isCharging = await _battery.isCharging;\n    setState(() {\n      _isCharging = isCharging;\n    });\n  }\n\n  // Step 5: Check if power save mode is enabled\n  Future<void> _getPowerSaveMode() async {\n    final isPowerSaveMode = await _battery.isPowerSaveMode;\n    setState(() {\n      _isPowerSaveMode = isPowerSaveMode;\n    });\n  }\n\n  // Step 6: Listen to battery state changes\n  void _listenToBatteryChanges() {\n    _battery.onBatteryStateChanged.listen((BatteryState state) {\n      setState(() {\n        _batteryState = state;\n        _getBatteryLevel();\n        _getChargingStatus();\n        _getPowerSaveMode();\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Battery Info')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Battery Level: $_batteryLevel%'),\n            Text('Battery State: $_batteryState'),\n            Text('Is Charging: $_isCharging'),\n            Text('Power Save Mode: $_isPowerSaveMode'),\n            ElevatedButton(\n              onPressed: _initBatteryInfo,\n              child: const Text('Refresh Battery Info'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and creates an instance of RealFlutter.\n// 2. RealFlutter sets up the MaterialApp and sets BatteryInfoPage as the home widget.\n// 3. BatteryInfoPage is created, and its state (_BatteryInfoPageState) is initialized.\n// 4. In initState(), _initBatteryInfo() is called, which:\n//    a. Gets the initial battery level\n//    b. Gets the initial battery state\n//    c. Checks the initial charging status\n//    d. Checks if power save mode is enabled\n//    e. Sets up a listener for battery state changes\n// 5. The UI is built, displaying the current battery information.\n// 6. When the battery state changes, the listener updates the state and refreshes the UI.\n// 7. The user can manually refresh the battery info by pressing the \"Refresh Battery Info\" button.\n\n// This example demonstrates all the key features of the battery_plus package:\n// - Getting battery level\n// - Getting battery state\n// - Checking charging status\n// - Checking power save mode\n// - Listening to real-time battery state changes\n```",
    "name": "battery_plus",
    "tutorialIncluded": true,
    "shortDescription": "Flutter plugin for accessing information about the battery state(full, charging, discharging).",
    "tags": [
      "battery",
      "utils",
      "device",
      "hardware"
    ],
    "lastUpdate": "2024-08-08T18:30:00.000Z",
    "tutorial": "## 2. Tutorial\n\nIn this section, we'll walk through the process of implementing the `battery_plus` package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n### Step 1: Installation\n\nAdd the `battery_plus` dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  battery_plus: ^5.0.3  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n### Step 2: Import the Package\n\nIn your Dart file, import the battery_plus package:\n\n```dart\nimport 'package:battery_plus/battery_plus.dart';\n```\n\n### Step 3: Create a Battery Instance\n\nCreate an instance of the `Battery` class:\n\n```dart\nfinal Battery _battery = Battery();\n```\n\n### Step 4: Basic Usage\n\n#### Get Battery Level\n\n```dart\nint batteryLevel = await _battery.batteryLevel;\nprint('Battery level: $batteryLevel%');\n```\n\n#### Check Charging Status\n\n```dart\nbool isCharging = await _battery.isCharging;\nprint('Is charging: $isCharging');\n```\n\n#### Get Battery State\n\n```dart\nBatteryState batteryState = await _battery.batteryState;\nprint('Battery state: $batteryState');\n```\n\n#### Check Power Save Mode\n\n```dart\nbool isPowerSaveMode = await _battery.isPowerSaveMode;\nprint('Power save mode: $isPowerSaveMode');\n```\n\n### Step 5: Listen to Battery Changes\n\nTo receive real-time updates on battery status:\n\n```dart\n_battery.onBatteryStateChanged.listen((BatteryState state) {\n  print('Battery state changed: $state');\n});\n```\n\n### Platform-Specific Considerations\n\n#### Android\n\n- Add the following permission to your `AndroidManifest.xml`:\n  ```xml\n  <uses-permission android:name=\"android.permission.BATTERY_STATS\" />\n  ```\n\n#### iOS\n\n- No additional setup required.\n\n#### Web\n\n- Battery information might be limited or unavailable in some browsers due to security restrictions.\n\n#### macOS\n\n- Add the following to your `macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`:\n  ```xml\n  <key>com.apple.security.device.bluetooth</key>\n  <true/>\n  ```\n\n#### Windows\n\n- Ensure you have the latest Windows SDK installed.\n\n#### Linux\n\n- Requires `upower` to be installed on the system.\n  ```bash\n  sudo apt-get install upower\n  ```\n\nBy following these steps and considering the platform-specific requirements, you can effectively implement the `battery_plus` package in your Flutter application across multiple platforms.",
    "_updatedAt": "2024-09-06T04:13:48Z",
    "author": "fluttercommunity.dev",
    "description": "# Battery Plus Package for Flutter: A Comprehensive Guide\n\n## 1. Description\n\nThe `battery_plus` package is a powerful Flutter plugin that provides a cross-platform (iOS, Android, Web, macOS, Windows, and Linux) API for accessing information about the device's battery state. This package is part of the Flutter Plus Plugins set, which aims to provide extended functionality for various device features.\n\n### Key Features:\n\n1. **Battery Level**: Get the current battery level as a percentage.\n2. **Charging Status**: Determine whether the device is currently charging or not.\n3. **Battery State**: Access the current state of the battery (full, charging, discharging).\n4. **Power Save Mode**: Check if the device is in power-saving mode.\n5. **Real-time Updates**: Listen to changes in battery status and level.\n\n### Why Use Battery Plus?\n\n- **Cross-platform Compatibility**: Works seamlessly across multiple platforms.\n- **Easy Integration**: Simple API for quick implementation in your Flutter projects.\n- **Improved User Experience**: Enhance your app by adapting to the device's battery status.\n- **Power Management**: Optimize your app's performance based on battery conditions.\n\nIn the following sections, we'll dive into a detailed tutorial on how to implement the `battery_plus` package in your Flutter application and showcase a comprehensive example demonstrating all its features.",
    "subCategories": [
      {
        "_ref": "t8DYBEKn49O4mjbyRAfECi",
        "_type": "reference",
        "_key": "orunaiuq"
      }
    ],
    "likesCount": 406,
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1WL9",
        "_type": "reference",
        "_key": "o5k37ow0"
      }
    ],
    "_createdAt": "2024-08-28T22:21:00Z",
    "slug": {
      "current": "battery_plus",
      "_type": "slug"
    }
  },
  {
    "pubPoint": 160,
    "likesCount": 388,
    "tutorial": "# gRPC in Flutter: A Comprehensive Guide\n\n## 2. Tutorial\n\nIn this tutorial, we'll walk through the process of setting up gRPC in a Flutter project and creating a simple client-server application.\n\n### Step 1: Set up the Flutter project\n\n1. Create a new Flutter project:\n   ```\n   flutter create grpc_flutter_demo\n   cd grpc_flutter_demo\n   ```\n\n2. Add the required dependencies to your `pubspec.yaml`:\n   ```yaml\n   dependencies:\n     flutter:\n       sdk: flutter\n     grpc: ^3.1.0\n     protobuf: ^2.1.0\n\n   dev_dependencies:\n     flutter_test:\n       sdk: flutter\n     protoc_plugin: ^20.0.1\n   ```\n\n3. Run `flutter pub get` to install the dependencies.\n\n### Step 2: Define the Protocol Buffer\n\n1. Create a new directory named `protos` in the project root.\n2. Create a file named `realflutter.proto` in the `protos` directory:\n\n```protobuf\nsyntax = \"proto3\";\n\npackage realflutter;\n\nservice RealFlutterService {\n  rpc SendMessage (MessageRequest) returns (MessageResponse) {}\n}\n\nmessage MessageRequest {\n  string message = 1;\n}\n\nmessage MessageResponse {\n  string reply = 1;\n}\n```\n\n### Step 3: Generate Dart code from the Protocol Buffer\n\n1. Run the following command to generate Dart code:\n   ```\n   protoc --dart_out=grpc:lib/src/generated -Iprotos protos/realflutter.proto\n   ```\n\n   This command generates the necessary Dart files in the `lib/src/generated` directory.\n\n### Step 4: Implement the gRPC server\n\n1. Create a new file `server.dart` in the `bin` directory:\n\n```dart\nimport 'package:grpc/grpc.dart';\nimport 'package:grpc_flutter_demo/src/generated/realflutter.pbgrpc.dart';\n\nclass RealFlutterService extends RealFlutterServiceBase {\n  @override\n  Future<MessageResponse> sendMessage(ServiceCall call, MessageRequest request) async {\n    print('Received message: ${request.message}');\n    return MessageResponse()..reply = 'Server received: ${request.message}';\n  }\n}\n\nFuture<void> main(List<String> args) async {\n  final server = Server([RealFlutterService()]);\n  await server.serve(port: 50051);\n  print('Server listening on port ${server.port}...');\n}\n```\n\n### Step 5: Implement the Flutter client\n\nWe'll implement the client in the main.dart file, which we'll cover in the next section.\n\n### Platform-specific details\n\n#### Android\n\n1. Add the following permission to your `android/app/src/main/AndroidManifest.xml`:\n   ```xml\n   <uses-permission android:name=\"android.permission.INTERNET\"/>\n   ```\n\n2. For Android 9 (API level 28) and above, update `android/app/src/main/res/xml/network_security_config.xml`:\n   ```xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <network-security-config>\n       <domain-config cleartextTrafficPermitted=\"true\">\n           <domain includeSubdomains=\"true\">10.0.2.2</domain>\n       </domain-config>\n   </network-security-config>\n   ```\n\n   Then, reference this file in your `AndroidManifest.xml`:\n   ```xml\n   <application\n       ...\n       android:networkSecurityConfig=\"@xml/network_security_config\">\n   ```\n\n#### iOS\n\n1. Update `ios/Runner/Info.plist` to allow cleartext traffic:\n   ```xml\n   <key>NSAppTransportSecurity</key>\n   <dict>\n       <key>NSAllowsArbitraryLoads</key>\n       <true/>\n   </dict>\n   ```\n\nWith these steps completed, your Flutter project is now set up to use gRPC. In the next section, we'll implement the main file to demonstrate the features of the gRPC package.",
    "slug": {
      "current": "grpc",
      "_type": "slug"
    },
    "author": "dart.dev",
    "packageImage": null,
    "lastUpdate": "2024-08-27T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8ChJF",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:grpc/grpc.dart';\nimport 'package:grpc_flutter_demo/src/generated/realflutter.pbgrpc.dart';\n\nvoid main() {\n  runApp(const RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  const RealFlutter({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RealFlutter gRPC Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const RealFlutterHome(title: 'RealFlutter gRPC Demo'),\n    );\n  }\n}\n\nclass RealFlutterHome extends StatefulWidget {\n  const RealFlutterHome({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  State<RealFlutterHome> createState() => _RealFlutterHomeState();\n}\n\nclass _RealFlutterHomeState extends State<RealFlutterHome> {\n  // Step 1: Initialize variables\n  final TextEditingController _messageController = TextEditingController();\n  String _response = '';\n  late RealFlutterServiceClient _client;\n\n  @override\n  void initState() {\n    super.initState();\n    // Step 2: Set up the gRPC channel and client\n    final channel = ClientChannel(\n      'localhost', // Use '10.0.2.2' for Android emulator\n      port: 50051,\n      options: const ChannelOptions(\n        credentials: ChannelCredentials.insecure(),\n      ),\n    );\n    _client = RealFlutterServiceClient(channel);\n  }\n\n  // Step 3: Implement the sendMessage function\n  Future<void> _sendMessage() async {\n    if (_messageController.text.isEmpty) return;\n\n    try {\n      // Step 4: Create a MessageRequest\n      final request = MessageRequest()..message = _messageController.text;\n\n      // Step 5: Send the request and await the response\n      final response = await _client.sendMessage(request);\n\n      // Step 6: Update the UI with the response\n      setState(() {\n        _response = response.reply;\n      });\n    } catch (e) {\n      // Step 7: Handle any errors\n      setState(() {\n        _response = 'Error: $e';\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 8: Create the UI elements\n            TextField(\n              controller: _messageController,\n              decoration: const InputDecoration(\n                labelText: 'Enter your message',\n              ),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: _sendMessage,\n              child: const Text('Send Message'),\n            ),\n            const SizedBox(height: 16),\n            Text(\n              'Server Response:',\n              style: Theme.of(context).textTheme.headline6,\n            ),\n            const SizedBox(height: 8),\n            Text(_response),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    // Step 9: Clean up resources\n    _messageController.dispose();\n    super.dispose();\n  }\n}\n\n// Application Flow:\n// 1. The application starts and initializes the gRPC channel and client in the initState method.\n// 2. The user enters a message in the TextField and taps the \"Send Message\" button.\n// 3. The _sendMessage function is called, which creates a MessageRequest with the user's input.\n// 4. The request is sent to the gRPC server using the sendMessage RPC method.\n// 5. The server processes the request and sends back a MessageResponse.\n// 6. The application receives the response and updates the UI to display the server's reply.\n// 7. If any errors occur during the process, they are caught and displayed in the UI.\n// 8. When the application is closed, the dispose method is called to clean up resources.\n\n// Note: For this example to work, make sure the gRPC server is running (as implemented in the server.dart file).\n// To test on an Android emulator, replace 'localhost' with '10.0.2.2' in the ClientChannel initialization.\n// For iOS simulators, 'localhost' should work fine.\n```",
    "name": "grpc",
    "tutorialIncluded": true,
    "_type": "package",
    "shortDescription": "Dart implementation of gRPC, a high performance, open-source universal RPC framework.",
    "similarPackages": [
      {
        "_ref": "V06bsD4sX3T8NTHrBPb2EG",
        "_type": "reference",
        "_key": "qubmycn6"
      }
    ],
    "subCategories": [
      {
        "_key": "9hg263sj",
        "_ref": "t8DYBEKn49O4mjbyRAfHom",
        "_type": "reference"
      }
    ],
    "dependentPackages": [
      {
        "_ref": "Rx1Nho763d29lawKra1LSx",
        "_type": "reference",
        "_key": "oxymsua5"
      },
      {
        "_ref": "Rx1Nho763d29lawKra1Jgx",
        "_type": "reference",
        "_key": "2dkha6qv"
      }
    ],
    "_createdAt": "2024-08-28T22:21:12Z",
    "_updatedAt": "2024-09-06T04:13:49Z",
    "_rev": "eaCZ7mIhmiYZX5KGqJmXHM",
    "description": "# gRPC in Flutter: A Comprehensive Guide\n\n## 1. Description\n\ngRPC (gRPC Remote Procedure Call) is a high-performance, open-source framework developed by Google for efficient and scalable communication between distributed systems. When combined with Flutter, it provides a powerful solution for building cross-platform mobile applications with robust client-server communication.\n\n### Key Features of gRPC in Flutter:\n\n1. **Protocol Buffers**: gRPC uses Protocol Buffers (protobuf) as its interface definition language, allowing for strongly-typed, efficient serialization of structured data.\n\n2. **HTTP/2 Support**: Built on top of HTTP/2, gRPC enables features like bidirectional streaming, flow control, and multiplexing.\n\n3. **Cross-Platform Compatibility**: gRPC supports multiple programming languages, making it ideal for building microservices-based architectures.\n\n4. **Code Generation**: Automatic code generation for client and server stubs, reducing boilerplate code and potential errors.\n\n5. **Streaming Support**: gRPC offers unary, server streaming, client streaming, and bidirectional streaming RPC methods.\n\n6. **Authentication**: Built-in support for various authentication mechanisms, including SSL/TLS and token-based authentication.\n\n### Benefits of Using gRPC in Flutter:\n\n- **Performance**: gRPC's efficient binary serialization and HTTP/2 transport lead to faster communication compared to traditional REST APIs.\n- **Strong Typing**: Protocol Buffers provide type safety, reducing runtime errors and improving code quality.\n- **Code Generation**: Automatically generated client libraries simplify implementation and maintenance.\n- **Bi-directional Streaming**: Real-time communication between client and server becomes seamless.\n- **Interoperability**: Easy integration with other gRPC-supported languages and platforms.\n\nIn the following sections, we'll dive into a tutorial on setting up gRPC in a Flutter project and demonstrate its usage with a practical example.",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "windows"
    ],
    "tags": [
      "grpc",
      "rpc",
      "protocols",
      "network",
      "api"
    ]
  },
  {
    "_rev": "AE3hjGWNkNE6aGQMMbaUPe",
    "_type": "package",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPFnr",
        "_type": "reference",
        "_key": "00jrlc20"
      }
    ],
    "likesCount": 333,
    "packageImage": null,
    "_createdAt": "2024-08-28T22:21:15Z",
    "tutorialIncluded": true,
    "pubPoint": 160,
    "shortDescription": "A pure flutter toast library, support custom style/widget, easy achieve the same effect with native toasts.",
    "tags": [
      "toast",
      "notification",
      "ui",
      "alert"
    ],
    "name": "oktoast",
    "similarPackages": [],
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "dependentPackages": [
      {
        "_type": "reference",
        "_key": "89fgr4lw",
        "_ref": "Rx1Nho763d29lawKra1u2B"
      },
      {
        "_ref": "uQRNMiDfrp20RZ8Id8CblP",
        "_type": "reference",
        "_key": "hoj47gyg"
      }
    ],
    "_updatedAt": "2024-09-06T04:13:50Z",
    "slug": {
      "current": "oktoast",
      "_type": "slug"
    },
    "author": "",
    "description": "# OkToast: Elegant Toast Messages for Flutter\n\n## Introduction\n\nIn the world of mobile app development, providing user feedback is crucial for a smooth user experience. Toast messages are a popular way to display brief, non-intrusive notifications to users. For Flutter developers, the `oktoast` package offers a simple yet powerful solution for implementing toast messages in their applications.\n\n## What is OkToast?\n\nOkToast is a Flutter package that allows developers to easily create and display toast messages in their applications. It provides a clean API for showing various types of toasts, including text-only toasts, custom widget toasts, and even loading toasts.\n\n## Key Features\n\n1. **Simple API**: OkToast offers an intuitive API that makes it easy to show toast messages with just a few lines of code.\n2. **Customization**: Developers can customize the appearance of toast messages, including background color, text style, and duration.\n3. **Widget Toasts**: In addition to text-only toasts, OkToast supports custom widget toasts for more complex notifications.\n4. **Loading Toasts**: The package includes built-in support for displaying loading indicators as toasts.\n5. **Dismissible Toasts**: Users can dismiss toasts before their duration expires by tapping on them.\n6. **Position Control**: Toasts can be positioned at the top, center, or bottom of the screen.\n7. **Cross-Platform**: OkToast works seamlessly on both Android and iOS platforms.\n\n## Why Choose OkToast?\n\nOkToast stands out from other toast packages due to its simplicity and flexibility. It's lightweight, easy to integrate, and provides all the essential features needed for implementing toast messages in Flutter applications. Whether you're building a simple app or a complex project, OkToast can help you create polished, user-friendly notifications with minimal effort.\n\nIn the following sections, we'll dive into a tutorial on how to use OkToast and explore a complete example demonstrating its features.",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:oktoast/oktoast.dart';\n\nvoid main() {\n  runApp(\n    OKToast(\n      child: MaterialApp(\n        title: 'OkToast Demo',\n        theme: ThemeData(primarySwatch: Colors.blue),\n        home: RealFlutter(),\n      ),\n    ),\n  );\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('OkToast Demo')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            ElevatedButton(\n              child: Text('Show Simple Toast'),\n              onPressed: () => _showSimpleToast(),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Custom Toast'),\n              onPressed: () => _showCustomToast(),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Widget Toast'),\n              onPressed: () => _showWidgetToast(),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              child: Text('Show Loading Toast'),\n              onPressed: () => _showLoadingToast(),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Step 1: Show a simple text toast\n  void _showSimpleToast() {\n    showToast(\n      \"This is a simple toast message!\",\n      duration: Duration(seconds: 2),\n      position: ToastPosition.bottom,\n    );\n  }\n\n  // Step 2: Show a customized toast\n  void _showCustomToast() {\n    showToast(\n      \"Customized Toast\",\n      duration: Duration(seconds: 3),\n      position: ToastPosition.center,\n      backgroundColor: Colors.green,\n      radius: 10.0,\n      textStyle: TextStyle(fontSize: 18.0, color: Colors.white),\n    );\n  }\n\n  // Step 3: Show a widget toast\n  void _showWidgetToast() {\n    showToastWidget(\n      Container(\n        padding: EdgeInsets.symmetric(horizontal: 24.0, vertical: 12.0),\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(25.0),\n          color: Colors.blueAccent,\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Icon(Icons.check, color: Colors.white),\n            SizedBox(width: 12.0),\n            Text(\"Widget Toast!\", style: TextStyle(color: Colors.white)),\n          ],\n        ),\n      ),\n      duration: Duration(seconds: 3),\n      position: ToastPosition.top,\n    );\n  }\n\n  // Step 4: Show a loading toast\n  void _showLoadingToast() {\n    ToastFuture loadingToast = showToastWidget(\n      Container(\n        padding: EdgeInsets.all(16),\n        decoration: BoxDecoration(\n          color: Colors.black54,\n          borderRadius: BorderRadius.circular(10),\n        ),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            CircularProgressIndicator(color: Colors.white),\n            SizedBox(height: 8),\n            Text(\"Loading...\", style: TextStyle(color: Colors.white)),\n          ],\n        ),\n      ),\n      duration: Duration(seconds: 0),\n      position: ToastPosition.center,\n    );\n\n    // Simulate a loading process\n    Future.delayed(Duration(seconds: 3), () {\n      loadingToast.dismiss();\n      showToast(\"Loading complete!\");\n    });\n  }\n}\n\n// Application Flow:\n// 1. The app starts and displays a screen with four buttons.\n// 2. Each button demonstrates a different type of toast:\n//    - Simple Toast: Shows a basic text toast at the bottom of the screen.\n//    - Custom Toast: Displays a customized toast with green background and centered position.\n//    - Widget Toast: Presents a custom widget as a toast at the top of the screen.\n//    - Loading Toast: Shows a loading indicator toast that dismisses after 3 seconds.\n// 3. When a button is pressed, it calls the corresponding method to show the toast.\n// 4. The loading toast simulates a process by showing for 3 seconds before dismissing.\n// 5. Users can interact with the app while toasts are displayed, and toasts automatically\n//    dismiss after their specified duration.\n\n// This example demonstrates the versatility of the OkToast package, \n// showcasing various types of toasts and customization options.\n```",
    "lastUpdate": "2023-11-16T18:30:00.000Z",
    "_id": "uQRNMiDfrp20RZ8Id8ChOl",
    "tutorial": "# OkToast Tutorial\n\nThis tutorial will guide you through the process of integrating and using the OkToast package in your Flutter application. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Installation\n\n1. Add the following dependency to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  oktoast: ^3.3.1\n```\n\n2. Run `flutter pub get` to install the package.\n\n## Basic Setup\n\nTo use OkToast in your Flutter app, you need to wrap your main app widget with the `OKToast` widget. This allows you to show toast messages from anywhere in your app.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:oktoast/oktoast.dart';\n\nvoid main() {\n  runApp(\n    OKToast(\n      child: MaterialApp(\n        home: RealFlutter(),\n      ),\n    ),\n  );\n}\n```\n\n## Showing Toast Messages\n\n### Text Toast\n\nTo show a simple text toast:\n\n```dart\nshowToast(\"Hello, OkToast!\");\n```\n\n### Customizing Toast Appearance\n\nYou can customize various aspects of the toast:\n\n```dart\nshowToast(\n  \"Customized Toast\",\n  duration: Duration(seconds: 2),\n  position: ToastPosition.bottom,\n  backgroundColor: Colors.blue,\n  radius: 8.0,\n  textStyle: TextStyle(fontSize: 16.0, color: Colors.white),\n);\n```\n\n### Widget Toast\n\nTo show a custom widget as a toast:\n\n```dart\nshowToastWidget(\n  Container(\n    padding: EdgeInsets.all(16),\n    decoration: BoxDecoration(\n      color: Colors.green,\n      borderRadius: BorderRadius.circular(10),\n    ),\n    child: Text(\"Custom Widget Toast\", style: TextStyle(color: Colors.white)),\n  ),\n  duration: Duration(seconds: 3),\n  position: ToastPosition.center,\n);\n```\n\n### Loading Toast\n\nTo show a loading indicator toast:\n\n```dart\nToastFuture loadingToast = showToastWidget(\n  Container(\n    padding: EdgeInsets.all(16),\n    decoration: BoxDecoration(\n      color: Colors.black54,\n      borderRadius: BorderRadius.circular(10),\n    ),\n    child: CircularProgressIndicator(color: Colors.white),\n  ),\n  duration: Duration(seconds: 0),\n  position: ToastPosition.center,\n);\n\n// Dismiss the loading toast when your operation is complete\nloadingToast.dismiss();\n```\n\n## Platform-Specific Considerations\n\n### Android\n\nOn Android, OkToast uses the native Toast implementation by default. If you want to use a custom implementation:\n\n```dart\nOKToast(\n  child: MaterialApp(\n    home: RealFlutter(),\n  ),\n  androidUseSystemToast: false,\n)\n```\n\n### iOS\n\nOn iOS, OkToast uses a custom implementation by default. No additional configuration is needed for iOS-specific behavior.\n\n## Best Practices\n\n1. Keep toast messages brief and informative.\n2. Use appropriate durations based on the content length.\n3. Consider the app's color scheme when customizing toast appearances.\n4. Use loading toasts for operations that might take a few seconds to complete.\n5. Test your toasts on both Android and iOS devices to ensure consistent behavior.\n\nBy following this tutorial, you should now have a good understanding of how to implement and use OkToast in your Flutter applications. In the next section, we'll look at a complete example that demonstrates all the features of this package."
  },
  {
    "likesCount": 381,
    "packageImage": null,
    "name": "platform_device_id",
    "shortDescription": "You can get device id from platform - linux/mac/windows/android/ios/web.",
    "subCategories": [
      {
        "_ref": "EyMM3FfV3Ih5n1NWrhPGUX",
        "_type": "reference",
        "_key": "tzdwhj11"
      }
    ],
    "tags": [
      "device-id",
      "identifier",
      "platform",
      "hardware"
    ],
    "_id": "uQRNMiDfrp20RZ8Id8ChUH",
    "tutorial": "# Tutorial: Implementing Platform Device ID in Flutter\n\nThis tutorial will guide you through the process of integrating the `platform_device_id` package into your Flutter project. We'll cover installation, basic usage, and platform-specific considerations.\n\n## Step 1: Installation\n\nAdd the `platform_device_id` package to your `pubspec.yaml` file:\n\n```yaml\ndependencies:\n  platform_device_id: ^1.0.1  # Use the latest version\n```\n\nRun `flutter pub get` to install the package.\n\n## Step 2: Import the Package\n\nIn your Dart file, import the package:\n\n```dart\nimport 'package:platform_device_id/platform_device_id.dart';\n```\n\n## Step 3: Basic Usage\n\nTo get the device ID, use the `getDeviceId()` method:\n\n```dart\nString? deviceId;\ntry {\n  deviceId = await PlatformDeviceId.getDeviceId;\n} catch (e) {\n  print('Error getting device ID: $e');\n}\n```\n\n## Step 4: Platform-Specific Considerations\n\n### Android\n\nAdd the following permission to your `AndroidManifest.xml` file:\n\n```xml\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n```\n\n### iOS\n\nAdd the following to your `Info.plist` file:\n\n```xml\n<key>NSBluetoothAlwaysUsageDescription</key>\n<string>This app requires Bluetooth permission to fetch device ID.</string>\n```\n\n### macOS\n\nNo additional configuration is required.\n\n### Web\n\nNo additional configuration is required. However, note that the web implementation uses local storage, which can be cleared by the user.\n\n## Step 5: Error Handling\n\nAlways wrap the `getDeviceId` call in a try-catch block to handle potential errors:\n\n```dart\nString? deviceId;\ntry {\n  deviceId = await PlatformDeviceId.getDeviceId;\n} on PlatformException {\n  deviceId = 'Failed to get device ID.';\n} catch (e) {\n  deviceId = 'Unexpected error occurred: $e';\n}\n```\n\n## Step 6: UI Integration\n\nHere's a simple example of how to display the device ID in your UI:\n\n```dart\nclass DeviceIdWidget extends StatefulWidget {\n  @override\n  _DeviceIdWidgetState createState() => _DeviceIdWidgetState();\n}\n\nclass _DeviceIdWidgetState extends State<DeviceIdWidget> {\n  String _deviceId = 'Unknown';\n\n  @override\n  void initState() {\n    super.initState();\n    _getDeviceId();\n  }\n\n  Future<void> _getDeviceId() async {\n    String? deviceId;\n    try {\n      deviceId = await PlatformDeviceId.getDeviceId;\n    } catch (e) {\n      deviceId = 'Failed to get device ID.';\n    }\n    setState(() {\n      _deviceId = deviceId ?? 'Unknown';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Device ID: $_deviceId');\n  }\n}\n```\n\nBy following these steps, you'll have successfully integrated the `platform_device_id` package into your Flutter project, allowing you to retrieve unique device identifiers across different platforms.",
    "tutorialIncluded": true,
    "slug": {
      "current": "platform_device_id",
      "_type": "slug"
    },
    "description": "# Platform Device ID Package for Flutter\n\nThe `platform_device_id` package is a powerful Flutter plugin that allows developers to retrieve unique device identifiers across multiple platforms. This package is essential for applications that require device-specific identification for various purposes such as analytics, device management, or user authentication.\n\n## Key Features\n\n1. **Cross-Platform Compatibility**: Supports Android, iOS, macOS, and Web platforms.\n2. **Unique Identifiers**: Provides consistent and unique device IDs for each platform.\n3. **Privacy-Compliant**: Adheres to platform-specific privacy guidelines and regulations.\n4. **Easy Integration**: Simple to implement with just a few lines of code.\n\n## How It Works\n\nThe `platform_device_id` package uses platform-specific methods to generate or retrieve unique identifiers:\n\n- **Android**: Uses the Android ID or SSAID (SQL Storage Android ID).\n- **iOS**: Utilizes the identifierForVendor or a generated UUID stored in KeyChain.\n- **macOS**: Employs a generated UUID stored in KeyChain.\n- **Web**: Generates a UUID and stores it in local storage.\n\nBy leveraging these platform-specific approaches, the package ensures that you get a reliable and consistent device identifier for each unique device your app runs on.\n\n## Use Cases\n\n1. **Analytics and Tracking**: Understand user behavior across sessions without requiring login.\n2. **Device Management**: Keep track of devices in enterprise or IoT applications.\n3. **Fraud Prevention**: Identify and prevent multiple account creations from the same device.\n4. **Personalization**: Offer device-specific features or content without user accounts.\n\nIn the following sections, we'll dive into a tutorial on how to implement this package in your Flutter project and provide a comprehensive example demonstrating its features.",
    "similarPackages": [
      {
        "_type": "reference",
        "_key": "o77an8ob",
        "_ref": "Rx1Nho763d29lawKra1WL9"
      }
    ],
    "dependentPackages": [],
    "_createdAt": "2024-08-28T22:21:16Z",
    "author": "di1shuai.com",
    "_type": "package",
    "example": "```\nimport 'package:flutter/material.dart';\nimport 'package:platform_device_id/platform_device_id.dart';\n\nvoid main() {\n  runApp(RealFlutter());\n}\n\nclass RealFlutter extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Platform Device ID Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: DeviceIdPage(),\n    );\n  }\n}\n\nclass DeviceIdPage extends StatefulWidget {\n  @override\n  _DeviceIdPageState createState() => _DeviceIdPageState();\n}\n\nclass _DeviceIdPageState extends State<DeviceIdPage> {\n  String _deviceId = 'Unknown';\n  bool _isLoading = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _getDeviceId();\n  }\n\n  // Step 1: Implement the getDeviceId method\n  Future<void> _getDeviceId() async {\n    setState(() {\n      _isLoading = true;\n    });\n\n    try {\n      // Step 2: Use the PlatformDeviceId.getDeviceId method to fetch the device ID\n      String? deviceId = await PlatformDeviceId.getDeviceId;\n      setState(() {\n        _deviceId = deviceId ?? 'Unknown';\n      });\n    } catch (e) {\n      // Step 3: Handle any errors that occur during the process\n      setState(() {\n        _deviceId = 'Failed to get device ID: $e';\n      });\n    } finally {\n      setState(() {\n        _isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Platform Device ID Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 4: Display the device ID or a loading indicator\n            _isLoading\n                ? CircularProgressIndicator()\n                : Text(\n                    'Device ID:',\n                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                  ),\n            SizedBox(height: 10),\n            _isLoading\n                ? Text('Fetching device ID...')\n                : Text(\n                    _deviceId,\n                    style: TextStyle(fontSize: 16),\n                    textAlign: TextAlign.center,\n                  ),\n            SizedBox(height: 20),\n            // Step 5: Add a refresh button to fetch the device ID again\n            ElevatedButton(\n              onPressed: _isLoading ? null : _getDeviceId,\n              child: Text('Refresh Device ID'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Application Flow:\n// 1. The app starts and runs the RealFlutter widget.\n// 2. RealFlutter sets up the MaterialApp with the DeviceIdPage as the home page.\n// 3. When DeviceIdPage is created, its state (_DeviceIdPageState) is initialized.\n// 4. In the initState method, _getDeviceId() is called to fetch the device ID.\n// 5. While fetching, a loading indicator is shown.\n// 6. Once the device ID is fetched (or if an error occurs), the UI updates to show the result.\n// 7. Users can press the \"Refresh Device ID\" button to fetch the ID again.\n// 8. The app handles potential errors and displays them to the user.\n\n// Note: This example demonstrates basic usage of the platform_device_id package.\n// In a real-world application, you might want to add more error handling,\n// persist the device ID, or use it for specific features like analytics or user identification.\n```",
    "platforms": [
      "android",
      "ios",
      "linux",
      "macos",
      "web",
      "windows"
    ],
    "lastUpdate": "2021-04-03T18:30:00.000Z",
    "_updatedAt": "2024-09-06T04:13:52Z",
    "pubPoint": 160,
    "_rev": "ezMiwuUkJkbYMWycA6Rh5q"
  }
]